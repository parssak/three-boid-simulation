{"mappings":"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CCvmC,OAAO;;;IAGTioD;MACCpiB;QACC7lC,OAAO;;MAER8lC;QACC9lC,OAAO;;;IAGTkoD;MACCniB;QACC/lC,OAAO;;MAERimC;QACCjmC,WAAW6W,QAAQ,GAAG;;;IAGxBsxC;MACCjiB;QACClmC,OAAO;;MAERmmC;QACCnmC,OAAO;;MAERomC;QACCpmC,OAAO;;;IAGTooD;MACC/hB;QACCrmC,OAAO;;;IAGTqoD;MACC/hB;QACCtmC,OAAO;;;IAGTsoD;MACCxhB;QACC9mC,OAAO;;;IAGTuB;MACCgnD;QACCvoD,OAAO;;MAERwoD;QACCxoD,OAAO;;MAERyoD;QACCzoD,OAAO;;MAER0oD;QACC1oD,WAAW8qC,MAAM;;;IAGnB+L;MACC8R;QACC3oD;;MAED4oD;QACC5oD;;MAED6oD;QACC7oD;QACA8oD;UACCl6B;UACArzB;;;MAGFwtD;QACC/oD;QACA8oD;UACCE;UACAC;UACAC;UACAC;;;MAGFC;QACCppD;;MAEDqpD;QACCrpD;;MAEDspD;QACCtpD;QACA8oD;UACCvtD;UACAO;UACA8yB;UACA3vB;UACAsqD;UACAC;UACAC;;;MAGFC;QACC1pD;QACA8oD;UACCE;UACAC;UACAC;UACAC;;;MAGFQ;QACC3pD;;MAED4pD;QACC5pD;;MAED6pD;QACC7pD;QACA8oD;UACCvtD;UACAO;UACA2tD;UACAxqD;;;MAGF6qD;QACC9pD;QACA8oD;UACCE;UACAC;UACAC;UACAC;UACAY;UACAC;;;MAGFC;QACCjqD;;MAEDkqD;QACClqD;;MAEDmqD;QACCnqD;QACA8oD;UACCl6B;UACAw7B;UACAC;;;;MAIFC;QACCtqD;QACA8oD;UACCvtD;UACAO;UACA4X;UACAC;;;MAGF42C;QACCvqD,OAAO;;MAERwqD;QACCxqD,OAAO;;;IAGT8pB;MACCy9B;QACCvnD,WAAW8qC,MAAM;;MAElB/I;QACC/hC,OAAO;;MAERV;QACCU,OAAO;;MAER+a;QACC/a,OAAO;;MAER/I;QACC+I,OAAO;;MAERwlC;QACCxlC,OAAO;;MAERwnD;QACCxnD,WAAWmb;;;IAGbuhC;MACC6K;QACCvnD,WAAW8qC,MAAM;;MAElB/I;QACC/hC,OAAO;;MAER4W;QACC5W,WAAW6W,QAAQ,KAAK;;MAEzB9Y;QACCiC,OAAO;;MAER/I;QACC+I,OAAO;;MAERwlC;QACCxlC,OAAO;;MAERwnD;QACCxnD,WAAWmb;;;;QAKRsvC;IACLC;MACCvU,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYI,aAAaJ,YAAYK,QAAQL,YAAYQ,OAAOR,YAAYS,UAAUT,YAAY/lD;MAC/Io1C,cAAc0Q,YAAYnB;MAC1BtP,gBAAgByQ,YAAYpB;;IAE7B0E;MACCxU,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYI,aAAaJ,YAAYK,QAAQL,YAAYQ,OAAOR,YAAYS,UAAUT,YAAYU,aAAaV,YAAY/lD,KAAK+lD,YAAYzQ;QACxLhS;UACC7kC,WAAW8qC,MAAM;;;MAGnB6L,cAAc0Q,YAAYjB;MAC1BxP,gBAAgByQ,YAAYlB;;IAE7ByE;MACCzU,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYI,aAAaJ,YAAYK,QAAQL,YAAYQ,OAAOR,YAAYS,UAAUT,YAAYU,aAAaV,YAAYW,SAASX,YAAYY,WAAWZ,YAAYa,iBAAiBb,YAAY/lD,KAAK+lD,YAAYzQ;QACjQhS;UACC7kC,WAAW8qC,MAAM;;QAElB/F;UACC/kC,WAAW8qC,MAAM;;QAElB9F;UACChlC,OAAO;;;MAGT22C,cAAc0Q,YAAYX;MAC1B9P,gBAAgByQ,YAAYZ;;IAE7BoE;MACC1U,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYK,QAAQL,YAAYQ,OAAOR,YAAYS,UAAUT,YAAYU,aAAaV,YAAYW,SAASX,YAAYY,WAAWZ,YAAYa,iBAAiBb,YAAYc,cAAcd,YAAYe,cAAcf,YAAY/lD,KAAK+lD,YAAYzQ;QAC5RhS;UACC7kC,WAAW8qC,MAAM;;QAElBpG;UACC1kC,OAAO;;QAER2kC;UACC3kC,OAAO;;QAER2mC;UACC3mC,OAAO;;;MAIT22C,cAAc0Q,YAAYT;MAC1BhQ,gBAAgByQ,YAAYV;;IAE7BmE;MACC3U,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYQ,OAAOR,YAAYS,UAAUT,YAAYU,aAAaV,YAAYW,SAASX,YAAYY,WAAWZ,YAAYa,iBAAiBb,YAAYgB,aAAahB,YAAY/lD,KAAK+lD,YAAYzQ;QAC7OhS;UACC7kC,WAAW8qC,MAAM;;;MAGnB6L,cAAc0Q,YAAYb;MAC1B5P,gBAAgByQ,YAAYd;;IAE7BhhB;MACC4Q,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYW,SAASX,YAAYY,WAAWZ,YAAYa,iBAAiBb,YAAY/lD;QACjIgkC;UACCvlC,OAAO;;;MAGT22C,cAAc0Q,YAAYf;MAC1B1P,gBAAgByQ,YAAYhB;;IAE7Bv8B;MACCqsB,UAAUI,eAAe+Q,YAAYx9B,QAAQw9B,YAAY/lD;MACzDo1C,cAAc0Q,YAAYL;MAC1BpQ,gBAAgByQ,YAAYN;;IAE7BgE;MACC5U,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAY/lD;QACxDwZ;UACC/a,OAAO;;QAERunC;UACCvnC,OAAO;;QAERgrD;UACChrD,OAAO;;;MAGT22C,cAAc0Q,YAAYrB;MAC1BpP,gBAAgByQ,YAAYtB;;IAE7BtlC;MACC01B,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYa;MACzDxR,cAAc0Q,YAAY3B;MAC1B9O,gBAAgByQ,YAAY5B;;IAE7Bj9B;MACC2tB,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYW,SAASX,YAAYY,WAAWZ,YAAYa;QACpGpmB;UACC/hC,OAAO;;;MAGT22C,cAAc0Q,YAAYP;MAC1BlQ,gBAAgByQ,YAAYR;;IAE7BnK;MACCvG,UAAUI,eAAe+Q,YAAY5K,QAAQ4K,YAAY/lD;MACzDo1C,cAAc0Q,YAAYD;MAC1BxQ,gBAAgByQ,YAAYF;;IAE7B8D;MACC9U;QACCqR;UACCxnD,WAAWmb;;QAEZ+vC;UACClrD,OAAO;;;MAGT22C,cAAc0Q,YAAY/B;MAC1B1O,gBAAgByQ,YAAYhC;;;;;IAM7B8F;MACChV,UAAUI,eAAe+Q,YAAYK;QACpC5lB;UACC/hC,OAAO;;;MAGT22C,cAAc0Q,YAAY7B;MAC1B5O,gBAAgByQ,YAAY9B;;IAE7B6F;MACCjV;QACCyE;UACC56C,OAAO;;;MAGT22C,cAAc0Q,YAAYvB;MAC1BlP,gBAAgByQ,YAAYxB;;IAE7BwF;MACClV,UAAUI,eAAe+Q,YAAYjH,QAAQiH,YAAYa;QACxDmD;UACCtrD,WAAWrF;;QAEZ4wD;UACCvrD,OAAO;;QAERwrD;UACCxrD,OAAO;;;MAGT22C,cAAc0Q,YAAYzB;MAC1BhP,gBAAgByQ,YAAY1B;;IAE7B8F;MACCtV,UAAUI,eAAe+Q,YAAYzQ,QAAQyQ,YAAY/lD;QACxDhG;UACCyE,WAAW8qC,MAAM;;QAElB/I;UACC/hC,OAAO;;;MAGT22C,cAAc0Q,YAAYH;MAC1BtQ,gBAAgByQ,YAAYJ;;;EAG9BwD,UAAUiB;IACTvV,UAAUI,eAAekU,UAAUI,SAAS1U;MAC3ClR;QACCjlC,OAAO;;MAERmlC;QACCnlC,OAAO;;MAERklC;QACCllC,OAAO;;MAERolC;QACCplC,OAAO;;MAERslC;QACCtlC,WAAW6W,QAAQ,GAAG;;MAEvBwuB;QACCrlC,OAAO;;MAER4kC;QACC5kC,WAAW8qC,MAAM;;MAElB/D;QACC/mC,OAAO;;MAERgnC;QACChnC,OAAO;;MAER2rD;QACC3rD,WAAW6W;;MAEZ+0C;QACC5rD,OAAO;;MAERinC;QACCjnC,OAAO;;MAERknC;QACClnC,OAAO;;MAERmnC;QACCnnC,OAAO;;MAERonC;QACCpnC,WAAW8qC,MAAM;;;IAGnB6L,cAAc0Q,YAAYT;IAC1BhQ,gBAAgByQ,YAAYV;;EAG7B,yBAAyB5lD,UAAU8qD,UAAUC,OAAOC,SAASjoB;UACtDkoB,iBAAiBlhB,MAAM;QACzBmhB,aAAa;QACbC;QACAC;QACAC,oBAAoB;QACpBC,2BAA2B;QAC3BC,qBAAqB;IAEzB,gBAAgBC,YAAYpsD;UACvBqsD,aAAa;UACbvB,aAAa9qD,MAAMssD,YAAY,OAAOtsD,MAAM8qD,aAAa;UAEzDA,cAAcA,WAAWvsC;QAC5BusC,aAAaY,SAASlN,IAAIsM;;;;YAKrBjR,KAAKj5C,SAASi5C;YACd0S,UAAU1S,GAAG2S,cAAc3S,GAAG2S;UAEhCD,WAAWA,QAAQE,yBAAyB;QAC/C3B,aAAa;;UAGVA,eAAe;QAClB4B,SAASb,YAAYC;iBACXhB,cAAcA,WAAW1mB;QACnCsoB,SAAS5B,YAAY;QACrBuB,aAAa;;UAGVzrD,SAAS+rD,aAAaN;QACzBzrD,SAAS9L,MAAM8L,SAASgsD,gBAAgBhsD,SAASisD,gBAAgBjsD,SAASksD;;UAGvEhC,eAAeA,WAAW1Q,iBAAiB0Q,WAAW3uC,YAAYjW;YACjE8lD,YAAYp5D;UACfo5D,cAAc1wD,SAAS8D,YAAY,GAAG,GAAG,QAAQk4C;YAChDp3C,MAAM;YACN81C,UAAUE,cAAcoU,UAAUU,KAAKhV;YACvCQ,cAAc8T,UAAUU,KAAKxU;YAC7BC,gBAAgB6T,UAAUU,KAAKvU;YAC/B/U,MAAMx+B;YACNm/B,WAAW;YACXC,YAAY;YACZlhC,KAAK;;UAEN4qD,QAAQlxD,SAASszC,gBAAgB;UACjC4d,QAAQlxD,SAASszC,gBAAgB;UAEjC4d,QAAQtyB,iBAAiB,UAAU94B,UAAUZ,OAAOinB;YACnD,KAAKK,YAAYsK,aAAa3K,OAAOK;;;UAItCnV,OAAOyK,eAAeovC,QAAQ9wD,UAAU;YACvCsjD,KAAK;qBACG,KAAKxI,SAAS1P,OAAOzmC;;;UAG9B+rD,QAAQjoC,OAAOqoC;;QAGhBA,QAAQ9wD,SAAS86C,SAAS1P,OAAOzmC,QAAQirD;QACzCkB,QAAQ9wD,SAAS86C,SAASyR,WAAW5nD,QAAQirD,WAAW1Q,iBAAiB0Q,WAAW5Q,oBAAoB,IAAI;YAExG+R,sBAAsBnB,cAAcoB,6BAA6BpB,WAAWztC,WAAW8uC,uBAAuBvrD,SAASmsD;UAC1Hf,QAAQ9wD,SAASojB,cAAc;UAC/B2tC,oBAAoBnB;UACpBoB,2BAA2BpB,WAAWztC;UACtC8uC,qBAAqBvrD,SAASmsD;;;QAI/BX,WAAWY,QAAQhB,SAASA,QAAQlxD,UAAUkxD,QAAQ9wD,UAAU,GAAG,GAAG;iBAC5D4vD,cAAcA,WAAWvsC;YAC/BwtC,cAAcn5D;UACjBm5D,gBAAgBzwD,SAAS2xD,cAAc,GAAG,QAAQ3V;YACjDp3C,MAAM;YACN81C,UAAUE,cAAcoU,UAAUQ,WAAW9U;YAC7CQ,cAAc8T,UAAUQ,WAAWtU;YACnCC,gBAAgB6T,UAAUQ,WAAWrU;YACrC/U,MAAMz+B;YACNo/B,WAAW;YACXC,YAAY;YACZlhC,KAAK;;UAEN2qD,UAAUjxD,SAASszC,gBAAgB;;UAEnCj8B,OAAOyK,eAAemvC,UAAU7wD,UAAU;YACzCsjD,KAAK;qBACG,KAAKxI,SAAS+U,IAAIlrD;;;UAG3B+rD,QAAQjoC,OAAOooC;;QAGhBA,UAAU7wD,SAAS86C,SAAS+U,IAAIlrD,QAAQirD;YAEpCA,WAAW9tC,qBAAqB;UACnC8tC,WAAWvtC;;QAGZwuC,UAAU7wD,SAAS86C,SAASqR,YAAYxnD,MAAMkU,KAAK+2C,WAAW/vC;YAE1DkxC,sBAAsBnB,cAAcoB,6BAA6BpB,WAAWztC,WAAW8uC,uBAAuBvrD,SAASmsD;UAC1HhB,UAAU7wD,SAASojB,cAAc;UACjC2tC,oBAAoBnB;UACpBoB,2BAA2BpB,WAAWztC;UACtC8uC,qBAAqBvrD,SAASmsD;;;QAI/BX,WAAWY,QAAQjB,WAAWA,UAAUjxD,UAAUixD,UAAU7wD,UAAU,GAAG,GAAG;;;IAI9E,kBAAkBE,OAAOwa;MACxB+1C,MAAMtO,QAAQjiD,MAAMsxD,SAAStxD,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW,GAAGqE,OAAO+tB;;;MAI/DupB,eAAe;eACPrB;;MAERsB,eAAe,UAAU/xD,OAAOwa,QAAQ;QACvCi2C,WAAW1qD,IAAI/F;QACf0wD,aAAal2C;QACb82C,SAASb,YAAYC;;MAEtBsB,eAAe;eACPtB;;MAERuB,eAAe,UAAUz3C;QACxBk2C,aAAal2C;QACb82C,SAASb,YAAYC;;MAEtB7R,QAAQA;;;EAIV,4BAA4BiD,IAAItG,YAAYlJ,YAAYyP;UACjDmQ,sBAAsBpQ,GAAG9xB,aAAa8xB,GAAGqQ;UACzCC,YAAYrQ,aAAaC,WAAW,OAAOxG,WAAW4H,IAAI;UAC1DiP,eAAetQ,aAAaC,YAAYoQ,cAAc;UACtDE;UACAC,eAAeC,mBAAmB;QACpCC,eAAeF;IAEnB,eAAezjC,QAAQhvB,UAAU4yD,SAAShzD,UAAUgU;UAC/Ci/C,gBAAgB;UAEhBN;cACG9B,QAAQqC,gBAAgBlzD,UAAUgzD,SAAS5yD;YAE7C2yD,iBAAiBlC;UACpBkC,eAAelC;UACfsC,sBAAsBJ,aAAa3jC;;QAGpC6jC,gBAAgBzvC,YAAYxjB,UAAUgU;YAClCi/C,eAAeG,UAAUpzD,UAAUgU;;cAEjCxP,YAAYpE,SAASoE,cAAc;YAErCuuD,aAAa/yD,aAAaA,SAASnG,MAAMk5D,aAAaC,YAAYA,QAAQn5D,MAAMk5D,aAAavuD,cAAcA;UAC9GuuD,aAAa/yD,WAAWA,SAASnG;UACjCk5D,aAAaC,UAAUA,QAAQn5D;UAC/Bk5D,aAAavuD,YAAYA;UACzByuD,gBAAgB;;;UAId7jC,OAAOkS,oBAAoB;QAC9B2xB,gBAAgB;;UAGbj/C,UAAU;QACb4+B,WAAW/pB,OAAO7U,OAAOouC,GAAGiR;;UAGzBJ;QACHK,sBAAsBlkC,QAAQhvB,UAAU4yD,SAAShzD;YAE7CgU,UAAU;UACbouC,GAAGO,WAAWP,GAAGiR,sBAAsBzgB,WAAW8Q,IAAI1vC,OAAOq+B;;;;IAKhE;UACKgQ,aAAaC,iBAAiBF,GAAGmR;aAC9Bb,UAAUc;;IAGlB,+BAA+BC;UAC1BpR,aAAaC,iBAAiBF,GAAGsR,gBAAgBD;aAC9Cf,UAAUiB,mBAAmBF;;IAGrC,iCAAiCA;UAC5BpR,aAAaC,iBAAiBF,GAAGwR,kBAAkBH;aAChDf,UAAUmB,qBAAqBJ;;IAGvC,yBAAyBzzD,UAAUgzD,SAAS5yD;YACrCoE,YAAYpE,SAASoE,cAAc;UACrCsvD,aAAalB,cAAc5yD,SAASnG;UAEpCi6D,eAAeh8D;QAClBg8D;QACAlB,cAAc5yD,SAASnG,MAAMi6D;;UAG1BC,WAAWD,WAAWd,QAAQn5D;UAE9Bk6D,aAAaj8D;QAChBi8D;QACAD,WAAWd,QAAQn5D,MAAMk6D;;UAGtBlD,QAAQkD,SAASvvD;UAEjBqsD,UAAU/4D;QACb+4D,QAAQiC,mBAAmBkB;QAC3BD,SAASvvD,aAAaqsD;;aAGhBA;;IAGR,4BAA4B4C;YACrBQ;YACAC;YACAC;eAEGj6D,IAAI,GAAGA,IAAIs4D,qBAAqBt4D;QACxC+5D,cAAc/5D,KAAK;QACnBg6D,kBAAkBh6D,KAAK;QACvBi6D,kBAAkBj6D,KAAK;;;;QAKvB8F,UAAU;QACVgzD,SAAS;QACTxuD,WAAW;QACXyvD,eAAeA;QACfC,mBAAmBA;QACnBC,mBAAmBA;QACnB/kC,QAAQqkC;QACR7gB;QACA5+B,OAAO;;;IAIT,qBAAqBhU,UAAUgU;YACxBogD,mBAAmBrB,aAAangB;YAChCyhB,qBAAqBr0D,SAAS4yC;UAChC0hB,gBAAgB;iBAET7xB,OAAO4xB;cACXE,kBAAkBH,iBAAiB3xB;cACnC+xB,oBAAoBH,mBAAmB5xB;YACzC8xB,oBAAoBz8D,kBAAkB;YACtCy8D,gBAAgBh5C,cAAci5C,0BAA0B;YACxDD,gBAAgBj9D,SAASk9D,kBAAkBl9D,aAAa;QAC5Dg9D;;UAGGvB,aAAauB,kBAAkBA,sBAAsB;UACrDvB,aAAa/+C,UAAUA,cAAc;aAClC;;IAGR,mBAAmBhU,UAAUgU;YACtBxV;YACAo0C,aAAa5yC,SAAS4yC;UACxB0hB,gBAAgB;iBAET7xB,OAAOmQ;cACXr3B,YAAYq3B,WAAWnQ;cACvBnrC;QACNA,KAAKikB,YAAYA;YAEbA,UAAUjkB;UACbA,KAAKA,OAAOikB,UAAUjkB;;QAGvBkH,MAAMikC,OAAOnrC;QACbg9D;;MAGDvB,aAAangB,aAAap0C;MAC1Bu0D,aAAauB,gBAAgBA;MAC7BvB,aAAa/+C,QAAQA;;IAGtB;YACOigD,gBAAgBlB,aAAakB;eAE1B/5D,IAAI,GAAGksB,KAAK6tC,cAAc95D,QAAQD,IAAIksB,IAAIlsB;QAClD+5D,cAAc/5D,KAAK;;;IAIrB,yBAAyBqhB;MACxBk5C,0BAA0Bl5C,WAAW;;IAGtC,mCAAmCA,WAAWm5C;YACvCT,gBAAgBlB,aAAakB;YAC7BC,oBAAoBnB,aAAamB;YACjCC,oBAAoBpB,aAAaoB;MACvCF,cAAc14C,aAAa;UAEvB24C,kBAAkB34C,eAAe;QACpC6mC,GAAGuS,wBAAwBp5C;QAC3B24C,kBAAkB34C,aAAa;;UAG5B44C,kBAAkB54C,eAAem5C;cAC9BhC,YAAYrQ,aAAaC,WAAWF,KAAKtG,WAAW4H,IAAI;QAC9DgP,UAAUrQ,aAAaC,WAAW,wBAAwB,4BAA4B/mC,WAAWm5C;QACjGP,kBAAkB54C,aAAam5C;;;IAIjC;YACOT,gBAAgBlB,aAAakB;YAC7BC,oBAAoBnB,aAAamB;eAE9Bh6D,IAAI,GAAGksB,KAAK8tC,kBAAkB/5D,QAAQD,IAAIksB,IAAIlsB;YAClDg6D,kBAAkBh6D,OAAO+5D,cAAc/5D;UAC1CkoD,GAAGwS,yBAAyB16D;UAC5Bg6D,kBAAkBh6D,KAAK;;;;IAK1B,6BAA6B8Z,OAAO3P,MAAMnL,MAAM02C,YAAYilB,QAAQz5C;UAC/DinC,aAAaC,aAAa,SAASppD,SAASkpD,GAAGc,OAAOhqD,SAASkpD,GAAGa;QACrEb,GAAG0S,qBAAqB9gD,OAAO3P,MAAMnL,MAAM27D,QAAQz5C;;QAEnDgnC,GAAG2S,oBAAoB/gD,OAAO3P,MAAMnL,MAAM02C,YAAYilB,QAAQz5C;;;IAIhE,+BAA+BgU,QAAQhvB,UAAU4yD,SAAShzD;UACrDqiD,aAAaC,aAAa,UAAUlzB,OAAOkS,mBAAmBthC,SAASg1D;YACtElZ,WAAW4H,IAAI,8BAA8B;;MAGlDuR;YACMZ,qBAAqBr0D,SAAS4yC;YAC9BsiB,oBAAoBlC,QAAQmC;YAC5BC,iCAAiCh1D,SAAS+7C;iBAErC/2C,QAAQ8vD;cACZG,mBAAmBH,kBAAkB9vD;YAEvCiwD,oBAAoB;gBACjBb,oBAAoBH,mBAAmBjvD;cAEzCovD,sBAAsB18D;kBACnB83C,aAAa4kB,kBAAkB5kB;kBAC/BvrC,OAAOmwD,kBAAkBrkB;kBACzB50B,YAAYq3B,WAAW8Q,IAAI8Q;;gBAE7Bj5C,cAAczjB;kBACZu6C,SAAS92B,UAAU82B;kBACnBn5C,OAAOqiB,UAAUriB;kBACjBmqD,kBAAkB9nC,UAAU8nC;gBAE9BmR,kBAAkB/Q;oBACfnsD,OAAOk9D,kBAAkBl9D;oBACzBu9D,SAASv9D,KAAKu9D;oBACdz5C,SAASo5C,kBAAkBp5C;kBAE7B9jB,QAAQA,KAAKg+D;gBAChBb,0BAA0BY,kBAAkB/9D,KAAKo9D;oBAE7C10D,SAASu1D,sBAAsBz9D;kBAClCkI,SAASu1D,oBAAoBj+D,KAAKo9D,mBAAmBp9D,KAAKgL;;;gBAG3DkzD,gBAAgBH;;cAGjBjT,GAAGO,WAAWP,GAAGqT,cAAcpjB;cAC/B0iB,oBAAoBM,kBAAkBhxD,MAAMnL,MAAM02C,YAAYilB,SAASxR,iBAAiBjoC,SAASioC;;kBAE7FmR,kBAAkBkB;gBACrBjB,0BAA0BY,kBAAkBb,kBAAkBE;oBAE1D10D,SAASu1D,sBAAsBz9D;kBAClCkI,SAASu1D,oBAAoBf,kBAAkBE,mBAAmBF,kBAAkBlyD;;;gBAGrFkzD,gBAAgBH;;cAGjBjT,GAAGO,WAAWP,GAAGqT,cAAcpjB;cAC/B0iB,oBAAoBM,kBAAkBhxD,MAAMnL,MAAM02C,YAAY,GAAG;;qBAExDxqC,SAAS;kBACbmW,YAAYq3B,WAAW8Q,IAAIt0B,OAAOmS;;gBAEpChmB,cAAczjB;kBACZu6C,SAAS92B,UAAU82B;kBACnBn5C,OAAOqiB,UAAUriB;YACvBu7D,0BAA0BY,mBAAmB,GAAG;YAChDZ,0BAA0BY,mBAAmB,GAAG;YAChDZ,0BAA0BY,mBAAmB,GAAG;YAChDZ,0BAA0BY,mBAAmB,GAAG;YAChDjT,GAAGO,WAAWP,GAAGqT,cAAcpjB;YAC/B+P,GAAG2S,oBAAoBM,mBAAmB,GAAG,GAAGn8D,MAAM,OAAO,IAAI;YACjEkpD,GAAG2S,oBAAoBM,mBAAmB,GAAG,GAAGn8D,MAAM,OAAO,IAAI;YACjEkpD,GAAG2S,oBAAoBM,mBAAmB,GAAG,GAAGn8D,MAAM,OAAO,IAAI;YACjEkpD,GAAG2S,oBAAoBM,mBAAmB,GAAG,GAAGn8D,MAAM,OAAO,IAAI;qBACvDkM,SAAS;kBACbmW,YAAYq3B,WAAW8Q,IAAIt0B,OAAOoS;;gBAEpCjmB,cAAczjB;kBACZu6C,SAAS92B,UAAU82B;kBACnBn5C,OAAOqiB,UAAUriB;YACvBu7D,0BAA0BY,kBAAkB;YAC5CjT,GAAGO,WAAWP,GAAGqT,cAAcpjB;YAC/B+P,GAAG2S,oBAAoBM,kBAAkB,GAAGn8D,MAAM,OAAO,IAAI;qBACnDk8D,mCAAmCt9D;kBACvCiN,QAAQqwD,+BAA+BhwD;gBAEzCL,UAAUjN;sBACLiN,MAAM5K;qBACR;kBACJioD,GAAGuT,gBAAgBN,kBAAkBtwD;;qBAGjC;kBACJq9C,GAAGwT,gBAAgBP,kBAAkBtwD;;qBAGjC;kBACJq9C,GAAGyT,gBAAgBR,kBAAkBtwD;;;kBAIrCq9C,GAAG0T,gBAAgBT,kBAAkBtwD;;;;;;MAO3CgxD;;IAGD;MACCC;iBAEWC,cAAcrD;cAClBkB,aAAalB,cAAcqD;mBAEtBC,aAAapC;gBACjBC,WAAWD,WAAWoC;qBAEjB1xD,aAAauvD;YACvBoC,wBAAwBpC,SAASvvD,WAAW4qB;mBACrC2kC,SAASvvD;;iBAGVsvD,WAAWoC;;eAGZtD,cAAcqD;;;IAIvB,iCAAiCj2D;UAC5B4yD,cAAc5yD,SAASnG,QAAQ/B;YAC7Bg8D,aAAalB,cAAc5yD,SAASnG;iBAE/Bq8D,aAAapC;cACjBC,WAAWD,WAAWoC;mBAEjB1xD,aAAauvD;UACvBoC,wBAAwBpC,SAASvvD,WAAW4qB;iBACrC2kC,SAASvvD;;eAGVsvD,WAAWoC;;aAGZtD,cAAc5yD,SAASnG;;IAG/B,gCAAgCm5D;iBACpBiD,cAAcrD;cAClBkB,aAAalB,cAAcqD;YAC7BnC,WAAWd,QAAQn5D,QAAQ/B;cACzBi8D,WAAWD,WAAWd,QAAQn5D;mBAEzB2K,aAAauvD;UACvBoC,wBAAwBpC,SAASvvD,WAAW4qB;iBACrC2kC,SAASvvD;;eAGVsvD,WAAWd,QAAQn5D;;;IAI5B;MACCu8D;UACIrD,iBAAiBF;MACrBE,eAAeF;MACfM,sBAAsBJ,aAAa3jC;;;IAIpC;MACCyjC,aAAa7yD,WAAW;MACxB6yD,aAAaG,UAAU;MACvBH,aAAaruD,YAAY;;;MAIzB6xD,OAAOA;MACPL,OAAOA;MACPI,mBAAmBA;MACnBv+D,SAASA;MACTy+D,yBAAyBA;MACzBC,wBAAwBA;MACxBtB,gBAAgBA;MAChBO,iBAAiBA;MACjBO,yBAAyBA;;;EAI3B,6BAA6B3T,IAAItG,YAAY0a,MAAMnU;UAC5CC,WAAWD,aAAaC;QAC1BmU;IAEJ,iBAAiB1xD;MAChB0xD,OAAO1xD;;IAGR,gBAAgBw+B,OAAOjhC;MACtB8/C,GAAGsU,WAAWD,MAAMlzB,OAAOjhC;MAC3Bk0D,KAAK3tC,OAAOvmB,OAAOm0D,MAAM;;IAG1B,yBAAyBlzB,OAAOjhC,OAAOq0D;UAClCA,cAAc;UACdjE,WAAWkE;UAEXtU;QACHoQ,YAAYtQ;QACZwU,aAAa;;QAEblE,YAAY5W,WAAW4H,IAAI;QAC3BkT,aAAa;YAETlE,cAAc;UACjB34D,QAAQa,MAAM;;;;MAKhB83D,UAAUkE,YAAYH,MAAMlzB,OAAOjhC,OAAOq0D;MAC1CH,KAAK3tC,OAAOvmB,OAAOm0D,MAAME;;;IAI1B,KAAKE,UAAUA;IACf,KAAK1X,SAASA;IACd,KAAK2X,kBAAkBA;;EAGxB,2BAA2B1U,IAAItG,YAAY/Z;QACtCg1B;IAEJ;UACKA,kBAAkBj/D,kBAAkBi/D;UAEpCjb,WAAWkb,IAAI,sCAAsC;cAClDtE,YAAY5W,WAAW4H,IAAI;QACjCqT,gBAAgB3U,GAAG9xB,aAAaoiC,UAAUuE;;QAE1CF,gBAAgB;;aAGVA;;IAGR,yBAAyBzuB;UACpBA,cAAc;YACb8Z,GAAG8U,yBAAyB9U,GAAG+U,eAAe/U,GAAGgV,YAAY9uB,YAAY,KAAK8Z,GAAG8U,yBAAyB9U,GAAGiV,iBAAiBjV,GAAGgV,YAAY9uB,YAAY;iBACrJ;;QAGRA,YAAY;;UAGTA,cAAc;YACb8Z,GAAG8U,yBAAyB9U,GAAG+U,eAAe/U,GAAGkV,cAAchvB,YAAY,KAAK8Z,GAAG8U,yBAAyB9U,GAAGiV,iBAAiBjV,GAAGkV,cAAchvB,YAAY;iBACzJ;;;aAIF;;;UAKFga,kBAAkBiV,2BAA2B,eAAenV,cAAcmV,iCAAiCC,kCAAkC,eAAepV,cAAcoV;;QAG5KlvB,YAAYvG,WAAWuG,cAAcxwC,YAAYiqC,WAAWuG,YAAY;UACtEmvB,eAAeC,gBAAgBpvB;QAEjCmvB,iBAAiBnvB;MACpBvuC,QAAQ0B,KAAK,wBAAwB6sC,WAAW,wBAAwBmvB,cAAc;MACtFnvB,YAAYmvB;;UAGPxb,cAAcqG,YAAYxG,WAAWkb,IAAI;UACzCW,yBAAyB51B,WAAW41B,2BAA2B;UAC/DC,cAAcxV,GAAG9xB,aAAa8xB,GAAGyV;UACjCC,oBAAoB1V,GAAG9xB,aAAa8xB,GAAG2V;UACvCC,iBAAiB5V,GAAG9xB,aAAa8xB,GAAG6V;UACpCC,iBAAiB9V,GAAG9xB,aAAa8xB,GAAG+V;UACpCC,gBAAgBhW,GAAG9xB,aAAa8xB,GAAGqQ;UACnC4F,oBAAoBjW,GAAG9xB,aAAa8xB,GAAGkW;UACvCC,cAAcnW,GAAG9xB,aAAa8xB,GAAGoW;UACjCC,sBAAsBrW,GAAG9xB,aAAa8xB,GAAGsW;UACzCC,iBAAiBb,oBAAoB;UACrCc,wBAAwBtW,YAAYxG,WAAWkb,IAAI;UACnD6B,sBAAsBF,kBAAkBC;UACxCE,aAAaxW,WAAWF,GAAG9xB,aAAa8xB,GAAG2W,eAAe;;MAE/DzW,UAAUA;MACVrG,aAAaA;MACb+c,kBAAkBA;MAClBtB,iBAAiBA;MACjBpvB,WAAWA;MACXqvB,wBAAwBA;MACxBC,aAAaA;MACbE,mBAAmBA;MACnBE,gBAAgBA;MAChBE,gBAAgBA;MAChBE,eAAeA;MACfC,mBAAmBA;MACnBE,aAAaA;MACbE,qBAAqBA;MACrBE,gBAAgBA;MAChBC,uBAAuBA;MACvBC,qBAAqBA;MACrBC,YAAYA;;;EAId,uBAAuBjL;UAChB9T,QAAQ;QACVkf,cAAc,MAChBC,kBAAkB,GAClBC,uBAAuB,OACvBC,mBAAmB;UACfxoC,YAAYmT,SACfs1B,uBAAuBn5C,WACvBq8B;MACFx3C,OAAO;MACPye,aAAa;;IAEd,KAAK+4B,UAAUA;IACf,KAAK+c,YAAY;IACjB,KAAKC,kBAAkB;IAEvB,KAAKC,OAAO,UAAUpZ,QAAQqZ,qBAAqBttC;YAC5C4xB,UAAUqC,OAAOjmD,WAAW,KAAKs/D;;MAEvCP,oBAAoB,KAAKC;MACzBA,uBAAuBM;MACvBR,cAAcS,cAActZ,QAAQj0B,QAAQ;MAC5C+sC,kBAAkB9Y,OAAOjmD;aAClB4jD;;IAGR,KAAK4b,eAAe;MACnBP,mBAAmB;MACnBM,cAAc;;IAGf,KAAKE,aAAa;MACjBR,mBAAmB;MACnBS;;IAGD,KAAKC,WAAW,UAAU15D,UAAU+rB,QAAQ4tC;YACrC3Z,SAAShgD,SAAS6nC,gBACrBC,mBAAmB9nC,SAAS8nC,kBAC5BC,cAAc/nC,SAAS+nC;YACpB6xB,qBAAqBnM,WAAWnK,IAAItjD;WAErC+4D,wBAAwB/Y,WAAW,QAAQA,OAAOjmD,WAAW,KAAKi/D,qBAAqBjxB;;YAEvFixB;;UAEHM,cAAc;;UAEdG;;;cAGKI,UAAUb,mBAAmB,IAAIF,iBACpCgB,UAAUD,UAAU;YACnBE,WAAWH,mBAAmBI,iBAAiB;QACnD7d,QAAQx3C,QAAQo1D;;QAEhBA,WAAWT,cAActZ,QAAQj0B,QAAQ+tC,SAASH;iBAEzC7/D,IAAI,GAAGA,MAAMggE,WAAWhgE;UAChCigE,SAASjgE,KAAK++D,YAAY/+D;;QAG3B8/D,mBAAmBI,gBAAgBD;QACnC,KAAKZ,kBAAkBrxB,mBAAmB,KAAKoxB,YAAY;QAC3D,KAAKA,aAAaW;;;IAIpB;UACK1d,QAAQx3C,UAAUk0D;QACrB1c,QAAQx3C,QAAQk0D;QAChB1c,QAAQ/4B,cAAc01C,kBAAkB;;MAGzCnf,MAAMuf,YAAYJ;MAClBnf,MAAMwf,kBAAkB;;IAGzB,uBAAuBnZ,QAAQj0B,QAAQ9E,WAAWgzC;YAC3CC,UAAUla,WAAW,OAAOA,OAAOjmD,SAAS;UAC9CggE,WAAW;UAEXG,YAAY;QACfH,WAAW5d,QAAQx3C;YAEfs1D,kBAAkB,QAAQF,aAAa;gBACpCI,WAAWlzC,YAAYizC,UAAU,GACpCE,aAAaruC,OAAOC;UACvBitC,iBAAiBl6C,gBAAgBq7C;cAE7BL,aAAa,QAAQA,SAAShgE,SAASogE;YAC1CJ,eAAejoB,aAAaqoB;;mBAGpBrgE,IAAI,GAAGugE,KAAKpzC,WAAWntB,MAAMogE,YAAWpgE,GAAGugE,MAAM;YACzD7pC,MAAM3X,KAAKmnC,OAAOlmD,IAAI6pB,aAAay2C,YAAYnB;YAC/CzoC,MAAMrD,OAAOlS,QAAQ8+C,UAAUM;YAC/BN,SAASM,KAAK,KAAK7pC,MAAMC;;;QAI3B0rB,QAAQx3C,QAAQo1D;QAChB5d,QAAQ/4B,cAAc;;MAGvBu2B,MAAMuf,YAAYgB;MAClBvgB,MAAMwf,kBAAkB;aACjBY;;;EAIT,uBAAuBr0D;QAClB8qD,eAAepO;IAEnB,2BAA2B58B,SAASvE;UAC/BA,YAAYnW;QACf0a,QAAQvE,UAAUrW;iBACRqW,YAAYlW;QACtBya,QAAQvE,UAAUpW;;aAGZ2a;;IAGR,aAAaA;UACRA,WAAWA,QAAQnC;cAChBpC,UAAUuE,QAAQvE;YAEpBA,YAAYnW,oCAAoCmW,YAAYlW;cAC3DylD,SAASoG,IAAIpxC;kBACV80C,UAAU9J,SAASlN,IAAI99B,SAASA;mBAC/B+0C,kBAAkBD,SAAS90C,QAAQvE;;kBAEpCf,QAAQsF,QAAQtF;gBAElBA,SAASA,MAAM5H,SAAS;oBACrBsmC,sBAAsBl5C,SAASm5C;oBAC/BX,mBAAmByB,sBAAsBz/B,MAAM5H,SAAS;cAC9D4lC,aAAamB,2BAA2B35C,UAAU8f;cAClDgrC,SAASvqD,IAAIuf,SAAS04B;cACtBx4C,SAASo5C,gBAAgBF;cACzBp5B,QAAQ/gB,iBAAiB,WAAW+1D;qBAC7BD,kBAAkBrc,aAAa14B,SAASA,QAAQvE;;;qBAGhD;;;;;aAMJuE;;IAGR,0BAA0B7sB;YACnB6sB,UAAU7sB,MAAM2K;MACtBkiB,QAAQ9R,oBAAoB,WAAW8mD;YACjCF,UAAU9J,SAASlN,IAAI99B;UAEzB80C,YAAY5iE;QACf84D,SAAShN,OAAOh+B;QAChB80C,QAAQ7iE;;;IAIV;MACC+4D,eAAepO;;;MAIfkB,KAAKA;MACL7rD,SAASA;;;EAIX,yBAAyBuqD;UAClBtG;IAEN,sBAAsB12C;UACjB02C,WAAW12C,UAAUtN;eACjBgkD,WAAW12C;;UAGfstD;cAEIttD;aACF;UACJstD,YAAYtQ,GAAGyY,aAAa,0BAA0BzY,GAAGyY,aAAa,8BAA8BzY,GAAGyY,aAAa;;aAGhH;UACJnI,YAAYtQ,GAAGyY,aAAa,qCAAqCzY,GAAGyY,aAAa,yCAAyCzY,GAAGyY,aAAa;;aAGtI;UACJnI,YAAYtQ,GAAGyY,aAAa,oCAAoCzY,GAAGyY,aAAa,wCAAwCzY,GAAGyY,aAAa;;aAGpI;UACJnI,YAAYtQ,GAAGyY,aAAa,qCAAqCzY,GAAGyY,aAAa;;;UAIjFnI,YAAYtQ,GAAGyY,aAAaz1D;;MAG9B02C,WAAW12C,QAAQstD;aACZA;;;MAIPsE,KAAK,UAAU5xD;eACPy1D,aAAaz1D,UAAU;;MAE/Bo0D,MAAM,UAAUnX;YACXA,aAAaC;UAChBuY,aAAa;;UAEbA,aAAa;UACbA,aAAa;UACbA,aAAa;UACbA,aAAa;UACbA,aAAa;UACbA,aAAa;UACbA,aAAa;UACbA,aAAa;;QAGdA,aAAa;QACbA,aAAa;;MAEdnX,KAAK,UAAUt+C;cACRstD,YAAYmI,aAAaz1D;YAE3BstD,cAAc;UACjB34D,QAAQ0B,KAAK,0BAA0B2J,OAAO;;eAGxCstD;;;;EAKV,yBAAyBtQ,IAAIxP,YAAY4jB,MAAM5D;UACxC3xB;UACA65B,0BAA0BtY;IAEhC,2BAA2BzpD;YACpBiH,WAAWjH,MAAM2K;UAEnB1D,SAASgU,UAAU;QACtB4+B,WAAWj3C,OAAOqE,SAASgU;;iBAGjB5O,QAAQpF,SAAS4yC;QAC3BA,WAAWj3C,OAAOqE,SAAS4yC,WAAWxtC;;MAGvCpF,SAAS8T,oBAAoB,WAAWinD;aACjC95B,WAAWjhC,SAASnG;YACrB0hB,YAAYu/C,oBAAoBpX,IAAI1jD;UAEtCub;QACHq3B,WAAWj3C,OAAO4f;QAClBu/C,oBAAoBlX,OAAO5jD;;MAG5B4yD,cAAc0D,wBAAwBt2D;UAElCA,SAASg1D,8BAA8B;eACnCh1D,SAASu1D;;;MAIjBiB,KAAKwE,OAAO/5B;;IAGb,aAAa7R,QAAQpvB;UAChBihC,WAAWjhC,SAASnG,QAAQ,aAAamG;MAC7CA,SAAS6E,iBAAiB,WAAWk2D;MACrC95B,WAAWjhC,SAASnG,MAAM;MAC1B28D,KAAKwE,OAAO/5B;aACLjhC;;IAGR,gBAAgBA;YACTq0D,qBAAqBr0D,SAAS4yC;;iBAEzBxtC,QAAQivD;QAClBzhB,WAAW/pB,OAAOwrC,mBAAmBjvD,OAAOg9C,GAAGqT;;;YAI1C5iB,kBAAkB7yC,SAAS6yC;iBAEtBztC,QAAQytC;cACZ1+B,QAAQ0+B,gBAAgBztC;iBAErBlL,IAAI,GAAGma,IAAIF,MAAMha,QAAQD,IAAIma,GAAGna;UACxC04C,WAAW/pB,OAAO1U,MAAMja,IAAIkoD,GAAGqT;;;;IAKlC,kCAAkCz1D;YAC3Bs0C;YACA2mB,gBAAgBj7D,SAASgU;YACzBknD,mBAAmBl7D,SAAS4yC,WAAW/xC;UACzC0hB,UAAU;UAEV04C,kBAAkB;cACf9mD,QAAQ8mD,cAAc9mD;QAC5BoO,UAAU04C,cAAc14C;iBAEfroB,IAAI,GAAGma,IAAIF,MAAMha,QAAQD,IAAIma,GAAGna,KAAK;gBACvCsc,IAAIrC,MAAMja,IAAI;gBACduc,IAAItC,MAAMja,IAAI;gBACdwc,IAAIvC,MAAMja,IAAI;UACpBo6C,QAAQ18C,KAAK4e,GAAGC,GAAGA,GAAGC,GAAGA,GAAGF;;;cAGvBrC,QAAQ+mD,iBAAiB/mD;QAC/BoO,UAAU24C,iBAAiB34C;iBAElBroB,IAAI,GAAGma,IAAIF,MAAMha,SAAS,IAAI,GAAGD,IAAIma,GAAGna,KAAK;gBAC/Csc,IAAItc,IAAI;gBACRuc,IAAIvc,IAAI;gBACRwc,IAAIxc,IAAI;UACdo6C,QAAQ18C,KAAK4e,GAAGC,GAAGA,GAAGC,GAAGA,GAAGF;;;YAIxB+E,iBAAiB43B,SAASmB,WAAW,QAAQlB,wBAAwBC,uBAAuBiB,SAAS;MAC3G/4B,UAAUgH,UAAUA;;;YAGd44C,oBAAoBL,oBAAoBpX,IAAI1jD;UAC9Cm7D,mBAAmBvoB,WAAWj3C,OAAOw/D;;MAEzCL,oBAAoBz0D,IAAIrG,UAAUub;;IAGnC,+BAA+Bvb;YACxBo7D,mBAAmBN,oBAAoBpX,IAAI1jD;UAE7Co7D;cACGH,gBAAgBj7D,SAASgU;YAE3BinD,kBAAkB;;cAEjBG,iBAAiB74C,UAAU04C,cAAc14C;YAC5C84C,yBAAyBr7D;;;;QAI3Bq7D,yBAAyBr7D;;aAGnB86D,oBAAoBpX,IAAI1jD;;;MAI/B0jD,KAAKA;MACL76B,QAAQA;MACRyyC,uBAAuBA;;;EAIzB,oCAAoClZ,IAAItG,YAAY0a,MAAMnU;UACnDC,WAAWD,aAAaC;QAC1BmU;IAEJ,iBAAiB1xD;MAChB0xD,OAAO1xD;;QAGJ7L,MAAMmqD;IAEV,kBAAkBt+C;MACjB7L,OAAO6L,MAAM7L;MACbmqD,kBAAkBt+C,MAAMs+C;;IAGzB,gBAAgB9f,OAAOjhC;MACtB8/C,GAAGmZ,aAAa9E,MAAMn0D,OAAOpJ,MAAMqqC,QAAQ8f;MAC3CmT,KAAK3tC,OAAOvmB,OAAOm0D,MAAM;;IAG1B,yBAAyBlzB,OAAOjhC,OAAOq0D;UAClCA,cAAc;UACdjE,WAAWkE;UAEXtU;QACHoQ,YAAYtQ;QACZwU,aAAa;;QAEblE,YAAY5W,WAAW4H,IAAI;QAC3BkT,aAAa;YAETlE,cAAc;UACjB34D,QAAQa,MAAM;;;;MAKhB83D,UAAUkE,YAAYH,MAAMn0D,OAAOpJ,MAAMqqC,QAAQ8f,iBAAiBsT;MAClEH,KAAK3tC,OAAOvmB,OAAOm0D,MAAME;;;IAI1B,KAAKE,UAAUA;IACf,KAAK3jB,WAAWA;IAChB,KAAKiM,SAASA;IACd,KAAK2X,kBAAkBA;;EAGxB,mBAAmB1U;UACZ4Y;MACL/5B,YAAY;MACZne,UAAU;;UAELq8B;MACL2C,OAAO;MACP0Z,OAAO;MACPC,WAAW;MACX5sC,QAAQ;MACR6sC,OAAO;;IAGR,gBAAgBp5D,OAAOm0D,MAAMkF;MAC5Bxc,OAAOqc;cAEC/E;aACFrU,GAAGwZ;UACPzc,OAAOsc,aAAaE,iBAAiBr5D,QAAQ;;aAGzC8/C,GAAGyZ;UACP1c,OAAOuc,SAASC,iBAAiBr5D,QAAQ;;aAGrC8/C,GAAG0Z;UACP3c,OAAOuc,SAASC,iBAAiBr5D,QAAQ;;aAGrC8/C,GAAG2Z;UACP5c,OAAOuc,SAASC,gBAAgBr5D;;aAG5B8/C,GAAG4Z;UACP7c,OAAOtwB,UAAU8sC,gBAAgBr5D;;;UAIjCvI,QAAQa,MAAM,uCAAuC67D;;;;IAKxD;MACCtX,OAAO2C;MACP3C,OAAOqc,QAAQ;MACfrc,OAAOsc,YAAY;MACnBtc,OAAOtwB,SAAS;MAChBswB,OAAOuc,QAAQ;;;MAIfV,QAAQA;MACR7b,QAAQA;MACR8c,UAAU;MACVC,WAAW;MACXlG,OAAOA;MACPntC,QAAQA;;;EAIV,uBAAuBrS,GAAGC;WAClBD,EAAE,KAAKC,EAAE;;EAGjB,0BAA0BD,GAAGC;WACrBxX,KAAK4W,IAAIY,EAAE,MAAMxX,KAAK4W,IAAIW,EAAE;;EAGpC,2BAA2B4rC;UACpB+Z;UACA3iB,sBAAsBtH,aAAa;UACnCkqB;aAEGliE,IAAI,GAAGA,IAAI,GAAGA;MACtBkiE,eAAeliE,MAAMA,GAAG;;IAGzB,gBAAgBk1B,QAAQpvB,UAAUI,UAAU4yD;YACrCqJ,mBAAmBjtC,OAAOspB;;;YAG1Bv+C,SAASkiE,qBAAqBvkE,YAAY,IAAIukE,iBAAiBliE;UACjEmiE,aAAaH,eAAen8D,SAASnG;UAErCyiE,eAAexkE;;QAElBwkE;iBAESpiE,IAAI,GAAGA,IAAIC,QAAQD;UAC3BoiE,WAAWpiE,MAAMA,GAAG;;QAGrBiiE,eAAen8D,SAASnG,MAAMyiE;;;eAItBpiE,IAAI,GAAGA,IAAIC,QAAQD;cACrBu/C,YAAY6iB,WAAWpiE;QAC7Bu/C,UAAU,KAAKv/C;QACfu/C,UAAU,KAAK4iB,iBAAiBniE;;MAGjCoiE,WAAWC,KAAKC;eAEPtiE,IAAI,GAAGA,IAAI,GAAGA;YAClBA,IAAIC,UAAUmiE,WAAWpiE,GAAG;UAC/BkiE,eAAeliE,GAAG,KAAKoiE,WAAWpiE,GAAG;UACrCkiE,eAAeliE,GAAG,KAAKoiE,WAAWpiE,GAAG;;UAErCkiE,eAAeliE,GAAG,KAAKkuB,OAAOq0C;UAC9BL,eAAeliE,GAAG,KAAK;;;MAIzBkiE,eAAeG,KAAKG;YACd/vB,eAAevsC,SAASusC,gBAAgB3sC,SAAS6yC,gBAAgBhyC;YACjE+rC,eAAexsC,SAASwsC,gBAAgB5sC,SAAS6yC,gBAAgBtlB;UACnEovC,qBAAqB;eAEhBziE,IAAI,GAAGA,IAAI,GAAGA;cAChBu/C,YAAY2iB,eAAeliE;cAC3B8Z,QAAQylC,UAAU;cAClB10C,QAAQ00C,UAAU;YAEpBzlC,UAAUoU,OAAOq0C,oBAAoB13D;cACpC4nC,gBAAgB3sC,SAAS7C,aAAa,gBAAgBjD,OAAOyyC,aAAa34B;YAC7EhU,SAAS9C,aAAa,gBAAgBhD,GAAGyyC,aAAa34B;;cAGnD44B,gBAAgB5sC,SAAS7C,aAAa,gBAAgBjD,OAAO0yC,aAAa54B;YAC7EhU,SAAS9C,aAAa,gBAAgBhD,GAAG0yC,aAAa54B;;UAGvDwlC,gBAAgBt/C,KAAK6K;UACrB43D,sBAAsB53D;;cAElB4nC,gBAAgB3sC,SAASuzC,aAAa,gBAAgBr5C,OAAO;YAChE8F,SAASszC,gBAAgB,gBAAgBp5C;;cAGtC0yC,gBAAgB5sC,SAASuzC,aAAa,gBAAgBr5C,OAAO;YAChE8F,SAASszC,gBAAgB,gBAAgBp5C;;UAG1Cs/C,gBAAgBt/C,KAAK;;;;;;YAOjB0iE,qBAAqB58D,SAAS8yC,uBAAuB,IAAI,IAAI6pB;MACnE3J,QAAQ6J,cAAcC,SAAS1a,IAAI,4BAA4Bwa;MAC/D5J,QAAQ6J,cAAcC,SAAS1a,IAAI,yBAAyB5I;;;MAI5D3wB,QAAQA;;;EAIV,sBAAsBu5B,IAAInhB,YAAY2R,YAAY4jB;QAC7CuG,gBAAgBva;IAEpB,gBAAgBpzB;YACT0yB,QAAQ0U,KAAKrX,OAAO2C;YACpB9hD,WAAWovB,OAAOpvB;YAClBg9D,iBAAiB/7B,WAAWyiB,IAAIt0B,QAAQpvB;;UAE1C+8D,UAAUrZ,IAAIsZ,oBAAoBlb;QACrC7gB,WAAWpY,OAAOm0C;QAClBD,UAAU12D,IAAI22D,gBAAgBlb;;UAG3B1yB,OAAOkS;YACNlS,OAAOvb,iBAAiB,WAAWopD,4BAA4B;UAClE7tC,OAAOvqB,iBAAiB,WAAWo4D;;QAGpCrqB,WAAW/pB,OAAOuG,OAAOmS,gBAAgB6gB,GAAGqT;YAExCrmC,OAAOoS,kBAAkB;UAC5BoR,WAAW/pB,OAAOuG,OAAOoS,eAAe4gB,GAAGqT;;;aAItCuH;;IAGR;MACCD,gBAAgBva;;IAGjB,gCAAgCzpD;YACzBmkE,gBAAgBnkE,MAAM2K;MAC5Bw5D,cAAcppD,oBAAoB,WAAWmpD;MAC7CrqB,WAAWj3C,OAAOuhE,cAAc37B;UAC5B27B,cAAc17B,kBAAkB,MAAMoR,WAAWj3C,OAAOuhE,cAAc17B;;;MAI1E3Y,QAAQA;MACRhxB,SAASA;;;EAIX,iCAAiCspB;IAChC7hB,YAAYhI,OAAO,MAAMmhB,QAAQ,GAAGC,SAAS,GAAG8M,QAAQ;MACvD,MAAM;MACN,KAAKlF;QACJhpB;QACAmhB;QACAC;QACA8M;;MAED,KAAK/D,YAAYhW;MACjB,KAAKiW,YAAYjW;MACjB,KAAK0xD,QAAQ5xD;MACb,KAAK4W,kBAAkB;MACvB,KAAKE,QAAQ;MACb,KAAKC,kBAAkB;MACvB,KAAKkB,cAAc;;;EAKrB45C,mBAAmBvhD,UAAUwhD,uBAAuB;EAEpD,4BAA4Bl8C;IAC3B7hB,YAAYhI,OAAO,MAAMmhB,QAAQ,GAAGC,SAAS,GAAG8M,QAAQ;;;;;;;;MAQvD,MAAM;MACN,KAAKlF;QACJhpB;QACAmhB;QACAC;QACA8M;;MAED,KAAK/D,YAAYhW;MACjB,KAAKiW,YAAYjW;MACjB,KAAK0xD,QAAQ5xD;MACb,KAAK4W,kBAAkB;MACvB,KAAKE,QAAQ;MACb,KAAKC,kBAAkB;MACvB,KAAKkB,cAAc;;;EAKrB85C,cAAczhD,UAAU0hD,kBAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QA4CpCC,mBAAmBr8C;QACnBs8C,0BAA0BL;QAC1BM,qBAAqBJ;QACrBK,uBAAuBte;;;QAGvBue;QACAC;;QAEAC,gBAAgB5rB,aAAa;QAC7B6rB,gBAAgB7rB,aAAa;QAC7B8rB,gBAAgB9rB,aAAa;;EAEnC,iBAAiB/9B,OAAO8pD,SAASC;UAC1BC,YAAYhqD,MAAM;QACpBgqD,aAAa,KAAKA,YAAY,UAAUhqD;;;UAGtCe,IAAI+oD,UAAUC;QAChB5+C,IAAIs+C,cAAc1oD;QAElBoK,MAAMxnB;MACTwnB,QAAQ4yB,aAAah9B;MACrB0oD,cAAc1oD,KAAKoK;;QAGhB2+C,YAAY;MACfE,UAAU9iD,QAAQiE,GAAG;eAEZplB,IAAI,GAAGkhB,SAAS,GAAGlhB,MAAM+jE,WAAW/jE;QAC5CkhB,UAAU8iD;QACV/pD,MAAMja,GAAGmhB,QAAQiE,GAAGlE;;;WAIfkE;;EAGR,qBAAqB9I,GAAGC;QACnBD,EAAErc,WAAWsc,EAAEtc,eAAe;aAEzBD,IAAI,GAAGma,IAAImC,EAAErc,QAAQD,IAAIma,GAAGna;UAChCsc,EAAEtc,OAAOuc,EAAEvc,WAAW;;WAGpB;;EAGR,mBAAmBsc,GAAGC;aACZvc,IAAI,GAAGma,IAAIoC,EAAEtc,QAAQD,IAAIma,GAAGna;MACpCsc,EAAEtc,KAAKuc,EAAEvc;;;;EAKX,uBAAuB4oB,UAAU5N;QAC5BoK,IAAIu+C,cAAc3oD;QAElBoK,MAAMxnB;MACTwnB,QAAQwyB,WAAW58B;MACnB2oD,cAAc3oD,KAAKoK;;aAGXplB,IAAI,GAAGA,MAAMgb,KAAKhb;MAC1BolB,EAAEplB,KAAK4oB,SAASs7C;;WAGV9+C;;;;;;EAOR,qBAAqB8iC,IAAI1jD;UAClBF,QAAQ,KAAKA;QACfA,MAAM,OAAOE;IACjB0jD,GAAGic,UAAU,KAAKC,MAAM5/D;IACxBF,MAAM,KAAKE;;;EAIZ,qBAAqB0jD,IAAI1jD;UAClBF,QAAQ,KAAKA;QAEfE,EAAEoC,MAAMhJ;UACP0G,MAAM,OAAOE,EAAEoC,KAAKtC,MAAM,OAAOE,EAAEuC;QACtCmhD,GAAGmc,UAAU,KAAKD,MAAM5/D,EAAEoC,GAAGpC,EAAEuC;QAC/BzC,MAAM,KAAKE,EAAEoC;QACbtC,MAAM,KAAKE,EAAEuC;;;UAGVu9D,YAAYhgE,OAAOE;MACvB0jD,GAAGqc,WAAW,KAAKH,MAAM5/D;MACzBkyC,UAAUpyC,OAAOE;;;EAInB,qBAAqB0jD,IAAI1jD;UAClBF,QAAQ,KAAKA;QAEfE,EAAEoC,MAAMhJ;UACP0G,MAAM,OAAOE,EAAEoC,KAAKtC,MAAM,OAAOE,EAAEuC,KAAKzC,MAAM,OAAOE,EAAEwC;QAC1DkhD,GAAGsc,UAAU,KAAKJ,MAAM5/D,EAAEoC,GAAGpC,EAAEuC,GAAGvC,EAAEwC;QACpC1C,MAAM,KAAKE,EAAEoC;QACbtC,MAAM,KAAKE,EAAEuC;QACbzC,MAAM,KAAKE,EAAEwC;;eAEJxC,EAAE4gB,MAAMxnB;UACd0G,MAAM,OAAOE,EAAE4gB,KAAK9gB,MAAM,OAAOE,EAAE+f,KAAKjgB,MAAM,OAAOE,EAAE+X;QAC1D2rC,GAAGsc,UAAU,KAAKJ,MAAM5/D,EAAE4gB,GAAG5gB,EAAE+f,GAAG/f,EAAE+X;QACpCjY,MAAM,KAAKE,EAAE4gB;QACb9gB,MAAM,KAAKE,EAAE+f;QACbjgB,MAAM,KAAKE,EAAE+X;;;UAGV+nD,YAAYhgE,OAAOE;MACvB0jD,GAAGuc,WAAW,KAAKL,MAAM5/D;MACzBkyC,UAAUpyC,OAAOE;;;EAInB,qBAAqB0jD,IAAI1jD;UAClBF,QAAQ,KAAKA;QAEfE,EAAEoC,MAAMhJ;UACP0G,MAAM,OAAOE,EAAEoC,KAAKtC,MAAM,OAAOE,EAAEuC,KAAKzC,MAAM,OAAOE,EAAEwC,KAAK1C,MAAM,OAAOE,EAAEwa;QAC9EkpC,GAAGwc,UAAU,KAAKN,MAAM5/D,EAAEoC,GAAGpC,EAAEuC,GAAGvC,EAAEwC,GAAGxC,EAAEwa;QACzC1a,MAAM,KAAKE,EAAEoC;QACbtC,MAAM,KAAKE,EAAEuC;QACbzC,MAAM,KAAKE,EAAEwC;QACb1C,MAAM,KAAKE,EAAEwa;;;UAGVslD,YAAYhgE,OAAOE;MACvB0jD,GAAGyc,WAAW,KAAKP,MAAM5/D;MACzBkyC,UAAUpyC,OAAOE;;;;EAKnB,oBAAoB0jD,IAAI1jD;UACjBF,QAAQ,KAAKA;UACbmb,WAAWjb,EAAEib;QAEfA,aAAa7hB;UACZ0mE,YAAYhgE,OAAOE;MACvB0jD,GAAG0c,iBAAiB,KAAKR,MAAM,OAAO5/D;MACtCkyC,UAAUpyC,OAAOE;;UAEb8/D,YAAYhgE,OAAOmb;MACvBqkD,UAAU33D,IAAIsT;MACdyoC,GAAG0c,iBAAiB,KAAKR,MAAM,OAAON;MACtCptB,UAAUpyC,OAAOmb;;;EAInB,oBAAoByoC,IAAI1jD;UACjBF,QAAQ,KAAKA;UACbmb,WAAWjb,EAAEib;QAEfA,aAAa7hB;UACZ0mE,YAAYhgE,OAAOE;MACvB0jD,GAAG2c,iBAAiB,KAAKT,MAAM,OAAO5/D;MACtCkyC,UAAUpyC,OAAOE;;UAEb8/D,YAAYhgE,OAAOmb;MACvBokD,UAAU13D,IAAIsT;MACdyoC,GAAG2c,iBAAiB,KAAKT,MAAM,OAAOP;MACtCntB,UAAUpyC,OAAOmb;;;EAInB,oBAAoByoC,IAAI1jD;UACjBF,QAAQ,KAAKA;UACbmb,WAAWjb,EAAEib;QAEfA,aAAa7hB;UACZ0mE,YAAYhgE,OAAOE;MACvB0jD,GAAG4c,iBAAiB,KAAKV,MAAM,OAAO5/D;MACtCkyC,UAAUpyC,OAAOE;;UAEb8/D,YAAYhgE,OAAOmb;MACvBmkD,UAAUz3D,IAAIsT;MACdyoC,GAAG4c,iBAAiB,KAAKV,MAAM,OAAOR;MACtCltB,UAAUpyC,OAAOmb;;;;EAKnB,qBAAqByoC,IAAI1jD;UAClBF,QAAQ,KAAKA;QACfA,MAAM,OAAOE;IACjB0jD,GAAG6c,UAAU,KAAKX,MAAM5/D;IACxBF,MAAM,KAAKE;;;EAIZ,qBAAqB0jD,IAAI1jD;UAClBF,QAAQ,KAAKA;QACfggE,YAAYhgE,OAAOE;IACvB0jD,GAAG8c,WAAW,KAAKZ,MAAM5/D;IACzBkyC,UAAUpyC,OAAOE;;EAGlB,qBAAqB0jD,IAAI1jD;UAClBF,QAAQ,KAAKA;QACfggE,YAAYhgE,OAAOE;IACvB0jD,GAAG+c,WAAW,KAAKb,MAAM5/D;IACzBkyC,UAAUpyC,OAAOE;;EAGlB,qBAAqB0jD,IAAI1jD;UAClBF,QAAQ,KAAKA;QACfggE,YAAYhgE,OAAOE;IACvB0jD,GAAGgd,WAAW,KAAKd,MAAM5/D;IACzBkyC,UAAUpyC,OAAOE;;;EAIlB,sBAAsB0jD,IAAI1jD;UACnBF,QAAQ,KAAKA;QACfA,MAAM,OAAOE;IACjB0jD,GAAGid,WAAW,KAAKf,MAAM5/D;IACzBF,MAAM,KAAKE;;;EAIZ,sBAAsB0jD,IAAI1jD;UACnBF,QAAQ,KAAKA;QACfggE,YAAYhgE,OAAOE;IACvB0jD,GAAGkd,YAAY,KAAKhB,MAAM5/D;IAC1BkyC,UAAUpyC,OAAOE;;EAGlB,sBAAsB0jD,IAAI1jD;UACnBF,QAAQ,KAAKA;QACfggE,YAAYhgE,OAAOE;IACvB0jD,GAAGmd,YAAY,KAAKjB,MAAM5/D;IAC1BkyC,UAAUpyC,OAAOE;;EAGlB,sBAAsB0jD,IAAI1jD;UACnBF,QAAQ,KAAKA;QACfggE,YAAYhgE,OAAOE;IACvB0jD,GAAGod,YAAY,KAAKlB,MAAM5/D;IAC1BkyC,UAAUpyC,OAAOE;;;EAIlB,oBAAoB0jD,IAAI1jD,GAAGokB;UACpBtkB,QAAQ,KAAKA;UACbihE,OAAO38C,SAASs7C;QAElB5/D,MAAM,OAAOihE;MAChBrd,GAAG6c,UAAU,KAAKX,MAAMmB;MACxBjhE,MAAM,KAAKihE;;IAGZ38C,SAAS48C,iBAAiBhhE,KAAK8+D,cAAciC;;EAG9C,sBAAsBrd,IAAI1jD,GAAGokB;UACtBtkB,QAAQ,KAAKA;UACbihE,OAAO38C,SAASs7C;QAElB5/D,MAAM,OAAOihE;MAChBrd,GAAG6c,UAAU,KAAKX,MAAMmB;MACxBjhE,MAAM,KAAKihE;;IAGZ38C,SAAS68C,aAAajhE,KAAKg/D,gBAAgB+B;;EAG5C,oBAAoBrd,IAAI1jD,GAAGokB;UACpBtkB,QAAQ,KAAKA;UACbihE,OAAO38C,SAASs7C;QAElB5/D,MAAM,OAAOihE;MAChBrd,GAAG6c,UAAU,KAAKX,MAAMmB;MACxBjhE,MAAM,KAAKihE;;IAGZ38C,SAAS88C,mBAAmBlhE,KAAKi/D,kBAAkB8B;;EAGpD,2BAA2Brd,IAAI1jD,GAAGokB;UAC3BtkB,QAAQ,KAAKA;UACbihE,OAAO38C,SAASs7C;QAElB5/D,MAAM,OAAOihE;MAChBrd,GAAG6c,UAAU,KAAKX,MAAMmB;MACxBjhE,MAAM,KAAKihE;;IAGZ38C,SAAS+8C,kBAAkBnhE,KAAK++D,qBAAqBgC;;;EAItD,2BAA2BvmE;YAClBA;WACF;eACG4mE;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;WACA;eACGC;WAGH;WACA;eACGC;WAGH;WACA;eACGC;WAGH;WACA;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;WAEA;WAEA;WAEA;WAEA;;eAEGC;WAEH;WAEA;WAEA;;eAEGC;WAEH;WAEA;WAEA;WAEA;;eAEGC;WAEH;WAEA;WAEA;WAEA;;eAEGC;;;;EAKV,0BAA0B5e,IAAI1jD;IAC7B0jD,GAAG6e,WAAW,KAAK3C,MAAM5/D;;;EAI1B,0BAA0B0jD,IAAI1jD;UACvBpH,OAAO4pE,QAAQxiE,GAAG,KAAK2F,MAAM;IACnC+9C,GAAGqc,WAAW,KAAKH,MAAMhnE;;EAG1B,0BAA0B8qD,IAAI1jD;UACvBpH,OAAO4pE,QAAQxiE,GAAG,KAAK2F,MAAM;IACnC+9C,GAAGuc,WAAW,KAAKL,MAAMhnE;;EAG1B,0BAA0B8qD,IAAI1jD;UACvBpH,OAAO4pE,QAAQxiE,GAAG,KAAK2F,MAAM;IACnC+9C,GAAGyc,WAAW,KAAKP,MAAMhnE;;;EAI1B,yBAAyB8qD,IAAI1jD;UACtBpH,OAAO4pE,QAAQxiE,GAAG,KAAK2F,MAAM;IACnC+9C,GAAG0c,iBAAiB,KAAKR,MAAM,OAAOhnE;;EAGvC,yBAAyB8qD,IAAI1jD;UACtBpH,OAAO4pE,QAAQxiE,GAAG,KAAK2F,MAAM;IACnC+9C,GAAG2c,iBAAiB,KAAKT,MAAM,OAAOhnE;;EAGvC,yBAAyB8qD,IAAI1jD;UACtBpH,OAAO4pE,QAAQxiE,GAAG,KAAK2F,MAAM;IACnC+9C,GAAG4c,iBAAiB,KAAKV,MAAM,OAAOhnE;;;EAIvC,0BAA0B8qD,IAAI1jD;IAC7B0jD,GAAG+e,WAAW,KAAK7C,MAAM5/D;;;EAI1B,0BAA0B0jD,IAAI1jD;IAC7B0jD,GAAG8c,WAAW,KAAKZ,MAAM5/D;;EAG1B,0BAA0B0jD,IAAI1jD;IAC7B0jD,GAAG+c,WAAW,KAAKb,MAAM5/D;;EAG1B,0BAA0B0jD,IAAI1jD;IAC7B0jD,GAAGgd,WAAW,KAAKd,MAAM5/D;;;EAI1B,2BAA2B0jD,IAAI1jD;IAC9B0jD,GAAGgf,YAAY,KAAK9C,MAAM5/D;;;EAI3B,2BAA2B0jD,IAAI1jD;IAC9B0jD,GAAGkd,YAAY,KAAKhB,MAAM5/D;;EAG3B,2BAA2B0jD,IAAI1jD;IAC9B0jD,GAAGmd,YAAY,KAAKjB,MAAM5/D;;EAG3B,2BAA2B0jD,IAAI1jD;IAC9B0jD,GAAGod,YAAY,KAAKlB,MAAM5/D;;;EAI3B,yBAAyB0jD,IAAI1jD,GAAGokB;UACzB5N,IAAIxW,EAAEvE;UACNknE,QAAQC,cAAcx+C,UAAU5N;IACtCktC,GAAG+e,WAAW,KAAK7C,MAAM+C;aAEhBnnE,IAAI,GAAGA,MAAMgb,KAAKhb;MAC1B4oB,SAAS48C,iBAAiBhhE,EAAExE,MAAMsjE,cAAc6D,MAAMnnE;;;EAIxD,yBAAyBkoD,IAAI1jD,GAAGokB;UACzB5N,IAAIxW,EAAEvE;UACNknE,QAAQC,cAAcx+C,UAAU5N;IACtCktC,GAAG+e,WAAW,KAAK7C,MAAM+C;aAEhBnnE,IAAI,GAAGA,MAAMgb,KAAKhb;MAC1B4oB,SAAS88C,mBAAmBlhE,EAAExE,MAAMyjE,kBAAkB0D,MAAMnnE;;;;EAK9D,4BAA4BhB;YACnBA;WACF;eACGqoE;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;WACA;eACGC;WAGH;WACA;eACGC;WAGH;WACA;eACGC;WAGH;WACA;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;eACGC;WAGH;WAEA;WAEA;WAEA;WAEA;;eAEGC;WAEH;WAEA;WAEA;WAEA;;eAEGC;;;;EAKV,uBAAuB1oE,IAAI2oE,YAAYlE;IACtC,KAAKzkE,KAAKA;IACV,KAAKykE,OAAOA;IACZ,KAAK9/D;IACL,KAAKs+D,WAAW2F,kBAAkBD,WAAWtpE;;EAG9C,0BAA0BW,IAAI2oE,YAAYlE;IACzC,KAAKzkE,KAAKA;IACV,KAAKykE,OAAOA;IACZ,KAAK9/D;IACL,KAAK6F,OAAOm+D,WAAWn+D;IACvB,KAAKy4D,WAAW4F,mBAAmBF,WAAWtpE;;EAG/CypE,iBAAiB9mD,UAAU+mD,cAAc,UAAUtrE;UAC5CkH,QAAQ,KAAKA;QAEflH,gBAAgB46C,gBAAgB1zC,MAAMrE,WAAW7C,KAAK6C;MACzD,KAAKqE,YAAY0zC,aAAa56C,KAAK6C;;IAGpCy2C,UAAUpyC,OAAOlH;;EAGlB,2BAA2BuC;IAC1B,KAAKA,KAAKA;IACV,KAAKgpE;IACL,KAAK7mE;;EAGN8mE,kBAAkBjnD,UAAUihD,WAAW,UAAU1a,IAAIr9C,OAAO+d;UACrD+/C,MAAM,KAAKA;aAER3oE,IAAI,GAAGgb,IAAI2tD,IAAI1oE,QAAQD,MAAMgb,KAAKhb;YACpCmrC,IAAIw9B,IAAI3oE;MACdmrC,EAAEy3B,SAAS1a,IAAIr9C,MAAMsgC,EAAExrC,KAAKipB;;;;;QAMxBigD,aAAa;;;;;;;;;EASnB,oBAAoBC,WAAWC;IAC9BD,UAAUH,IAAIjrE,KAAKqrE;IACnBD,UAAUhnE,IAAIinE,cAAcppE,MAAMopE;;EAGnC,sBAAsBT,YAAYlE,MAAM0E;UACjCE,OAAOV,WAAWp9D,MACrB+9D,aAAaD,KAAK/oE;;IAErB4oE,WAAWK,YAAY;WAEhB;YACAC,QAAQN,WAAWl1B,KAAKq1B,OAC3BI,WAAWP,WAAWK;UACrBvpE,KAAKwpE,MAAM;YACTE,YAAYF,MAAM,OAAO,KAC5BG,YAAYH,MAAM;UACjBE,WAAW1pE,KAAKA,KAAK;;UAErB2pE,cAAc1rE,aAAa0rE,cAAc,OAAOF,WAAW,MAAMH;;QAEpEM,WAAWT,WAAWQ,cAAc1rE,gBAAgB4rE,cAAc7pE,IAAI2oE,YAAYlE,YAAYqE,iBAAiB9oE,IAAI2oE,YAAYlE;;;;cAIzHtiE,MAAMgnE,UAAUhnE;YAClB2nE,OAAO3nE,IAAInC;YAEX8pE,SAAS7rE;UACZ6rE,WAAWb,kBAAkBjpE;UAC7B4pE,WAAWT,WAAWW;;QAGvBX,YAAYW;;;;;EAMf,uBAAuBvhB,IAAI4Q;IAC1B,KAAK6P;IACL,KAAK7mE;UACCkZ,IAAIktC,GAAGwhB,oBAAoB5Q,SAAS5Q,GAAGyhB;aAEpC3pE,IAAI,GAAGA,IAAIgb,KAAKhb;YAClBs8D,OAAOpU,GAAG0hB,iBAAiB9Q,SAAS94D,IACvCokE,OAAOlc,GAAG2hB,mBAAmB/Q,SAASwD,KAAKpxD;MAC9C4+D,aAAaxN,MAAM8H,MAAM;;;EAI3B2F,cAAcpoD,UAAUihD,WAAW,UAAU1a,IAAIh9C,MAAML,OAAO+d;UACvDuiB,IAAI,KAAKrpC,IAAIoJ;QACfigC,MAAMvtC,WAAWutC,EAAEy3B,SAAS1a,IAAIr9C,OAAO+d;;EAG5CmhD,cAAcpoD,UAAUqoD,cAAc,UAAU9hB,IAAIhzB,QAAQhqB;UACrD1G,IAAI0wB,OAAOhqB;QACb1G,MAAM5G,WAAW,KAAKglE,SAAS1a,IAAIh9C,MAAM1G;;;EAI9CulE,cAAcE,SAAS,UAAU/hB,IAAIygB,KAAKrgC,QAAQ1f;aACxC5oB,IAAI,GAAGgb,IAAI2tD,IAAI1oE,QAAQD,MAAMgb,KAAKhb;YACpCmrC,IAAIw9B,IAAI3oE,IACXwE,IAAI8jC,OAAO6C,EAAExrC;UAEZ6E,EAAE8kB,gBAAgB;;QAErB6hB,EAAEy3B,SAAS1a,IAAI1jD,EAAEqG,OAAO+d;;;;EAK3BmhD,cAAcG,eAAe,UAAUvB,KAAKrgC;UACrCljB;aAEGplB,IAAI,GAAGgb,IAAI2tD,IAAI1oE,QAAQD,MAAMgb,KAAKhb;YACpCmrC,IAAIw9B,IAAI3oE;WACVmrC,EAAExrC,MAAM2oC,SAAQljB,EAAE1nB,KAAKytC;;WAGrB/lB;;EAGR,qBAAqB8iC,IAAIlpD,MAAMy0C;UACxB+R,SAAS0C,GAAGiiB,aAAanrE;IAC/BkpD,GAAGkiB,aAAa5kB,QAAQ/R;IACxByU,GAAGmiB,cAAc7kB;WACVA;;MAGJ8kB,iBAAiB;EAErB,wBAAwB72B;UACjB+tB,QAAQ/tB,OAAOvwC,MAAM;aAElBlD,IAAI,GAAGA,IAAIwhE,MAAMvhE,QAAQD;MACjCwhE,MAAMxhE,KAAKA,IAAI,IAAI,OAAOwhE,MAAMxhE;;WAG1BwhE,MAAM3gE,KAAK;;EAGnB,+BAA+B8mB;YACtBA;WACF1Q;gBACI,UAAU;WAEdC;gBACI,QAAQ;WAEZE;gBACI,QAAQ;WAEZE;gBACI,QAAQ;WAEZC;gBACI,QAAQ;WAEZC;gBACI,QAAQ;WAEZL;gBACI,SAAS;WAEbE;gBACI,UAAU;;QAGlBxX,QAAQ0B,KAAK,6CAA6ComB;gBAClD,UAAU;;;EAIrB,yBAAyBugC,IAAI1C,QAAQxmD;UAC9BurE,SAASriB,GAAGsiB,mBAAmBhlB,QAAQ0C,GAAGuiB;UAC1C/oE,MAAMwmD,GAAGwiB,iBAAiBllB,QAAQmlB;QACpCJ,UAAU7oE,QAAQ,WAAW;;;UAG3B8mB,SAAS0/B,GAAG0iB,gBAAgBplB;WAC3B,8CAA8CxmD,OAAO,OAAO0C,MAAMmpE,eAAeriD;;EAGzF,kCAAkCsiD,cAAcnjD;UACzCisB,aAAam3B,sBAAsBpjD;WAClC,UAAUmjD,eAAe,6BAA6Bl3B,WAAW,KAAK,aAAaA,WAAW,KAAK;;EAG3G,kCAAkCk3B,cAAcnjD;UACzCisB,aAAam3B,sBAAsBpjD;WAClC,UAAUmjD,eAAe,qCAAqCl3B,WAAW,KAAKA,WAAW,KAAK;;EAGtG,gCAAgCk3B,cAAc/S;QACzCiT;YAEIjT;WACFvnD;QACJw6D,kBAAkB;;WAGdv6D;QACJu6D,kBAAkB;;WAGdt6D;QACJs6D,kBAAkB;;WAGdr6D;QACJq6D,kBAAkB;;WAGdp6D;QACJo6D,kBAAkB;;;QAIlBnrE,QAAQ0B,KAAK,gDAAgDw2D;QAC7DiT,kBAAkB;;WAGb,UAAUF,eAAe,6BAA6BE,kBAAkB;;EAGhF,4BAA4BnjC;UACrBojC,UAAUpjC,WAAWqjC,wBAAwBrjC,WAAWsjC,gBAAgBtjC,WAAW6I,WAAW7I,WAAWujC,yBAAyBvjC,WAAWqI,sBAAsBrI,WAAWqH,eAAerH,WAAWwjC,aAAa,aAAa,oDAAoD,KAAKxjC,WAAWyjC,sBAAsBzjC,WAAW41B,2BAA2B51B,WAAW0jC,6BAA6B,0CAA0C,IAAI1jC,WAAW2jC,wBAAwB3jC,WAAW4jC,+BAA+B,6CAA6C,KAAK5jC,WAAW6jC,6BAA6B7jC,WAAWyJ,UAAUzJ,WAAW+J,eAAe,QAAQ/J,WAAW8jC,oCAAoC,kDAAkD;WACtvBV,OAAO9rE,OAAOysE,iBAAiB/qE,KAAK;;EAG5C,yBAAyB0gD;UAClB0pB;eAEK//D,QAAQq2C;YACZ12C,QAAQ02C,QAAQr2C;UAClBL,UAAU;MACdogE,OAAOvtE,KAAK,aAAawN,OAAO,MAAML;;WAGhCogE,OAAOpqE,KAAK;;EAGpB,iCAAiCqnD,IAAI4Q;UAC9BpgB;UACA19B,IAAIktC,GAAGwhB,oBAAoB5Q,SAAS5Q,GAAG2jB;aAEpC7rE,IAAI,GAAGA,IAAIgb,GAAGhb;YAChBs8D,OAAOpU,GAAG4jB,gBAAgBhT,SAAS94D;YACnCkL,OAAOoxD,KAAKpxD;;MAElBwtC,WAAWxtC,QAAQg9C,GAAG6jB,kBAAkBjT,SAAS5tD;;WAG3CwtC;;EAGR,yBAAyBjF;WACjBA,WAAW;;EAGnB,0BAA0BA,QAAQ5L;WAC1B4L,OAAOu4B,QAAQ,mBAAmBnkC,WAAWokC,cAAcD,QAAQ,oBAAoBnkC,WAAWqkC,eAAeF,QAAQ,yBAAyBnkC,WAAWskC,mBAAmBH,QAAQ,qBAAqBnkC,WAAWukC,gBAAgBJ,QAAQ,oBAAoBnkC,WAAWwkC,eAAeL,QAAQ,0BAA0BnkC,WAAWykC,oBAAoBN,QAAQ,2BAA2BnkC,WAAW0kC,qBAAqBP,QAAQ,4BAA4BnkC,WAAW2kC;;EAGzd,kCAAkC/4B,QAAQ5L;WAClC4L,OAAOu4B,QAAQ,wBAAwBnkC,WAAW4kC,mBAAmBT,QAAQ,0BAA0BnkC,WAAW4kC,oBAAoB5kC,WAAW6kC;;;QAInJC,iBAAiB;EAEvB,yBAAyBl5B;WACjBA,OAAOu4B,QAAQW,gBAAgBC;;EAGvC,yBAAyBzD,OAAO0D;UACzBp5B,SAASye,YAAY2a;QAEvBp5B,WAAW71C;gBACJwN,MAAM,+BAA+ByhE,UAAU;;WAGnDC,gBAAgBr5B;;;QAIlBs5B,8BAA8B;QAC9BC,oBAAoB;EAE1B,qBAAqBv5B;WACbA,OAAOu4B,QAAQgB,mBAAmBC,cAAcjB,QAAQe,6BAA6BG;;EAG7F,gCAAgC/D,OAAO9/B,OAAOI,KAAK0jC;IAClDttE,QAAQ0B,KAAK;WACN0rE,aAAa9D,OAAO9/B,OAAOI,KAAK0jC;;EAGxC,sBAAsBhE,OAAO9/B,OAAOI,KAAK0jC;QACpC15B,SAAS;aAEJzzC,IAAI6zC,SAASxK,QAAQrpC,IAAI6zC,SAASpK,MAAMzpC;MAChDyzC,UAAU05B,QAAQnB,QAAQ,gBAAgB,OAAOhsE,IAAI,MAAMgsE,QAAQ,wBAAwBhsE;;WAGrFyzC;;;EAIR,2BAA2B5L;QACtBulC,kBAAkB,eAAevlC,WAAWuG,YAAY,wBAAwBvG,WAAWuG,YAAY;QAEvGvG,WAAWuG,cAAc;MAC5Bg/B,mBAAmB;eACTvlC,WAAWuG,cAAc;MACnCg/B,mBAAmB;eACTvlC,WAAWuG,cAAc;MACnCg/B,mBAAmB;;WAGbA;;EAGR,qCAAqCvlC;QAChCwlC,sBAAsB;QAEtBxlC,WAAWylC,kBAAkBx/D;MAChCu/D,sBAAsB;eACZxlC,WAAWylC,kBAAkBv/D;MACvCs/D,sBAAsB;eACZxlC,WAAWylC,kBAAkBt/D;MACvCq/D,sBAAsB;;WAGhBA;;EAGR,kCAAkCxlC;QAC7B0lC,mBAAmB;QAEnB1lC,WAAWyJ;cACNzJ,WAAW2lC;aACb18D;aACAC;UACJw8D,mBAAmB;;aAGfr8D;aACAC;UACJo8D,mBAAmB;;;;WAKfA;;EAGR,kCAAkC1lC;QAC7B4lC,mBAAmB;QAEnB5lC,WAAWyJ;cACNzJ,WAAW2lC;aACbz8D;aACAI;UACJs8D,mBAAmB;;;;WAKfA;;EAGR,sCAAsC5lC;QACjC6lC,uBAAuB;QAEvB7lC,WAAWyJ;cACNzJ,WAAW0J;aACbnhC;UACJs9D,uBAAuB;;aAGnBr9D;UACJq9D,uBAAuB;;aAGnBp9D;UACJo9D,uBAAuB;;;;WAKnBA;;EAGR,sBAAsB9hE,UAAU+hE,UAAU9lC,YAAY6wB;UAC/CxQ,KAAKt8C,SAAS8a;UACd66B,UAAU1Z,WAAW0Z;QACvBC,eAAe3Z,WAAW2Z;QAC1BC,iBAAiB5Z,WAAW4Z;UAC1B4rB,sBAAsBO,4BAA4B/lC;UAClD0lC,mBAAmBM,yBAAyBhmC;UAC5C4lC,mBAAmBK,yBAAyBjmC;UAC5C6lC,uBAAuBK,6BAA6BlmC;UACpDmmC,oBAAoBpiE,SAASuoC,cAAc,IAAIvoC,SAASuoC,cAAc;UACtE85B,mBAAmBpmC,WAAWugB,WAAW,KAAK8lB,mBAAmBrmC;UACjEsmC,gBAAgBC,gBAAgB7sB;UAChCuX,UAAU5Q,GAAGmmB;QACfC,cAAcC;QACdC,gBAAgB3mC,WAAWua,cAAc,cAAcva,WAAWua,cAAc,OAAO;QAEvFva,WAAW4mC;MACdH,gBAAgBH,eAAehvE,OAAOysE,iBAAiB/qE,KAAK;UAExDytE,aAAaruE,SAAS;QACzBquE,gBAAgB;;MAGjBC,kBAAkBN,kBAAkBE,eAAehvE,OAAOysE,iBAAiB/qE,KAAK;UAE5E0tE,eAAetuE,SAAS;QAC3BsuE,kBAAkB;;;MAGnBD,gBAAgBI,kBAAkB7mC,aAAa,yBAAyBA,WAAW8mC,YAAYR,eAAetmC,WAAW+mC,aAAa,2BAA2B,IAAI/mC,WAAWgnC,kBAAkB,iCAAiC,IAAIhnC,WAAWinC,yBAAyB,4BAA4B,IAAI,0BAA0Bd,mBAAmB,uBAAuBnmC,WAAWknC,UAAUlnC,WAAWmnC,UAAUnnC,WAAWz7B,MAAM,oBAAoB,IAAIy7B,WAAWmnC,UAAUnnC,WAAWonC,UAAU,qBAAqB,IAAIpnC,WAAW/lC,MAAM,oBAAoB,IAAI+lC,WAAWyJ,SAAS,uBAAuB,IAAIzJ,WAAWyJ,SAAS,aAAam8B,mBAAmB,IAAI5lC,WAAWyI,WAAW,yBAAyB,IAAIzI,WAAW2I,QAAQ,sBAAsB,IAAI3I,WAAWuJ,cAAc,4BAA4B,IAAIvJ,WAAW6I,UAAU,wBAAwB,IAAI7I,WAAW+I,YAAY,0BAA0B,IAAI/I,WAAW+I,aAAa/I,WAAWqnC,uBAAuB,kCAAkC,IAAIrnC,WAAW+I,aAAa/I,WAAWujC,wBAAwB,mCAAmC,IAAIvjC,WAAWmI,eAAe,6BAA6B,IAAInI,WAAWoI,wBAAwB,uCAAuC,IAAIpI,WAAWqI,qBAAqB,oCAAoC,IAAIrI,WAAWkJ,mBAAmBlJ,WAAWinC,yBAAyB,gCAAgC,IAAIjnC,WAAWwJ,cAAc,4BAA4B,IAAIxJ,WAAWqJ,eAAe,6BAA6B,IAAIrJ,WAAWsJ,eAAe,6BAA6B,IAAItJ,WAAWwI,WAAW,yBAAyB,IAAIxI,WAAW+J,eAAe,6BAA6B,IAAI/J,WAAWgK,kBAAkB,gCAAgC,IAAIhK,WAAWkK,eAAe,6BAA6B,IAAIlK,WAAWsnC,iBAAiB,wBAAwB,IAAItnC,WAAW8E,eAAe,sBAAsB,IAAI9E,WAAWunC,eAAe,4BAA4B,IAAIvnC,WAAWwnC,YAAY,mBAAmB,IAAIxnC,WAAWynC,gBAAgB,4BAA4B,IAAIznC,WAAWqH,cAAc,wBAAwB,IAAIrH,WAAW0nC,WAAW,yBAAyB,IAAI1nC,WAAW2nC,mBAAmB,yBAAyB,IAAI3nC,WAAW4K,eAAe,6BAA6B,IAAI5K,WAAW6K,gBAAgB7K,WAAWqH,gBAAgB,QAAQ,6BAA6B,IAAIrH,WAAW4nC,cAAc,yBAAyB,IAAI5nC,WAAW6nC,YAAY,uBAAuB,IAAI7nC,WAAW8nC,mBAAmB,0BAA0B,IAAI9nC,WAAW8nC,mBAAmB,aAAatC,sBAAsB,IAAIxlC,WAAWqK,kBAAkB,gCAAgC,IAAIrK,WAAW41B,yBAAyB,4BAA4B,IAAI51B,WAAW41B,0BAA0B51B,WAAW0jC,6BAA6B,gCAAgC,IAAI,6BAA6B,iCAAiC,kCAAkC,4BAA4B,8BAA8B,gCAAgC,gCAAgC,yBAAyB,mCAAmC,UAAU,+BAA+B,kCAAkC,UAAU,4BAA4B,0BAA0B,sBAAsB,sBAAsB,4BAA4B,UAAU,kCAAkC,0BAA0B,8BAA8B,0BAA0B,UAAU,2BAA2B,iCAAiC,iCAAiC,iCAAiC,iCAAiC,4BAA4B,kCAAkC,kCAAkC,kCAAkC,kCAAkC,UAAU,kCAAkC,kCAAkC,kCAAkC,kCAAkC,WAAW,UAAU,uBAAuB,8BAA8B,+BAA+B,UAAU,MAAMpsE,OAAOysE,iBAAiB/qE,KAAK;MAC7iI0tE,kBAAkBN,kBAAkBS,kBAAkB7mC,aAAa,yBAAyBA,WAAW8mC,YAAYR,eAAetmC,WAAW4G,YAAY,uBAAuB5G,WAAW4G,aAAa5G,WAAW4G,YAAY,IAAI,KAAK,QAAQ;MAChP,0BAA0Bu/B,mBAAmBnmC,WAAWmnC,UAAUnnC,WAAWz7B,MAAM,oBAAoB,IAAIy7B,WAAWmnC,UAAUnnC,WAAWonC,UAAU,qBAAqB,IAAIpnC,WAAW/lC,MAAM,oBAAoB,IAAI+lC,WAAWuI,SAAS,uBAAuB,IAAIvI,WAAWyJ,SAAS,uBAAuB,IAAIzJ,WAAWyJ,SAAS,aAAai8B,mBAAmB,IAAI1lC,WAAWyJ,SAAS,aAAam8B,mBAAmB,IAAI5lC,WAAWyJ,SAAS,aAAao8B,uBAAuB,IAAI7lC,WAAWyI,WAAW,yBAAyB,IAAIzI,WAAW2I,QAAQ,sBAAsB,IAAI3I,WAAWuJ,cAAc,4BAA4B,IAAIvJ,WAAW6I,UAAU,wBAAwB,IAAI7I,WAAW+I,YAAY,0BAA0B,IAAI/I,WAAW+I,aAAa/I,WAAWqnC,uBAAuB,kCAAkC,IAAIrnC,WAAW+I,aAAa/I,WAAWujC,wBAAwB,mCAAmC,IAAIvjC,WAAWmI,eAAe,6BAA6B,IAAInI,WAAWoI,wBAAwB,uCAAuC,IAAIpI,WAAWqI,qBAAqB,oCAAoC,IAAIrI,WAAWwJ,cAAc,4BAA4B,IAAIxJ,WAAWqJ,eAAe,6BAA6B,IAAIrJ,WAAWsJ,eAAe,6BAA6B,IAAItJ,WAAWwI,WAAW,yBAAyB,IAAIxI,WAAW4H,QAAQ,sBAAsB,IAAI5H,WAAW+J,eAAe,6BAA6B,IAAI/J,WAAWgK,kBAAkB,gCAAgC,IAAIhK,WAAWkK,eAAe,6BAA6B,IAAIlK,WAAWsnC,iBAAiB,wBAAwB,IAAItnC,WAAW8E,gBAAgB9E,WAAWgnC,kBAAkB,sBAAsB,IAAIhnC,WAAWunC,eAAe,4BAA4B,IAAIvnC,WAAWwnC,YAAY,mBAAmB,IAAIxnC,WAAWynC,gBAAgB,4BAA4B,IAAIznC,WAAW8J,cAAc,4BAA4B,IAAI9J,WAAWqH,cAAc,wBAAwB,IAAIrH,WAAW4nC,cAAc,yBAAyB,IAAI5nC,WAAW6nC,YAAY,uBAAuB,IAAI7nC,WAAW8nC,mBAAmB,0BAA0B,IAAI9nC,WAAW8nC,mBAAmB,aAAatC,sBAAsB,IAAIxlC,WAAW8G,qBAAqB,gCAAgC,IAAI9G,WAAW+nC,0BAA0B,sCAAsC,IAAI/nC,WAAW41B,yBAAyB,4BAA4B,IAAI51B,WAAW41B,0BAA0B51B,WAAW0jC,6BAA6B,gCAAgC,KAAK1jC,WAAW6jC,6BAA6B7jC,WAAWyJ,WAAWzJ,WAAW8jC,oCAAoC,4BAA4B,IAAI,4BAA4B,gCAAgC,gCAAgC9jC,WAAWkwB,gBAAgBxnD,gBAAgB,yBAAyB,IAAIs3B,WAAWkwB,gBAAgBxnD,gBAAgB2hD,YAAY,+BAA+B;MAC74FrqB,WAAWkwB,gBAAgBxnD,gBAAgBs/D,uBAAuB,eAAehoC,WAAWkwB,eAAe,IAAIlwB,WAAW2G,YAAY,sBAAsB,IAAI0jB,YAAY;MAC5KrqB,WAAW/lC,MAAMguE,yBAAyB,oBAAoBjoC,WAAWkoC,eAAe,IAAIloC,WAAWuI,SAAS0/B,yBAAyB,uBAAuBjoC,WAAWmoC,kBAAkB,IAAInoC,WAAWyJ,SAASw+B,yBAAyB,uBAAuBjoC,WAAWooC,kBAAkB,IAAIpoC,WAAWuJ,cAAc0+B,yBAAyB,4BAA4BjoC,WAAWqoC,uBAAuB,IAAIroC,WAAWyI,WAAWw/B,yBAAyB,yBAAyBjoC,WAAWsoC,oBAAoB,IAAIC,yBAAyB,uBAAuBvoC,WAAWwoC,iBAAiBxoC,WAAWyoC,eAAe,2BAA2BzoC,WAAWyoC,eAAe,IAAI,MAAMnxE,OAAOysE,iBAAiB/qE,KAAK;;IAGxsB2gD,eAAesrB,gBAAgBtrB;IAC/BA,eAAe+uB,iBAAiB/uB,cAAc3Z;IAC9C2Z,eAAegvB,yBAAyBhvB,cAAc3Z;IACtD4Z,iBAAiBqrB,gBAAgBrrB;IACjCA,iBAAiB8uB,iBAAiB9uB,gBAAgB5Z;IAClD4Z,iBAAiB+uB,yBAAyB/uB,gBAAgB5Z;IAC1D2Z,eAAeivB,YAAYjvB;IAC3BC,iBAAiBgvB,YAAYhvB;QAEzB5Z,WAAWugB,YAAYvgB,WAAW4mC,wBAAwB;;MAE7DD,gBAAgB;MAChBF,gBAAgB,wBAAwB,uBAAuB,6BAA6BztE,KAAK,QAAQ,OAAOytE;MAChHC,kBAAkB,sBAAsB1mC,WAAWua,gBAAgB7oC,QAAQ,KAAK,gCAAgCsuB,WAAWua,gBAAgB7oC,QAAQ,KAAK,qCAAqC,wCAAwC,6BAA6B,+BAA+B,qCAAqC,sCAAsC,8CAA8C,wCAAwC,wCAAwC,gDAAgD,0CAA0C1Y,KAAK,QAAQ,OAAO0tE;;UAGnlBmC,aAAalC,gBAAgBF,eAAe9sB;UAC5CmvB,eAAenC,gBAAgBD,iBAAiB9sB;;;UAGhDmvB,iBAAiBC,YAAY3oB,IAAIA,GAAG+U,eAAeyT;UACnDI,mBAAmBD,YAAY3oB,IAAIA,GAAGiV,iBAAiBwT;IAC7DzoB,GAAG6oB,aAAajY,SAAS8X;IACzB1oB,GAAG6oB,aAAajY,SAASgY;;QAErBjpC,WAAWqa,wBAAwBtkD;MACtCsqD,GAAG8oB,mBAAmBlY,SAAS,GAAGjxB,WAAWqa;eACnCra,WAAW4K,iBAAiB;;MAEtCyV,GAAG8oB,mBAAmBlY,SAAS,GAAG;;IAGnC5Q,GAAG+oB,YAAYnY;;QAEXltD,SAASslE,MAAMC;YACZC,aAAalpB,GAAGmpB,kBAAkBvY,SAAS6R;YAC3C2G,YAAYppB,GAAGwiB,iBAAiBkG,gBAAgBjG;YAChD4G,cAAcrpB,GAAGwiB,iBAAiBoG,kBAAkBnG;UACtD6G,WAAW;UACXC,kBAAkB;UAElBvpB,GAAGwhB,oBAAoB5Q,SAAS5Q,GAAGwpB,iBAAiB;QACvDF,WAAW;cACLG,eAAeC,gBAAgB1pB,IAAI0oB,gBAAgB;cACnDiB,iBAAiBD,gBAAgB1pB,IAAI4oB,kBAAkB;QAC7DjxE,QAAQa,MAAM,sCAAsCwnD,GAAG4pB,YAAY,sBAAsB5pB,GAAGwhB,oBAAoB5Q,SAAS5Q,GAAG6pB,kBAAkB,wBAAwBX,YAAYO,cAAcE;iBACtLT,eAAe;QACzBvxE,QAAQ0B,KAAK,8CAA8C6vE;iBACjDE,cAAc,MAAMC,gBAAgB;QAC9CE,kBAAkB;;UAGfA;QACH,KAAKnxE;UACJkxE,UAAUA;UACVJ,YAAYA;UACZ5vB;YACC9/C,KAAK4vE;YACLU,QAAQ1D;;UAET7sB;YACC//C,KAAK6vE;YACLS,QAAQzD;;;;;;;;;IAUZrmB,GAAG+pB,aAAarB;IAChB1oB,GAAG+pB,aAAanB;;QAEZoB;IAEJ,KAAKvP,cAAc;UACduP,mBAAmBt0E;QACtBs0E,qBAAqBnI,cAAc7hB,IAAI4Q;;aAGjCoZ;;;QAIJhY;IAEJ,KAAKe,gBAAgB;UAChBf,qBAAqBt8D;QACxBs8D,mBAAmBiY,wBAAwBjqB,IAAI4Q;;aAGzCoB;;;IAIR,KAAKkY,UAAU;MACd1Z,cAAc2D,uBAAuB;MACrCnU,GAAGmqB,cAAcvZ;MACjB,KAAKA,UAAUl7D;;;IAIhB,KAAKsN,OAAO28B,WAAW8mC;IACvB,KAAKhvE,KAAK2qE;IACV,KAAKqD,WAAWA;IAChB,KAAK2E,YAAY;IACjB,KAAKxZ,UAAUA;IACf,KAAKtX,eAAeovB;IACpB,KAAKnvB,iBAAiBqvB;WACf;;EAGR,uBAAuBllE,UAAU8qD,UAAU9U,YAAYuG,cAAcuQ,eAAe/W;UAC7EogB;UACA3Z,WAAWD,aAAaC;UACxBqV,yBAAyBtV,aAAasV;UACtCkB,sBAAsBxW,aAAawW;UACnCR,oBAAoBhW,aAAagW;UACjCM,iBAAiBtW,aAAasW;QAChCrwB,YAAY+Z,aAAa/Z;UACvBmkC;MACLC,mBAAmB;MACnBC,sBAAsB;MACtBpoE,oBAAoB;MACpBwrC,mBAAmB;MACnB68B,qBAAqB;MACrBvsE,mBAAmB;MACnBwsE,kBAAkB;MAClBC,sBAAsB;MACtBC,sBAAsB;MACtBC,oBAAoB;MACpBC,mBAAmB;MACnBC,oBAAoB;MACpBC,gBAAgB;MAChBC,gBAAgB;MAChBC,gBAAgB;;UAEXC,kBAAkB,aAAa,YAAY,0BAA0B,kBAAkB,cAAc,mBAAmB,OAAO,eAAe,UAAU,kBAAkB,UAAU,cAAc,kBAAkB,gBAAgB,YAAY,oBAAoB,SAAS,eAAe,uBAAuB,WAAW,aAAa,wBAAwB,yBAAyB,gBAAgB,yBAAyB,sBAAsB,mBAAmB,eAAe,gBAAgB,gBAAgB,eAAe,YAAY,WAAW,gBAAgB,gBAAgB,kBAAkB,aAAa,iBAAiB,OAAO,UAAU,WAAW,eAAe,mBAAmB,0BAA0B,YAAY,YAAY,oBAAoB,gBAAgB,gBAAgB,sBAAsB,gBAAgB,kBAAkB,iBAAiB,iBAAiB,qBAAqB,sBAAsB,wBAAwB,uBAAuB,oBAAoB,iBAAiB,eAAe,2BAA2B,aAAa,eAAe,aAAa,qBAAqB,uBAAuB,gBAAgB,aAAa,SAAS,gBAAgB,mBAAmB;IAE9rC,qBAAqBl+C;YACdgT,WAAWhT,OAAOgT;YAClBmrC,QAAQnrC,SAASmrC;UAEnB1U;eACI;;;;;;;;cAQD2U,kBAAkBnV;cAClBoV,kBAAkBxuE,KAAKC,OAAOsuE,kBAAkB,MAAM;cACtDvE,WAAWhqE,KAAKD,IAAIyuE,iBAAiBF,MAAMpzE;YAE7C8uE,WAAWsE,MAAMpzE;UACpBJ,QAAQ0B,KAAK,uCAAuC8xE,MAAMpzE,SAAS,+BAA+B8uE,WAAW;iBACtG;;eAGDA;;;IAIT,mCAAmCjtE;UAC9B6lB;UAEA7lB,OAAOA,IAAIynB;QACd5B,WAAW7lB,IAAI6lB;iBACL7lB,OAAOA,IAAImqB;QACrBpsB,QAAQ0B,KAAK;QACbomB,WAAW7lB,IAAI4pB,QAAQ/D;;QAEvBA,WAAW1Q;;aAGL0Q;;IAGR,uBAAuBzhB,UAAUw7C,QAAQ8xB,SAASxoE,OAAOkqB;YAClD9oB,MAAMpB,MAAMoB;YACZqnE,cAAcvtE,SAASwtE,yBAAyB1oE,MAAMyoE,cAAc;YACpEniC,SAASolB,SAASlN,IAAItjD,SAASorC,UAAUmiC;YACzCpI,WAAWkH,UAAUrsE,SAASlH;;;YAG9B+vE,WAAW75C,OAAO6S,gBAAgB4rC,YAAYz+C,UAAU;UAE1DhvB,SAASkoC,cAAc;QAC1BA,YAAY+Z,aAAaqV,gBAAgBt3D,SAASkoC;YAE9CA,cAAcloC,SAASkoC;UAC1BvuC,QAAQ0B,KAAK,qCAAqC2E,SAASkoC,WAAW,wBAAwBA,WAAW;;;UAIvGoT,cAAcC;UAEd4pB;cACG7lB,SAAS8P,UAAU+V;QACzB7pB,eAAegE,OAAOhE;QACtBC,iBAAiB+D,OAAO/D;;QAExBD,eAAet7C,SAASs7C;QACxBC,iBAAiBv7C,SAASu7C;;YAGrBqD,sBAAsBl5C,SAASm5C;YAC/Bld;QACLugB,UAAUA;QACVijB,UAAUA;QACVsD,YAAYzoE,SAASlH;QACrBwiD,cAAcA;QACdC,gBAAgBA;QAChBF,SAASr7C,SAASq7C;QAClBktB,qBAAqBvoE,SAASuoE,wBAAwB;QACtDrsB,aAAal8C,SAASk8C;QACtBhU,WAAWA;QACXwgC,YAAY15C,OAAOkS,oBAAoB;QACvCynC,iBAAiB35C,OAAOkS,oBAAoB,QAAQlS,OAAOoS,kBAAkB;QAC7EwnC,wBAAwBrQ;QACxB4R,gBAAgBvrB,wBAAwB,OAAO8uB,0BAA0B9uB,oBAAoBp5B,WAAW9f,SAASykE;QACjHvuE,OAAOoE,SAASpE;QAChBiuE,aAAa6D,0BAA0B1tE,SAASpE;QAChDsuC,UAAUlqC,SAASkqC;QACnB4/B,gBAAgB4D,0BAA0B1tE,SAASkqC;QACnDkB,UAAUA;QACVk8B,YAAYl8B,UAAUA,OAAOnqB;QAC7B8oD,gBAAgB2D,0BAA0BtiC;QAC1C65B,gBAAgB75B,WAAWA,OAAOnqB,YAAYjW,2BAA2BogC,OAAOnqB,YAAYhW;QAC5Fm/B,YAAYpqC,SAASoqC;QACrB6/B,kBAAkByD,0BAA0B1tE,SAASoqC;QACrDE,SAAStqC,SAASsqC;QAClBY,eAAelrC,SAASkrC;QACxB8+B,qBAAqB0D,0BAA0B1tE,SAASkrC;QACxDV,WAAWxqC,SAASwqC;QACpBE,aAAa1qC,SAAS0qC;QACtBs+B,sBAAsBhpE,SAAS2qC,kBAAkBj5B;QACjDwzD,uBAAuBllE,SAAS2qC,kBAAkBl5B;QAClDq4B,gBAAgB9pC,SAAS8pC;QACzBC,yBAAyB/pC,SAAS+pC;QAClCC,sBAAsBhqC,SAASgqC;QAC/Ba,mBAAmB7qC,SAAS6qC;QAC5BG,gBAAgBhrC,SAASgrC;QACzBC,gBAAgBjrC,SAASirC;QACzBE,eAAenrC,SAASmrC;QACxBhB,YAAYnqC,SAASmqC;QACrBsB,eAAezrC,SAASyrC;QACxBlC,SAASvpC,SAASupC;QAClBmC,gBAAgB1rC,SAAS0rC;QACzBC,mBAAmB3rC,SAAS2rC;QAC5BE,gBAAgB7rC,SAAS6rC;QACzBR,SAASrrC,SAASqrC;QAClB49B,gBAAgBjpE,SAAS0qC,aAAa1qC,SAASipE;QAC/CxiC,cAAczmC,SAASymC;QACvByiC,cAAclpE,SAASymC,iBAAiB,QAAQzX,OAAOpvB,YAAYovB,OAAOpvB,SAAS4yC,WAAWtyC,SAAS8uB,OAAOpvB,SAAS4yC,WAAWtyC,MAAM6vC,aAAa;QACrJo5B,aAAanpE,SAASpE,SAASoE,SAASwqC,aAAaxqC,SAAS0qC,eAAe1qC,SAASmrC,iBAAiBnrC,SAASmqC,cAAcnqC,SAASkrC,iBAAiBlrC,SAASgrC,kBAAkBhrC,SAASirC,kBAAkBjrC,SAAS8pC,kBAAkB9pC,SAAS+pC,2BAA2B/pC,SAASgqC,wBAAwBhqC,SAAS6qC,qBAAqB7qC,SAAS0rC,kBAAkB1rC,SAAS2rC,qBAAqB3rC,SAAS6rC;QAC9Yu9B,mBAAmBppE,SAASpE,SAASoE,SAASwqC,aAAaxqC,SAAS0qC,eAAe1qC,SAASmrC,iBAAiBnrC,SAASmqC,cAAcnqC,SAASkrC,iBAAiBlrC,SAASgrC,kBAAkBhrC,SAASirC,kBAAkBjrC,SAASgqC,wBAAwBhqC,SAAS0rC,kBAAkB1rC,SAAS2rC,qBAAqB3rC,SAAS6rC,mBAAmB7rC,SAAS6qC;QACnV3kC,OAAOA;QACP4iE,QAAQ9oE,SAASkG;QACjB6iE,SAAS7iE,OAAOA,IAAIynE;QACpB3kC,eAAehpC,SAASgpC;QACxBgD,iBAAiBhsC,SAASgsC;QAC1BurB,wBAAwBA;QACxB8R,UAAUr6C,OAAO6S,kBAAkB,QAAQgnC,WAAW;QACtDA,UAAUA;QACVS,kBAAkB7Q;QAClBlsB,cAAcvsC,SAASusC;QACvBC,cAAcxsC,SAASwsC;QACvBu5B,cAAcvqB,OAAOoyB,YAAY7zE;QACjCmsE,gBAAgB1qB,OAAOlsB,MAAMv1B;QAC7BisE,eAAexqB,OAAOqyB,KAAK9zE;QAC3BksE,mBAAmBzqB,OAAOsyB,SAAS/zE;QACnCosE,eAAe3qB,OAAOuyB,KAAKh0E;QAC3BqsE,oBAAoB5qB,OAAOuS,qBAAqBh0D;QAChDusE,sBAAsB9qB,OAAOoT,eAAe70D;QAC5CssE,qBAAqB7qB,OAAO8S,cAAcv0D;QAC1CwsE,mBAAmB9qB,SAASyd;QAC5BsN,qBAAqB/qB,SAAS0d;QAC9B7wB,WAAWtoC,SAASsoC;QACpBmhC,kBAAkB/jE,SAASsoE,UAAUrwB,WAAW2vB,QAAQvzE,SAAS;QACjEqtE,eAAe1hE,SAASsoE,UAAUl1E;QAClC+4D,aAAa7xD,SAAS0oC,aAAahjC,SAASmsD,cAAcxnD;QAC1Dq/D,yBAAyBhkE,SAASgkE;QAClCjhC,oBAAoBzoC,SAASyoC;QAC7BF,WAAWvoC,SAASuoC;QACpBghC,aAAavpE,SAASwmC,SAASv+B;QAC/BuhE,WAAWxpE,SAASwmC,SAASx+B;QAC7BoiE,cAAcpqE,SAASoqE,iBAAiB1yE,YAAYsI,SAASoqE,eAAe;QAC5EpuB,qBAAqBh8C,SAASg8C;QAC9BgpB,sBAAsBhlE,SAAS07C,cAAc17C,SAAS07C,WAAWC;QACjEypB,oBAAoBplE,SAAS07C,cAAc17C,SAAS07C,WAAWE;QAC/D0pB,sBAAsBtlE,SAAS07C,cAAc17C,SAAS07C,WAAWG;QACjE2pB,2BAA2BxlE,SAAS07C,cAAc17C,SAAS07C,WAAWI;QACtEupB,4BAA4BnjB,YAAYxG,WAAWkb,IAAI;QACvD2O,8BAA8BrjB,YAAYxG,WAAWkb,IAAI;QACzD6O,mCAAmCvjB,YAAYxG,WAAWkb,IAAI;QAC9D/tB,uBAAuB7oC,SAAS6oC;;aAE1BlH;;IAGR,4BAA4BA;YACrB5tB;UAEF4tB,WAAWwjC;QACdpxD,MAAMvc,KAAKmqC,WAAWwjC;;QAEtBpxD,MAAMvc,KAAKmqC,WAAW4Z;QACtBxnC,MAAMvc,KAAKmqC,WAAW2Z;;UAGnB3Z,WAAW0Z,YAAY3jD;mBACfsN,QAAQ28B,WAAW0Z;UAC7BtnC,MAAMvc,KAAKwN;UACX+O,MAAMvc,KAAKmqC,WAAW0Z,QAAQr2C;;;UAI5B28B,WAAW4mC,wBAAwB;iBAC7BzuE,IAAI,GAAGA,IAAIozE,eAAenzE,QAAQD;UAC1Cia,MAAMvc,KAAKmqC,WAAWurC,eAAepzE;;QAGtCia,MAAMvc,KAAKkO,SAASykE;QACpBp2D,MAAMvc,KAAKkO,SAASuoC;;MAGrBl6B,MAAMvc,KAAKmqC,WAAWkH;aACf90B,MAAMpZ;;IAGd,qBAAqBqF;YACdmlE,WAAWkH,UAAUrsE,SAASlH;UAChCgiD;UAEAqqB;cACG7lB,SAAS8P,UAAU+V;QACzBrqB,WAAWG,cAAc35C,MAAMg+C,OAAOxE;;QAEtCA,WAAW96C,SAAS86C;;aAGdA;;IAGR,wBAAwBnZ,YAAY8lC;UAC/B7U;;eAEKhpC,IAAI,GAAGqkD,KAAKpS,SAAS9hE,QAAQ6vB,IAAIqkD,IAAIrkD;cACvCskD,qBAAqBrS,SAASjyC;YAEhCskD,mBAAmBzG,aAAaA;UACnC7U,UAAUsb;YACRtb,QAAQwZ;;;;UAKRxZ,YAAYl7D;QACfk7D,cAAcub,aAAazoE,UAAU+hE,UAAU9lC,YAAY6wB;QAC3DqJ,SAASrkE,KAAKo7D;;aAGRA;;IAGR,wBAAwBA;YACjBA,QAAQwZ,cAAc;;cAErBtyE,IAAI+hE,SAAS7jE,QAAQ46D;QAC3BiJ,SAAS/hE,KAAK+hE,SAASA,SAAS9hE,SAAS;QACzC8hE,SAASuS;;QAETxb,QAAQsZ;;;;MAKTmC,eAAeA;MACfC,oBAAoBA;MACpB7R,aAAaA;MACb8R,gBAAgBA;MAChBC,gBAAgBA;;MAEhB3S,UAAUA;;;EAIZ;QACKpO,iBAAiBrL;IAErB,aAAapzB;UACRpzB,MAAM6xD,WAAWnK,IAAIt0B;UAErBpzB,QAAQlE;QACXkE;QACA6xD,WAAWxnD,IAAI+oB,QAAQpzB;;aAGjBA;;IAGR,gBAAgBozB;MACfy+B,WAAWjK,OAAOx0B;;IAGnB,gBAAgBA,QAAQqT,KAAK19B;MAC5B8oD,WAAWnK,IAAIt0B,QAAQqT,OAAO19B;;IAG/B;MACC8oD,iBAAiBrL;;;MAIjBkB,KAAKA;MACL/nD,QAAQA;MACRktB,QAAQA;MACRhxB,SAASA;;;EAIX,2BAA2B2e,GAAGC;QACzBD,EAAEq4D,eAAep4D,EAAEo4D;aACfr4D,EAAEq4D,aAAap4D,EAAEo4D;eACdr4D,EAAEioB,gBAAgBhoB,EAAEgoB;aACvBjoB,EAAEioB,cAAchoB,EAAEgoB;eACfjoB,EAAEw8C,YAAYv8C,EAAEu8C;aACnBx8C,EAAEw8C,QAAQn5D,KAAK4c,EAAEu8C,QAAQn5D;eACtB2c,EAAEpW,SAASvG,OAAO4c,EAAErW,SAASvG;aAChC2c,EAAEpW,SAASvG,KAAK4c,EAAErW,SAASvG;eACxB2c,EAAEtV,MAAMuV,EAAEvV;aACbsV,EAAEtV,IAAIuV,EAAEvV;;aAERsV,EAAE3c,KAAK4c,EAAE5c;;;EAIlB,kCAAkC2c,GAAGC;QAChCD,EAAEq4D,eAAep4D,EAAEo4D;aACfr4D,EAAEq4D,aAAap4D,EAAEo4D;eACdr4D,EAAEioB,gBAAgBhoB,EAAEgoB;aACvBjoB,EAAEioB,cAAchoB,EAAEgoB;eACfjoB,EAAEtV,MAAMuV,EAAEvV;aACbuV,EAAEvV,IAAIsV,EAAEtV;;aAERsV,EAAE3c,KAAK4c,EAAE5c;;;EAIlB,yBAAyBg0D;UAClBihB;QACFC,mBAAmB;UACjBC;UACAC;UACAloC;UACAmoC;MACLr1E,KAAK;;IAGN;MACCk1E,mBAAmB;MACnBC,OAAO70E,SAAS;MAChB80E,aAAa90E,SAAS;MACtB4sC,YAAY5sC,SAAS;;IAGtB,2BAA2Bi1B,QAAQpvB,UAAUI,UAAUyuE,YAAY3tE,GAAGkB;UACjE+sE,aAAaL,YAAYC;YACvB/U,qBAAqBnM,WAAWnK,IAAItjD;UAEtC+uE,eAAer3E;QAClBq3E;UACCt1E,IAAIu1B,OAAOv1B;UACXu1B,QAAQA;UACRpvB,UAAUA;UACVI,UAAUA;UACV4yD,SAASgH,mBAAmBhH,WAAWkc;UACvCL,YAAYA;UACZpwC,aAAarP,OAAOqP;UACpBv9B,GAAGA;UACHkB,OAAOA;;QAER0sE,YAAYC,oBAAoBI;;QAEhCA,WAAWt1E,KAAKu1B,OAAOv1B;QACvBs1E,WAAW//C,SAASA;QACpB+/C,WAAWnvE,WAAWA;QACtBmvE,WAAW/uE,WAAWA;QACtB+uE,WAAWnc,UAAUgH,mBAAmBhH,WAAWkc;QACnDC,WAAWN,aAAaA;QACxBM,WAAW1wC,cAAcrP,OAAOqP;QAChC0wC,WAAWjuE,IAAIA;QACfiuE,WAAW/sE,QAAQA;;MAGpB2sE;aACOI;;IAGR,cAAc//C,QAAQpvB,UAAUI,UAAUyuE,YAAY3tE,GAAGkB;YAClD+sE,aAAaC,kBAAkBhgD,QAAQpvB,UAAUI,UAAUyuE,YAAY3tE,GAAGkB;UAE5EhC,SAAS0rC,eAAe;QAC3BmjC,aAAar3E,KAAKu3E;iBACR/uE,SAAS2mC,gBAAgB;QACnCA,YAAYnvC,KAAKu3E;;QAEjBH,OAAOp3E,KAAKu3E;;;IAId,iBAAiB//C,QAAQpvB,UAAUI,UAAUyuE,YAAY3tE,GAAGkB;YACrD+sE,aAAaC,kBAAkBhgD,QAAQpvB,UAAUI,UAAUyuE,YAAY3tE,GAAGkB;UAE5EhC,SAAS0rC,eAAe;QAC3BmjC,aAAa/c,QAAQid;iBACX/uE,SAAS2mC,gBAAgB;QACnCA,YAAYmrB,QAAQid;;QAEpBH,OAAO9c,QAAQid;;;IAIjB,cAAcE,kBAAkBC;UAC3BN,OAAO70E,SAAS,GAAG60E,OAAOzS,KAAK8S,oBAAoBE;UACnDN,aAAa90E,SAAS,GAAG80E,aAAa1S,KAAK+S,yBAAyBE;UACpEzoC,YAAY5sC,SAAS,GAAG4sC,YAAYw1B,KAAK+S,yBAAyBE;;IAGvE;;eAEUt1E,IAAI60E,kBAAkB3oD,KAAK0oD,YAAY30E,QAAQD,IAAIksB,IAAIlsB;cACzDi1E,aAAaL,YAAY50E;YAC3Bi1E,WAAWt1E,OAAO;QACtBs1E,WAAWt1E,KAAK;QAChBs1E,WAAW//C,SAAS;QACpB+/C,WAAWnvE,WAAW;QACtBmvE,WAAW/uE,WAAW;QACtB+uE,WAAWnc,UAAU;QACrBmc,WAAW/sE,QAAQ;;;;MAKpB4sE,QAAQA;MACRC,cAAcA;MACdloC,aAAaA;MACbyyB,MAAMA;MACN5hE,MAAMA;MACNs6D,SAASA;MACTud,QAAQA;MACRlT,MAAMA;;;EAIR,0BAA0B1O;QACrB6hB,YAAYltB;IAEhB,aAAat9C,OAAOyqE;UACfC;UAEAF,MAAM1Y,IAAI9xD,WAAW;QACxB0qE,WAAWC,gBAAgBhiB;QAC3B6hB,MAAMrpE,IAAInB,QAAQ0qE;;YAEdD,mBAAmBD,MAAMhsB,IAAIx+C,OAAO/K;UACvCy1E,WAAWC,gBAAgBhiB;UAC3B6hB,MAAMhsB,IAAIx+C,OAAOtN,KAAKg4E;;UAEtBA,OAAOF,MAAMhsB,IAAIx+C,OAAOyqE;;;aAInBC;;IAGR;MACCF,YAAYltB;;;MAIZkB,KAAKA;MACL7rD,SAASA;;;EAIX;UACO+jD;;MAEL8H,KAAK,UAAUv9C;YACVy1C,OAAOz1C,MAAMtM,QAAQ/B;iBACjB8jD,OAAOz1C,MAAMtM;;YAGjBqhD;gBAEI/0C,MAAMjN;eACR;YACJgiD;cACCvnB,eAAej0B;cACfY,WAAWuvC;;;eAIR;YACJqL;cACCr6C,cAAcnB;cACdi0B,eAAej0B;cACfY,WAAWuvC;cACX7rC,UAAU;cACVsqD,SAAS;cACTC,aAAa;cACbC,OAAO;;;eAIJ;YACJtT;cACCr6C,cAAcnB;cACdY,WAAWuvC;cACX7rC,UAAU;cACVwqD,OAAO;;;eAIJ;YACJtT;cACCvnB,eAAej0B;cACfyvD,cAActf;cACduf,iBAAiBvf;;;eAId;YACJqL;cACC56C,WAAWuvC;cACXhvC,cAAcnB;cACdowE,eAAepwE;cACfqwE,gBAAgBrwE;;;;QAKnBk8C,OAAOz1C,MAAMtM,MAAMqhD;eACZA;;;;EAKV;UACOU;;MAEL8H,KAAK,UAAUv9C;YACVy1C,OAAOz1C,MAAMtM,QAAQ/B;iBACjB8jD,OAAOz1C,MAAMtM;;YAGjBqhD;gBAEI/0C,MAAMjN;eACR;YACJgiD;cACC6S,YAAY;cACZC,kBAAkB;cAClBC,cAAc;cACdC,mBAAmBtyC;;;eAIhB;YACJs/B;cACC6S,YAAY;cACZC,kBAAkB;cAClBC,cAAc;cACdC,mBAAmBtyC;;;eAIhB;YACJs/B;cACC6S,YAAY;cACZC,kBAAkB;cAClBC,cAAc;cACdC,mBAAmBtyC;cACnBkzC,kBAAkB;cAClBC,iBAAiB;;;;QAMpBnT,OAAOz1C,MAAMtM,MAAMqhD;eACZA;;;;MAKN80B,cAAc;EAElB,kCAAkCC,QAAQC;YACjCA,OAAO5xC,aAAa,IAAI,MAAM2xC,OAAO3xC,aAAa,IAAI;;EAG/D,qBAAqBwd,YAAYuG;UAC1B7jD,YAAY2xE;UACZC,cAAcC;UACdxf;MACLtuC,SAAS;MACT+tD;QACCC,oBAAoB;QACpBC,cAAc;QACdC,aAAa;QACbC,iBAAiB;QACjBC,aAAa;QACbC,wBAAwB;QACxBC,kBAAkB;QAClBC,iBAAiB;;MAElBC,UAAU,GAAG,GAAG;MAChBC;MACAhD;MACAiD;MACA9iB;MACAC;MACA6f;MACAiD;MACAxiB;MACAC;MACAuf;MACAiD,cAAc;MACdC,cAAc;MACd1hD;MACA2hD;MACAriB;MACAC;MACAkf;;aAGQj0E,IAAI,GAAGA,IAAI,GAAGA,KAAK22D,MAAMmgB,MAAMp5E,SAAS8H;UAE3C4xE,cAAc5xE;UACd0f,cAAcyX;UACd06C,eAAe16C;IAErB,eAAe+kB;UACVt8B,IAAI,GACNb,IAAI,GACJhI,IAAI;eAEGvc,IAAI,GAAGA,IAAI,GAAGA,KAAK22D,MAAMmgB,MAAM92E,GAAGmM,IAAI,GAAG,GAAG;UAEjDkqE,oBAAoB;UACpBC,cAAc;UACdC,aAAa;UACbC,iBAAiB;UACjBC,aAAa;UACbC,wBAAwB;UACxBC,kBAAkB;UAClBC,iBAAiB;MACrBl1B,OAAO2gB,KAAKiV;eAEHt3E,IAAI,GAAGma,IAAIunC,OAAOzhD,QAAQD,IAAIma,GAAGna;cACnCiM,QAAQy1C,OAAO1hD;cACfoG,QAAQ6F,MAAM7F;cACd4F,YAAYC,MAAMD;cAClBlC,WAAWmC,MAAMnC;cACjBoqE,YAAYjoE,MAAMqqD,UAAUrqD,MAAMqqD,OAAOx0D,MAAMmK,MAAMqqD,OAAOx0D,IAAI4pB,UAAU;YAE5Ezf,MAAMsrE;UACTnyD,KAAKhf,MAAMgf,IAAIpZ;UACfuY,KAAKne,MAAMme,IAAIvY;UACfuQ,KAAKnW,MAAMmW,IAAIvQ;mBACLC,MAAMurE;mBACPr/C,IAAI,GAAGA,IAAI,GAAGA;YACtBw+B,MAAMmgB,MAAM3+C,GAAGhZ,gBAAgBlT,MAAMwrE,GAAGC,aAAav/C,IAAInsB;;mBAEhDC,MAAM0rE;gBACV32B,WAAW18C,MAAMklD,IAAIv9C;UAC3B+0C,SAAS56C,MAAM2Y,KAAK9S,MAAM7F,OAAOgB,eAAe6E,MAAMD;cAElDC,MAAMm4B;kBACHkyB,SAASrqD,MAAMqqD;kBACfshB,iBAAiB1B,YAAY1sB,IAAIv9C;YACvC2rE,eAAe/jB,aAAayC,OAAOuhB;YACnCD,eAAe9jB,mBAAmBwC,OAAOwhB;YACzCF,eAAe7jB,eAAeuC,OAAO9vD;YACrCoxE,eAAe5jB,gBAAgBsC,OAAOyhB;YACtCphB,MAAMogB,kBAAkBV,qBAAqBuB;YAC7CjhB,MAAM1C,qBAAqBoiB,qBAAqBnC;YAChDvd,MAAMzC,wBAAwBmiB,qBAAqBpqE,MAAMqqD,OAAOvwC;YAChE2wD;;UAGD/f,MAAMmd,YAAYuC,qBAAqBr1B;UACvCq1B;mBACUpqE,MAAM+rE;gBACVh3B,WAAW18C,MAAMklD,IAAIv9C;UAC3B+0C,SAASr6C,SAASitB,sBAAsB3nB,MAAMqmB;UAC9C0uB,SAAS56C,MAAM2Y,KAAK3Y,OAAOgB,eAAe4E;UAC1Cg1C,SAASl3C,WAAWA;UACpBk3C,SAASoT,UAAUrvD,KAAK+B,IAAImF,MAAMoU;UAClC2gC,SAASqT,cAActvD,KAAK+B,IAAImF,MAAMoU,SAAS,IAAIpU,MAAMgsE;UACzDj3B,SAASsT,QAAQroD,MAAMqoD;cAEnBroD,MAAMm4B;kBACHkyB,SAASrqD,MAAMqqD;kBACfshB,iBAAiB1B,YAAY1sB,IAAIv9C;YACvC2rE,eAAe/jB,aAAayC,OAAOuhB;YACnCD,eAAe9jB,mBAAmBwC,OAAOwhB;YACzCF,eAAe7jB,eAAeuC,OAAO9vD;YACrCoxE,eAAe5jB,gBAAgBsC,OAAOyhB;YACtCphB,MAAMqgB,WAAWT,cAAcqB;YAC/BjhB,MAAMnC,cAAc+hB,cAAcrC;YAClCvd,MAAMlC,iBAAiB8hB,cAActqE,MAAMqqD,OAAOvwC;YAClD6wD;;UAGDjgB,MAAMod,KAAKwC,cAAcv1B;UACzBu1B;mBACUtqE,MAAMisE;gBACVl3B,WAAW18C,MAAMklD,IAAIv9C;;;;UAI3B+0C,SAAS56C,MAAM2Y,KAAK3Y,OAAOgB,eAAe4E;UAC1Cg1C,SAAS40B,UAAUzpE,IAAIF,MAAMsS,QAAQ,KAAK,KAAK;UAC/CyiC,SAAS60B,WAAW1pE,IAAI,KAAKF,MAAMuS,SAAS,KAAK;UACjDm4C,MAAMqd,SAASwC,kBAAkBx1B;UACjCw1B;mBACUvqE,MAAMksE;gBACVn3B,WAAW18C,MAAMklD,IAAIv9C;UAC3B+0C,SAAS56C,MAAM2Y,KAAK9S,MAAM7F,OAAOgB,eAAe6E,MAAMD;UACtDg1C,SAASl3C,WAAWmC,MAAMnC;UAC1Bk3C,SAASsT,QAAQroD,MAAMqoD;cAEnBroD,MAAMm4B;kBACHkyB,SAASrqD,MAAMqqD;kBACfshB,iBAAiB1B,YAAY1sB,IAAIv9C;YACvC2rE,eAAe/jB,aAAayC,OAAOuhB;YACnCD,eAAe9jB,mBAAmBwC,OAAOwhB;YACzCF,eAAe7jB,eAAeuC,OAAO9vD;YACrCoxE,eAAe5jB,gBAAgBsC,OAAOyhB;YACtCH,eAAehjB,mBAAmB0B,OAAOrkC,OAAOiP;YAChD02C,eAAe/iB,kBAAkByB,OAAOrkC,OAAOkP;YAC/Cw1B,MAAMwgB,YAAYb,eAAesB;YACjCjhB,MAAM7B,eAAewhB,eAAepC;YACpCvd,MAAM5B,kBAAkBuhB,eAAerqE,MAAMqqD,OAAOvwC;YACpD4wD;;UAGDhgB,MAAMnhC,MAAM8gD,eAAet1B;UAC3Bs1B;mBACUrqE,MAAMmsE;gBACVp3B,WAAW18C,MAAMklD,IAAIv9C;UAC3B+0C,SAASiU,SAASl2C,KAAK9S,MAAM7F,OAAOgB,eAAe4E;UACnDg1C,SAASkU,YAAYn2C,KAAK9S,MAAMipD,aAAa9tD,eAAe4E;UAC5D2qD,MAAMsd,KAAKwC,cAAcz1B;UACzBy1B;;;UAIED,iBAAiB;YAChBruB,aAAaC;;UAEhBuO,MAAMsgB,eAAe9kB,YAAYkmB;UACjC1hB,MAAMugB,eAAe/kB,YAAYmmB;;;cAG7B12B,WAAWkb,IAAI,gCAAgC;YAClDnG,MAAMsgB,eAAe9kB,YAAYkmB;YACjC1hB,MAAMugB,eAAe/kB,YAAYmmB;qBACvB12B,WAAWkb,IAAI,qCAAqC;YAC9DnG,MAAMsgB,eAAe9kB,YAAYomB;YACjC5hB,MAAMugB,eAAe/kB,YAAYqmB;;YAEjC34E,QAAQa,MAAM;;;;MAKjBi2D,MAAMkgB,QAAQ,KAAKzxD;MACnBuxC,MAAMkgB,QAAQ,KAAKtyD;MACnBoyC,MAAMkgB,QAAQ,KAAKt6D;YACb65D,OAAOzf,MAAMyf;UAEfA,KAAKC,sBAAsBA,qBAAqBD,KAAKE,gBAAgBA,eAAeF,KAAKG,eAAeA,cAAcH,KAAKI,mBAAmBA,kBAAkBJ,KAAKK,eAAeA,cAAcL,KAAKM,0BAA0BA,yBAAyBN,KAAKO,oBAAoBA,mBAAmBP,KAAKQ,mBAAmBA;QACjUjgB,MAAMmd,YAAY7zE,SAASo2E;QAC3B1f,MAAMod,KAAK9zE,SAASs2E;QACpB5f,MAAMqd,SAAS/zE,SAASu2E;QACxB7f,MAAMnhC,MAAMv1B,SAASq2E;QACrB3f,MAAMsd,KAAKh0E,SAASw2E;QACpB9f,MAAMogB,kBAAkB92E,SAASy2E;QACjC/f,MAAM1C,qBAAqBh0D,SAASy2E;QACpC/f,MAAMwgB,YAAYl3E,SAAS02E;QAC3BhgB,MAAM7B,eAAe70D,SAAS02E;QAC9BhgB,MAAMqgB,WAAW/2E,SAAS22E;QAC1BjgB,MAAMnC,cAAcv0D,SAAS22E;QAC7BjgB,MAAMzC,wBAAwBj0D,SAASy2E;QACvC/f,MAAM5B,kBAAkB90D,SAAS02E;QACjChgB,MAAMlC,iBAAiBx0D,SAAS22E;QAChCR,KAAKC,oBAAoBA;QACzBD,KAAKE,cAAcA;QACnBF,KAAKG,aAAaA;QAClBH,KAAKI,iBAAiBA;QACtBJ,KAAKK,aAAaA;QAClBL,KAAKM,wBAAwBA;QAC7BN,KAAKO,kBAAkBA;QACvBP,KAAKQ,iBAAiBA;QACtBjgB,MAAMtuC,UAAUytD;;;IAIlB,mBAAmBp0B,QAAQzvB;UACtBokD,oBAAoB;UACpBC,cAAc;UACdC,aAAa;UACbC,iBAAiB;UACjBC,aAAa;YACXnW,aAAaruC,OAAOC;eAEjBlyB,IAAI,GAAGma,IAAIunC,OAAOzhD,QAAQD,IAAIma,GAAGna;cACnCiM,QAAQy1C,OAAO1hD;YAEjBiM,MAAM0rE;gBACH32B,WAAW2V,MAAMmd,YAAYuC;UACnCr1B,SAASvnB,UAAU7F,sBAAsB3nB,MAAMqmB;UAC/C8kD,QAAQxjD,sBAAsB3nB,MAAMzC,OAAO8oB;UAC3C0uB,SAASvnB,UAAUra,IAAIg4D;UACvBp2B,SAASvnB,UAAUlH,mBAAmB+tC;UACtC+V;mBACUpqE,MAAM+rE;gBACVh3B,WAAW2V,MAAMod,KAAKwC;UAC5Bv1B,SAASr6C,SAASitB,sBAAsB3nB,MAAMqmB;UAC9C0uB,SAASr6C,SAASkjB,aAAay2C;UAC/Btf,SAASvnB,UAAU7F,sBAAsB3nB,MAAMqmB;UAC/C8kD,QAAQxjD,sBAAsB3nB,MAAMzC,OAAO8oB;UAC3C0uB,SAASvnB,UAAUra,IAAIg4D;UACvBp2B,SAASvnB,UAAUlH,mBAAmB+tC;UACtCiW;mBACUtqE,MAAMisE;gBACVl3B,WAAW2V,MAAMqd,SAASwC;UAChCx1B,SAASr6C,SAASitB,sBAAsB3nB,MAAMqmB;UAC9C0uB,SAASr6C,SAASkjB,aAAay2C;;UAE/B+W,SAAS70D;UACT0C,QAAQnG,KAAK9S,MAAMqmB;UACnBpN,QAAQjC,YAAYq9C;UACpB+W,SAASt6C,gBAAgB7X;UACzB87B,SAAS40B,UAAUzpE,IAAIF,MAAMsS,QAAQ,KAAK,KAAK;UAC/CyiC,SAAS60B,WAAW1pE,IAAI,KAAKF,MAAMuS,SAAS,KAAK;UACjDwiC,SAAS40B,UAAU/rD,aAAawtD;UAChCr2B,SAAS60B,WAAWhsD,aAAawtD;UACjCb;mBACUvqE,MAAMksE;gBACVn3B,WAAW2V,MAAMnhC,MAAM8gD;UAC7Bt1B,SAASr6C,SAASitB,sBAAsB3nB,MAAMqmB;UAC9C0uB,SAASr6C,SAASkjB,aAAay2C;UAC/BgW;mBACUrqE,MAAMmsE;gBACVp3B,WAAW2V,MAAMsd,KAAKwC;UAC5Bz1B,SAASvnB,UAAU7F,sBAAsB3nB,MAAMqmB;UAC/C0uB,SAASvnB,UAAUlH,mBAAmB+tC;UACtCtf,SAASvnB,UAAUrwB;UACnBqtE;;;;;MAMFta,OAAOA;MACPsc,WAAWA;MACX9hB,OAAOA;;;EAIT,0BAA0B/U,YAAYuG;UAC/BzG,aAAag3B,YAAY92B,YAAYuG;UACrCwwB;UACAC;IAEN;MACCD,YAAY14E,SAAS;MACrB24E,aAAa34E,SAAS;;IAGvB,mBAAmBgM;MAClB0sE,YAAYj7E,KAAKuO;;IAGlB,oBAAoB4sE;MACnBD,aAAal7E,KAAKm7E;;IAGnB;MACCn3B,OAAOya,MAAMwc;;IAGd,yBAAyB1mD;MACxByvB,OAAO+2B,UAAUE,aAAa1mD;;UAGzB0kC;MACLgiB,aAAaA;MACbC,cAAcA;MACdl3B,QAAQA;;;MAGR4d,MAAMA;MACN3I,OAAOA;MACPmiB,aAAaA;MACbC,iBAAiBA;MACjBC,WAAWA;MACXC,YAAYA;;;EAId,2BAA2Br3B,YAAYuG;QAClC+wB,mBAAmB5wB;IAEvB,aAAat9C,OAAOyqE,kBAAkB;UACjC0D;UAEAD,aAAapc,IAAI9xD,WAAW;QAC/BmuE,kBAAkBC,iBAAiBx3B,YAAYuG;QAC/C+wB,aAAa/sE,IAAInB,QAAQmuE;;YAErB1D,mBAAmByD,aAAa1vB,IAAIx+C,OAAO/K;UAC9Ck5E,kBAAkBC,iBAAiBx3B,YAAYuG;UAC/C+wB,aAAa1vB,IAAIx+C,OAAOtN,KAAKy7E;;UAE7BA,cAAcD,aAAa1vB,IAAIx+C,OAAOyqE;;;aAIjC0D;;IAGR;MACCD,mBAAmB5wB;;;MAInBkB,KAAKA;MACL7rD,SAASA;;;;;;;;;;;;;;;;;;;;EAsBX,gCAAgCk1C;IAC/BztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKsxE,eAAe74D;MACpB,KAAKg7B,eAAe;MACpB,KAAK3wC,MAAM;MACX,KAAKuuC,WAAW;MAChB,KAAKU,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAK3mC,YAAY;MACjB,KAAKgoC,qBAAqB;MAC1B,KAAKlmC,MAAM;MACX,KAAK4iC,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK8nD,eAAe9nD,OAAO8nD;MAC3B,KAAK79B,eAAejqB,OAAOiqB;MAC3B,KAAK3wC,MAAM0mB,OAAO1mB;MAClB,KAAKuuC,WAAW7nB,OAAO6nB;MACvB,KAAKU,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;MAC/B,KAAK3mC,YAAYke,OAAOle;MACxB,KAAKgoC,qBAAqB9pB,OAAO8pB;aAC1B;;;EAKTkgC,kBAAkB7wD,UAAU03D,sBAAsB;;;;;;;;;;;;;;;;;;;;EAsBlD,mCAAmCxmC;IAClCztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKm3D,wBAAwB3wD;MAC7B,KAAK4wD,eAAe;MACpB,KAAKC,cAAc;MACnB,KAAK5jB,eAAe;MACpB,KAAK3wC,MAAM;MACX,KAAKuuC,WAAW;MAChB,KAAKU,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAK7kC,MAAM;MACX,KAAK4iC,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK2tC,kBAAkBp3C,KAAKyJ,OAAO2tC;MACnC,KAAKC,eAAe5tC,OAAO4tC;MAC3B,KAAKC,cAAc7tC,OAAO6tC;MAC1B,KAAK5jB,eAAejqB,OAAOiqB;MAC3B,KAAK3wC,MAAM0mB,OAAO1mB;MAClB,KAAKuuC,WAAW7nB,OAAO6nB;MACvB,KAAKU,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;aACxB;;;EAKTwhC,qBAAqB9wD,UAAU23D,yBAAyB;MAEpDC,WAAW;MAEXC,WAAW;EAEf,wBAAwBC,WAAWC,UAAUC;QACxCC,eAAeC;UAEbC,qBAAqBp4D,WACxBq4D,oBAAoBr4D,WACpBs4D,gBAAgB5uD,WAChB6uD,sBACAC,yBACAC,qBACAC,kBAAkBT,cAAc7b;UAE7B5vB;MACL,GAAGhgC;MACH,GAAGD;MACH,GAAGE;;UAEEksE,6BAA6B/3B;MAClCf;QACC+4B,aAAa,MAAM;QACnBC,kBAAkB,MAAM;;MAEzBv5B;QACCw5B;UACC3vE,OAAO;;QAER4vE;UACC5vE,WAAW6W;;QAEZlb;UACCqE,OAAO;;;MAGT22C,cAAcg4B;MACd/3B,gBAAgB83B;;UAEXmB,2BAA2BL,uBAAuB7yE;IACxDkzE,yBAAyBn5B,QAAQo5B,kBAAkB;UAC7CC,oBAAoB99B;IAC1B89B,cAAc53E,aAAa,gBAAgBq0C,oBAAoBW,eAAe,IAAI,GAAG,KAAK,IAAI,GAAG,MAAM,GAAG,GAAG,OAAO;UAC9G6iC,qBAAqBv0E,KAAKs0E,eAAeP;UACzCx6B,QAAQ;IACd,KAAKgE,UAAU;IACf,KAAKi3B,aAAa;IAClB,KAAKxxD,cAAc;IACnB,KAAKtqB,OAAO8O;IAEZ,KAAKm3C,SAAS,UAAUvD,QAAQ12C,OAAOinB;UAClC4tB,MAAMgE,YAAY;UAClBhE,MAAMi7B,eAAe,SAASj7B,MAAMv2B,gBAAgB;UACpDo4B,OAAOzhD,WAAW;YAEhB6kD,sBAAsB20B,UAAU10B;YAEhCg2B,iBAAiBtB,UAAUuB;YAE3BC,oBAAoBxB,UAAUyB;YAE9BC,SAAS1B,UAAU9iB;;MAEzBwkB,OAAOC,YAAY9sE;MAEnB6sE,OAAO9yB,QAAQjiD,MAAMsxD,SAAS,GAAG,GAAG,GAAG;MAEvCyjB,OAAO9yB,QAAQ/8B,MAAM+vD,QAAQ;MAE7BF,OAAOG,eAAe;;eAGbt7E,IAAI,GAAGksB,KAAKw1B,OAAOzhD,QAAQD,IAAIksB,IAAIlsB;cACrCiM,QAAQy1C,OAAO1hD;cACfs2D,SAASrqD,MAAMqqD;YAEjBA,WAAW14D;UACdiC,QAAQ0B,KAAK,yBAAyB0K,OAAO;;;YAI1CqqD,OAAOwkB,eAAe,SAASxkB,OAAOhtC,gBAAgB;QAE1DwwD,eAAe/6D,KAAKu3C,OAAOyhB;cAErBwD,qBAAqBjlB,OAAOklB;QAElC1B,eAAex6D,SAASi8D;QAExBxB,cAAch7D,KAAKu3C,OAAOyhB;YAEtB+B,eAAelzE,IAAIwzE,mBAAmBN,eAAe/yE,IAAIqzE;cACxDN,eAAelzE,IAAIwzE;YACtBL,cAAcnzE,IAAI7B,KAAKC,MAAMo1E,kBAAkBmB,mBAAmB30E;YAClEkzE,eAAelzE,IAAImzE,cAAcnzE,IAAI20E,mBAAmB30E;YACxD0vD,OAAOyhB,QAAQnxE,IAAImzE,cAAcnzE;;cAG9BkzE,eAAe/yE,IAAIqzE;YACtBL,cAAchzE,IAAIhC,KAAKC,MAAMo1E,kBAAkBmB,mBAAmBx0E;YAClE+yE,eAAe/yE,IAAIgzE,cAAchzE,IAAIw0E,mBAAmBx0E;YACxDuvD,OAAOyhB,QAAQhxE,IAAIgzE,cAAchzE;;;YAI/BuvD,OAAOx0D,QAAQ,SAASw0D,OAAOmlB,sBAAsB,KAAKz8E,SAASgP;gBAChE0tE;YACLl0D,WAAW5V;YACX2V,WAAW3V;YACX6V,QAAQ1U;;UAETujD,OAAOx0D,UAAUkqB,kBAAkB8tD,eAAelzE,GAAGkzE,eAAe/yE,GAAG20E;UACvEplB,OAAOx0D,IAAI4pB,QAAQxgB,OAAOe,MAAMf,OAAO;UACvCorD,OAAOqlB,cAAc3vD,kBAAkB8tD,eAAelzE,GAAGkzE,eAAe/yE,GAAG20E;UAC3EplB,OAAOrkC,OAAO+wB;;YAGXsT,OAAOx0D,QAAQ;gBACZ45E;YACLl0D,WAAWjW;YACXgW,WAAWhW;YACXkW,QAAQ1U;;UAETujD,OAAOx0D,UAAUkqB,kBAAkB8tD,eAAelzE,GAAGkzE,eAAe/yE,GAAG20E;UACvEplB,OAAOx0D,IAAI4pB,QAAQxgB,OAAOe,MAAMf,OAAO;UACvCorD,OAAOrkC,OAAO+wB;;QAGfy2B,UAAUz0B,gBAAgBsR,OAAOx0D;QAEjC23E,UAAU35E;cAEJ87E,gBAAgBtlB,OAAOulB;iBAEpBC,KAAK,GAAGA,KAAKF,eAAeE;gBAC9BrwD,WAAW6qC,OAAOylB,YAAYD;UAEpC9B,UAAU7tE,IAAI4tE,cAAcnzE,IAAI6kB,SAAS7kB,GAAGmzE,cAAchzE,IAAI0kB,SAAS1kB,GAAGgzE,cAAcnzE,IAAI6kB,SAASzkB,GAAG+yE,cAAchzE,IAAI0kB,SAASzM;UAEnIm8D,OAAO1vD,SAASuuD;UAEhB1jB,OAAO0lB,eAAe/vE,OAAO6vE;UAC7BlC,WAAWtjB,OAAO2lB;UAClBC,aAAalxE,OAAOinB,QAAQqkC,OAAOrkC,QAAQhmB,OAAO,KAAKjN;;;aAInDs3D,OAAOmlB,sBAAsB,KAAKz8E,SAASgP;UAC/CmuE,QAAQ7lB,QAAQrkC;;QAGjBqkC,OAAOhtC,cAAc;;MAGtBu2B,MAAMv2B,cAAc;MAEpBmwD,UAAUz0B,gBAAgBF,qBAAqBi2B,gBAAgBE;;IAGhE,iBAAiB3kB,QAAQrkC;YAClBnsB,WAAW4zE,SAAS/qD,OAAOksD;;MAGjCR,uBAAuBr5B,SAASw5B,YAAY3vE,QAAQyrD,OAAOx0D,IAAI4pB;MAC/D2uD,uBAAuBr5B,SAASy5B,WAAW5vE,QAAQyrD,OAAOyhB;MAC1DsC,uBAAuBr5B,SAASx6C,OAAOqE,QAAQyrD,OAAO9vD;MAEtDizE,UAAUz0B,gBAAgBsR,OAAOqlB;MAEjClC,UAAU35E;MAEV25E,UAAU2C,mBAAmBnqD,QAAQ,MAAMnsB,UAAUu0E,wBAAwBQ,gBAAgB;;MAG7FH,yBAAyB15B,SAASw5B,YAAY3vE,QAAQyrD,OAAOqlB,QAAQjwD;MACrEgvD,yBAAyB15B,SAASy5B,WAAW5vE,QAAQyrD,OAAOyhB;MAC5D2C,yBAAyB15B,SAASx6C,OAAOqE,QAAQyrD,OAAO9vD;MAExDizE,UAAUz0B,gBAAgBsR,OAAOx0D;MAEjC23E,UAAU35E;MAEV25E,UAAU2C,mBAAmBnqD,QAAQ,MAAMnsB,UAAU40E,0BAA0BG,gBAAgB;;IAGhG,iCAAiCwB;YAC1BviE,QAAQuiE,eAAe;UACzBn2E,WAAW+zE,gBAAgBngE;UAE3B5T,aAAatI;QAChBsI,eAAessE;UACdlC,cAAc54D;UACd+6B,cAAc4pC;;QAEfpC,gBAAgBngE,SAAS5T;;aAGnBA;;IAGR,oCAAoCm2E;YAC7BviE,QAAQuiE,eAAe;UACzBn2E,WAAWg0E,mBAAmBpgE;UAE9B5T,aAAatI;QAChBsI,eAAeusE;UACdhgC,cAAc4pC;;QAEfnC,mBAAmBpgE,SAAS5T;;aAGtBA;;IAGR,0BAA0BgvB,QAAQpvB,UAAUI,UAAU+F,OAAO2oD,kBAAkBC,iBAAiB71D;UAC3Fs9E,SAAS;UACTC,qBAAqBC;UACrBC,iBAAiBvnD,OAAOwnD;UAExBzwE,MAAMksE,iBAAiB;QAC1BoE,qBAAqBI;QACrBF,iBAAiBvnD,OAAO0nD;;UAGrBH,mBAAmB7+E;YAClBy+E,cAAc;YAEdn2E,SAASusC,iBAAiB;UAC7B4pC,cAAcv2E,SAAS6yC,mBAAmB7yC,SAAS6yC,gBAAgBhyC,YAAYb,SAAS6yC,gBAAgBhyC,SAAS1G,SAAS;;QAG3Hq8E,SAASC,mBAAmBF;;QAE5BC,SAASG;;UAGNhD,UAAUxa,wBAAwB/4D,SAAS+nC,gBAAgB,QAAQ/nC,SAAS6nC,eAAe9tC,WAAW;;;cAGnG48E,OAAOP,OAAOxhE,MACjBgiE,OAAO52E,SAAS4U;YACfiiE,sBAAsB5C,eAAe0C;YAErCE,wBAAwBn/E;UAC3Bm/E;UACA5C,eAAe0C,QAAQE;;YAGpBC,iBAAiBD,oBAAoBD;YAErCE,mBAAmBp/E;UACtBo/E,iBAAiBV,OAAO90E;UACxBu1E,oBAAoBD,QAAQE;;QAG7BV,SAASU;;MAGVV,OAAOn4C,UAAUj+B,SAASi+B;MAC1Bm4C,OAAOhyE,YAAYpE,SAASoE;UAExBtL,SAASgP;QACZsuE,OAAO5vC,OAAOxmC,SAASgoC,eAAe,OAAOhoC,SAASgoC,aAAahoC,SAASwmC;;QAE5E4vC,OAAO5vC,OAAOxmC,SAASgoC,eAAe,OAAOhoC,SAASgoC,aAAaA,WAAWhoC,SAASwmC;;MAGxF4vC,OAAOruC,cAAc/nC,SAAS+nC;MAC9BquC,OAAOvuC,iBAAiB7nC,SAAS6nC;MACjCuuC,OAAOtuC,mBAAmB9nC,SAAS8nC;MACnCsuC,OAAOhqC,qBAAqBpsC,SAASosC;MACrCgqC,OAAOnqC,YAAYjsC,SAASisC;UAExBlmC,MAAMksE,iBAAiB,QAAQmE,OAAOhD,2BAA2B;QACpEgD,OAAOnmB,kBAAkBviC,sBAAsB3nB,MAAMqmB;QACrDgqD,OAAOlmB,eAAexB;QACtB0nB,OAAOjmB,cAAcxB;;aAGfynB;;IAGR,sBAAsBpnD,QAAQjD,QAAQgrD,cAAchxE,OAAOjN;UACtDk2B,OAAOiP,YAAY;YACjBA,UAAUjP,OAAOuN,OAAO/jC,KAAKuzB,OAAOwQ;UAEtC0B,YAAYjP,OAAOuS,UAAUvS,OAAOwS,UAAUxS,OAAOyS;aACnDzS,OAAOkP,cAAclP,OAAOmP,iBAAiBrlC,SAASgP,mBAAmBknB,OAAOoP,iBAAiBs1C,SAASvyB,iBAAiBnyB;UAC/HA,OAAO4O,gBAAgB9gB,iBAAiBi6D,aAAa/qD,oBAAoBgD,OAAO5C;gBAE1ExsB,WAAW4zE,SAAS/qD,OAAOuG;gBAE3BhvB,WAAWgvB,OAAOhvB;cAEpB5D,MAAMC,QAAQ2D;kBACX2yC,SAAS/yC,SAAS+yC;qBAEf12C,IAAI,GAAG+6E,KAAKrkC,OAAO54C,QAAQkC,IAAI+6E,IAAI/6E;oBACrC+F,QAAQ2wC,OAAO12C;oBACf88C,gBAAgB/4C,SAASgC,MAAMqxC;kBAEjC0F,iBAAiBA,cAAc9a;sBAC5Bg5C,gBAAgBC,iBAAiBloD,QAAQpvB,UAAUm5C,eAAehzC,OAAOgxE,aAAa/7C,MAAM+7C,aAAa97C,KAAKniC;gBAEpHy6E,UAAU2C,mBAAmBa,cAAc,MAAMn3E,UAAUq3E,eAAejoD,QAAQhtB;;;qBAG1EhC,SAASi+B;kBACbg5C,gBAAgBC,iBAAiBloD,QAAQpvB,UAAUI,UAAU+F,OAAOgxE,aAAa/7C,MAAM+7C,aAAa97C,KAAKniC;YAE/Gy6E,UAAU2C,mBAAmBa,cAAc,MAAMn3E,UAAUq3E,eAAejoD,QAAQ;;;;YAK/Ee,WAAWf,OAAOe;eAEfj2B,IAAI,GAAGma,IAAI8b,SAASh2B,QAAQD,IAAIma,GAAGna;QAC3Ck8E,aAAajmD,SAASj2B,IAAIiyB,QAAQgrD,cAAchxE,OAAOjN;;;;EAK1D,oBAAoBkpD,IAAItG,YAAYuG;UAC7BC,WAAWD,aAAaC;IAE9B;UACKi1B,SAAS;YACPj3E,YAAYglB;UACdkyD,mBAAmB;YACjBC,wBAAwBnyD,QAAQ,GAAG,GAAG,GAAG;;QAE9CoyD,SAAS,UAAUC;cACdH,qBAAqBG,cAAcJ;YACtCn1B,GAAGu1B,UAAUA,WAAWA,WAAWA,WAAWA;YAC9CH,mBAAmBG;;;QAGrBC,WAAW,UAAUC;UACpBN,SAASM;;QAEVjmB,UAAU,UAAUtyC,GAAGb,GAAGhI,GAAGD,GAAGqyB;cAC3BA,uBAAuB;YAC1BvpB,KAAK9I;YACLiI,KAAKjI;YACLC,KAAKD;;UAGNlW,MAAM+F,IAAIiZ,GAAGb,GAAGhI,GAAGD;cAEfihE,kBAAkBv8D,OAAO5a,WAAW;YACvC8hD,GAAG2O,WAAWzxC,GAAGb,GAAGhI,GAAGD;YACvBihE,kBAAkBx+D,KAAK3Y;;;QAGzB01D,OAAO;UACNuhB,SAAS;UACTC,mBAAmB;UACnBC,kBAAkBpxE,KAAK,GAAG,GAAG,GAAG;;;;IAKnC;UACKkxE,SAAS;UACTO,mBAAmB;UACnBC,mBAAmB;UACnBC,oBAAoB;;QAEvBzC,SAAS,UAAUhuC;cACdA;YACHjL,OAAO8lB,GAAG61B;;YAEVx7C,QAAQ2lB,GAAG61B;;;QAGbP,SAAS,UAAUQ;cACdJ,qBAAqBI,cAAcX;YACtCn1B,GAAG81B,UAAUA;YACbJ,mBAAmBI;;;QAGrBC,SAAS,UAAU7wC;cACdywC,qBAAqBzwC;gBACpBA;sBACKA;qBACFx9B;kBACJs4C,GAAG9a,UAAU8a,GAAGg2B;;qBAGZruE;kBACJq4C,GAAG9a,UAAU8a,GAAGi2B;;qBAGZruE;kBACJo4C,GAAG9a,UAAU8a,GAAGk2B;;qBAGZruE;kBACJm4C,GAAG9a,UAAU8a,GAAGm2B;;qBAGZruE;kBACJk4C,GAAG9a,UAAU8a,GAAGo2B;;qBAGZruE;kBACJi4C,GAAG9a,UAAU8a,GAAGq2B;;qBAGZruE;kBACJg4C,GAAG9a,UAAU8a,GAAGs2B;;qBAGZruE;kBACJ+3C,GAAG9a,UAAU8a,GAAGu2B;;;kBAIhBv2B,GAAG9a,UAAU8a,GAAGm2B;;;cAGlBn2B,GAAG9a,UAAU8a,GAAGm2B;;YAGjBR,mBAAmBzwC;;;QAGrBswC,WAAW,UAAUC;UACpBN,SAASM;;QAEVjmB,UAAU,UAAUpsC;cACfwyD,sBAAsBxyD;YACzB48B,GAAGw2B,WAAWpzD;YACdwyD,oBAAoBxyD;;;QAGtBwwC,OAAO;UACNuhB,SAAS;UACTO,mBAAmB;UACnBC,mBAAmB;UACnBC,oBAAoB;;;;IAKvB;UACKT,SAAS;UACTsB,qBAAqB;UACrBC,qBAAqB;UACrBC,oBAAoB;UACpBC,yBAAyB;UACzBC,qBAAqB;UACrBC,sBAAsB;UACtBC,sBAAsB;UACtBC,sBAAsB;;QAEzB7D,SAAS,UAAU8D;eACb9B;gBACA8B;cACH/8C,OAAO8lB,GAAGk3B;;cAEV78C,QAAQ2lB,GAAGk3B;;;;QAId5B,SAAS,UAAU6B;cACdV,uBAAuBU,gBAAgBhC;YAC1Cn1B,GAAGm3B,YAAYA;YACfV,qBAAqBU;;;QAGvBpB,SAAS,UAAUzwC,aAAaC,YAAY4xC;cACvCT,uBAAuBpxC,eAAeqxC,sBAAsBpxC,cAAcqxC,2BAA2BO;YACxGn3B,GAAG1a,YAAYA,aAAaC,YAAY4xC;YACxCT,qBAAqBpxC;YACrBqxC,oBAAoBpxC;YACpBqxC,yBAAyBO;;;QAG3BC,OAAO,UAAU3xC,aAAaC,cAAcC;cACvCkxC,uBAAuBpxC,eAAeqxC,wBAAwBpxC,gBAAgBqxC,wBAAwBpxC;YACzGqa,GAAGq3B,UAAU5xC,aAAaC,cAAcC;YACxCkxC,qBAAqBpxC;YACrBqxC,sBAAsBpxC;YACtBqxC,sBAAsBpxC;;;QAGxB6vC,WAAW,UAAUC;UACpBN,SAASM;;QAEVjmB,UAAU,UAAU9R;cACfs5B,wBAAwBt5B;YAC3BsC,GAAGs3B,aAAa55B;YAChBs5B,sBAAsBt5B;;;QAGxBkW,OAAO;UACNuhB,SAAS;UACTsB,qBAAqB;UACrBC,qBAAqB;UACrBC,oBAAoB;UACpBC,yBAAyB;UACzBC,qBAAqB;UACrBC,sBAAsB;UACtBC,sBAAsB;UACtBC,sBAAsB;;;;;UAMnBO,kBAAkBC;UAClB/zD,kBAAkBg0D;UAClB/zD,oBAAoBg0D;QACtBC;QACAC,gBAAgB;QAChBC;QACAC,iBAAiB;QACjBC,yBAAyB;QACzBC,kBAAkB;QAClBC,uBAAuB;QACvBC,kBAAkB;QAClBC,kBAAkB;QAClBC,4BAA4B;QAC5BC,uBAAuB;QACvBC,uBAAuB;QACvBC,2BAA2B;QAC3BC,mBAAmB;QACnBC,kBAAkB;QAClBC,mBAAmB;QACnBC,6BAA6B;QAC7BC,4BAA4B;UAC1BpjB,cAAcxV,GAAG9xB,aAAa8xB,GAAG64B;QACnCC,qBAAqB;QACrB34D,UAAU;UACR44D,YAAY/4B,GAAG9xB,aAAa8xB,GAAGg5B;QAEjCD,UAAU/iF,QAAQ,cAAc;MACnCmqB,UAAUqrB,YAAW,eAAcC,KAAKstC,WAAW;MACnDD,qBAAqB34D,WAAW;eACtB44D,UAAU/iF,QAAQ,kBAAkB;MAC9CmqB,UAAUqrB,YAAW,mBAAkBC,KAAKstC,WAAW;MACvDD,qBAAqB34D,WAAW;;QAG7B84D,qBAAqB;QACrBC;UACEC,eAAen5B,GAAG9xB,aAAa8xB,GAAGo5B;UAClCC,gBAAgBr5B,GAAG9xB,aAAa8xB,GAAGs5B;UACnCC,qBAAqBr2D,UAAUnK,UAAUogE;UACzCK,sBAAsBt2D,UAAUnK,UAAUsgE;IAEhD,uBAAuBviF,MAAMwK,QAAQpB;YAC9BhL,WAAWo6C,WAAW;;YAEtB9rB,UAAUw8B,GAAGy5B;MACnBz5B,GAAG05B,YAAY5iF,MAAM0sB;MACrBw8B,GAAG25B,cAAc7iF,MAAMkpD,GAAG45B,oBAAoB55B,GAAG65B;MACjD75B,GAAG25B,cAAc7iF,MAAMkpD,GAAG85B,oBAAoB95B,GAAG65B;eAExC/hF,IAAI,GAAGA,IAAIoI,OAAOpI;QAC1BkoD,GAAG+5B,WAAWz4E,SAASxJ,GAAG,GAAGkoD,GAAGg6B,MAAM,GAAG,GAAG,GAAGh6B,GAAGg6B,MAAMh6B,GAAGgB,eAAe9rD;;aAGpEsuB;;UAGFy2D;IACNA,cAAcj6B,GAAGk6B,cAAcT,cAAcz5B,GAAGk6B,YAAYl6B,GAAGk6B,YAAY;IAC3ED,cAAcj6B,GAAGm6B,oBAAoBV,cAAcz5B,GAAGm6B,kBAAkBn6B,GAAGo6B,6BAA6B;;IAExG7C,YAAY/nB,SAAS,GAAG,GAAG,GAAG;IAC9B/rC,YAAY+rC,SAAS;IACrB9rC,cAAc8rC,SAAS;IACvBt1B,OAAO8lB,GAAG61B;IACVpyD,YAAYsyD,QAAQluE;IACpBwyE,aAAa;IACbC,YAAY90E;IACZ00B,OAAO8lB,GAAGu6B;IACVrH,YAAY9sE;;IAEZ,gBAAgB3O;UACXkgF,oBAAoBlgF,QAAQ;QAC/BuoD,GAAG9lB,OAAOziC;QACVkgF,oBAAoBlgF,MAAM;;;IAI5B,iBAAiBA;UACZkgF,oBAAoBlgF,QAAQ;QAC/BuoD,GAAG3lB,QAAQ5iC;QACXkgF,oBAAoBlgF,MAAM;;;IAI5B,2BAA2B+iF;UACtBA,gBAAgB5C;QACnB53B,GAAGy6B,gBAAgBz6B,GAAG06B,aAAaF;QACnC5C,gBAAgB4C;;;IAIlB,yBAAyBl5E,QAAQk5E;UAC5BA,gBAAgB,QAAQ5C,kBAAkB,MAAM4C,cAAc5C;;UAE9DC,yBAAyBv2E,YAAYk5E;QACxCx6B,GAAGy6B,gBAAgBn5E,QAAQk5E;QAC3B3C,yBAAyBv2E,UAAUk5E;YAE/Bt6B;;cAEC5+C,WAAW0+C,GAAG26B;YACjB9C,yBAAyB73B,GAAG06B,eAAeF;;cAGxCl5E,WAAW0+C,GAAG06B;YACjB7C,yBAAyB73B,GAAG26B,oBAAoBH;;;eAI3C;;aAGD;;IAGR,oBAAoB5pB;UACfknB,mBAAmBlnB;QACtB5Q,GAAG46B,WAAWhqB;QACdknB,iBAAiBlnB;eACV;;aAGD;;UAGFiqB;OACJn0E,cAAcs5C,GAAG86B;OACjBn0E,mBAAmBq5C,GAAG+6B;OACtBn0E,0BAA0Bo5C,GAAGg7B;;QAG3B96B;MACH26B,aAAah0E,eAAem5C,GAAGi7B;MAC/BJ,aAAa/zE,eAAek5C,GAAGk7B;;YAEzB5qB,YAAY5W,WAAW4H,IAAI;UAE7BgP,cAAc;QACjBuqB,aAAah0E,eAAeypD,UAAU6qB;QACtCN,aAAa/zE,eAAewpD,UAAU8qB;;;UAIlCC;OACJt0E,aAAai5C,GAAGs7B;OAChBt0E,YAAYg5C,GAAGu7B;OACft0E,iBAAiB+4C,GAAGw7B;OACpBr0E,iBAAiB64C,GAAGy7B;OACpBh0E,yBAAyBu4C,GAAG07B;OAC5Bn0E,iBAAiBy4C,GAAG27B;OACpBt0E,iBAAiB24C,GAAG47B;OACpB10E,yBAAyB84C,GAAG67B;OAC5Bz0E,yBAAyB44C,GAAG87B;OAC5Bt0E,yBAAyBw4C,GAAG+7B;OAC5Bz0E,yBAAyB04C,GAAGg8B;;IAG9B,qBAAqBz3C,UAAUO,eAAeF,UAAUC,UAAUI,oBAAoBF,eAAeC,eAAeyB;UAC/GlC,aAAan+B;YACZ2xE,2BAA2B;UAC9B19C,QAAQ2lB,GAAGi8B;UACXlE,yBAAyB;;;;UAMvBA,2BAA2B;QAC9B79C,OAAO8lB,GAAGi8B;QACVlE,yBAAyB;;UAGtBxzC,aAAa99B;YACZ89B,aAAayzC,mBAAmBvxC,uBAAuB8xC;cACtDN,yBAAyBvxE,eAAe0xE,8BAA8B1xE;YACzEs5C,GAAGlb,cAAckb,GAAG86B;YACpB7C,uBAAuBvxE;YACvB0xE,4BAA4B1xE;;cAGzB+/B;oBACKlC;mBACFl+B;gBACJ25C,GAAGk8B,kBAAkBl8B,GAAGu7B,KAAKv7B,GAAG87B,qBAAqB97B,GAAGu7B,KAAKv7B,GAAG87B;;mBAG5Dx1E;gBACJ05C,GAAGm8B,UAAUn8B,GAAGu7B,KAAKv7B,GAAGu7B;;mBAGpBh1E;gBACJy5C,GAAGk8B,kBAAkBl8B,GAAGs7B,MAAMt7B,GAAGs7B,MAAMt7B,GAAG67B,qBAAqB77B,GAAG87B;;mBAG9Dt1E;gBACJw5C,GAAGk8B,kBAAkBl8B,GAAGs7B,MAAMt7B,GAAGw7B,WAAWx7B,GAAGs7B,MAAMt7B,GAAGy7B;;;gBAIxD9jF,QAAQa,MAAM,wCAAwC+rC;;;;oBAIhDA;mBACFl+B;gBACJ25C,GAAGk8B,kBAAkBl8B,GAAGy7B,WAAWz7B,GAAG87B,qBAAqB97B,GAAGu7B,KAAKv7B,GAAG87B;;mBAGlEx1E;gBACJ05C,GAAGm8B,UAAUn8B,GAAGy7B,WAAWz7B,GAAGu7B;;mBAG1Bh1E;gBACJy5C,GAAGm8B,UAAUn8B,GAAGs7B,MAAMt7B,GAAG67B;;mBAGrBr1E;gBACJw5C,GAAGm8B,UAAUn8B,GAAGs7B,MAAMt7B,GAAGw7B;;;gBAIzB7jF,QAAQa,MAAM,wCAAwC+rC;;;;UAKzD2zC,kBAAkB;UAClBC,kBAAkB;UAClBE,uBAAuB;UACvBC,uBAAuB;UACvBN,kBAAkBzzC;UAClBg0C,2BAA2B9xC;;;;;MAO7BxB,qBAAqBA,sBAAsBH;MAC3CC,gBAAgBA,iBAAiBH;MACjCI,gBAAgBA,iBAAiBH;UAE7BC,kBAAkBmzC,wBAAwBhzC,uBAAuBmzC;QACpEp4B,GAAGo8B,sBAAsBvB,aAAa/1C,gBAAgB+1C,aAAa51C;QACnEgzC,uBAAuBnzC;QACvBszC,4BAA4BnzC;;UAGzBL,aAAaszC,mBAAmBrzC,aAAaszC,mBAAmBpzC,kBAAkBszC,wBAAwBrzC,kBAAkBszC;QAC/Ht4B,GAAGk8B,kBAAkBb,WAAWz2C,WAAWy2C,WAAWx2C,WAAWw2C,WAAWt2C,gBAAgBs2C,WAAWr2C;QACvGkzC,kBAAkBtzC;QAClBuzC,kBAAkBtzC;QAClBwzC,uBAAuBtzC;QACvBuzC,uBAAuBtzC;;MAGxBgzC,kBAAkBzzC;MAClBg0C,2BAA2B;;IAG5B,qBAAqBv6E,UAAUq+E;MAC9Br+E,SAASwmC,SAASv+B,aAAao0B,QAAQ2lB,GAAGu6B,aAAargD,OAAO8lB,GAAGu6B;UAC7D/S,YAAYxpE,SAASwmC,SAASx+B;UAC9Bq2E,aAAa7U,aAAaA;MAC9B6S,aAAa7S;MACbxpE,SAASumC,aAAal+B,kBAAkBrI,SAAS2mC,gBAAgB,QAAQuuC,YAAY9sE,cAAc8sE,YAAYl1E,SAASumC,UAAUvmC,SAAS8mC,eAAe9mC,SAAS4mC,UAAU5mC,SAAS6mC,UAAU7mC,SAASinC,oBAAoBjnC,SAAS+mC,eAAe/mC,SAASgnC,eAAehnC,SAASyoC;MACtRhjB,YAAYsyD,QAAQ/3E,SAASknC;MAC7BzhB,YAAY0vD,QAAQn1E,SAASmnC;MAC7B1hB,YAAY6xD,QAAQt3E,SAASonC;MAC7BmyC,YAAYjC,QAAQt3E,SAASioC;YACvBL,eAAe5nC,SAAS4nC;MAC9BliB,cAAcyvD,QAAQvtC;UAElBA;QACHliB,cAAc4xD,QAAQt3E,SAASqnC;QAC/B3hB,cAAcqyD,QAAQ/3E,SAASsnC,aAAatnC,SAASunC,YAAYvnC,SAASwnC;QAC1E9hB,cAAc0zD,MAAMp5E,SAASynC,aAAaznC,SAAS0nC,cAAc1nC,SAAS2nC;;MAG3E22C,iBAAiBt+E,SAASmoC,eAAenoC,SAASooC,qBAAqBpoC,SAASqoC;MAChFroC,SAASwoC,oBAAoB,OAAOtM,OAAO8lB,GAAGu8B,4BAA4BliD,QAAQ2lB,GAAGu8B;;;IAItF,sBAAsB/U;UACjBgR,qBAAqBhR;YACpBA;UACHxnB,GAAGw8B,UAAUx8B,GAAGy8B;;UAEhBz8B,GAAGw8B,UAAUx8B,GAAG08B;;QAGjBlE,mBAAmBhR;;;IAIrB,qBAAqBmV;UAChBA,aAAap3E;QAChB20B,OAAO8lB,GAAGu6B;YAENoC,aAAalE;cACZkE,aAAan3E;YAChBw6C,GAAG28B,SAAS38B,GAAG48B;qBACLD,aAAal3E;YACvBu6C,GAAG28B,SAAS38B,GAAG68B;;YAEf78B,GAAG28B,SAAS38B,GAAG88B;;;;QAIjBziD,QAAQ2lB,GAAGu6B;;MAGZ9B,kBAAkBkE;;IAGnB,sBAAsBtmE;UACjBA,UAAUqiE;YACTI,oBAAoB94B,GAAG+8B,UAAU1mE;QACrCqiE,mBAAmBriE;;;IAIrB,0BAA0B8vB,eAAe62C,QAAQ/d;UAC5C94B;QACHjM,OAAO8lB,GAAGi9B;YAENtE,+BAA+BqE,UAAUpE,8BAA8B3Z;UAC1Ejf,GAAG7Z,cAAc62C,QAAQ/d;UACzB0Z,6BAA6BqE;UAC7BpE,4BAA4B3Z;;;QAG7B5kC,QAAQ2lB,GAAGi9B;;;IAIb,wBAAwB35D;UACnBA;QACH4W,OAAO8lB,GAAGk9B;;QAEV7iD,QAAQ2lB,GAAGk9B;;;;IAKb,uBAAuBC;UAClBA,cAAcznF,WAAWynF,YAAYn9B,GAAGo9B,WAAW5nB,cAAc;UAEjEyjB,uBAAuBkE;QAC1Bn9B,GAAGq9B,cAAcF;QACjBlE,qBAAqBkE;;;IAIvB,qBAAqBG,WAAWC;UAC3BtE,uBAAuB;QAC1BoE;;UAGGG,eAAetE,qBAAqBD;UAEpCuE,iBAAiB9nF;QACpB8nF;UACC1mF,MAAMpB;UACN8tB,SAAS9tB;;QAEVwjF,qBAAqBD,sBAAsBuE;;UAGxCA,aAAa1mF,SAASwmF,aAAaE,aAAah6D,YAAY+5D;QAC/Dv9B,GAAG05B,YAAY4D,WAAWC,gBAAgBtD,cAAcqD;QACxDE,aAAa1mF,OAAOwmF;QACpBE,aAAah6D,UAAU+5D;;;IAIzB;YACOC,eAAetE,qBAAqBD;UAEtCuE,iBAAiB9nF,aAAa8nF,aAAa1mF,SAASpB;QACvDsqD,GAAG05B,YAAY8D,aAAa1mF,MAAM;QAClC0mF,aAAa1mF,OAAOpB;QACpB8nF,aAAah6D,UAAU9tB;;;IAIzB;;QAEEsqD,GAAGy9B,qBAAqBhhF,MAAMujD,IAAIrmC;eAC1BnhB;QACRb,QAAQa,MAAM,qBAAqBA;;;IAIrC;;QAEEwnD,GAAG+5B,WAAWt9E,MAAMujD,IAAIrmC;eAChBnhB;QACRb,QAAQa,MAAM,qBAAqBA;;;IAIrC;;QAEEwnD,GAAG09B,WAAWjhF,MAAMujD,IAAIrmC;eAChBnhB;QACRb,QAAQa,MAAM,qBAAqBA;;;;IAKrC,iBAAiB6qB;UACZk2D,eAAezgE,OAAOuK,aAAa;QACtC28B,GAAG38B,QAAQA,QAAQ3kB,GAAG2kB,QAAQxkB,GAAGwkB,QAAQvkB,GAAGukB,QAAQvM;QACpDyiE,eAAe1iE,KAAKwM;;;IAItB,kBAAkBE;UACbi2D,gBAAgB1gE,OAAOyK,cAAc;QACxCy8B,GAAGz8B,SAASA,SAAS7kB,GAAG6kB,SAAS1kB,GAAG0kB,SAASzkB,GAAGykB,SAASzM;QACzD0iE,gBAAgB3iE,KAAK0M;;;;IAKvB;;MAECy8B,GAAG3lB,QAAQ2lB,GAAGi8B;MACdj8B,GAAG3lB,QAAQ2lB,GAAGu6B;MACdv6B,GAAG3lB,QAAQ2lB,GAAG61B;MACd71B,GAAG3lB,QAAQ2lB,GAAGi9B;MACdj9B,GAAG3lB,QAAQ2lB,GAAGk9B;MACdl9B,GAAG3lB,QAAQ2lB,GAAGk3B;MACdl3B,GAAG3lB,QAAQ2lB,GAAGu8B;MACdv8B,GAAGlb,cAAckb,GAAG86B;MACpB96B,GAAGm8B,UAAUn8B,GAAGu7B,KAAKv7B,GAAGs7B;MACxBt7B,GAAGk8B,kBAAkBl8B,GAAGu7B,KAAKv7B,GAAGs7B,MAAMt7B,GAAGu7B,KAAKv7B,GAAGs7B;MACjDt7B,GAAGu1B,UAAU,MAAM,MAAM,MAAM;MAC/Bv1B,GAAG2O,WAAW,GAAG,GAAG,GAAG;MACvB3O,GAAG81B,UAAU;MACb91B,GAAG9a,UAAU8a,GAAGk2B;MAChBl2B,GAAGw2B,WAAW;MACdx2B,GAAGm3B,YAAY;MACfn3B,GAAG1a,YAAY0a,GAAGi2B,QAAQ,GAAG;MAC7Bj2B,GAAGq3B,UAAUr3B,GAAG29B,MAAM39B,GAAG29B,MAAM39B,GAAG29B;MAClC39B,GAAGs3B,aAAa;MAChBt3B,GAAG28B,SAAS38B,GAAG48B;MACf58B,GAAGw8B,UAAUx8B,GAAG08B;MAChB18B,GAAG7Z,cAAc,GAAG;MACpB6Z,GAAGq9B,cAAcr9B,GAAGo9B;MACpBp9B,GAAGy6B,gBAAgBz6B,GAAG06B,aAAa;UAE/Bx6B,aAAa;QAChBF,GAAGy6B,gBAAgBz6B,GAAG26B,kBAAkB;QACxC36B,GAAGy6B,gBAAgBz6B,GAAG49B,kBAAkB;;MAGzC59B,GAAG46B,WAAW;MACd56B,GAAG+8B,UAAU;MACb/8B,GAAG38B,QAAQ,GAAG,GAAG28B,GAAG3hC,OAAOhI,OAAO2pC,GAAG3hC,OAAO/H;MAC5C0pC,GAAGz8B,SAAS,GAAG,GAAGy8B,GAAG3hC,OAAOhI,OAAO2pC,GAAG3hC,OAAO/H;;MAE7CqhE;MACAsB,qBAAqB;MACrBC;MACAtB,gBAAgB;MAChBC;MACAC,iBAAiB;MACjBC,yBAAyB;MACzBC,kBAAkB;MAClBC,uBAAuB;MACvBC,kBAAkB;MAClBC,kBAAkB;MAClBC,4BAA4B;MAC5BC,uBAAuB;MACvBC,uBAAuB;MACvBC,2BAA2B;MAC3BC,mBAAmB;MACnBC,kBAAkB;MAClBC,mBAAmB;MACnBC,6BAA6B;MAC7BC,4BAA4B;MAC5BW,eAAet1E,IAAI,GAAG,GAAG+7C,GAAG3hC,OAAOhI,OAAO2pC,GAAG3hC,OAAO/H;MACpDkjE,gBAAgBv1E,IAAI,GAAG,GAAG+7C,GAAG3hC,OAAOhI,OAAO2pC,GAAG3hC,OAAO/H;MACrDihE,YAAY3jB;MACZnwC,YAAYmwC;MACZlwC,cAAckwC;;;MAIdzT;QACCjiD,OAAOq5E;QACPn0D,OAAOK;QACPi6B,SAASh6B;;MAEVwW,QAAQA;MACRG,SAASA;MACTogD,iBAAiBA;MACjBoD,mBAAmBA;MACnBjD,YAAYA;MACZ1H,aAAaA;MACb4K,aAAaA;MACbzD,cAAcA;MACdC,aAAaA;MACbyD,cAAcA;MACdzB,kBAAkBA;MAClBlJ,gBAAgBA;MAChBiK,eAAeA;MACf3D,aAAaA;MACbsE,eAAeA;MACfP,sBAAsBA;MACtB1D,YAAYA;MACZ2D,YAAYA;MACZr6D,SAASA;MACTE,UAAUA;MACVqwC,OAAOA;;;EAIT,uBAAuBqqB,KAAKvkC,YAAY+U,OAAOhD,YAAYxL,cAAci+B,OAAO9pB;UACzElU,WAAWD,aAAaC;UACxBsV,cAAcvV,aAAauV;UAC3BM,iBAAiB7V,aAAa6V;UAC9BF,iBAAiB3V,aAAa2V;UAC9Bc,aAAazW,aAAayW;UAE1BynB,qBAAqB/9B;QAEvBpiC;;;;QAKAogE,qBAAqB;;MAGxBA,4BAA4BC,oBAAoB,mBAAmBA,gBAAgB,GAAG,GAAG7/D,WAAW,UAAU;aACtG8/D;IAGT,sBAAsBjoE,OAAOC;;aAErB8nE,yBAAyBC,gBAAgBhoE,OAAOC,UAAUvd,SAASulB,gBAAgB,gCAAgC;;IAG3H,qBAAqBJ,OAAOqgE,iBAAiBC,gBAAgBC;UACxD/gE,QAAQ;;UAERQ,MAAM7H,QAAQooE,WAAWvgE,MAAM5H,SAASmoE;QAC3C/gE,QAAQ+gE,UAAU5hF,KAAKF,IAAIuhB,MAAM7H,OAAO6H,MAAM5H;;;UAI3CoH,QAAQ,KAAK6gE,oBAAoB;;mBAEzBj9D,qBAAqB,eAAepD,iBAAiBoD,2BAA2BlD,sBAAsB,eAAeF,iBAAiBE,4BAA4BmD,gBAAgB,eAAerD,iBAAiBqD;gBACtNzkB,QAAQyhF,kBAAkBpoE,kBAAkBtZ,KAAKC;gBACjDuZ,QAAQvZ,MAAM4gB,QAAQQ,MAAM7H;gBAC5BC,SAASxZ,MAAM4gB,QAAQQ,MAAM5H;cAC/B0H,YAAYtoB,WAAWsoB,UAAU0gE,aAAaroE,OAAOC;;gBAEnD+H,SAASmgE,iBAAiBE,aAAaroE,OAAOC,UAAU0H;UAC9DK,OAAOhI,QAAQA;UACfgI,OAAO/H,SAASA;gBACViI,UAAUF,OAAOG,WAAW;UAClCD,QAAQI,UAAUT,OAAO,GAAG,GAAG7H,OAAOC;UACtC3e,QAAQ0B,KAAK,yDAAyD6kB,MAAM7H,QAAQ,MAAM6H,MAAM5H,SAAS,WAAWD,QAAQ,MAAMC,SAAS;iBACpI+H;;eAEH,UAAUH;YACbvmB,QAAQ0B,KAAK,2DAA2D6kB,MAAM7H,QAAQ,MAAM6H,MAAM5H,SAAS;;iBAGrG4H;;;aAIFA;;IAGR,wBAAwBA;aAChBjI,aAAaiI,MAAM7H,UAAUJ,aAAaiI,MAAM5H;;IAGxD,gCAAgCkN;UAC3B08B,iBAAiB;aACd18B,QAAQrE,UAAUhW,uBAAuBqa,QAAQpE,UAAUjW,uBAAuBqa,QAAQlE,cAAcjW,iBAAiBma,QAAQlE,cAAc5V;;IAGvJ,qCAAqC8Z,SAASm7D;aACtCn7D,QAAQzD,mBAAmB4+D,gBAAgBn7D,QAAQlE,cAAcjW,iBAAiBma,QAAQlE,cAAc5V;;IAGhH,wBAAwBpI,QAAQkiB,SAASnN,OAAOC;MAC/C2nE,IAAIW,eAAet9E;YAEbu9E,oBAAoBpzB,WAAWnK,IAAI99B;MACzCq7D,kBAAkBC,gBAAgBjiF,KAAKkiF,KAAKliF,KAAKF,IAAI0Z,OAAOC;;IAG7D,2BAA2B0oE,oBAAoBC,UAAUC;UACpDh/B,aAAa,cAAc++B;UAE3BD,uBAAuB;YACtBf,IAAIe,wBAAwBtpF,kBAAkBuoF,IAAIe;QACtDrnF,QAAQ0B,KAAK,8EAA8E2lF,qBAAqB;;UAG7Gp/D,iBAAiBq/D;UAEjBA,aAAahB,IAAIkB;YAChBD,WAAWjB,IAAIx9B,OAAO7gC,iBAAiBq+D,IAAImB;YAC3CF,WAAWjB,IAAIv9B,YAAY9gC,iBAAiBq+D,IAAIoB;YAChDH,WAAWjB,IAAIj9B,eAAephC,iBAAiBq+D,IAAIqB;;UAGpDL,aAAahB,IAAIsB;YAChBL,WAAWjB,IAAIx9B,OAAO7gC,iBAAiBq+D,IAAIuB;YAC3CN,WAAWjB,IAAIv9B,YAAY9gC,iBAAiBq+D,IAAIwB;YAChDP,WAAWjB,IAAIj9B,eAAephC,iBAAiBq+D,IAAIyB;;UAGpDT,aAAahB,IAAIjE;YAChBkF,WAAWjB,IAAIx9B,OAAO7gC,iBAAiBq+D,IAAI0B;YAC3CT,WAAWjB,IAAIv9B,YAAY9gC,iBAAiBq+D,IAAI2B;YAChDV,WAAWjB,IAAIj9B,eAAephC,iBAAiBq+D,IAAI4B;;UAGpDjgE,mBAAmBq+D,IAAIoB,QAAQz/D,mBAAmBq+D,IAAImB,QAAQx/D,mBAAmBq+D,IAAI2B,WAAWhgE,mBAAmBq+D,IAAI0B;QAC1HjmC,WAAW4H,IAAI;;aAGT1hC;;;IAIR,wBAAwBpgB;UACnBA,MAAM6J,iBAAiB7J,MAAM8J,8BAA8B9J,MAAMgK;eAC7Dy0E,IAAIpE;;aAGLoE,IAAI6B;;;IAIZ,0BAA0BnpF;YACnB6sB,UAAU7sB,MAAM2K;MACtBkiB,QAAQ9R,oBAAoB,WAAW8mD;MACvCunB,kBAAkBv8D;UAEdA,QAAQw8D;QACX7B,eAAe38B,OAAOh+B;;MAGvB4wC,KAAKwE,OAAOl4C;;IAGb,+BAA+B/pB;YACxBulD,eAAevlD,MAAM2K;MAC3B46C,aAAaxqC,oBAAoB,WAAWuuE;MAC5CC,uBAAuBhkC;;;IAIxB,2BAA2B14B;YACpBq7D,oBAAoBpzB,WAAWnK,IAAI99B;UACrCq7D,kBAAkBsB,gBAAgBzqF;MAEtCuoF,IAAImC,cAAcvB,kBAAkBwB;MAEpC50B,WAAWlyD,OAAOiqB;;IAGnB,gCAAgC04B;YACzB14B,UAAU04B,aAAa14B;YACvB88D,yBAAyB70B,WAAWnK,IAAIpF;YACxC2iC,oBAAoBpzB,WAAWnK,IAAI99B;WACpC04B;UAED2iC,kBAAkBwB,mBAAmB3qF;QACxCuoF,IAAImC,cAAcvB,kBAAkBwB;QAEpCjsB,KAAKwE,OAAOl4C;;UAGTw7B,aAAav4B;QAChBu4B,aAAav4B,aAAaluB;;UAGvBymD,aAAaC;iBACPrkD,IAAI,GAAGA,IAAI,GAAGA;UACtBmmF,IAAIsC,kBAAkBD,uBAAuBE,mBAAmB1oF;cAE5DwoF,uBAAuBG,oBAAoBxC,IAAIyC,mBAAmBJ,uBAAuBG,mBAAmB3oF;;;QAGjHmmF,IAAIsC,kBAAkBD,uBAAuBE;YAEzCF,uBAAuBG,oBAAoBxC,IAAIyC,mBAAmBJ,uBAAuBG;YACzFH,uBAAuBK,gCAAgC1C,IAAIsC,kBAAkBD,uBAAuBK;YACpGL,uBAAuBM,0BAA0B3C,IAAIyC,mBAAmBJ,uBAAuBM;YAC/FN,uBAAuBO,0BAA0B5C,IAAIyC,mBAAmBJ,uBAAuBO;;UAGhG3kC,aAAah4B;iBACPpsB,IAAI,GAAGksB,KAAKR,QAAQzrB,QAAQD,IAAIksB,IAAIlsB;gBACtCgpF,uBAAuBr1B,WAAWnK,IAAI99B,QAAQ1rB;cAEhDgpF,qBAAqBT;YACxBpC,IAAImC,cAAcU,qBAAqBT;YAEvCjsB,KAAKwE,OAAOl4C;;UAGb+qC,WAAWlyD,OAAOiqB,QAAQ1rB;;;MAI5B2zD,WAAWlyD,OAAOiqB;MAClBioC,WAAWlyD,OAAO2iD;;;QAIf6kC,eAAe;IAEnB;MACCA,eAAe;;IAGhB;YACOC,cAAcD;UAEhBC,eAAexrB;QAClB79D,QAAQ0B,KAAK,wCAAwC2nF,cAAc,iDAAiDxrB;;MAGrHurB,gBAAgB;aACTC;;;IAIR,sBAAsBx9D,SAASy9D;YACxBpC,oBAAoBpzB,WAAWnK,IAAI99B;UACrCA,QAAQw8D,gBAAgBkB,mBAAmB19D;UAE3CA,QAAQrD,UAAU,KAAK0+D,kBAAkBsC,cAAc39D,QAAQrD;cAC5DjC,QAAQsF,QAAQtF;YAElBA,UAAUxoB;UACbiC,QAAQ0B,KAAK;mBACH6kB,MAAMkjE,aAAa;UAC7BzpF,QAAQ0B,KAAK;;UAEbgoF,cAAcxC,mBAAmBr7D,SAASy9D;;;;MAK5CxyB,MAAM4uB,cAAcY,IAAIb,WAAW6D;MACnCxyB,MAAMirB,YAAYuE,IAAI/D,YAAY2E,kBAAkBwB;;IAGrD,2BAA2B78D,SAASy9D;YAC7BpC,oBAAoBpzB,WAAWnK,IAAI99B;UAErCA,QAAQrD,UAAU,KAAK0+D,kBAAkBsC,cAAc39D,QAAQrD;QAClEkhE,cAAcxC,mBAAmBr7D,SAASy9D;;;MAI3CxyB,MAAM4uB,cAAcY,IAAIb,WAAW6D;MACnCxyB,MAAMirB,YAAYuE,IAAIqD,kBAAkBzC,kBAAkBwB;;IAG3D,sBAAsB78D,SAASy9D;YACxBpC,oBAAoBpzB,WAAWnK,IAAI99B;UAErCA,QAAQrD,UAAU,KAAK0+D,kBAAkBsC,cAAc39D,QAAQrD;QAClEkhE,cAAcxC,mBAAmBr7D,SAASy9D;;;MAI3CxyB,MAAM4uB,cAAcY,IAAIb,WAAW6D;MACnCxyB,MAAMirB,YAAYuE,IAAIsD,YAAY1C,kBAAkBwB;;IAGrD,wBAAwB78D,SAASy9D;YAC1BpC,oBAAoBpzB,WAAWnK,IAAI99B;UAErCA,QAAQrD,UAAU,KAAK0+D,kBAAkBsC,cAAc39D,QAAQrD;QAClEqhE,kBAAkB3C,mBAAmBr7D,SAASy9D;;;MAI/CxyB,MAAM4uB,cAAcY,IAAIb,WAAW6D;MACnCxyB,MAAMirB,YAAYuE,IAAI9D,kBAAkB0E,kBAAkBwB;;UAGrDoB;OACJv4E,iBAAiB+0E,IAAIyD;OACrBv4E,sBAAsB80E,IAAI0D;OAC1Bv4E,yBAAyB60E,IAAI2D;;UAEzBC;OACJx4E,gBAAgB40E,IAAIpE;OACpBvwE,6BAA6B20E,IAAI6D;OACjCt4E,4BAA4By0E,IAAI8D;OAChCr4E,eAAeu0E,IAAI6B;OACnBn2E,4BAA4Bs0E,IAAI+D;OAChCn4E,2BAA2Bo0E,IAAIgE;;IAGjC,8BAA8BC,aAAa1+D,SAASm7D;UAC/CA;QACHV,IAAItE,cAAcuI,aAAajE,IAAIkE,gBAAgBV,aAAaj+D,QAAQrE;QAExE8+D,IAAItE,cAAcuI,aAAajE,IAAImE,gBAAgBX,aAAaj+D,QAAQpE;YAEpE8iE,gBAAgBjE,IAAIsD,cAAcW,gBAAgBjE,IAAIqD;UACzDrD,IAAItE,cAAcuI,aAAajE,IAAIoE,gBAAgBZ,aAAaj+D,QAAQu3C;;QAGzEkjB,IAAItE,cAAcuI,aAAajE,IAAInE,oBAAoB+H,WAAWr+D,QAAQnE;QAE1E4+D,IAAItE,cAAcuI,aAAajE,IAAIrE,oBAAoBiI,WAAWr+D,QAAQlE;;QAE1E2+D,IAAItE,cAAcuI,aAAajE,IAAIkE,gBAAgBlE,IAAI0D;QAEvD1D,IAAItE,cAAcuI,aAAajE,IAAImE,gBAAgBnE,IAAI0D;YAEnDO,gBAAgBjE,IAAIsD,cAAcW,gBAAgBjE,IAAIqD;UACzDrD,IAAItE,cAAcuI,aAAajE,IAAIoE,gBAAgBpE,IAAI0D;;YAGpDn+D,QAAQrE,UAAUhW,uBAAuBqa,QAAQpE,UAAUjW;UAC9DxR,QAAQ0B,KAAK;;QAGd4kF,IAAItE,cAAcuI,aAAajE,IAAInE,oBAAoBwI,eAAe9+D,QAAQnE;QAE9E4+D,IAAItE,cAAcuI,aAAajE,IAAIrE,oBAAoB0I,eAAe9+D,QAAQlE;YAE1EkE,QAAQlE,cAAcjW,iBAAiBma,QAAQlE,cAAc5V;UAChE/R,QAAQ0B,KAAK;;;UAIXqgD,WAAWkb,IAAI,sCAAsC;cAClDtE,YAAY5W,WAAW4H,IAAI;YAC7B99B,QAAQ1sB,SAASuT,aAAaqvC,WAAWkb,IAAI,gCAAgC;;YAE7E1U,aAAa,SAAS18B,QAAQ1sB,SAASwT,iBAAiBovC,WAAWkb,IAAI,qCAAqC;;YAE5GpxC,QAAQhE,aAAa,KAAKisC,WAAWnK,IAAI99B,SAAS++D;UACrDtE,IAAIuE,cAAcN,aAAa5xB,UAAUmyB,4BAA4B5lF,KAAKD,IAAI4mB,QAAQhE,YAAYygC,aAAa2W;UAE/GnL,WAAWnK,IAAI99B,SAAS++D,sBAAsB/+D,QAAQhE;;;;IAKzD,qBAAqBq/D,mBAAmBr7D;UACnCq7D,kBAAkBsB,gBAAgBzqF;QACrCmpF,kBAAkBsB,cAAc;QAChC38D,QAAQ/gB,iBAAiB,WAAW+1D;QACpCqmB,kBAAkBwB,iBAAiBpC,IAAIxE;QACvCrlB,KAAKwE,OAAOl4C;;;IAId,uBAAuBm+D,mBAAmBr7D,SAASy9D;UAC9CiB,cAAcjE,IAAI/D;UAClB12D,QAAQy3C,sBAAsBinB,cAAcjE,IAAIqD;UAChD99D,QAAQ23C,iBAAiB+mB,cAAcjE,IAAIsD;MAC/CmB,YAAY7D,mBAAmBr7D;MAC/BirC,MAAM4uB,cAAcY,IAAIb,WAAW6D;MACnCxyB,MAAMirB,YAAYwI,aAAarD,kBAAkBwB;MAEjDpC,IAAI0E,YAAY1E,IAAI2E,qBAAqBp/D,QAAQvD;MAEjDg+D,IAAI0E,YAAY1E,IAAI4E,gCAAgCr/D,QAAQxD;MAE5Di+D,IAAI0E,YAAY1E,IAAI6E,kBAAkBt/D,QAAQtD;MAE9C+9D,IAAI0E,YAAY1E,IAAI8E,oCAAoC9E,IAAI+E;YAEtDzE,kBAAkB0E,uBAAuBz/D,YAAY0/D,eAAe1/D,QAAQtF,WAAW;YACvFA,QAAQilE,YAAY3/D,QAAQtF,OAAOqgE,iBAAiB,OAAO3oB;YAC3D+oB,eAAeuE,eAAehlE,UAAUgiC,UAC3C++B,WAAWf,MAAMkF,QAAQ5/D,QAAQjE;UAChC2/D,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB,OACjCusF,mBAAmBC,kBAAkB9/D,QAAQ5D,gBAAgBq/D,UAAUC;MACzEqE,qBAAqBrB,aAAa1+D,SAASm7D;UACvC6E;YACE7jE,UAAU6D,QAAQ7D;UAEpB6D,QAAQigE;;QAEXJ,mBAAmBpF,IAAIyF;YAEnBxjC;cACC18B,QAAQ1sB,SAASuT;YACpBg5E,mBAAmBpF,IAAI0F;qBACbngE,QAAQ1sB,SAASsT;YAC3Bi5E,mBAAmBpF,IAAI2F;qBACbpgE,QAAQ1sB,SAAS4T;YAC3B24E,mBAAmBpF,IAAI4F;;YAEvBR,mBAAmBpF,IAAI6F;;;cAGpBtgE,QAAQ1sB,SAASuT;YACpB1S,QAAQa,MAAM;;;;YAKZgrB,QAAQjE,WAAWtU,eAAeo4E,qBAAqBpF,IAAIyF;;;;cAI1DlgE,QAAQ1sB,SAASoT,qBAAqBsZ,QAAQ1sB,SAASsT;YAC1DzS,QAAQ0B,KAAK;YACbmqB,QAAQ1sB,OAAOoT;YACfg1E,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB;;;YAI7B0sB,QAAQjE,WAAWrU,sBAAsBm4E,qBAAqBpF,IAAIyF;;;UAGrEL,mBAAmBpF,IAAI8F;;;;cAInBvgE,QAAQ1sB,SAAS4T;YACpB/S,QAAQ0B,KAAK;YACbmqB,QAAQ1sB,OAAO4T;YACfw0E,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB;;;;QAKjC23D,MAAMsrB,WAAWkE,IAAI/D,YAAY,GAAGmJ,kBAAkBnlE,MAAM7H,OAAO6H,MAAM5H,QAAQ,GAAG2oE,UAAUC,QAAQ;iBAC5F17D,QAAQxC;;;;YAIdrB,QAAQ5nB,SAAS,KAAK4mF;mBAChB7mF,IAAI,GAAGksB,KAAKrE,QAAQ5nB,QAAQD,IAAIksB,IAAIlsB;YAC5C0rF,SAAS7jE,QAAQ7nB;YACjB22D,MAAMsrB,WAAWkE,IAAI/D,YAAYpiF,GAAGurF,kBAAkBG,OAAOntE,OAAOmtE,OAAOltE,QAAQ,GAAG2oE,UAAUC,QAAQsE,OAAOtuF;;UAGhHsuB,QAAQzD,kBAAkB;UAC1B8+D,kBAAkBC,gBAAgBn/D,QAAQ5nB,SAAS;;UAEnD02D,MAAMsrB,WAAWkE,IAAI/D,YAAY,GAAGmJ,kBAAkBnlE,MAAM7H,OAAO6H,MAAM5H,QAAQ,GAAG2oE,UAAUC,QAAQhhE,MAAMhpB;UAC5G2pF,kBAAkBC,gBAAgB;;iBAEzBt7D,QAAQwgE;iBACTlsF,IAAI,GAAGksB,KAAKrE,QAAQ5nB,QAAQD,IAAIksB,IAAIlsB;UAC5C0rF,SAAS7jE,QAAQ7nB;cAEb0rB,QAAQjE,WAAW1U,cAAc2Y,QAAQjE,WAAW3U;gBACnDq0E,aAAa;cAChBxwB,MAAMgvB,qBAAqBQ,IAAI/D,YAAYpiF,GAAGurF,kBAAkBG,OAAOntE,OAAOmtE,OAAOltE,QAAQ,GAAGktE,OAAOtuF;;cAEvGyC,QAAQ0B,KAAK;;;YAGdo1D,MAAMsrB,WAAWkE,IAAI/D,YAAYpiF,GAAGurF,kBAAkBG,OAAOntE,OAAOmtE,OAAOltE,QAAQ,GAAG2oE,UAAUC,QAAQsE,OAAOtuF;;;QAIjH2pF,kBAAkBC,gBAAgBn/D,QAAQ5nB,SAAS;iBACzCyrB,QAAQy3C;QAClBxM,MAAMivB,WAAWO,IAAIqD,kBAAkB,GAAG+B,kBAAkBnlE,MAAM7H,OAAO6H,MAAM5H,QAAQ4H,MAAMkF,OAAO,GAAG67D,UAAUC,QAAQhhE,MAAMhpB;QAC/H2pF,kBAAkBC,gBAAgB;iBACxBt7D,QAAQ23C;QAClB1M,MAAMivB,WAAWO,IAAIsD,YAAY,GAAG8B,kBAAkBnlE,MAAM7H,OAAO6H,MAAM5H,QAAQ4H,MAAMkF,OAAO,GAAG67D,UAAUC,QAAQhhE,MAAMhpB;QACzH2pF,kBAAkBC,gBAAgB;;;;;;YAM9Bn/D,QAAQ5nB,SAAS,KAAK4mF;mBAChB7mF,IAAI,GAAGksB,KAAKrE,QAAQ5nB,QAAQD,IAAIksB,IAAIlsB;YAC5C0rF,SAAS7jE,QAAQ7nB;YACjB22D,MAAMsrB,WAAWkE,IAAI/D,YAAYpiF,GAAGurF,kBAAkBpE,UAAUC,QAAQsE;;UAGzEhgE,QAAQzD,kBAAkB;UAC1B8+D,kBAAkBC,gBAAgBn/D,QAAQ5nB,SAAS;;UAEnD02D,MAAMsrB,WAAWkE,IAAI/D,YAAY,GAAGmJ,kBAAkBpE,UAAUC,QAAQhhE;UACxE2gE,kBAAkBC,gBAAgB;;;UAIhCmF,4BAA4BzgE,SAASm7D;QACxCC,eAAesD,aAAa1+D,SAAStF,MAAM7H,OAAO6H,MAAM5H;;MAGzDuoE,kBAAkBsC,YAAY39D,QAAQrD;UAClCqD,QAAQpD,UAAUoD,QAAQpD,SAASoD;;IAGxC,2BAA2Bq7D,mBAAmBr7D,SAASy9D;UAClDz9D,QAAQtF,MAAMnmB,WAAW;MAC7B2qF,YAAY7D,mBAAmBr7D;MAC/BirC,MAAM4uB,cAAcY,IAAIb,WAAW6D;MACnCxyB,MAAMirB,YAAYuE,IAAI9D,kBAAkB0E,kBAAkBwB;MAE1DpC,IAAI0E,YAAY1E,IAAI2E,qBAAqBp/D,QAAQvD;MAEjDg+D,IAAI0E,YAAY1E,IAAI4E,gCAAgCr/D,QAAQxD;MAE5Di+D,IAAI0E,YAAY1E,IAAI6E,kBAAkBt/D,QAAQtD;MAE9C+9D,IAAI0E,YAAY1E,IAAI8E,oCAAoC9E,IAAI+E;YAEtDkB,eAAe1gE,YAAYA,QAAQwgE,uBAAuBxgE,QAAQtF,MAAM,GAAG8lE;YAC3EhjE,gBAAgBwC,QAAQtF,MAAM,MAAMsF,QAAQtF,MAAM,GAAG8C;YACrDmjE;eAEGrsF,IAAI,GAAGA,IAAI,GAAGA;aACjBosF,iBAAiBljE;UACrBmjE,UAAUrsF,KAAKqrF,YAAY3/D,QAAQtF,MAAMpmB,IAAI,OAAO,MAAMg+D;;UAE1DquB,UAAUrsF,KAAKkpB,gBAAgBwC,QAAQtF,MAAMpmB,GAAGomB,QAAQsF,QAAQtF,MAAMpmB;;;YAIlEomB,QAAQimE,UAAU,IACrBxF,eAAeuE,eAAehlE,UAAUgiC,UACxC++B,WAAWf,MAAMkF,QAAQ5/D,QAAQjE,SACjC2/D,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB,OAC/BusF,mBAAmBC,kBAAkB9/D,QAAQ5D,gBAAgBq/D,UAAUC;MAC1EqE,qBAAqBtF,IAAI9D,kBAAkB32D,SAASm7D;UAChDh/D;UAEAukE;iBACMpsF,IAAI,GAAGA,IAAI,GAAGA;UACtB6nB,UAAUwkE,UAAUrsF,GAAG6nB;mBAEdsQ,IAAI,GAAGA,IAAItQ,QAAQ5nB,QAAQk4B;kBAC7BuzD,SAAS7jE,QAAQsQ;gBAEnBzM,QAAQjE,WAAW1U,cAAc2Y,QAAQjE,WAAW3U;kBACnDq0E,aAAa;gBAChBxwB,MAAMgvB,qBAAqBQ,IAAI7D,8BAA8BtiF,GAAGm4B,GAAGozD,kBAAkBG,OAAOntE,OAAOmtE,OAAOltE,QAAQ,GAAGktE,OAAOtuF;;gBAE5HyC,QAAQ0B,KAAK;;;cAGdo1D,MAAMsrB,WAAWkE,IAAI7D,8BAA8BtiF,GAAGm4B,GAAGozD,kBAAkBG,OAAOntE,OAAOmtE,OAAOltE,QAAQ,GAAG2oE,UAAUC,QAAQsE,OAAOtuF;;;;QAKvI2pF,kBAAkBC,gBAAgBn/D,QAAQ5nB,SAAS;;QAEnD4nB,UAAU6D,QAAQ7D;iBAET7nB,IAAI,GAAGA,IAAI,GAAGA;cAClBkpB;YACHytC,MAAMsrB,WAAWkE,IAAI7D,8BAA8BtiF,GAAG,GAAGurF,kBAAkBc,UAAUrsF,GAAGue,OAAO8tE,UAAUrsF,GAAGwe,QAAQ,GAAG2oE,UAAUC,QAAQiF,UAAUrsF,GAAG5C;qBAE7I+6B,IAAI,GAAGA,IAAItQ,QAAQ5nB,QAAQk4B;oBAC7BuzD,SAAS7jE,QAAQsQ;oBACjBm0D,cAAcZ,OAAOtlE,MAAMpmB,GAAGomB;cACpCuwC,MAAMsrB,WAAWkE,IAAI7D,8BAA8BtiF,GAAGm4B,IAAI,GAAGozD,kBAAkBe,YAAY/tE,OAAO+tE,YAAY9tE,QAAQ,GAAG2oE,UAAUC,QAAQkF,YAAYlvF;;;YAGxJu5D,MAAMsrB,WAAWkE,IAAI7D,8BAA8BtiF,GAAG,GAAGurF,kBAAkBpE,UAAUC,QAAQiF,UAAUrsF;qBAE9Fm4B,IAAI,GAAGA,IAAItQ,QAAQ5nB,QAAQk4B;oBAC7BuzD,SAAS7jE,QAAQsQ;cACvBw+B,MAAMsrB,WAAWkE,IAAI7D,8BAA8BtiF,GAAGm4B,IAAI,GAAGozD,kBAAkBpE,UAAUC,QAAQsE,OAAOtlE,MAAMpmB;;;;QAKjH+mF,kBAAkBC,gBAAgBn/D,QAAQ5nB;;UAGvCksF,4BAA4BzgE,SAASm7D;;QAExCC,eAAeX,IAAI9D,kBAAkB32D,SAAStF,MAAM7H,OAAO6H,MAAM5H;;MAGlEuoE,kBAAkBsC,YAAY39D,QAAQrD;UAClCqD,QAAQpD,UAAUoD,QAAQpD,SAASoD;;;;IAKxC,iCAAiCg3D,aAAat+B,cAAc14B,SAAS6gE,YAAYC;YAC1ErF,WAAWf,MAAMkF,QAAQ5/D,QAAQjE;YACjC2/D,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB;YAC/BusF,mBAAmBC,kBAAkB9/D,QAAQ5D,gBAAgBq/D,UAAUC;UAEzEoF,kBAAkBrG,IAAIsD,cAAc+C,kBAAkBrG,IAAIqD;QAC7D7yB,MAAMivB,WAAW4G,eAAe,GAAGjB,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC,QAAQ4lC,aAAa94B,OAAO,GAAG67D,UAAUC,QAAQ;;QAEvIzwB,MAAMsrB,WAAWuK,eAAe,GAAGjB,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC,QAAQ,GAAG2oE,UAAUC,QAAQ;;MAGpHzwB,MAAMgsB,gBAAgBwD,IAAIvD,aAAaF;MAEvCyD,IAAIsG,qBAAqBtG,IAAIvD,aAAa2J,YAAYC,eAAe74B,WAAWnK,IAAI99B,SAAS68D,gBAAgB;MAE7G5xB,MAAMgsB,gBAAgBwD,IAAIvD,aAAa;;;IAIxC,kCAAkC8J,cAActoC,cAAcuoC;MAC7DxG,IAAIyG,iBAAiBzG,IAAI0G,cAAcH;UAEnCtoC,aAAaz4B,gBAAgBy4B,aAAax4B;YACzC2/D,mBAAmBpF,IAAI6F;YAEvBW;gBACG9gE,eAAeu4B,aAAav4B;cAE9BA,gBAAgBA,aAAa8/D;gBAC5B9/D,aAAa7sB,SAASuT;cACzBg5E,mBAAmBpF,IAAI0F;uBACbhgE,aAAa7sB,SAASsT;cAChCi5E,mBAAmBpF,IAAI2F;;;gBAInBz/D,UAAUygE,uBAAuB1oC;UAEvC+hC,IAAI4G,+BAA+B5G,IAAI0G,cAAcxgE,SAASk/D,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC;;UAEjH2nE,IAAI6G,oBAAoB7G,IAAI0G,cAActB,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC;;QAG9F2nE,IAAI8G,wBAAwB9G,IAAIvD,aAAauD,IAAI+G,kBAAkB/G,IAAI0G,cAAcH;iBAC3EtoC,aAAaz4B,eAAey4B,aAAax4B;YAC/C+gE;gBACGtgE,UAAUygE,uBAAuB1oC;UAEvC+hC,IAAI4G,+BAA+B5G,IAAI0G,cAAcxgE,SAAS85D,IAAI4F,kBAAkB3nC,aAAa7lC,OAAO6lC,aAAa5lC;;UAErH2nE,IAAI6G,oBAAoB7G,IAAI0G,cAAc1G,IAAI8F,eAAe7nC,aAAa7lC,OAAO6lC,aAAa5lC;;QAG/F2nE,IAAI8G,wBAAwB9G,IAAIvD,aAAauD,IAAIgH,0BAA0BhH,IAAI0G,cAAcH;;;cAGvFhhE,UAAU04B,aAAah4B,iCAAiC,OAAOg4B,aAAa14B,QAAQ,KAAK04B,aAAa14B;cACtGy7D,WAAWf,MAAMkF,QAAQ5/D,QAAQjE;cACjC2/D,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB;cAC/BusF,mBAAmBC,kBAAkB9/D,QAAQ5D,gBAAgBq/D,UAAUC;YAEzEuF;gBACGtgE,UAAUygE,uBAAuB1oC;UAEvC+hC,IAAI4G,+BAA+B5G,IAAI0G,cAAcxgE,SAASk/D,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC;;UAEjH2nE,IAAI6G,oBAAoB7G,IAAI0G,cAActB,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC;;;MAI/F2nE,IAAIyG,iBAAiBzG,IAAI0G,cAAc;;;IAIxC,2BAA2BnK,aAAat+B;YACjCgpC,SAAShpC,gBAAgBA,aAAaC;UACxC+oC,kBAAkBhiF,MAAM;MAC5BurD,MAAMgsB,gBAAgBwD,IAAIvD,aAAaF;YAEjCt+B,aAAav4B,gBAAgBu4B,aAAav4B,aAAa8/D;kBAClDvgF,MAAM;;;WAIZuoD,WAAWnK,IAAIpF,aAAav4B,cAAc08D,kBAAkBnkC,aAAav4B,aAAazF,MAAM7H,UAAU6lC,aAAa7lC,SAAS6lC,aAAav4B,aAAazF,MAAM5H,WAAW4lC,aAAa5lC;QACxL4lC,aAAav4B,aAAazF,MAAM7H,QAAQ6lC,aAAa7lC;QACrD6lC,aAAav4B,aAAazF,MAAM5H,SAAS4lC,aAAa5lC;QACtD4lC,aAAav4B,aAAavC,cAAc;;MAGzC+jE,aAAajpC,aAAav4B,cAAc;YAElCyhE,oBAAoB35B,WAAWnK,IAAIpF,aAAav4B,cAAc08D;UAEhEnkC,aAAav4B,aAAapE,WAAWtU;QACxCgzE,IAAIsG,qBAAqBtG,IAAIvD,aAAauD,IAAI+G,kBAAkB/G,IAAI/D,YAAYkL,mBAAmB;iBACzFlpC,aAAav4B,aAAapE,WAAWrU;QAC/C+yE,IAAIsG,qBAAqBtG,IAAIvD,aAAauD,IAAIgH,0BAA0BhH,IAAI/D,YAAYkL,mBAAmB;;kBAEjGliF,MAAM;;;;IAKlB,gCAAgCg5C;YACzBokC,yBAAyB70B,WAAWnK,IAAIpF;YACxCgpC,SAAShpC,aAAaC,4BAA4B;UAEpDD,aAAav4B;YACZuhE,kBAAkBhiF,MAAM;QAC5BmiF,kBAAkB/E,uBAAuBE,oBAAoBtkC;;YAEzDgpC;UACH5E,uBAAuBG;mBAEd3oF,IAAI,GAAGA,IAAI,GAAGA;YACtB22D,MAAMgsB,gBAAgBwD,IAAIvD,aAAa4F,uBAAuBE,mBAAmB1oF;YACjFwoF,uBAAuBG,mBAAmB3oF,KAAKmmF,IAAIqH;YACnDC,yBAAyBjF,uBAAuBG,mBAAmB3oF,IAAIokD,cAAc;;;UAGtFuS,MAAMgsB,gBAAgBwD,IAAIvD,aAAa4F,uBAAuBE;UAC9DF,uBAAuBG,qBAAqBxC,IAAIqH;UAChDC,yBAAyBjF,uBAAuBG,oBAAoBvkC,cAAc;;;MAIpFuS,MAAMgsB,gBAAgBwD,IAAIvD,aAAa;;;IAIxC,2BAA2Bx+B;YACpB14B,UAAU04B,aAAa14B;YACvB88D,yBAAyB70B,WAAWnK,IAAIpF;YACxC2iC,oBAAoBpzB,WAAWnK,IAAI99B;MACzC04B,aAAaz5C,iBAAiB,WAAWw9E;UAErC/jC,aAAah4B,iCAAiC;QACjD26D,kBAAkBwB,iBAAiBpC,IAAIxE;QACvCoF,kBAAkBsC,YAAY39D,QAAQrD;QACtCi0C,KAAKwE,OAAOl4C;;YAGPwkE,SAAShpC,aAAaC,4BAA4B;YAClDqpC,0BAA0BtpC,aAAah4B,iCAAiC;YACxEugE,gBAAgBvoC,aAAa73B,mCAAmC;YAChEohE,mBAAmBjiE,QAAQ23C,mBAAmB33C,QAAQy3C;YACtD0jB,eAAeuE,eAAehnC,iBAAiBgE;;UAEjDA,YAAY18B,QAAQjE,WAAW3U,cAAc4Y,QAAQ1sB,SAASuT,aAAamZ,QAAQ1sB,SAASwT;QAC/FkZ,QAAQjE,SAAS1U;QACjBlT,QAAQ0B,KAAK;;;UAIV6rF;QACH5E,uBAAuBE;iBAEd1oF,IAAI,GAAGA,IAAI,GAAGA;UACtBwoF,uBAAuBE,mBAAmB1oF,KAAKmmF,IAAIyH;;;QAGpDpF,uBAAuBE,qBAAqBvC,IAAIyH;YAE5CF;cACCvlC,aAAapG;kBACVn5B,WAAWw7B,aAAa14B;qBAErB1rB,IAAI,GAAGksB,KAAKtD,SAAS3oB,QAAQD,IAAIksB,IAAIlsB;oBACvCgpF,uBAAuBr1B,WAAWnK,IAAI5gC,SAAS5oB;kBAEjDgpF,qBAAqBT,mBAAmB3qF;gBAC3CorF,qBAAqBT,iBAAiBpC,IAAIxE;gBAC1CrlB,KAAKwE,OAAOl4C;;;;YAId/oB,QAAQ0B,KAAK;;mBAEJorF;cACNvkC;YACHogC,uBAAuBK,iCAAiC1C,IAAIyH;YAC5DpF,uBAAuBM,2BAA2B3C,IAAIqH;YAEtDrH,IAAIyG,iBAAiBzG,IAAI0G,cAAcrE,uBAAuBM;kBAExD3B,WAAWf,MAAMkF,QAAQ5/D,QAAQjE;kBACjC2/D,SAAShB,MAAMkF,QAAQ5/D,QAAQ1sB;kBAC/BusF,mBAAmBC,kBAAkB9/D,QAAQ5D,gBAAgBq/D,UAAUC;kBACvE/6D,UAAUygE,uBAAuB1oC;YAEvC+hC,IAAI4G,+BAA+B5G,IAAI0G,cAAcxgE,SAASk/D,kBAAkBnnC,aAAa7lC,OAAO6lC,aAAa5lC;YAEjHm4C,MAAMgsB,gBAAgBwD,IAAIvD,aAAa4F,uBAAuBK;YAE9D1C,IAAI8G,wBAAwB9G,IAAIvD,aAAauD,IAAI0H,mBAAmB1H,IAAI0G,cAAcrE,uBAAuBM;YAE7G3C,IAAIyG,iBAAiBzG,IAAI0G,cAAc;gBAEnCzoC,aAAaz4B;cAChB68D,uBAAuBO,2BAA2B5C,IAAIqH;cACtDC,yBAAyBjF,uBAAuBO,0BAA0B3kC,cAAc;;YAGzFuS,MAAMgsB,gBAAgBwD,IAAIvD,aAAa;;YAEvC/iF,QAAQ0B,KAAK;;;;;UAMZ6rF;QACHz2B,MAAMirB,YAAYuE,IAAI9D,kBAAkB0E,kBAAkBwB;QAC1DkD,qBAAqBtF,IAAI9D,kBAAkB32D,SAASm7D;iBAE3C7mF,IAAI,GAAGA,IAAI,GAAGA;UACtB8tF,wBAAwBtF,uBAAuBE,mBAAmB1oF,IAAIokD,cAAc14B,SAASy6D,IAAI0H,mBAAmB1H,IAAI7D,8BAA8BtiF;;YAGnJmsF,4BAA4BzgE,SAASm7D;UACxCC,eAAeX,IAAI9D,kBAAkB32D,SAAS04B,aAAa7lC,OAAO6lC,aAAa5lC;;QAGhFm4C,MAAMirB,YAAYuE,IAAI9D,kBAAkB;iBAC9BqL;cACJ9kE,WAAWw7B,aAAa14B;iBAErB1rB,IAAI,GAAGksB,KAAKtD,SAAS3oB,QAAQD,IAAIksB,IAAIlsB;gBACvCusF,aAAa3jE,SAAS5oB;gBACtBgpF,uBAAuBr1B,WAAWnK,IAAI+iC;UAC5C51B,MAAMirB,YAAYuE,IAAI/D,YAAY4G,qBAAqBT;UACvDkD,qBAAqBtF,IAAI/D,YAAYmK,YAAY1F;UACjDiH,wBAAwBtF,uBAAuBE,oBAAoBtkC,cAAcmoC,YAAYpG,IAAI0H,oBAAoB7tF,GAAGmmF,IAAI/D;cAExH+J,4BAA4BI,YAAY1F;YAC3CC,eAAeX,IAAI/D,YAAYmK,YAAYnoC,aAAa7lC,OAAO6lC,aAAa5lC;;;QAI9Em4C,MAAMirB,YAAYuE,IAAI/D,YAAY;;YAE9B2L,gBAAgB5H,IAAI/D;YAEpBuL;;cAECvlC;kBACG4lC,cAActiE,QAAQ23C;YAC5B0qB,gBAAgBC,cAAc7H,IAAIsD,aAAatD,IAAIqD;;YAEnD3pF,QAAQ0B,KAAK;;;QAIfo1D,MAAMirB,YAAYmM,eAAehH,kBAAkBwB;QACnDkD,qBAAqBsC,eAAeriE,SAASm7D;QAC7CiH,wBAAwBtF,uBAAuBE,oBAAoBtkC,cAAc14B,SAASy6D,IAAI0H,mBAAmBE;YAE7G5B,4BAA4BzgE,SAASm7D;UACxCC,eAAeX,IAAI/D,YAAY12D,SAAS04B,aAAa7lC,OAAO6lC,aAAa5lC;;QAG1Em4C,MAAMirB,YAAYuE,IAAI/D,YAAY;;;UAI/Bh+B,aAAaz4B;QAChBsiE,uBAAuB7pC;;;IAIzB,kCAAkCA;YAC3ByiC,eAAeuE,eAAehnC,iBAAiBgE;YAC/Cx/B,WAAWw7B,aAAah4B,iCAAiC,OAAOg4B,aAAa14B,WAAW04B,aAAa14B;eAElG1rB,IAAI,GAAGksB,KAAKtD,SAAS3oB,QAAQD,IAAIksB,IAAIlsB;cACvC0rB,UAAU9C,SAAS5oB;YAErBmsF,4BAA4BzgE,SAASm7D;gBAClCr9E,SAAS46C,aAAaC,0BAA0B8hC,IAAI9D,mBAAmB8D,IAAI/D;gBAE3EqD,eAAe9xB,WAAWnK,IAAI99B,SAAS68D;UAE7C5xB,MAAMirB,YAAYp4E,QAAQi8E;UAC1BqB,eAAet9E,QAAQkiB,SAAS04B,aAAa7lC,OAAO6lC,aAAa5lC;UACjEm4C,MAAMirB,YAAYp4E,QAAQ;;;;IAK7B,uCAAuC46C;UAClCA,aAAa73B;YACZ67B;gBACG7pC,QAAQ6lC,aAAa7lC;gBACrBC,SAAS4lC,aAAa5lC;cACxB0jB,OAAOikD,IAAI+H;cACX9pC,aAAaz4B,aAAauW,QAAQikD,IAAIgI;cACtC/pC,aAAax4B,eAAesW,QAAQikD,IAAIiI;gBACtC5F,yBAAyB70B,WAAWnK,IAAIpF;UAC9CuS,MAAMgsB,gBAAgBwD,IAAIL,kBAAkB0C,uBAAuBK;UACnElyB,MAAMgsB,gBAAgBwD,IAAItD,kBAAkB2F,uBAAuBE;UAEnEvC,IAAIkI,gBAAgB,GAAG,GAAG9vE,OAAOC,QAAQ,GAAG,GAAGD,OAAOC,QAAQ0jB,MAAMikD,IAAIpE;UAExEprB,MAAMgsB,gBAAgBwD,IAAIL,kBAAkB;UAC5CnvB,MAAMgsB,gBAAgBwD,IAAItD,kBAAkB2F,uBAAuBK;;UAEnEhpF,QAAQ0B,KAAK;;;;IAKhB,gCAAgC6iD;aACxBgE,YAAYhE,aAAa73B,iCAAiCxnB,KAAKD,IAAI85D,YAAYxa,aAAa/3B,WAAW;;IAG/G,4BAA4BX;YACrBk8B,QAAQ0U,KAAKrX,OAAO2C;;UAEtBy+B,eAAe78B,IAAI99B,aAAak8B;QACnCy+B,eAAel6E,IAAIuf,SAASk8B;QAE5Bl8B,QAAQiD;;;;QAKN2/D,kBAAkB;QAClBC,oBAAoB;IAExB,0BAA0B7iE,SAASy9D;UAC9Bz9D,WAAWA,QAAQO;YAClBqiE,oBAAoB;UACvBzuF,QAAQ0B,KAAK;UACb+sF,kBAAkB;;QAGnB5iE,UAAUA,QAAQA;;MAGnB2hE,aAAa3hE,SAASy9D;;IAGvB,4BAA4Bz9D,SAASy9D;UAChCz9D,WAAWA,QAAQ24B;YAClBkqC,sBAAsB;UACzB1uF,QAAQ0B,KAAK;UACbgtF,oBAAoB;;QAGrB7iE,UAAUA,QAAQA;;MAGnB8iE,eAAe9iE,SAASy9D;;;IAIzB,KAAKjlB,sBAAsBA;IAC3B,KAAKuqB,oBAAoBA;IACzB,KAAKpB,eAAeA;IACpB,KAAK1nB,oBAAoBA;IACzB,KAAKF,eAAeA;IACpB,KAAK+oB,iBAAiBA;IACtB,KAAKE,oBAAoBA;IACzB,KAAKC,2BAA2BA;IAChC,KAAKC,gCAAgCA;IACrC,KAAKppB,mBAAmBA;IACxB,KAAKE,qBAAqBA;;EAG3B,oBAAoBxd,IAAItG,YAAYuG;UAC7BC,WAAWD,aAAaC;IAE9B,iBAAiBt4B;UACZ0oC;UACA1oC,MAAM7d,yBAAyBi2C,GAAGgB;UAClCp5B,MAAMrd,8BAA8By1C,GAAG2mC;UACvC/+D,MAAMpd,8BAA8Bw1C,GAAG4mC;UACvCh/D,MAAMnd,6BAA6Bu1C,GAAG6mC;UACtCj/D,MAAM5d,iBAAiBg2C,GAAGe;UAC1Bn5B,MAAM3d,kBAAkB+1C,GAAGY;UAC3Bh5B,MAAM1d,0BAA0B81C,GAAGW;UACnC/4B,MAAMzd,gBAAgB61C,GAAGc;UACzBl5B,MAAMxd,wBAAwB41C,GAAGa;UACjCj5B,MAAMvd,kBAAkB21C,GAAGS;UAE3B74B,MAAMtd;YACL41C,iBAAiBF,GAAGU;QACxB4P,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;iBACVA,UAAUw2B;;iBAEV;;;UAILl/D,MAAMjd,oBAAoBq1C,GAAG+mC;UAC7Bn/D,MAAMhd,kBAAkBo1C,GAAGu/B;UAC3B33D,MAAM/c,mBAAmBm1C,GAAGg6B;UAC5BpyD,MAAM9c,wBAAwBk1C,GAAGgnC;UACjCp/D,MAAM7c,6BAA6Bi1C,GAAGinC;UACtCr/D,MAAM3c,oBAAoB+0C,GAAG0jC;UAC7B97D,MAAM1c,2BAA2B80C,GAAG+jC;UACpCn8D,MAAMzc,kBAAkB60C,GAAGm/B;;UAE3Bv3D,MAAMxc,yBAAyB40C,GAAGknC;UAClCt/D,MAAMvc,iBAAiB20C,GAAGmnC;UAC1Bv/D,MAAMtc,wBAAwB00C,GAAGonC;UACjCx/D,MAAMrc,yBAAyBy0C,GAAGqnC;UAClCz/D,MAAMpc,0BAA0Bw0C,GAAGsnC;UAEnC1/D,MAAMnc,wBAAwBmc,MAAMlc,yBAAyBkc,MAAMjc,yBAAyBic,MAAMhc;QACrG0kD,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;cACb1oC,MAAMnc,6BAA6B6kD,UAAUi3B;cAC7C3/D,MAAMlc,8BAA8B4kD,UAAUk3B;cAC9C5/D,MAAMjc,8BAA8B2kD,UAAUm3B;cAC9C7/D,MAAMhc,8BAA8B0kD,UAAUo3B;;iBAE3C;;;UAIL9/D,MAAM/b,2BAA2B+b,MAAM9b,2BAA2B8b,MAAM7b,4BAA4B6b,MAAM5b;QAC7GskD,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;cACb1oC,MAAM/b,gCAAgCykD,UAAUq3B;cAChD//D,MAAM9b,gCAAgCwkD,UAAUs3B;cAChDhgE,MAAM7b,iCAAiCukD,UAAUu3B;cACjDjgE,MAAM5b,iCAAiCskD,UAAUw3B;;iBAE9C;;;UAILlgE,MAAM3b;QACTqkD,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;iBACVA,UAAUy3B;;iBAEV;;;UAILngE,MAAM1b,mBAAmB0b,MAAMzb;QAClCmkD,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;cACb1oC,MAAM1b,wBAAwBokD,UAAU03B;cACxCpgE,MAAMzb,6BAA6BmkD,UAAU23B;;;UAI/CrgE,MAAMxb,wBAAwBwb,MAAMvb,wBAAwBub,MAAMtb,wBAAwBsb,MAAMrb,wBAAwBqb,MAAMpb,wBAAwBob,MAAMnb,wBAAwBmb,MAAMlb,wBAAwBkb,MAAMjb,wBAAwBib,MAAMhb,yBAAyBgb,MAAM/a,yBAAyB+a,MAAM9a,yBAAyB8a,MAAM7a,0BAA0B6a,MAAM5a,0BAA0B4a,MAAM3a,0BAA0B2a,MAAMza,gCAAgCya,MAAMxa,gCAAgCwa,MAAMva,gCAAgCua,MAAMta,gCAAgCsa,MAAMra,gCAAgCqa,MAAMpa,gCAAgCoa,MAAMna,gCAAgCma,MAAMla,gCAAgCka,MAAMja,iCAAiCia,MAAMha,iCAAiCga,MAAM/Z,iCAAiC+Z,MAAM9Z,kCAAkC8Z,MAAM7Z,kCAAkC6Z,MAAM5Z;QAC36BsiD,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;;iBAEV1oC;;iBAEA;;;UAILA,MAAM1a;QACTojD,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;;iBAEV1oC;;iBAEA;;;UAILA,MAAMld;YACLw1C,iBAAiBF,GAAGkoC;QACxB53B,YAAY5W,WAAW4H,IAAI;YAEvBgP,cAAc;iBACVA,UAAU63B;;iBAEV;;;;;MAMT/E,SAASA;;;EAIX,0BAA0BpnC;IACzB9+C,YAAY6U;MACX;MACA,KAAKq2E,UAAUr2E;;;EAKjBs2E,YAAY5uE,UAAU6uE,gBAAgB;EAEtC,oBAAoBjtD;IACnBn+B;MACC;MACA,KAAKpG,OAAO;;;EAKdmJ,MAAMwZ,UAAU8uE,UAAU;QAEpBC;IACL1xF,MAAM;;EAGP;IACCoG;MACC,KAAKurF,aAAa;MAClB,KAAKC,QAAQ;MACb,KAAKC,QAAQ;;IAGdC;UACK,KAAKD,UAAU;QAClB,KAAKA,YAAY1oF;QACjB,KAAK0oF,MAAM7oE,mBAAmB;QAC9B,KAAK6oE,MAAM1sD,UAAU;QACrB,KAAK0sD,MAAME;QACX,KAAKF,MAAMG;UACVC,UAAU;;;aAIL,KAAKJ;;IAGbK;UACK,KAAKP,eAAe;QACvB,KAAKA,iBAAiBxoF;QACtB,KAAKwoF,WAAW3oE,mBAAmB;QACnC,KAAK2oE,WAAWxsD,UAAU;QAC1B,KAAKwsD,WAAWQ,oBAAoB;QACpC,KAAKR,WAAWS,qBAAqB5rF;QACrC,KAAKmrF,WAAWU,qBAAqB;QACrC,KAAKV,WAAWW,sBAAsB9rF;;aAGhC,KAAKmrF;;IAGbY;UACK,KAAKX,UAAU;QAClB,KAAKA,YAAYzoF;QACjB,KAAKyoF,MAAM5oE,mBAAmB;QAC9B,KAAK4oE,MAAMzsD,UAAU;QACrB,KAAKysD,MAAMO,oBAAoB;QAC/B,KAAKP,MAAMQ,qBAAqB5rF;QAChC,KAAKorF,MAAMS,qBAAqB;QAChC,KAAKT,MAAMU,sBAAsB9rF;;aAG3B,KAAKorF;;IAGb52E,cAAcnb;UACT,KAAK8xF,eAAe;QACvB,KAAKA,WAAW32E,cAAcnb;;UAG3B,KAAK+xF,UAAU;QAClB,KAAKA,MAAM52E,cAAcnb;;UAGtB,KAAKgyF,UAAU;QAClB,KAAKA,MAAM72E,cAAcnb;;aAGnB;;IAGR2yF,WAAWC;MACV,KAAKz3E;QACJhb,MAAM;QACN5B,MAAMq0F;;UAGH,KAAKd,eAAe;QACvB,KAAKA,WAAWxsD,UAAU;;UAGvB,KAAKysD,UAAU;QAClB,KAAKA,MAAMzsD,UAAU;;UAGlB,KAAK0sD,UAAU;QAClB,KAAKA,MAAM1sD,UAAU;;aAGf;;IAGRxV,OAAO8iE,aAAa7pC,OAAO8pC;UACtBC,YAAY;UACZC,WAAW;UACXC,WAAW;YACTC,YAAY,KAAKnB;YACjBoB,OAAO,KAAKnB;YACZoB,OAAO,KAAKnB;UAEdY,eAAe7pC,MAAM2P,QAAQ06B,oBAAoB;YAChDH,cAAc;UACjBH,YAAY/pC,MAAMsqC,QAAQT,YAAYU,gBAAgBT;cAElDC,cAAc;YACjBG,UAAU/rE,OAAO9E,UAAU0wE,UAAUS,UAAUrsE;YAC/C+rE,UAAU/rE,OAAOya,UAAUsxD,UAAUnrF,UAAUmrF,UAAUlpF,UAAUkpF,UAAUlsE;gBAEzE+rE,UAAUP;cACbU,UAAUX,oBAAoB;cAC9BW,UAAUV,eAAeryE,KAAK4yE,UAAUP;;cAExCU,UAAUX,oBAAoB;;gBAG3BQ,UAAUL;cACbQ,UAAUT,qBAAqB;cAC/BS,UAAUR,gBAAgBvyE,KAAK4yE,UAAUL;;cAEzCQ,UAAUT,qBAAqB;;YAGhC,KAAKr3E,cAAc02E;;;YAIjBsB,QAAQP,YAAYO;UACvBH,WAAW;qBAEAQ,cAAcZ,YAAYO,KAAK1pD;;kBAEnCgqD,YAAY1qC,MAAM2qC,aAAaF,YAAYX;gBAE7CM,KAAKjB,OAAOsB,WAAWG,eAAe50F;;oBAEnC60F,YAAYtqF;cAClBsqF,MAAMzqE,mBAAmB;cACzByqE,MAAMtuD,UAAU;cAChB6tD,KAAKjB,OAAOsB,WAAWG,aAAaC;;cAEpCT,KAAK3qF,IAAIorF;;kBAGJA,QAAQT,KAAKjB,OAAOsB,WAAWG;gBAEjCF,cAAc;cACjBG,MAAM1sE,OAAO9E,UAAUqxE,UAAUF,UAAUrsE;cAC3C0sE,MAAM1sE,OAAOya,UAAUiyD,MAAM9rF,UAAU8rF,MAAM7pF,UAAU6pF,MAAM7sE;cAC7D6sE,MAAMC,cAAcJ,UAAU9rF;;YAG/BisF,MAAMtuD,UAAUmuD,cAAc;;;;gBAKzBK,WAAWX,KAAKjB,OAAO;gBACvB6B,WAAWZ,KAAKjB,OAAO;gBACvBjnF,WAAW6oF,SAAShsF,SAASuC,WAAW0pF,SAASjsF;gBACjDksF,kBAAkB;gBAClBC,YAAY;cAEdd,KAAKhB,WAAWC,YAAYnnF,WAAW+oF,kBAAkBC;YAC5Dd,KAAKhB,WAAWC,WAAW;YAC3B,KAAKj3E;cACJhb,MAAM;cACN+zF,YAAYtB,YAAYsB;cACxBvpF,QAAQ;;sBAEEwoF,KAAKhB,WAAWC,YAAYnnF,YAAY+oF,kBAAkBC;YACrEd,KAAKhB,WAAWC,WAAW;YAC3B,KAAKj3E;cACJhb,MAAM;cACN+zF,YAAYtB,YAAYsB;cACxBvpF,QAAQ;;;;cAINuoF,SAAS,QAAQN,YAAYuB;YAChCpB,WAAWhqC,MAAMsqC,QAAQT,YAAYuB,WAAWtB;gBAE5CE,aAAa;cAChBG,KAAKhsE,OAAO9E,UAAU2wE,SAASQ,UAAUrsE;cACzCgsE,KAAKhsE,OAAOya,UAAUuxD,KAAKprF,UAAUorF,KAAKnpF,UAAUmpF,KAAKnsE;kBAErDgsE,SAASR;gBACZW,KAAKZ,oBAAoB;gBACzBY,KAAKX,eAAeryE,KAAK6yE,SAASR;;gBAElCW,KAAKZ,oBAAoB;;kBAGtBS,SAASN;gBACZS,KAAKV,qBAAqB;gBAC1BU,KAAKT,gBAAgBvyE,KAAK6yE,SAASN;;gBAEnCS,KAAKV,qBAAqB;;;;;;UAO3BS,cAAc;QACjBA,UAAU3tD,UAAUwtD,cAAc;;UAG/BI,SAAS;QACZA,KAAK5tD,UAAUytD,aAAa;;UAGzBI,SAAS;QACZA,KAAK7tD,UAAU0tD,aAAa;;aAGtB;;;EAKT,2BAA2B7qE;IAC1B5hB,YAAYwG,UAAUs8C;MACrB;YACMrI,QAAQ;YACR8W,QAAQ/qD,SAAS+qD;UACnBY,UAAU;UACV07B,yBAAyB;UACzBvB,iBAAiB;UACjBwB,qBAAqB;UACrBC,OAAO;YACLC;YACAC,sBAAsBC;;YAEtBC,cAAcrvC;MACpBqvC,QAAQ9wD,OAAOL,OAAO;MACtBmxD,QAAQ9nE,eAAeL;YACjBooE,cAActvC;MACpBsvC,QAAQ/wD,OAAOL,OAAO;MACtBoxD,QAAQ/nE,eAAeL;YACjBklE,WAAWiD,SAASC;YACpBC,eAAelD;MACrBkD,SAAShxD,OAAOL,OAAO;MACvBqxD,SAAShxD,OAAOL,OAAO;UACnBsxD,oBAAoB;UACpBC,mBAAmB;;MAEvB,KAAKC,mBAAmB;MACxB,KAAK/vC,UAAU;MACf,KAAKgwC,eAAe;MAEpB,KAAKC,gBAAgB,UAAUh6E;YAC1Bi6E,aAAaX,YAAYt5E;YAEzBi6E,eAAen2F;UAClBm2F,iBAAiBC;UACjBZ,YAAYt5E,SAASi6E;;eAGfA,WAAW7C;;MAGnB,KAAK+C,oBAAoB,UAAUn6E;YAC9Bi6E,aAAaX,YAAYt5E;YAEzBi6E,eAAen2F;UAClBm2F,iBAAiBC;UACjBZ,YAAYt5E,SAASi6E;;eAGfA,WAAWxC;;MAGnB,KAAK2C,UAAU,UAAUp6E;YACpBi6E,aAAaX,YAAYt5E;YAEzBi6E,eAAen2F;UAClBm2F,iBAAiBC;UACjBZ,YAAYt5E,SAASi6E;;eAGfA,WAAWjD;;;MAInB,wBAAwBjyF;cACjBk1F,aAAaV,gBAAgB7pC,IAAI3qD,MAAM4yF;YAEzCsC;UACHA,WAAW/5E;YACVhb,MAAMH,MAAMG;YACZ5B,MAAMyB,MAAM4yF;;;;MAKf;QACC4B,gBAAgB9zF,QAAQ,UAAUw0F,YAAYtC;UAC7CsC,WAAWvC,WAAWC;;QAEvB4B,gBAAgBvzF;QAChB4zF,oBAAoB;QACpBC,mBAAmB;;QAEnBh9B,MAAMovB,kBAAkB;QACxBn6E,SAASo5C,gBAAgBp5C,SAASm5C;;QAElC3c,UAAU2f;QACVlI,MAAMg0C,eAAe;QACrBh0C,MAAM7lC;UACLhb,MAAM;;;MAIR,KAAKm1F,4BAA4B,UAAUtpF;QAC1CooF,yBAAyBpoF;YAErBg1C,MAAMg0C,iBAAiB;UAC1Bh0F,QAAQ0B,KAAK;;;MAIf,KAAK6yF,wBAAwB,UAAUvpF;QACtCqoF,qBAAqBroF;YAEjBg1C,MAAMg0C,iBAAiB;UAC1Bh0F,QAAQ0B,KAAK;;;MAIf,KAAK8yF,oBAAoB;eACjB3C;;MAGR,KAAKl6B,aAAa;eACVD;;MAGR,KAAK+8B,aAAa,gBAAgBzpF;QACjC0sD,UAAU1sD;YAEN0sD,YAAY;UACfA,QAAQ5sD,iBAAiB,UAAU4pF;UACnCh9B,QAAQ5sD,iBAAiB,eAAe4pF;UACxCh9B,QAAQ5sD,iBAAiB,aAAa4pF;UACtCh9B,QAAQ5sD,iBAAiB,WAAW4pF;UACpCh9B,QAAQ5sD,iBAAiB,gBAAgB4pF;UACzCh9B,QAAQ5sD,iBAAiB,cAAc4pF;UACvCh9B,QAAQ5sD,iBAAiB,OAAO6pF;UAChCj9B,QAAQ5sD,iBAAiB,sBAAsB8pF;gBACzC/7C,aAAawP,GAAGwsC;cAElBh8C,WAAWi8C,iBAAiB;YAC/B,MAAMzsC,GAAG0sC;;gBAGJC;YACLC,WAAWp8C,WAAWo8C;YACtBl0E,OAAO83B,WAAW93B;YAClB0K,OAAOotB,WAAWptB;YAClBs6B,SAASlN,WAAWkN;YACpBqtC,wBAAwBA;;;gBAGnB8B,gBAAgBC,aAAaz9B,SAASrP,IAAI2sC;UAChDt9B,QAAQ09B;YACPF,WAAWA;;UAEZrD,iBAAiB,MAAMn6B,QAAQ29B,sBAAsBhC;UACrD9qD,UAAU6f,WAAWsP;UACrBnvB,UAAUiB;UACVwW,MAAMg0C,eAAe;UACrBh0C,MAAM7lC;YACLhb,MAAM;;;;MAKT,8BAA8BH;cACvBs2F,eAAe59B,QAAQ49B;;iBAEpBn1F,IAAI,GAAGA,IAAIozF,YAAYnzF,QAAQD;UACvCqzF,gBAAgBlnF,IAAIgpF,aAAan1F,IAAIozF,YAAYpzF;;;iBAIzCA,IAAI,GAAGA,IAAInB,MAAMu2F,QAAQn1F,QAAQD;gBACnCyxF,cAAc5yF,MAAMu2F,QAAQp1F;gBAC5B+zF,aAAaV,gBAAgB7pC,IAAIioC;cAEnCsC;YACHA,WAAW/5E;cACVhb,MAAM;cACN5B,MAAMq0F;;YAEP4B,gBAAgB3pC,OAAO+nC;;;;iBAKhBzxF,IAAI,GAAGA,IAAInB,MAAMw2F,MAAMp1F,QAAQD;gBACjCyxF,cAAc5yF,MAAMw2F,MAAMr1F;gBAC1B+zF,aAAaV,gBAAgB7pC,IAAIioC;cAEnCsC;YACHA,WAAW/5E;cACVhb,MAAM;cACN5B,MAAMq0F;;;;;;YAOJ6D,iBAAiB9vF;YACjB+vF,iBAAiB/vF;;;;;;;MAQvB,gCAAgCysB,QAAQshE,SAASC;QAChD8B,WAAW1hE,sBAAsB2/D,QAAQjhE;QACzCijE,WAAW3hE,sBAAsB4/D,QAAQlhE;cACnCkjE,MAAMF,WAAWpsF,WAAWqsF;cAC5BE,QAAQlC,QAAQphE,iBAAiB1S;cACjCi2E,QAAQlC,QAAQrhE,iBAAiB1S;;;;cAIjCyhB,OAAOu0D,MAAM,OAAOA,MAAM,MAAM;cAChCt0D,MAAMs0D,MAAM,OAAOA,MAAM,MAAM;cAC/BE,UAAUF,MAAM,KAAK,KAAKA,MAAM;cAChCG,aAAaH,MAAM,KAAK,KAAKA,MAAM;cACnCI,WAAWJ,MAAM,KAAK,KAAKA,MAAM;cACjCK,YAAYJ,MAAM,KAAK,KAAKA,MAAM;cAClC50D,OAAOI,OAAO20D;cACd90D,QAAQG,OAAO40D;;;cAGfC,UAAUP,QAAQK,UAAUC;cAC5BE,UAAUD,WAAWF;;QAE3BtC,QAAQjhE,YAAYkO,UAAUvO,OAAOtrB,UAAUsrB,OAAOzD,YAAYyD,OAAOrM;QACzEqM,OAAOoT,WAAW2wD;QAClB/jE,OAAOsT,WAAWwwD;QAClB9jE,OAAOK,YAAY0L,QAAQ/L,OAAOtrB,UAAUsrB,OAAOzD,YAAYyD,OAAOrM;QACtEqM,OAAOC,mBAAmBnT,KAAKkT,OAAOK,aAAa7N;;;;cAI7CwxE,QAAQ/0D,OAAO60D;cACfG,OAAO/0D,MAAM40D;cACbI,QAAQr1D,OAAOk1D;cACfI,SAASr1D,SAASy0D,MAAMQ;cACxBK,OAAOV,SAASx0D,MAAM+0D,OAAOD;cAC7BK,UAAUV,YAAYz0D,MAAM+0D,OAAOD;QACzChkE,OAAOE,iBAAiB0O,gBAAgBs1D,OAAOC,QAAQC,MAAMC,SAASL,OAAOC;;MAG9E,sBAAsBjkE,QAAQ5zB;YACzBA,WAAW;UACd4zB,OAAOK,YAAYvT,KAAKkT,OAAOlM;;UAE/BkM,OAAOK,YAAYtP,iBAAiB3kB,OAAOi0B,aAAaL,OAAOlM;;QAGhEkM,OAAOC,mBAAmBnT,KAAKkT,OAAOK,aAAa7N;;MAGpD,KAAK8xE,eAAe,UAAUtkE;YACzBslC,YAAY;QAChBk8B,SAASvyD,OAAOsyD,QAAQtyD,OAAOqyD,QAAQryD,OAAOjP,OAAOiP;QACrDuyD,SAAStyD,MAAMqyD,QAAQryD,MAAMoyD,QAAQpyD,MAAMlP,OAAOkP;YAE9CuyD,sBAAsBD,SAASvyD,QAAQyyD,qBAAqBF,SAAStyD;;UAExEo2B,QAAQ09B;YACPuB,WAAW/C,SAASvyD;YACpBu1D,UAAUhD,SAAStyD;;UAEpBuyD,oBAAoBD,SAASvyD;UAC7ByyD,mBAAmBF,SAAStyD;;cAGvB9iC,SAAS4zB,OAAO5zB;cAChBiyF,UAAUmD,SAASnD;QACzBiG,aAAa9C,UAAUp1F;iBAEd2B,IAAI,GAAGA,IAAIswF,QAAQrwF,QAAQD;UACnCu2F,aAAajG,QAAQtwF,IAAI3B;;;QAI1B4zB,OAAOK,YAAYvT,KAAK00E,SAASnhE;QACjCL,OAAOlM,OAAOhH,KAAK00E,SAAS1tE;QAC5BkM,OAAOlM,OAAOya,UAAUvO,OAAOtrB,UAAUsrB,OAAOzD,YAAYyD,OAAOrM;cAC7DqQ,WAAWhE,OAAOgE;iBAEfj2B,IAAI,GAAGma,IAAI8b,SAASh2B,QAAQD,IAAIma,GAAGna;UAC3Ci2B,SAASj2B,GAAG2mC,kBAAkB;;;YAI3B2pD,QAAQrwF,WAAW;UACtBy2F,uBAAuBjD,UAAUF,SAASC;;;UAG1CC,SAASthE,iBAAiBpT,KAAKw0E,QAAQphE;;;MAIzC,KAAKwkE,YAAY;eACTlD;;;UAIJmD,2BAA2B;MAE/B,0BAA0B1vF,MAAM0gD;QAC/BurC,OAAOvrC,MAAMivC,cAAcnF;YAEvByB,SAAS;gBACN2D,QAAQ3D,KAAK2D;gBACb/B,YAAYx9B,QAAQ4hB,YAAY4b;UACtCp+B,MAAMovB,kBAAkBgP,UAAUrS;cAC9BqU,sBAAsB;;cAEtBD,MAAM72F,WAAWwzF,SAASnD,QAAQrwF;YACrCwzF,SAASnD,QAAQrwF,SAAS;YAC1B82F,sBAAsB;;mBAGd/2F,IAAI,GAAGA,IAAI82F,MAAM72F,QAAQD;kBAC3B6iD,OAAOi0C,MAAM92F;kBACbyrB,WAAWspE,UAAUhZ,YAAYl5B;kBACjC5wB,SAASq+D,QAAQtwF;YACvBiyB,OAAOlM,OAAO9E,UAAU4hC,KAAKuvC,UAAUrsE;YACvCkM,OAAOE,iBAAiBlR,UAAU4hC,KAAK1wB;YACvCF,OAAOxG,SAAStf,IAAIsf,SAAS7kB,GAAG6kB,SAAS1kB,GAAG0kB,SAASlN,OAAOkN,SAASjN;gBAEjExe,MAAM;cACTyzF,SAAS1tE,OAAOhH,KAAKkT,OAAOlM;;gBAGzBgxE,wBAAwB;cAC3BtD,SAASnD,QAAQ5yF,KAAKu0B;;;;;cAMnBkjE,eAAe59B,QAAQ49B;iBAEpBn1F,IAAI,GAAGA,IAAIozF,YAAYnzF,QAAQD;gBACjC+zF,aAAaX,YAAYpzF;gBACzByxF,cAAc0D,aAAan1F;UACjC+zF,WAAWplE,OAAO8iE,aAAa7pC,OAAO8pC;;YAGnCkF,0BAA0BA,yBAAyB1vF,MAAM0gD;;YAGxDxf,gBAAgB4uD;MACtB5uD,UAAUv8B,iBAAiBi8C;MAE3B,KAAKj8C,mBAAmB,UAAUklB;QACjC6lE,2BAA2B7lE;;MAG5B,KAAKpzB,UAAU;;;EAKjB,wBAAwBg2D;IACvB,4BAA4B3S,UAAU50C;MACrC40C,SAASuS,SAAS1oD,MAAMkU,KAAK3S,IAAIhG;UAE7BgG,IAAI6qF;QACPj2C,SAASqS,QAAQxoD,QAAQuB,IAAI80B;QAC7B8f,SAASsS,OAAOzoD,QAAQuB,IAAI+0B;iBAClB/0B,IAAIynE;QACd7yB,SAASoS,WAAWvoD,QAAQuB,IAAI8qF;;;IAIlC,iCAAiCl2C,UAAU96C,UAAUixF,YAAY34E,QAAQ44E;UACpElxF,SAAS4vC;QACZuhD,sBAAsBr2C,UAAU96C;iBACtBA,SAASoxF;QACnBD,sBAAsBr2C,UAAU96C;QAChCqxF,uBAAuBv2C,UAAU96C;iBACvBA,SAASsxF;QACnBH,sBAAsBr2C,UAAU96C;QAChCuxF,oBAAoBz2C,UAAU96C;iBACpBA,SAASwxF;QACnBL,sBAAsBr2C,UAAU96C;QAChCyxF,qBAAqB32C,UAAU96C;iBACrBA,SAASwtE;QACnB2jB,sBAAsBr2C,UAAU96C;YAE5BA,SAAS0xF;UACZC,wBAAwB72C,UAAU96C,UAAUkxF;;UAE5CU,wBAAwB92C,UAAU96C;;iBAEzBA,SAAS6xF;QACnBV,sBAAsBr2C,UAAU96C;QAChC8xF,sBAAsBh3C,UAAU96C;iBACtBA,SAASmzE;QACnBge,sBAAsBr2C,UAAU96C;QAChC+xF,qBAAqBj3C,UAAU96C;iBACrBA,SAASozE;QACnB+d,sBAAsBr2C,UAAU96C;QAChCgyF,wBAAwBl3C,UAAU96C;iBACxBA,SAASiyF;QACnBd,sBAAsBr2C,UAAU96C;QAChCkyF,sBAAsBp3C,UAAU96C;iBACtBA,SAASmyF;QACnBC,oBAAoBt3C,UAAU96C;YAE1BA,SAASqyF;UACZC,oBAAoBx3C,UAAU96C;;iBAErBA,SAASuyF;QACnBC,sBAAsB13C,UAAU96C,UAAUixF,YAAY34E;iBAC5CtY,SAASyyF;QACnBC,uBAAuB53C,UAAU96C;iBACvBA,SAAS2yF;QACnB73C,SAAS56C,MAAMyE,MAAMkU,KAAK7Y,SAASE;QACnC46C,SAASpU,QAAQ/hC,QAAQ3E,SAAS0mC;iBACxB1mC,SAASq8C;QACnBr8C,SAASi8C,qBAAqB;;;IAIhC,+BAA+BnB,UAAU96C;MACxC86C,SAASpU,QAAQ/hC,QAAQ3E,SAAS0mC;UAE9B1mC,SAASE;QACZ46C,SAASoR,QAAQvnD,MAAMkU,KAAK7Y,SAASE;;UAGlCF,SAASwpC;QACZsR,SAAStR,SAAS7kC,MAAMkU,KAAK7Y,SAASwpC,UAAUtoC,eAAelB,SAASypC;;UAGrEzpC,SAASpE;QACZk/C,SAASl/C,IAAI+I,QAAQ3E,SAASpE;;UAG3BoE,SAASmqC;QACZ2Q,SAAS3Q,SAASxlC,QAAQ3E,SAASmqC;;UAGhCnqC,SAASmrC;QACZ2P,SAAS3P,YAAYxmC,QAAQ3E,SAASmrC;;YAGjCC,SAASqiB,WAAWnK,IAAItjD,UAAUorC;UAEpCA;QACH0P,SAAS1P,OAAOzmC,QAAQymC;QACxB0P,SAASyR,WAAW5nD,QAAQymC,OAAO8T,iBAAiB9T,OAAO4T,oBAAoB,IAAI;QACnFlE,SAASvP,aAAa5mC,QAAQ3E,SAASurC;QACvCuP,SAAStP,gBAAgB7mC,QAAQ3E,SAASwrC;cAEpCghB,cAAciB,WAAWnK,IAAIlY,QAAQ01C;YAEvCt0B,gBAAgB90D;UACnBojD,SAAS0R,YAAY7nD,QAAQ6nD;;;UAI3BxsD,SAASoqC;QACZ0Q,SAAS1Q,SAASzlC,QAAQ3E,SAASoqC;QACnC0Q,SAASzQ,kBAAkB1lC,QAAQ3E,SAASqqC;;UAGzCrqC,SAASsqC;QACZwQ,SAASxQ,MAAM3lC,QAAQ3E,SAASsqC;QAChCwQ,SAASvQ,eAAe5lC,QAAQ3E,SAASuqC;;;;;;;;;;;;;;;UAgBtCqoD;UAEA5yF,SAASpE;QACZg3F,aAAa5yF,SAASpE;iBACZoE,SAASmrC;QACnBynD,aAAa5yF,SAASmrC;iBACZnrC,SAAS6qC;QACnB+nD,aAAa5yF,SAAS6qC;iBACZ7qC,SAAS0qC;QACnBkoD,aAAa5yF,SAAS0qC;iBACZ1qC,SAASwqC;QACnBooD,aAAa5yF,SAASwqC;iBACZxqC,SAASgrC;QACnB4nD,aAAa5yF,SAASgrC;iBACZhrC,SAASirC;QACnB2nD,aAAa5yF,SAASirC;iBACZjrC,SAASmqC;QACnByoD,aAAa5yF,SAASmqC;iBACZnqC,SAASkrC;QACnB0nD,aAAa5yF,SAASkrC;iBACZlrC,SAAS8pC;QACnB8oD,aAAa5yF,SAAS8pC;iBACZ9pC,SAASgqC;QACnB4oD,aAAa5yF,SAASgqC;iBACZhqC,SAAS+pC;QACnB6oD,aAAa5yF,SAAS+pC;;UAGnB6oD,eAAel7F;;YAEdk7F,WAAW7sE;UACd6sE,aAAaA,WAAWptE;;YAGrBotE,WAAW9wE,qBAAqB;UACnC8wE,WAAWvwE;;QAGZy4B,SAASqR,YAAYxnD,MAAMkU,KAAK+5E,WAAW/yE;;;;;UAMxCgzE;UAEA7yF,SAASsqC;QACZuoD,cAAc7yF,SAASsqC;iBACbtqC,SAASoqC;QACnByoD,cAAc7yF,SAASoqC;;UAGpByoD,gBAAgBn7F;;YAEfm7F,YAAY9sE;UACf8sE,cAAcA,YAAYrtE;;YAGvBqtE,YAAY/wE,qBAAqB;UACpC+wE,YAAYxwE;;QAGby4B,SAASsR,aAAaznD,MAAMkU,KAAKg6E,YAAYhzE;;;IAI/C,6BAA6Bi7B,UAAU96C;MACtC86C,SAASoR,QAAQvnD,MAAMkU,KAAK7Y,SAASE;MACrC46C,SAASpU,QAAQ/hC,QAAQ3E,SAAS0mC;;IAGnC,6BAA6BoU,UAAU96C;MACtC86C,SAAS5O,SAASvnC,QAAQ3E,SAASksC;MACnC4O,SAAS6U,UAAUhrD,QAAQ3E,SAASksC,WAAWlsC,SAASmsC;MACxD2O,SAASp7B,MAAM/a,QAAQ3E,SAAS0f;;IAGjC,+BAA+Bo7B,UAAU96C,UAAUixF,YAAY34E;MAC9DwiC,SAASoR,QAAQvnD,MAAMkU,KAAK7Y,SAASE;MACrC46C,SAASpU,QAAQ/hC,QAAQ3E,SAAS0mC;MAClCoU,SAAS72C,KAAKU,QAAQ3E,SAASiE,OAAOgtF;MACtCn2C,SAASp7B,MAAM/a,QAAQ2T,SAAS;UAE5BtY,SAASpE;QACZk/C,SAASl/C,IAAI+I,QAAQ3E,SAASpE;;UAG3BoE,SAASmqC;QACZ2Q,SAAS3Q,SAASxlC,QAAQ3E,SAASmqC;;;;;UAMhCyoD;UAEA5yF,SAASpE;QACZg3F,aAAa5yF,SAASpE;iBACZoE,SAASmqC;QACnByoD,aAAa5yF,SAASmqC;;UAGnByoD,eAAel7F;YACdk7F,WAAW9wE,qBAAqB;UACnC8wE,WAAWvwE;;QAGZy4B,SAASqR,YAAYxnD,MAAMkU,KAAK+5E,WAAW/yE;;;IAI7C,gCAAgCi7B,UAAU96C;MACzC86C,SAASoR,QAAQvnD,MAAMkU,KAAK7Y,SAASE;MACrC46C,SAASpU,QAAQ/hC,QAAQ3E,SAAS0mC;MAClCoU,SAASp4C,SAASiC,QAAQ3E,SAAS0C;UAE/B1C,SAASpE;QACZk/C,SAASl/C,IAAI+I,QAAQ3E,SAASpE;;UAG3BoE,SAASmqC;QACZ2Q,SAAS3Q,SAASxlC,QAAQ3E,SAASmqC;;;;;UAMhCyoD;UAEA5yF,SAASpE;QACZg3F,aAAa5yF,SAASpE;iBACZoE,SAASmqC;QACnByoD,aAAa5yF,SAASmqC;;UAGnByoD,eAAel7F;YACdk7F,WAAW9wE,qBAAqB;UACnC8wE,WAAWvwE;;QAGZy4B,SAASqR,YAAYxnD,MAAMkU,KAAK+5E,WAAW/yE;;;IAI7C,gCAAgCi7B,UAAU96C;UACrCA,SAASkrC;QACZ4P,SAAS5P,YAAYvmC,QAAQ3E,SAASkrC;;;IAIxC,8BAA8B4P,UAAU96C;MACvC86C,SAASpR,SAAS/kC,MAAMkU,KAAK7Y,SAAS0pC;MACtCoR,SAASnR,UAAUhlC,QAAQ9F,KAAKF,IAAIqB,SAAS2pC,WAAW;;UAEpD3pC,SAASkrC;QACZ4P,SAAS5P,YAAYvmC,QAAQ3E,SAASkrC;;UAGnClrC,SAASwqC;QACZsQ,SAAStQ,QAAQ7lC,QAAQ3E,SAASwqC;QAClCsQ,SAASrQ,UAAU9lC,QAAQ3E,SAASyqC;YAChCzqC,SAASwmC,SAASx+B,UAAU8yC,SAASrQ,UAAU9lC,UAAU;;UAG1D3E,SAAS0qC;QACZoQ,SAASpQ,UAAU/lC,QAAQ3E,SAAS0qC;QACpCoQ,SAASlQ,YAAYjmC,MAAMkU,KAAK7Y,SAAS4qC;YACrC5qC,SAASwmC,SAASx+B,UAAU8yC,SAASlQ,YAAYjmC,MAAMkV;;UAGxD7Z,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;;IAI7C,6BAA6B+P,UAAU96C;UAClCA,SAASyrC;QACZqP,SAASrP,YAAY9mC,QAAQ3E,SAASyrC;;UAGnCzrC,SAASkrC;QACZ4P,SAAS5P,YAAYvmC,QAAQ3E,SAASkrC;;UAGnClrC,SAASwqC;QACZsQ,SAAStQ,QAAQ7lC,QAAQ3E,SAASwqC;QAClCsQ,SAASrQ,UAAU9lC,QAAQ3E,SAASyqC;YAChCzqC,SAASwmC,SAASx+B,UAAU8yC,SAASrQ,UAAU9lC,UAAU;;UAG1D3E,SAAS0qC;QACZoQ,SAASpQ,UAAU/lC,QAAQ3E,SAAS0qC;QACpCoQ,SAASlQ,YAAYjmC,MAAMkU,KAAK7Y,SAAS4qC;YACrC5qC,SAASwmC,SAASx+B,UAAU8yC,SAASlQ,YAAYjmC,MAAMkV;;UAGxD7Z,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;;IAI7C,iCAAiC+P,UAAU96C;MAC1C86C,SAASzR,UAAU1kC,QAAQ3E,SAASqpC;MACpCyR,SAASxR,UAAU3kC,QAAQ3E,SAASspC;UAEhCtpC,SAASgrC;QACZ8P,SAAS9P,aAAarmC,QAAQ3E,SAASgrC;;UAGpChrC,SAASirC;QACZ6P,SAAS7P,aAAatmC,QAAQ3E,SAASirC;;UAGpCjrC,SAASkrC;QACZ4P,SAAS5P,YAAYvmC,QAAQ3E,SAASkrC;;UAGnClrC,SAASwqC;QACZsQ,SAAStQ,QAAQ7lC,QAAQ3E,SAASwqC;QAClCsQ,SAASrQ,UAAU9lC,QAAQ3E,SAASyqC;YAChCzqC,SAASwmC,SAASx+B,UAAU8yC,SAASrQ,UAAU9lC,UAAU;;UAG1D3E,SAAS0qC;QACZoQ,SAASpQ,UAAU/lC,QAAQ3E,SAAS0qC;QACpCoQ,SAASlQ,YAAYjmC,MAAMkU,KAAK7Y,SAAS4qC;YACrC5qC,SAASwmC,SAASx+B,UAAU8yC,SAASlQ,YAAYjmC,MAAMkV;;UAGxD7Z,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;YAGtCK,SAASqiB,WAAWnK,IAAItjD,UAAUorC;UAEpCA;;QAEH0P,SAASxP,gBAAgB3mC,QAAQ3E,SAASsrC;;;IAI5C,iCAAiCwP,UAAU96C,UAAUkxF;MACpDU,wBAAwB92C,UAAU96C;MAClC86C,SAASvP,aAAa5mC,QAAQ3E,SAASurC;;MAEvCuP,SAASlR,UAAUjlC,QAAQ3E,SAAS4pC;MACpCkR,SAASjR,mBAAmBllC,QAAQ3E,SAAS6pC;UACzC7pC,SAASupC,OAAOuR,SAASvR,MAAM5kC,MAAMkU,KAAK7Y,SAASupC;UAEnDvpC,SAAS8pC;QACZgR,SAAShR,aAAanlC,QAAQ3E,SAAS8pC;;UAGpC9pC,SAAS+pC;QACZ+Q,SAAS/Q,sBAAsBplC,QAAQ3E,SAAS+pC;;UAG7C/pC,SAASgqC;QACZ8Q,SAAS7Q,qBAAqBtlC,MAAMkU,KAAK7Y,SAASiqC;QAClD6Q,SAAS9Q,mBAAmBrlC,QAAQ3E,SAASgqC;YAEzChqC,SAASwmC,SAASx+B;UACrB8yC,SAAS7Q,qBAAqBtlC,MAAMkV;;;MAItCihC,SAASpP,aAAa/mC,QAAQ3E,SAAS0rC;UAEnC1rC,SAAS2rC;QACZmP,SAASnP,gBAAgBhnC,QAAQ3E,SAAS2rC;;UAGvC3rC,SAAS0rC,eAAe;QAC3BoP,SAASyV,uBAAuB5rD,QAAQusF,yBAAyB1rE;QACjEs1B,SAASwV,wBAAwB3rD,MAAMsB,IAAIirF,yBAAyB74E,OAAO64E,yBAAyB54E;;MAGrGwiC,SAASlP,UAAUjnC,QAAQ3E,SAAS4rC;UAEhC5rC,SAAS6rC;QACZiP,SAASjP,aAAalnC,QAAQ3E,SAAS6rC;;MAGxCiP,SAAShP,oBAAoBnnC,QAAQ3E,SAAS8rC;MAC9CgP,SAAS/O,iBAAiBpnC,MAAMkU,KAAK7Y,SAAS+rC;;IAG/C,+BAA+B+O,UAAU96C;UACpCA,SAASkqC;QACZ4Q,SAAS5Q,OAAOvlC,QAAQ3E,SAASkqC;;UAG9BlqC,SAASwqC;QACZsQ,SAAStQ,QAAQ7lC,QAAQ3E,SAASwqC;QAClCsQ,SAASrQ,UAAU9lC,QAAQ3E,SAASyqC;YAChCzqC,SAASwmC,SAASx+B,UAAU8yC,SAASrQ,UAAU9lC,UAAU;;UAG1D3E,SAAS0qC;QACZoQ,SAASpQ,UAAU/lC,QAAQ3E,SAAS0qC;QACpCoQ,SAASlQ,YAAYjmC,MAAMkU,KAAK7Y,SAAS4qC;YACrC5qC,SAASwmC,SAASx+B,UAAU8yC,SAASlQ,YAAYjmC,MAAMkV;;UAGxD7Z,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;;IAI7C,8BAA8B+P,UAAU96C;UACnCA,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;;IAI7C,iCAAiC+P,UAAU96C;UACtCA,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;MAG5C+P,SAASmV,kBAAkBtrD,MAAMkU,KAAK7Y,SAASiwD;MAC/CnV,SAASoV,aAAavrD,QAAQ3E,SAASkwD;MACvCpV,SAASqV,YAAYxrD,QAAQ3E,SAASmwD;;IAGvC,+BAA+BrV,UAAU96C;UACpCA,SAASwqC;QACZsQ,SAAStQ,QAAQ7lC,QAAQ3E,SAASwqC;QAClCsQ,SAASrQ,UAAU9lC,QAAQ3E,SAASyqC;YAChCzqC,SAASwmC,SAASx+B,UAAU8yC,SAASrQ,UAAU9lC,UAAU;;UAG1D3E,SAAS0qC;QACZoQ,SAASpQ,UAAU/lC,QAAQ3E,SAAS0qC;QACpCoQ,SAASlQ,YAAYjmC,MAAMkU,KAAK7Y,SAAS4qC;YACrC5qC,SAASwmC,SAASx+B,UAAU8yC,SAASlQ,YAAYjmC,MAAMkV;;UAGxD7Z,SAAS6qC;QACZiQ,SAASjQ,gBAAgBlmC,QAAQ3E,SAAS6qC;QAC1CiQ,SAAShQ,kBAAkBnmC,QAAQ3E,SAAS8qC;QAC5CgQ,SAAS/P,iBAAiBpmC,QAAQ3E,SAAS+qC;;;;MAK5C+nD,oBAAoBA;MACpBC,yBAAyBA;;;EAI3B;UACO1yE,SAAStlB,SAASulB,gBAAgB,gCAAgC;IACxED,OAAOitB,MAAM0lD,UAAU;WAChB3yE;;EAGR,uBAAuBshB;IACtBA,aAAaA;UAEP3hB,UAAU2hB,WAAWthB,WAAW3oB,YAAYiqC,WAAWthB,SAAS4yE,uBACnEC,WAAWvxD,WAAWphB,YAAY7oB,YAAYiqC,WAAWphB,UAAU,MACnE4yE,SAASxxD,WAAWjnB,UAAUhjB,YAAYiqC,WAAWjnB,QAAQ,OAC7D04E,SAASzxD,WAAWvc,UAAU1tB,YAAYiqC,WAAWvc,QAAQ,MAC7DiuE,WAAW1xD,WAAW+d,YAAYhoD,YAAYiqC,WAAW+d,UAAU,MACnE4zC,aAAa3xD,WAAWitD,cAAcl3F,YAAYiqC,WAAWitD,YAAY,OACzE2E,sBAAsB5xD,WAAW8G,uBAAuB/wC,YAAYiqC,WAAW8G,qBAAqB,MACpG+qD,yBAAyB7xD,WAAW8xD,0BAA0B/7F,YAAYiqC,WAAW8xD,wBAAwB,OAC7GC,mBAAmB/xD,WAAWgyD,oBAAoBj8F,YAAYiqC,WAAWgyD,kBAAkB,WAC3FC,gCAAgCjyD,WAAWkyD,iCAAiCn8F,YAAYiqC,WAAWkyD,+BAA+B;QAEjIC,oBAAoB;QACpBC,qBAAqB;;;UAGnBC;UACAC;;IAEN,KAAKC,aAAal0E;;IAElB,KAAKgrD;;;;;MAKJC,mBAAmB;;;IAGpB,KAAKxZ,YAAY;IACjB,KAAKC,iBAAiB;IACtB,KAAKC,iBAAiB;IACtB,KAAKC,mBAAmB;;IAExB,KAAKuiC,cAAc;;IAEnB,KAAKtsD;IACL,KAAKkxB,uBAAuB;;IAE5B,KAAK9qB,cAAc;;IAEnB,KAAKk8B,iBAAiBp5D;;IAEtB,KAAK24D,0BAA0B;;IAE/B,KAAK7X,cAAcxnD;IACnB,KAAK+pF,sBAAsB;;UAErBC,QAAQ;QAEVC,iBAAiB;;QAEjBC,yBAAyB;QACzBC,4BAA4B;QAC5BC,uBAAuB;QAEvBC,sBAAsB;QAEtBC,iBAAiB;UAEfC,uBAAuB1vE;UAEvB2vE,sBAAsB3vE;QAExB4vE,sBAAsB;;QAEtBC,SAAS/0E,QAAQ3H;QACjB28E,UAAUh1E,QAAQ1H;QAClB28E,cAAc;QACdC,cAAc;QACdC,mBAAmB;UAEjBrhB,gBAAgB5uD,QAAQ,GAAG,GAAG6vE,QAAQC;UAEtCI,eAAelwE,QAAQ,GAAG,GAAG6vE,QAAQC;QAEvCK,eAAe;;UAEbC;;UAEA5hB,eAAeC;;QAGjB4hB,mBAAmB;QACnBC,wBAAwB;;QAExBC,4BAA4B;;UAE1BC,wBAAwBj/D;UAExBk/D,eAAer2F;UAEfs2F;MACLhmC,YAAY;MACZ1pD,KAAK;MACLqnE,aAAa;MACbsoB,kBAAkB;MAClBzkC,SAAS;;IAGV;aACQqjC,yBAAyB,OAAOQ,cAAc;;;QAIlDhV,MAAMiT;IAEV,oBAAoB4C,cAAcC;eACxBj8F,IAAI,GAAGA,IAAIg8F,aAAa/7F,QAAQD;cAClCk8F,cAAcF,aAAah8F;cAE3BymB,UAAUP,QAAQQ,WAAWw1E,aAAaD;YAE5Cx1E,YAAY,aAAaA;;aAGvB;;;YAIDw1E;QACLr7E,OAAOy4E;QACP/tE,OAAOguE;QACP1zC,SAAS2zC;QACTzE,WAAW0E;QACX7qD,oBAAoB8qD;QACpBE,uBAAuBD;QACvBG,iBAAiBD;QACjBG,8BAA8BD;;;MAG/B5zE,QAAQvb,iBAAiB,oBAAoBwxF,eAAe;MAE5Dj2E,QAAQvb,iBAAiB,wBAAwByxF,kBAAkB;UAE/DjW,QAAQ;cACL6V,gBAAgB,UAAU,SAAS;YAErCzB,MAAM8B,qBAAqB;UAC9BL,aAAaM;;QAGdnW,MAAMz/D,WAAWs1E,cAAcC;YAE3B9V,QAAQ;cACPz/D,WAAWs1E;sBACJ5wF,MAAM;;sBAENA,MAAM;;;;;UAMf+6E,IAAInpB,6BAA6Bp/D;QACpCuoF,IAAInpB,2BAA2B;;YAE7B,YAAY;YACZ,YAAY;YACZ,aAAa;;;;aAIRt8D;MACRb,QAAQa,MAAM,0BAA0BA,MAAMC;YACxCD;;QAGHkhD,YAAYuG,cAAcwO,OAAO2F;QACjC3I,YAAY/qC,UAAU8tC,UAAUhe,YAAY3R,YAAY6vB;QACxD2lC,cAAcv1D,WAAWw1D,aAAatjB,cAAcv3B,UAAUuyB;QAC9Dpe,YAAY2mC,cAAcC,gBAAgBC;QAC1CvW,OAAO1tB;IAEX;MACC9W,iBAAiBg7C,gBAAgBzW;MACjCh+B,mBAAmB00C,kBAAkB1W,KAAKvkC,YAAY/Z;MACtD+Z,WAAW0d,KAAKnX;MAChBi+B,YAAY0W,WAAW3W,KAAKvkC,YAAYuG;MACxCwO,YAAYomC,WAAW5W,KAAKvkC,YAAYuG;MACxCqzC,oBAAoB,KAAKrV,IAAIrB;MAC7BxoB,WAAW0gC,UAAU7W;MACrBxyB,iBAAiBspC;MACjBr0E,eAAes0E,cAAc/W,KAAKvkC,YAAY+U,OAAOhD,YAAYxL,cAAci+B,OAAO9pB;MACtF5F,eAAeymC,cAAc5C;MAC7B7hD,iBAAiB0kD,gBAAgBjX,KAAKh+B;MACtCuQ,oBAAoB2kC,mBAAmBlX,KAAKvkC,YAAYlJ,YAAYyP;MACpEphB,iBAAiBu2D,gBAAgBnX,KAAKztC,YAAY4jB,MAAM5D;MACxD9B,cAAc2mC,aAAapX,KAAKp/C,YAAY2R,YAAY4jB;MACxDmgC,mBAAmBe,kBAAkBrX;MACrCxkC,eAAe87C,cAAc9pC;MAC7B4oC,mBAAmBmB,cAAcnD,OAAO7jC,UAAU9U,YAAYuG,cAAcuQ,eAAe/W;MAC3F3a,gBAAgB22D,eAAehqC;MAC/B6oC,kBAAkBoB,iBAAiBjqC;MACnCulB,mBAAmB2kB,kBAAkBj8C,YAAYuG;MACjD2N,iBAAiBgoC,gBAAgBvD,OAAO7jC,UAAUC,OAAOC,SAAS6iC;MAClEvlB,gBAAgB6pB,eAAexD,OAAO3jC,SAASzO;MAC/Cu0C,qBAAqBsB,oBAAoB7X,KAAKvkC,YAAY0a,MAAMnU;MAChEw0C,4BAA4BsB,2BAA2B9X,KAAKvkC,YAAY0a,MAAMnU;MAC9EmU,KAAKyF,WAAWw6B,aAAax6B;MAC7Bw4B,MAAMpyC,eAAeA;MACrBoyC,MAAM34C,aAAaA;MACnB24C,MAAM5mC,aAAaA;MACnB4mC,MAAMiC,cAAcA;MACpBjC,MAAMrmB,YAAYA;MAClBqmB,MAAM5jC,QAAQA;MACd4jC,MAAMj+B,OAAOA;;IAGd4hC;;UAEMr5C,SAASs5C,aAAa5D,OAAOpU;IACnC,KAAKthC,KAAKA;;IAEV,KAAKn+B,aAAa;aACVy/D;;IAGR,KAAKuO,uBAAuB;aACpBvO,IAAIuO;;IAGZ,KAAK0J,mBAAmB;YACjB5lC,YAAY5W,WAAW4H,IAAI;UAC7BgP,WAAWA,UAAU6lC;;IAG1B,KAAKC,sBAAsB;YACpB9lC,YAAY5W,WAAW4H,IAAI;UAC7BgP,WAAWA,UAAU+lC;;IAG1B,KAAKC,gBAAgB;aACbrD;;IAGR,KAAKsD,gBAAgB,UAAU5zF;UAC1BA,UAAUjN;MACdu9F,cAActwF;MACd,KAAKkhB,QAAQkvE,QAAQC,SAAS;;IAG/B,KAAK3lE,UAAU,UAAU/rB;UACpBA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAakY;;aAGPlY,OAAO2C,IAAI8uF,QAAQC;;IAG3B,KAAKnvE,UAAU,UAAUxN,OAAOC,QAAQkgF;UACnC75C,GAAGgvC;QACNh0F,QAAQ0B,KAAK;;;MAId05F,SAAS18E;MACT28E,UAAU18E;MACV0H,QAAQ3H,QAAQxZ,KAAKC,MAAMuZ,QAAQ48E;MACnCj1E,QAAQ1H,SAASzZ,KAAKC,MAAMwZ,SAAS28E;UAEjCuD,gBAAgB;QACnBx4E,QAAQstB,MAAMj1B,QAAQA,QAAQ;QAC9B2H,QAAQstB,MAAMh1B,SAASA,SAAS;;MAGjC,KAAKmgF,YAAY,GAAG,GAAGpgF,OAAOC;;IAG/B,KAAKogF,uBAAuB,UAAUp1F;UACjCA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAakY;;aAGPlY,OAAO2C,IAAI8uF,SAASE,aAAaD,UAAUC,aAAan2F;;IAGhE,KAAK65F,uBAAuB,UAAUtgF,OAAOC,QAAQ24E;MACpD8D,SAAS18E;MACT28E,UAAU18E;MACV28E,cAAchE;MACdjxE,QAAQ3H,QAAQxZ,KAAKC,MAAMuZ,QAAQ44E;MACnCjxE,QAAQ1H,SAASzZ,KAAKC,MAAMwZ,SAAS24E;MACrC,KAAKwH,YAAY,GAAG,GAAGpgF,OAAOC;;IAG/B,KAAKsgF,qBAAqB,UAAUt1F;UAC/BA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAa4hB;;aAGP5hB,OAAOuV,KAAK+7E;;IAGpB,KAAK/e,cAAc,UAAUvyE;aACrBA,OAAOuV,KAAKi7D;;IAGpB,KAAK2kB,cAAc,UAAU/3F,GAAGG,GAAGwX,OAAOC;UACrC5X,EAAEykB;QACL2uD,UAAU7tE,IAAIvF,EAAEA,GAAGA,EAAEG,GAAGH,EAAEI,GAAGJ,EAAEoY;;QAE/Bg7D,UAAU7tE,IAAIvF,GAAGG,GAAGwX,OAAOC;;MAG5Bm4C,MAAMlrC,SAASqvE,iBAAiB/7E,KAAKi7D,WAAW5yE,eAAe+zF,aAAan2F;;IAG7E,KAAK+5F,aAAa,UAAUv1F;aACpBA,OAAOuV,KAAKu8E;;IAGpB,KAAK0D,aAAa,UAAUp4F,GAAGG,GAAGwX,OAAOC;UACpC5X,EAAEykB;QACLiwE,SAASnvF,IAAIvF,EAAEA,GAAGA,EAAEG,GAAGH,EAAEI,GAAGJ,EAAEoY;;QAE9Bs8E,SAASnvF,IAAIvF,GAAGG,GAAGwX,OAAOC;;MAG3Bm4C,MAAMprC,QAAQwvE,gBAAgBh8E,KAAKu8E,UAAUl0F,eAAe+zF,aAAan2F;;IAG1E,KAAKi6F,iBAAiB;aACd1D;;IAGR,KAAKjgB,iBAAiB,UAAU4jB;MAC/BvoC,MAAM2kB,eAAeigB,eAAe2D;;IAGrC,KAAKC,gBAAgB,UAAUC;MAC9BhE,cAAcgE;;IAGf,KAAKC,qBAAqB,UAAUD;MACnC/D,mBAAmB+D;;;IAIpB,KAAKlnC,gBAAgB,UAAU1uD;UAC1BA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAamsC;;aAGPnsC,OAAOuV,KAAK+2C,WAAWoC;;IAG/B,KAAKC,gBAAgB;MACpBrC,WAAWqC,cAAcxzD,MAAMmxD,YAAYj0C;;IAG5C,KAAKu2C,gBAAgB;aACbtC,WAAWsC;;IAGnB,KAAKC,gBAAgB;MACpBvC,WAAWuC,cAAc1zD,MAAMmxD,YAAYj0C;;IAG5C,KAAK/hB,QAAQ,UAAUsG,OAAOklB,OAAOs6B;UAChC05C,OAAO;UACPl5F,UAAUxI,aAAawI,OAAOk5F,QAAQnZ,IAAI+H;UAC1C5iE,UAAU1tB,aAAa0tB,OAAOg0E,QAAQnZ,IAAIgI;UAC1CvoC,YAAYhoD,aAAagoD,SAAS05C,QAAQnZ,IAAIiI;MAElDjI,IAAIrmF,MAAMw/F;;IAGX,KAAKzoC,aAAa;MACjB,KAAK/2D,MAAM,MAAM,OAAO;;IAGzB,KAAK4+E,aAAa;MACjB,KAAK5+E,MAAM,OAAO,MAAM;;IAGzB,KAAK0/E,eAAe;MACnB,KAAK1/E,MAAM,OAAO,OAAO;;;IAI1B,KAAKnC,UAAU;MACduoB,QAAQtM,oBAAoB,oBAAoBuiF,eAAe;MAE/Dj2E,QAAQtM,oBAAoB,wBAAwBwiF,kBAAkB;MAEtEI,YAAY7+F;MACZu7E,aAAav7E;MACbg2D,WAAWh2D;MACX+4D,SAAS/4D;MACTi5D,QAAQj5D;MACR+6D,cAAc/6D;MACdknD,GAAGlnD;MACHknD,GAAGjrC,oBAAoB,gBAAgB2lF;MACvC16C,GAAGjrC,oBAAoB,cAAc4lF;UAEjC7D;QACHA,0BAA0Bh+F;QAE1Bg+F,4BAA4B;;MAG7BvzD,UAAU2f;;;IAIX,uBAAuBlpD;MACtBA,MAAM4gG;MACN5/F,QAAQ6B,IAAI;MACZ84F,iBAAiB;;IAGlB;;MAGC36F,QAAQ6B,IAAI;MACZ84F,iBAAiB;YACXkF,gBAAgBpjC,KAAK0F;YACrB2N,mBAAmBuE,UAAUrwB;YAC7B87C,sBAAsBzrB,UAAU4G;YAChC8kB,uBAAuB1rB,UAAU5qD;YACjCgkD,gBAAgB4G,UAAUl1E;MAChCk/F;MACA5hC,KAAK0F,YAAY09B;MACjBxrB,UAAUrwB,UAAU8rB;MACpBuE,UAAU4G,aAAa6kB;MACvBzrB,UAAU5qD,cAAcs2E;MACxB1rB,UAAUl1E,OAAOsuE;;IAGlB,2BAA2BzuE;YACpBqH,WAAWrH,MAAM2K;MACvBtD,SAAS0T,oBAAoB,WAAWimF;MACxCC,mBAAmB55F;;;IAIpB,4BAA4BA;MAC3B65F,iCAAiC75F;MACjCytD,WAAWlyD,OAAOyE;;IAGnB,0CAA0CA;YACnC67D,WAAWpO,WAAWnK,IAAItjD,UAAU67D;UAEtCA,aAAankE;QAChBmkE,SAASxiE,QAAQ,UAAUu5D;UAC1ByjC,aAAa7nB,eAAe5b;;;;;IAM/B,+BAA+B5jC,QAAQ4jC;MACtC5jC,OAAO+vB,OAAO,UAAU/vB;QACvBqlE,MAAMyF,sBAAsB9qE,QAAQ4jC;;;IAItC,KAAKknC,wBAAwB,UAAU9qE,QAAQ4jC;MAC9CJ,cAAcqC;YACR1S,UAAUsL,WAAWnK,IAAIt0B;UAC3BA,OAAO+qE,iBAAiB53C,QAAQ1hD,UAAU0hD,QAAQ1hD,WAAWw/E,IAAI39B;UACjEtzB,OAAOgrE,eAAe73C,QAAQh1B,QAAQg1B,QAAQh1B,SAAS8yD,IAAI39B;UAC3DtzB,OAAOirE,WAAW93C,QAAQh/B,IAAIg/B,QAAQh/B,KAAK88D,IAAI39B;UAC/CtzB,OAAOkrE,cAAc/3C,QAAQjiD,OAAOiiD,QAAQjiD,QAAQ+/E,IAAI39B;YACtDwS,oBAAoBlC,QAAQmC;UAE9B/lC,OAAO+qE;QACV9Z,IAAI19B,WAAW09B,IAAI5qB,cAAclT,QAAQ1hD;QAEzCw/E,IAAIz9B,WAAWy9B,IAAI5qB,cAAcrmC,OAAOmrE,eAAela,IAAIma;QAE3D5nC,cAAc4C,gBAAgBN,kBAAkBr0D;QAEhDw/E,IAAItrB,oBAAoBG,kBAAkBr0D,UAAU,GAAGw/E,IAAIx9B,OAAO,OAAO,GAAG;;UAGzEzzB,OAAOgrE;QACV/Z,IAAI19B,WAAW09B,IAAI5qB,cAAclT,QAAQh1B;QAEzC8yD,IAAIz9B,WAAWy9B,IAAI5qB,cAAcrmC,OAAOqrE,aAAapa,IAAIma;QAEzD5nC,cAAc4C,gBAAgBN,kBAAkB3nC;QAEhD8yD,IAAItrB,oBAAoBG,kBAAkB3nC,QAAQ,GAAG8yD,IAAIx9B,OAAO,OAAO,GAAG;;UAGvEzzB,OAAOirE;QACVha,IAAI19B,WAAW09B,IAAI5qB,cAAclT,QAAQh/B;QAEzC88D,IAAIz9B,WAAWy9B,IAAI5qB,cAAcrmC,OAAOsrE,SAASra,IAAIma;QAErD5nC,cAAc4C,gBAAgBN,kBAAkB3xC;QAEhD88D,IAAItrB,oBAAoBG,kBAAkB3xC,IAAI,GAAG88D,IAAIx9B,OAAO,OAAO,GAAG;;UAGnEzzB,OAAOkrE;QACVja,IAAI19B,WAAW09B,IAAI5qB,cAAclT,QAAQjiD;QAEzC+/E,IAAIz9B,WAAWy9B,IAAI5qB,cAAcrmC,OAAOurE,YAAYta,IAAIma;QAExD5nC,cAAc4C,gBAAgBN,kBAAkB50D;QAEhD+/E,IAAItrB,oBAAoBG,kBAAkB50D,OAAO,GAAG+/E,IAAIx9B,OAAO,OAAO,GAAG;;MAG1E+P,cAAcmD;MAEdsqB,IAAI3pB,WAAW2pB,IAAIzkB,WAAW,GAAGxsC,OAAO9sB;MAExC8sB,OAAO9sB,QAAQ;;IAGhB,KAAKg0E,qBAAqB,UAAUnqD,QAAQjnB,OAAOlF,UAAUI,UAAUgvB,QAAQhtB;UAC1E8C,UAAU,MAAMA,QAAQ8wF;;YAEtBvX,cAAcrvD,OAAOuS,UAAUvS,OAAO5C,YAAYhO,gBAAgB;YAClEw0C,UAAU4nC,WAAWzuE,QAAQjnB,OAAO9E,UAAUgvB;MACpDyhC,MAAMqvB,YAAY9/E,UAAUq+E;;UAExBzqE,QAAQhU,SAASgU;YACfnT,WAAWb,SAAS4yC,WAAW/xC;;UAEjCmT,UAAU;YACTnT,aAAa/I,aAAa+I,SAASyB,UAAU;iBACvC0R,MAAM1R,UAAU;;;;UAKvBu4F,cAAc;UAEdz6F,SAASoE,cAAc;QAC1BwP,QAAQitB,WAAWq6B,sBAAsBt7D;QACzC66F,cAAc;;UAGXz6F,SAASusC,gBAAgBvsC,SAASwsC;QACrC+pD,aAAa9tE,OAAOuG,QAAQpvB,UAAUI,UAAU4yD;;MAGjDJ,cAAcyD,MAAMjnC,QAAQhvB,UAAU4yD,SAAShzD,UAAUgU;UACrDuH;UACAzV,WAAW8wF;UAEX5iF,UAAU;QACbuH,YAAYq3B,WAAW8Q,IAAI1vC;QAC3BlO,WAAW+wF;QACX/wF,SAASotC,SAAS33B;;;YAIbu/E,YAAY9mF,UAAU,OAAOA,MAAM1R,QAAQzB,SAASyB;YACpDy4F,aAAa/6F,SAASgzC,UAAUzP,QAAQs3D;YACxCG,aAAah7F,SAASgzC,UAAU1wC,QAAQu4F;YACxC3gD,aAAa93C,UAAU,OAAOA,MAAMmhC,QAAQs3D,cAAc;YAC1D7/C,aAAa54C,UAAU,OAAOA,MAAME,QAAQu4F,cAAc1sE;YAC1D8sE,YAAYh8F,KAAKF,IAAIg8F,YAAY7gD;YACjCghD,UAAUj8F,KAAKD,IAAI87F,WAAWC,aAAaC,YAAY9gD,aAAac,cAAc;YAClFmgD,YAAYl8F,KAAKF,IAAI,GAAGm8F,UAAUD,YAAY;UAChDE,cAAc;;UAEd/rE,OAAOuS;YACNvhC,SAASoE,cAAc;UAC1BqsD,MAAMsvB,aAAa//E,SAASosC,qBAAqB4uD;UACjDt1F,SAAS+wD,QAAQwpB,IAAIxkB;;UAErB/1D,SAAS+wD,QAAQwpB,IAAIzkB;;iBAEZxsC,OAAOwS;YACbu9C,YAAY/+E,SAASisC;YACrB8yC,cAAcrnF,WAAWqnF,YAAY;;QAEzCtuB,MAAMsvB,aAAahB,YAAYic;YAE3BhsE,OAAOisE;UACVv1F,SAAS+wD,QAAQwpB,IAAIxkB;mBACXzsC,OAAOksE;UACjBx1F,SAAS+wD,QAAQwpB,IAAItkB;;UAErBj2D,SAAS+wD,QAAQwpB,IAAIvkB;;iBAEZ1sC,OAAOyS;QACjB/7B,SAAS+wD,QAAQwpB,IAAIrkB;iBACX5sC,OAAOmsE;QACjBz1F,SAAS+wD,QAAQwpB,IAAIzkB;;UAGlBxsC,OAAOkS;QACVx7B,SAASgxD,gBAAgBmkC,WAAWE,WAAW/rE,OAAO9sB;iBAC5CtC,SAASg1D;cACb2G,gBAAgB18D,KAAKD,IAAIgB,SAAS27D,eAAe37D,SAASu1D;QAChEzvD,SAASgxD,gBAAgBmkC,WAAWE,WAAWx/B;;QAE/C71D,SAASq5C,OAAO87C,WAAWE;;;;IAK7B,KAAKK,UAAU,UAAUt2F,OAAOinB;MAC/BgoE,qBAAqB/gB,aAAa1vB,IAAIx+C;MACtCivF,mBAAmB36B;MACnBt0D,MAAMy7B,gBAAgB,UAAUvR;YAC3BA,OAAOyQ,WAAWzQ,OAAOuN,OAAO/jC,KAAKuzB,OAAOwQ;UAC/Cw3D,mBAAmBjhB,UAAU9jD;cAEzBA,OAAOkP;YACV61D,mBAAmBhhB,WAAW/jD;;;;MAIjC+kE,mBAAmBnhB;MACnB9tE,MAAMw7B,SAAS,UAAUtR;cAClBhvB,WAAWgvB,OAAOhvB;YAEpBA;cACC5D,MAAMC,QAAQ2D;qBACRlG,IAAI,GAAGA,IAAIkG,SAASjG,QAAQD;oBAC9BuhG,YAAYr7F,SAASlG;cAC3BwhG,WAAWD,WAAWv2F,OAAOkqB;;;YAG9BssE,WAAWt7F,UAAU8E,OAAOkqB;;;;;;QAO5B0hE,2BAA2B;IAE/B,0BAA0B1vF;UACrB0vF,0BAA0BA,yBAAyB1vF;;IAGxD;MACCkhC,UAAU2f;;IAGX;MACC3f,UAAUiB;;UAGLjB,gBAAgB4uD;IACtB5uD,UAAUv8B,iBAAiBi8C;eAChB3nD,WAAW,aAAaioC,UAAU6f,WAAW9nD;IAExD,KAAK0L,mBAAmB,UAAUklB;MACjC6lE,2BAA2B7lE;MAC3B8zB,GAAGh5C,iBAAiBklB;MACpBA,aAAa,OAAOqX,UAAU2f,SAAS3f,UAAUiB;;IAGlDwb,GAAGl6C,iBAAiB,gBAAgB40F;IACpC16C,GAAGl6C,iBAAiB,cAAc60F;;IAElC,KAAKv6C,SAAS,UAAUj6C,OAAOinB;UAC1BA,WAAWr0B,aAAaq0B,OAAOyT,aAAa;QAC/C7lC,QAAQa,MAAM;;;UAIX85F,mBAAmB;;UAEnBxvF,MAAM8vE,eAAe,MAAM9vE,MAAM27B;;UAEjC1U,OAAO5zB,WAAW,MAAM4zB,OAAO0U;UAE/Bke,GAAGhB,YAAY,QAAQgB,GAAGgvC,iBAAiB;YAC1ChvC,GAAG+uC,qBAAqB,MAAM/uC,GAAG0xC,aAAatkE;QAClDA,SAAS4yB,GAAG8xC;;;UAIT3rF,MAAMssD,YAAY,MAAMtsD,MAAM05B,eAAe61D,OAAOvvF,OAAOinB,QAAQ0oE;MACvEV,qBAAqB/gB,aAAa1vB,IAAIx+C,OAAOmvF,iBAAiBl6F;MAC9Dg6F,mBAAmB36B;MACnB66B,iBAAiBz8F,KAAKu8F;MAEtB2B,kBAAkB54E,iBAAiBiP,OAAOE,kBAAkBF,OAAOC;MAEnE0nD,SAASxzB,wBAAwBw1C;MAEjCF,wBAAwB,KAAKz8B;MAC7Bw8B,mBAAmB95C,SAAS2d,KAAK,KAAKvxB,gBAAgB2tD,uBAAuBzpE;MAC7E+nE,oBAAoBwC,YAAYhzC,IAAIx+C,OAAOkvF,gBAAgBj6F;MAC3D+5F,kBAAkB16B;MAClB46B,gBAAgBx8F,KAAKs8F;MACrByH,cAAcz2F,OAAOinB,QAAQ,GAAGsoE,MAAMF;MACtCL,kBAAkBzkB;UAEdglB,MAAMF,gBAAgB;QACzBL,kBAAkB33B,KAAK+4B,aAAaC;;;UAIjCI,qBAAqB,MAAM95C,SAAS8d;YAClCmZ,eAAeqhB,mBAAmBtjC,MAAMiiB;MAC9C1E,UAAUjvB,OAAO2zB,cAAc5tE,OAAOinB;MACtCgoE,mBAAmBnhB;MACnBmhB,mBAAmBlhB,gBAAgB9mD;UAC/BwpE,qBAAqB,MAAM95C,SAAS+d;;UAEpC,KAAKpD,KAAK0F,cAAc,MAAM,KAAK1F,KAAKR;;MAE5ChG,WAAW7Q,OAAO+0C,mBAAmBhvF;;YAE/B02F,gBAAgB1H,kBAAkBllB;YAClC6sB,sBAAsB3H,kBAAkBjlB;YACxC6sB,qBAAqB5H,kBAAkBntD;UACzC60D,cAAczhG,SAAS,GAAG4hG,cAAcH,eAAe12F,OAAOinB;UAC9D0vE,oBAAoB1hG,SAAS,GAAG6hG,0BAA0BJ,eAAeC,qBAAqB32F,OAAOinB;UACrG2vE,mBAAmB3hG,SAAS,GAAG4hG,cAAcD,oBAAoB52F,OAAOinB;;UAExE0oE,yBAAyB;;QAE5B/xE,SAAS+lE,yBAAyBgM;;QAElC/xE,SAASgmE,8BAA8B+L;;;UAIpC3vF,MAAMssD,YAAY,MAAMtsD,MAAM25B,cAAc41D,OAAOvvF,OAAOinB;;MAE9D0kC,MAAMtO,QAAQ/8B,MAAM+vD,QAAQ;MAC5B1kB,MAAMtO,QAAQ/8B,MAAMkyD,QAAQ;MAC5B7mB,MAAMtO,QAAQjiD,MAAMo3E,QAAQ;MAC5B7mB,MAAM6tB,iBAAiB;;MAEvB9rB,cAAcwD;MACd0+B,sBAAsB;MACtBC,iBAAiB;MACjBV,iBAAiB7lB;UAEb6lB,iBAAiBl6F,SAAS;QAC7Bg6F,qBAAqBE,iBAAiBA,iBAAiBl6F,SAAS;;QAEhEg6F,qBAAqB;;MAGtBC,gBAAgB5lB;UAEZ4lB,gBAAgBj6F,SAAS;QAC5B+5F,oBAAoBE,gBAAgBA,gBAAgBj6F,SAAS;;QAE7D+5F,oBAAoB;;;IAItB,uBAAuB9kE,QAAQjD,QAAQ0iD,YAAY0lB;UAC9CnlE,OAAOiP,YAAY;YACjBA,UAAUjP,OAAOuN,OAAO/jC,KAAKuzB,OAAOwQ;UAEtC0B;YACCjP,OAAOu7D;UACV9b,aAAaz/C,OAAOqP;mBACVrP,OAAO6sE;cACb7sE,OAAO4lD,eAAe,MAAM5lD,OAAOvG,OAAOsD;mBACpCiD,OAAOyQ;UACjBs0D,mBAAmBjhB,UAAU9jD;cAEzBA,OAAOkP;YACV61D,mBAAmBhhB,WAAW/jD;;mBAErBA,OAAOmsE;eACZnsE,OAAOoP,iBAAiBs1C,SAAStyB,iBAAiBpyB;gBAClDmlE;cACHwB,SAASjoE,sBAAsBsB,OAAO5C,aAAazI,aAAa+xE;;kBAG3D91F,WAAW8wD,QAAQjoC,OAAOuG;kBAC1BhvB,WAAWgvB,OAAOhvB;gBAEpBA,SAASi+B;cACZ61D,kBAAkBt8F,KAAKw3B,QAAQpvB,UAAUI,UAAUyuE,YAAYknB,SAAS70F,GAAG;;;mBAGnEkuB,OAAO8sE;cACb3H;YACHwB,SAASjoE,sBAAsBsB,OAAO5C,aAAazI,aAAa+xE;;UAGjE5B,kBAAkBt8F,KAAKw3B,QAAQ,MAAMA,OAAOhvB,UAAUyuE,YAAYknB,SAAS70F,GAAG;mBACpEkuB,OAAOuS,UAAUvS,OAAOwS,UAAUxS,OAAOyS;cAC/CzS,OAAO6S;;gBAEN7S,OAAOgT,SAAS0f,UAAU0U,KAAKrX,OAAO2C;cACzC1yB,OAAOgT,SAASvZ;cAChBuG,OAAOgT,SAAS0f,QAAQ0U,KAAKrX,OAAO2C;;;eAIjC1yB,OAAOoP,iBAAiBs1C,SAASvyB,iBAAiBnyB;gBAClDmlE;cACHwB,SAASjoE,sBAAsBsB,OAAO5C,aAAazI,aAAa+xE;;kBAG3D91F,WAAW8wD,QAAQjoC,OAAOuG;kBAC1BhvB,WAAWgvB,OAAOhvB;gBAEpB5D,MAAMC,QAAQ2D;oBACX2yC,SAAS/yC,SAAS+yC;uBAEf74C,IAAI,GAAGma,IAAI0+B,OAAO54C,QAAQD,IAAIma,GAAGna;sBACnCkI,QAAQ2wC,OAAO74C;sBACfi/C,gBAAgB/4C,SAASgC,MAAMqxC;oBAEjC0F,iBAAiBA,cAAc9a;kBAClC61D,kBAAkBt8F,KAAKw3B,QAAQpvB,UAAUm5C,eAAe01B,YAAYknB,SAAS70F,GAAGkB;;;uBAGxEhC,SAASi+B;cACnB61D,kBAAkBt8F,KAAKw3B,QAAQpvB,UAAUI,UAAUyuE,YAAYknB,SAAS70F,GAAG;;;;;YAMzEivB,WAAWf,OAAOe;eAEfj2B,IAAI,GAAGma,IAAI8b,SAASh2B,QAAQD,IAAIma,GAAGna;QAC3CyhG,cAAcxrE,SAASj2B,IAAIiyB,QAAQ0iD,YAAY0lB;;;IAIjD,mCAAmCqH,eAAeC,qBAAqB32F,OAAOinB;UACzE0pE,8BAA8B;QACjCA,gCAAgC3vE,kBAAkB,MAAM;UACvD/D,iBAAiB;UACjBT,WAAWzV;UACXwV,WAAWhW;UACX8V,OAAOhW;UACPiW,OAAOjW;;;YAIHyzC,sBAAsBy1C,MAAMx1C;MAElCw1C,MAAMv1C,gBAAgB22C;MAEtBpB,MAAMz6F;MAEN+hG,cAAcH,eAAe12F,OAAOinB;MACpCrJ,SAAS+lE,yBAAyBgN;MAElCpB,MAAMv1C,gBAAgBF;MAEtB+8C,cAAcF,qBAAqB32F,OAAOinB;;IAG3C,uBAAuBmlC,YAAYpsD,OAAOinB;YACnC8pE,mBAAmB/wF,MAAMssD,YAAY,OAAOtsD,MAAM+wF,mBAAmB;eAElE/7F,IAAI,GAAGma,IAAIi9C,WAAWn3D,QAAQD,IAAIma,GAAGna;cACvCi1E,aAAa7d,WAAWp3D;cACxBk1B,SAAS+/C,WAAW//C;cACpBpvB,WAAWmvE,WAAWnvE;cACtBI,WAAW61F,qBAAqB,OAAO9mB,WAAW/uE,WAAW61F;cAC7D7zF,QAAQ+sE,WAAW/sE;YAErB+pB,OAAOu+D;gBACJF,UAAUr+D,OAAOq+D;mBAEdn4D,IAAI,GAAG8hB,KAAKq2C,QAAQrwF,QAAQk4B,IAAI8hB,IAAI9hB;kBACtC8pE,UAAU3R,QAAQn4D;gBAEpBjD,OAAOuN,OAAO/jC,KAAKujG,QAAQx/D;cAC9Bk0B,MAAMlrC,SAASqvE,iBAAiB/7E,KAAKkjF,QAAQx2E;cAC7CwuE,mBAAmBlhB,gBAAgBkpB;cACnC/lB,aAAahnD,QAAQlqB,OAAOi3F,SAASn8F,UAAUI,UAAUgC;;;;UAI3Dg0E,aAAahnD,QAAQlqB,OAAOinB,QAAQnsB,UAAUI,UAAUgC;;;;IAK3D,sBAAsBgtB,QAAQlqB,OAAOinB,QAAQnsB,UAAUI,UAAUgC;MAChEgtB,OAAOwP,eAAe61D,OAAOvvF,OAAOinB,QAAQnsB,UAAUI,UAAUgC;MAChEgtB,OAAO4O,gBAAgB9gB,iBAAiBiP,OAAOC,oBAAoBgD,OAAO5C;MAC1E4C,OAAO6O,aAAa9e,gBAAgBiQ,OAAO4O;UAEvC5O,OAAO8sE;cACJlpC,UAAU4nC,WAAWzuE,QAAQjnB,OAAO9E,UAAUgvB;QACpDyhC,MAAMqvB,YAAY9/E;QAClBwyD,cAAcoD;QACdomC,sBAAsBhtE,QAAQ4jC;;QAE9ByhC,MAAMne,mBAAmBnqD,QAAQjnB,OAAOlF,UAAUI,UAAUgvB,QAAQhtB;;MAGrEgtB,OAAOyP,cAAc41D,OAAOvvF,OAAOinB,QAAQnsB,UAAUI,UAAUgC;;IAGhE,oBAAoBhC,UAAU8E,OAAOkqB;UAChClqB,MAAMssD,YAAY,MAAMtsD,QAAQ8wF;;YAE9Bh8B,qBAAqBnM,WAAWnK,IAAItjD;YACpCw7C,SAASu4C,mBAAmBtjC,MAAMjV;YAClCk3B,eAAeqhB,mBAAmBtjC,MAAMiiB;YACxCupB,qBAAqBzgD,OAAOiV,MAAMtuC;YAClCwf,aAAa00D,aAAahoB,cAAcruE,UAAUw7C,OAAOiV,OAAOiiB,cAAc5tE,OAAOkqB;YACrFktE,kBAAkB7F,aAAa/nB,mBAAmB3sC;UACpDk6B,WAAWjC,mBAAmBiC;;MAElCjC,mBAAmB2T,cAAcvtE,SAASwtE,yBAAyB1oE,MAAMyoE,cAAc;MACvF3T,mBAAmB1zD,MAAMpB,MAAMoB;MAC/B0zD,mBAAmBxuB,SAASolB,SAASlN,IAAItjD,SAASorC,UAAUwuB,mBAAmB2T;UAE3E1R,aAAankE;;QAEhBsI,SAASyE,iBAAiB,WAAWk1F;QACrC99B,eAAeuxB;QACfxzB,mBAAmBiC,WAAWA;;UAG3BjJ,UAAUiJ,SAASvY,IAAI44C;UAEvBtpC,YAAYl7D;;YAEXkiE,mBAAmBkgB,mBAAmBlnB,WAAWgH,mBAAmBqiC,uBAAuBA;UAC9FE,+BAA+Bn8F,UAAU2hC;iBAClCixB;;;QAGRjxB,WAAWmZ,WAAWu7C,aAAa55B,YAAYz8D;QAC/CA,SAAS2oC,QAAQhH,YAAY0yD;QAC7Br0F,SAAS4oC,gBAAgBjH,YAAY0yD;QACrCzhC,UAAUyjC,aAAa9nB,eAAe5sC,YAAYu6D;QAClDrgC,SAAS51D,IAAIi2F,iBAAiBtpC;QAC9BgH,mBAAmB9e,WAAWnZ,WAAWmZ;;YAGpCA,WAAW8e,mBAAmB9e;WAE/B96C,SAASq8C,qBAAqBr8C,SAASuoE,uBAAuBvoE,SAASy7C,aAAa;QACxFX,SAASjT,iBAAiB4T,SAASU;;MAGpCggD,+BAA+Bn8F,UAAU2hC;;MAEzCi4B,mBAAmBwiC,cAAcC,oBAAoBr8F;MACrD45D,mBAAmBqiC,qBAAqBA;UAEpCriC,mBAAmBwiC;;QAEtBthD,SAASwS,kBAAkB3oD,QAAQ62C,OAAOiV,MAAMkgB;QAChD71B,SAASyS,WAAW5oD,QAAQ62C,OAAOiV,MAAMmgB;QACzC91B,SAAS0S,kBAAkB7oD,QAAQ62C,OAAOiV,MAAMmd;QAChD9yB,SAAS4S,wBAAwB/oD,QAAQ62C,OAAOiV,MAAMogB;QACtD/1B,SAASmT,WAAWtpD,QAAQ62C,OAAOiV,MAAMod;QACzC/yB,SAASuT,iBAAiB1pD,QAAQ62C,OAAOiV,MAAMqgB;QAC/Ch2B,SAASmU,eAAetqD,QAAQ62C,OAAOiV,MAAMqd;QAC7ChzB,SAASoU,MAAMvqD,QAAQ62C,OAAOiV,MAAMsgB;QACpCj2B,SAASqU,MAAMxqD,QAAQ62C,OAAOiV,MAAMugB;QACpCl2B,SAAS0T,YAAY7pD,QAAQ62C,OAAOiV,MAAMnhC;QAC1CwrB,SAAS2T,kBAAkB9pD,QAAQ62C,OAAOiV,MAAMwgB;QAChDn2B,SAASgU,iBAAiBnqD,QAAQ62C,OAAOiV,MAAMsd;QAC/CjzB,SAASiT,qBAAqBppD,QAAQ62C,OAAOiV,MAAM1C;QACnDjT,SAASkT,wBAAwBrpD,QAAQ62C,OAAOiV,MAAMzC;QACtDlT,SAASwT,cAAc3pD,QAAQ62C,OAAOiV,MAAMnC;QAC5CxT,SAASyT,iBAAiB5pD,QAAQ62C,OAAOiV,MAAMlC;QAC/CzT,SAAS8T,eAAejqD,QAAQ62C,OAAOiV,MAAM7B;QAC7C9T,SAAS+T,kBAAkBlqD,QAAQ62C,OAAOiV,MAAM5B;;YAG3CytC,eAAe1pC,QAAQ6J;YACvB8/B,eAAe14B,cAAcG,aAAas4B,aAAa75B,KAAK3nB;MAClE8e,mBAAmBkgB,iBAAiBlnB;MACpCgH,mBAAmB2iC,eAAeA;aAC3B3pC;;IAGR,wCAAwC5yD,UAAU2hC;YAC3Ci4B,qBAAqBnM,WAAWnK,IAAItjD;MAC1C45D,mBAAmBuQ,iBAAiBxoC,WAAWwoC;MAC/CvQ,mBAAmB8O,aAAa/mC,WAAW+mC;MAC3C9O,mBAAmByP,WAAW1nC,WAAW0nC;MACzCzP,mBAAmB2M,oBAAoB5kC,WAAW4kC;MAClD3M,mBAAmBT,kBAAkBx3B,WAAW6kC;MAChD5M,mBAAmBsP,eAAevnC,WAAWunC;;IAG9C,oBAAoBn9C,QAAQjnB,OAAO9E,UAAUgvB;UACxClqB,MAAMssD,YAAY,MAAMtsD,QAAQ8wF;;MAEpClzE,SAAS6lE;YACHriF,MAAMpB,MAAMoB;YACZqnE,cAAcvtE,SAASwtE,yBAAyB1oE,MAAMyoE,cAAc;YACpE9rD,WAAWgzE,yBAAyB,OAAOJ,MAAMlqB,iBAAiBsqB,qBAAqBjvE,QAAQ/D;YAC/F2pB,SAASolB,SAASlN,IAAItjD,SAASorC,UAAUmiC;YACzCrE,eAAelpE,SAASymC,iBAAiB,QAAQzX,OAAOpvB,YAAYovB,OAAOpvB,SAAS4yC,WAAWtyC,SAAS8uB,OAAOpvB,SAAS4yC,WAAWtyC,MAAM6vC,aAAa;YACtJ6pB,qBAAqBnM,WAAWnK,IAAItjD;YACpCw7C,SAASu4C,mBAAmBtjC,MAAMjV;UAEpC+5C,qBAAqB;YACpBC,0BAA0B,QAAQzpE,WAAW4oE;gBAC1Ch7B,WAAW5tC,WAAW4oE,kBAAkB30F,SAASvG,OAAOi7F;;;;UAI9Dj5C,SAASie,SAAS15D,UAAU+rB,QAAQ4tC;;;;UAKlC6iC,qBAAqB;UAErBx8F,SAASmiB,YAAYy3C,mBAAmBupB;YACvCvpB,mBAAmBwiC,eAAexiC,mBAAmBqiC,uBAAuBzgD,OAAOiV,MAAMtuC;UAC5Fq6E,qBAAqB;mBACX5iC,mBAAmBuQ,mBAAmB1oD;UAChD+6E,qBAAqB;mBACXxtE,OAAOkS,mBAAmB04B,mBAAmB8O,eAAe;UACtE8zB,qBAAqB;oBACVxtE,OAAOkS,mBAAmB04B,mBAAmB8O,eAAe;UACvE8zB,qBAAqB;mBACXxtE,OAAO6S,iBAAiB+3B,mBAAmByP,aAAa;UAClEmzB,qBAAqB;oBACVxtE,OAAO6S,iBAAiB+3B,mBAAmByP,aAAa;UACnEmzB,qBAAqB;mBACX5iC,mBAAmBxuB,WAAWA;UACxCoxD,qBAAqB;mBACXx8F,SAASkG,OAAO0zD,mBAAmB1zD,QAAQA;UACrDs2F,qBAAqB;mBACX5iC,mBAAmB2M,sBAAsB7uE,cAAckiE,mBAAmB2M,sBAAsB9qB,SAASyd,aAAaU,mBAAmBT,oBAAoB1d,SAAS0d;UAChLqjC,qBAAqB;mBACX5iC,mBAAmBsP,iBAAiBA;UAC9CszB,qBAAqB;;;QAGtBA,qBAAqB;QACrB5iC,mBAAmBupB,YAAYnjF,SAASmiB;;;UAIrCywC,UAAUgH,mBAAmBkgB;UAE7B0iB,uBAAuB;QAC1B5pC,UAAU0oC,WAAWt7F,UAAU8E,OAAOkqB;;UAGnCytE,iBAAiB;UACjBC,kBAAkB;UAClBC,gBAAgB;YACdC,aAAahqC,QAAQ6J,eACxBogC,aAAajjC,mBAAmB9e;UAE/B2V,MAAMmsB,WAAWhqB,QAAQA;QAC5B6pC,iBAAiB;QACjBC,kBAAkB;QAClBC,gBAAgB;;UAGb38F,SAASvG,OAAOi7F;QACnBA,qBAAqB10F,SAASvG;QAC9BijG,kBAAkB;;UAGfD,kBAAkB9H,mBAAmB5oE;QACxC6wE,WAAWlgC,SAASujB,KAAK,oBAAoBl0D,OAAOE;YAEhDg2B,aAAasV;UAChBqlC,WAAWlgC,SAASujB,KAAK,iBAAiB,OAAOphF,KAAKrD,IAAIuwB,OAAOkP,MAAM,OAAOp8B,KAAKqX;;YAGhFy+E,mBAAmB5oE;UACtB4oE,iBAAiB5oE;;;;UAIjB2wE,kBAAkB;;UAElBC,gBAAgB;;;;YAKb38F,SAASq8C,oBAAoBr8C,SAASwxF,uBAAuBxxF,SAASsxF,sBAAsBtxF,SAASwtE,0BAA0BxtE,SAASorC;gBACrI0xD,UAAUF,WAAWhhG,IAAImhG;cAE3BD,YAAYplG;YACfolG,QAAQpgC,SAASujB,KAAK0V,SAASjoE,sBAAsB3B,OAAOK;;;YAI1DpsB,SAASwxF,uBAAuBxxF,SAASsxF,sBAAsBtxF,SAASoxF,yBAAyBpxF,SAAS4vC,uBAAuB5vC,SAASwtE,0BAA0BxtE,SAASq8C;UAChLugD,WAAWlgC,SAASujB,KAAK,kBAAkBl0D,OAAOixE,yBAAyB;;YAGxEh9F,SAASwxF,uBAAuBxxF,SAASsxF,sBAAsBtxF,SAASoxF,yBAAyBpxF,SAAS4vC,uBAAuB5vC,SAASwtE,0BAA0BxtE,SAASq8C,oBAAoBr8C,SAAS2yF,oBAAoB3jE,OAAO6S;UACxO+6D,WAAWlgC,SAASujB,KAAK,cAAcl0D,OAAOC;;;;;;UAO5CgD,OAAO6S;QACV+6D,WAAW94B,YAAYmc,KAAKjxD,QAAQ;QACpC4tE,WAAW94B,YAAYmc,KAAKjxD,QAAQ;cAC9BgT,WAAWhT,OAAOgT;YAEpBA;cACCigB,aAAawW;gBACZz2B,SAASi7D,gBAAgB,MAAMj7D,SAASk7D;YAC5CN,WAAWlgC,SAASujB,KAAK,eAAej+C,SAASi7D,aAAav6E;YAC9Dk6E,WAAWlgC,SAASujB,KAAK,mBAAmBj+C,SAASm7D;;YAErDP,WAAW94B,YAAYmc,KAAKj+C,UAAU;;;;UAKrC06D,mBAAmB9iC,mBAAmBz7B,kBAAkBnP,OAAOmP;QAClEy7B,mBAAmBz7B,gBAAgBnP,OAAOmP;QAC1Cy+D,WAAWlgC,SAASujB,KAAK,iBAAiBjxD,OAAOmP;;UAG9Cu+D;QACHE,WAAWlgC,SAASujB,KAAK,uBAAuBoU,MAAMD;YAElDx6B,mBAAmBwiC;;;;;;;;UAQtBgB,8BAA8BP,YAAYF;;;YAIvCz2F,OAAOlG,SAASkG;UACnB46B,UAAUgyD,mBAAmB+J,YAAY32F;;QAG1C46B,UAAUiyD,wBAAwB8J,YAAY78F,UAAUi1F,aAAaD,SAASS;QAC9E5xB,cAAcE,OAAOkc,KAAKrmB,mBAAmB2iC,cAAcM,YAAYn6E;;UAGpE1iB,SAASq8C,oBAAoBr8C,SAASi8C,uBAAuB;QAChE4nB,cAAcE,OAAOkc,KAAKrmB,mBAAmB2iC,cAAcM,YAAYn6E;QACvE1iB,SAASi8C,qBAAqB;;UAG3Bj8C,SAASyyF;QACZmK,WAAWlgC,SAASujB,KAAK,UAAUjxD,OAAOzT;;;MAI3CqhF,WAAWlgC,SAASujB,KAAK,mBAAmBjxD,OAAO4O;MACnDg/D,WAAWlgC,SAASujB,KAAK,gBAAgBjxD,OAAO6O;MAChD++D,WAAWlgC,SAASujB,KAAK,eAAejxD,OAAO5C;aACxCwmC;;;IAIR,uCAAuC9X,UAAUn2C;MAChDm2C,SAASwS,kBAAkBlqC,cAAcze;MACzCm2C,SAASyS,WAAWnqC,cAAcze;MAClCm2C,SAAS0S,kBAAkBpqC,cAAcze;MACzCm2C,SAAS4S,wBAAwBtqC,cAAcze;MAC/Cm2C,SAAS0T,YAAYprC,cAAcze;MACnCm2C,SAAS2T,kBAAkBrrC,cAAcze;MACzCm2C,SAASmT,WAAW7qC,cAAcze;MAClCm2C,SAASuT,iBAAiBjrC,cAAcze;MACxCm2C,SAASmU,eAAe7rC,cAAcze;MACtCm2C,SAASgU,iBAAiB1rC,cAAcze;;IAGzC,6BAA6B3E;aACrBA,SAASoxF,yBAAyBpxF,SAASsxF,sBAAsBtxF,SAASwxF,uBAAuBxxF,SAASwtE,0BAA0BxtE,SAAS2yF,oBAAoB3yF,SAASq8C,oBAAoBr8C,SAASw7C,WAAW;;IAG1N,KAAKs5B,oBAAoB;aACjByf;;IAGR,KAAKvf,uBAAuB;aACpBwf;;IAGR,KAAK31C,kBAAkB;aACf41C;;IAGR,KAAK31C,kBAAkB,UAAUZ,cAAc22B,iBAAiB,GAAGE,oBAAoB;MACtF0f,uBAAuBv2C;MACvBq2C,yBAAyB1f;MACzB2f,4BAA4Bzf;UAExB72B,gBAAgBuP,WAAWnK,IAAIpF,cAAcskC,uBAAuB9qF;QACvEgrB,SAAS8lE,kBAAkBtqC;;UAGxBs+B,cAAc;UACd0K,SAAS;UACTO,mBAAmB;UAEnBvpC;cACG14B,UAAU04B,aAAa14B;YAEzBA,QAAQ23C,mBAAmB33C,QAAQy3C;UACtCwqB,mBAAmB;;cAGdjF,qBAAqB/0B,WAAWnK,IAAIpF,cAAcskC;YAEpDtkC,aAAaC;UAChBq+B,cAAcgG,mBAAmB3N;UACjCqS,SAAS;mBACChpC,aAAa73B;UACvBm2D,cAAc/uB,WAAWnK,IAAIpF,cAAcykC;;UAE3CnG,cAAcgG;;QAGfoS,iBAAiB/7E,KAAKqlC,aAAa34B;QAEnCsvE,gBAAgBh8E,KAAKqlC,aAAa74B;QAElCyvE,sBAAsB52C,aAAa54B;;QAEnCsvE,iBAAiB/7E,KAAKi7D,WAAW5yE,eAAe+zF,aAAan2F;QAE7D+1F,gBAAgBh8E,KAAKu8E,UAAUl0F,eAAe+zF,aAAan2F;QAE3Dg2F,sBAAsBO;;YAGjBgI,mBAAmB5sC,MAAMgsB,gBAAgBwD,IAAIvD,aAAaF;UAE5D6gB,oBAAoBp7C,aAAapG;YAChCz4B,cAAc;YAEd86B;cACCA,aAAah4B;kBACVxD,WAAWw7B,aAAa14B;gBAE1B8vE,oBAAoBv7F,WAAW2oB,SAAS3oB,UAAUu7F,oBAAoB,OAAOrV,IAAI0H;uBAC3E7tF,IAAI,GAAGksB,KAAKtD,SAAS3oB,QAAQD,IAAIksB,IAAIlsB;gBAC7Cw7F,oBAAoBx7F,KAAKmmF,IAAI0H,oBAAoB7tF;;cAGlDw7F,oBAAoBv7F,SAAS2oB,SAAS3oB;cACtCqpB,cAAc;;;gBAGXkyE,oBAAoBv7F,WAAW,KAAKu7F,oBAAoB,OAAOrV,IAAI0H;cACtE2N,oBAAoB,KAAKrV,IAAI0H;cAC7B2N,oBAAoBv7F,SAAS;cAC7BqpB,cAAc;;;;cAIZkyE,oBAAoBv7F,WAAW,KAAKu7F,oBAAoB,OAAOrV,IAAIrB;YACtE0W,oBAAoB,KAAKrV,IAAIrB;YAC7B0W,oBAAoBv7F,SAAS;YAC7BqpB,cAAc;;;YAIZA;cACC6+B,aAAaC;YAChB+9B,IAAIpkC,YAAYy5C;;YAEhB55C,WAAW4H,IAAI,sBAAsBg6C,iBAAiBhI;;;;MAKzD7kC,MAAMlrC,SAASqvE;MACfnkC,MAAMprC,QAAQwvE;MACdpkC,MAAM2kB,eAAe0f;UAEjB5N;cACGrG,oBAAoBpzB,WAAWnK,IAAIpF,aAAa14B;QAEtDy6D,IAAIsG,qBAAqBtG,IAAIvD,aAAauD,IAAI0H,mBAAmB1H,IAAI7D,8BAA8BvH,gBAAgBgM,kBAAkBwB,gBAAgBtN;iBAC3I0S;cACJ5G,oBAAoBpzB,WAAWnK,IAAIpF,aAAa14B;cAChD+3E,QAAQ1oB,kBAAkB;QAEhCoL,IAAIud,wBAAwBvd,IAAIvD,aAAauD,IAAI0H,mBAAmB9G,kBAAkBwB,gBAAgBtN,qBAAqB,GAAGwoB;;;IAIhI,KAAKE,yBAAyB,UAAUv/C,cAAcx9C,GAAGG,GAAGwX,OAAOC,QAAQ25B,QAAQyrD;YAC5Ex/C,gBAAgBA,aAAan4B;QAClCpsB,QAAQa,MAAM;;;UAIXgiF,cAAc/uB,WAAWnK,IAAIpF,cAAcskC;UAE3CtkC,aAAaC,2BAA2Bu/C,wBAAwBhmG;QACnE8kF,cAAcA,YAAYkhB;;UAGvBlhB;QACH/rB,MAAMgsB,gBAAgBwD,IAAIvD,aAAaF;;gBAGhCh3D,UAAU04B,aAAa14B;gBACvBm4E,gBAAgBn4E,QAAQjE;gBACxB2iE,cAAc1+D,QAAQ1sB;cAExB6kG,kBAAkB9wF,cAAcqzE,MAAMkF,QAAQuY,mBAAmB1d,IAAI/vD,aAAa+vD,IAAI2d;YACzFjkG,QAAQa,MAAM;;;gBAITqjG,0BAA0B3Z,gBAAgB53E,kBAAkBovC,WAAWkb,IAAI,kCAAkC3U,aAAaC,YAAYxG,WAAWkb,IAAI;cAEvJstB,gBAAgBn4E,oBAAoBm0E,MAAMkF,QAAQlB,iBAAiBjE,IAAI/vD,aAAa+vD,IAAI6d;YAC1F5Z,gBAAgB73E,cAAc41C,aAAaC,YAAYxG,WAAWkb,IAAI,wBAAwBlb,WAAWkb,IAAI;WAC9GinC;YACAlkG,QAAQa,MAAM;;;cAIXylF,IAAI8d,uBAAuB9d,IAAIvD,iBAAiBuD,IAAI+d;;gBAEnDt9F,KAAK,KAAKA,KAAKw9C,aAAa7lC,QAAQA,SAASxX,KAAK,KAAKA,KAAKq9C,aAAa5lC,SAASA;cACrF2nE,IAAIge,WAAWv9F,GAAGG,GAAGwX,OAAOC,QAAQ4nE,MAAMkF,QAAQuY,gBAAgBzd,MAAMkF,QAAQlB,cAAcjyC;;;YAG/Ft4C,QAAQa,MAAM;;;;gBAITgiF,cAAciY,yBAAyB,OAAOhnC,WAAWnK,IAAImxC,sBAAsBjS,qBAAqB;UAC9G/xB,MAAMgsB,gBAAgBwD,IAAIvD,aAAaF;;;;IAK1C,KAAK0hB,2BAA2B,UAAUz9F,UAAU+kB,SAAS24E,QAAQ;YAC9DC,aAAav/F,KAAKgF,IAAI,IAAIs6F;YAC1B9lF,QAAQxZ,KAAKC,MAAM0mB,QAAQtF,MAAM7H,QAAQ+lF;YACzC9lF,SAASzZ,KAAKC,MAAM0mB,QAAQtF,MAAM5H,SAAS8lF;UAC7Cnd,WAAWf,MAAMkF,QAAQ5/D,QAAQjE;UAEjC0gC,aAAaC;;YAEZ++B,aAAahB,IAAIsB,KAAKN,WAAWhB,IAAIyB;YACrCT,aAAahB,IAAIjE,MAAMiF,WAAWhB,IAAI4B;;MAG3Cn/D,SAASykE,aAAa3hE,SAAS;MAE/By6D,IAAIoe,eAAepe,IAAI/D,YAAYiiB,OAAOld,UAAUxgF,SAASC,GAAGD,SAASI,GAAGwX,OAAOC,QAAQ;MAE3Fm4C,MAAMuvB;;IAGP,KAAKse,uBAAuB,UAAU79F,UAAU89F,YAAYC,YAAYL,QAAQ;YACzE9lF,QAAQkmF,WAAWr+E,MAAM7H;YACzBC,SAASimF,WAAWr+E,MAAM5H;YAC1B2oE,WAAWf,MAAMkF,QAAQoZ,WAAWj9E;YACpC2/D,SAAShB,MAAMkF,QAAQoZ,WAAW1lG;MACxC4pB,SAASykE,aAAaqX,YAAY;;;MAGlCve,IAAI0E,YAAY1E,IAAI2E,qBAAqB4Z,WAAWv8E;MAEpDg+D,IAAI0E,YAAY1E,IAAI4E,gCAAgC2Z,WAAWx8E;MAE/Di+D,IAAI0E,YAAY1E,IAAI6E,kBAAkB0Z,WAAWt8E;UAE7Cq8E,WAAWv7E;QACdi9D,IAAIwe,cAAcxe,IAAI/D,YAAYiiB,OAAO19F,SAASC,GAAGD,SAASI,GAAGwX,OAAOC,QAAQ2oE,UAAUC,QAAQqd,WAAWr+E,MAAMhpB;;YAE/GqnG,WAAWvY;UACd/F,IAAIye,wBAAwBze,IAAI/D,YAAYiiB,OAAO19F,SAASC,GAAGD,SAASI,GAAG09F,WAAW58E,QAAQ,GAAGtJ,OAAOkmF,WAAW58E,QAAQ,GAAGrJ,QAAQ2oE,UAAUsd,WAAW58E,QAAQ,GAAGzqB;;UAEtK+oF,IAAIwe,cAAcxe,IAAI/D,YAAYiiB,OAAO19F,SAASC,GAAGD,SAASI,GAAGogF,UAAUC,QAAQqd,WAAWr+E;;;;UAK5Fi+E,UAAU,KAAKK,WAAWz8E,iBAAiBk+D,IAAIW,eAAeX,IAAI/D;MACtEzrB,MAAMuvB;;IAGP,KAAK2e,yBAAyB,UAAUC,WAAWn+F,UAAU89F,YAAYC,YAAYL,QAAQ;UACxF9J,MAAM8B;QACTx8F,QAAQ0B,KAAK;;;aAKbgd,OACAC,QACAphB,QACGqnG,WAAWr+E;YACT+gE,WAAWf,MAAMkF,QAAQoZ,WAAWj9E;YACpC2/D,SAAShB,MAAMkF,QAAQoZ,WAAW1lG;UACpC+lG;UAEAL,WAAWrhC;QACdz6C,SAAS68C,aAAai/B,YAAY;QAClCK,WAAW5e,IAAIsD;iBACLib,WAAWvhC;QACrBv6C,SAAS+8C,kBAAkB++B,YAAY;QACvCK,WAAW5e,IAAIqD;;QAEf3pF,QAAQ0B,KAAK;;;MAId4kF,IAAI0E,YAAY1E,IAAI2E,qBAAqB4Z,WAAWv8E;MAEpDg+D,IAAI0E,YAAY1E,IAAI4E,gCAAgC2Z,WAAWx8E;MAE/Di+D,IAAI0E,YAAY1E,IAAI6E,kBAAkB0Z,WAAWt8E;YAE3C48E,eAAe7e,IAAI/vD,aAAa+vD,IAAI8e;YAEpCC,oBAAoB/e,IAAI/vD,aAAa+vD,IAAIgf;YAEzCC,mBAAmBjf,IAAI/vD,aAAa+vD,IAAIkf;YAExCC,iBAAiBnf,IAAI/vD,aAAa+vD,IAAIof;YAEtCC,mBAAmBrf,IAAI/vD,aAAa+vD,IAAIsf;MAE9Ctf,IAAI0E,YAAY1E,IAAI8e,mBAAmB1mF;MAEvC4nE,IAAI0E,YAAY1E,IAAIgf,qBAAqB3mF;MAEzC2nE,IAAI0E,YAAY1E,IAAIkf,oBAAoBP,UAAUhgG,IAAI8B;MAEtDu/E,IAAI0E,YAAY1E,IAAIof,kBAAkBT,UAAUhgG,IAAIiC;MAEpDo/E,IAAI0E,YAAY1E,IAAIsf,oBAAoBX,UAAUhgG,IAAIkC;MAEtDm/E,IAAIuf,cAAcX,UAAUV,OAAO19F,SAASC,GAAGD,SAASI,GAAGJ,SAASK,GAAG89F,UAAUjgG,IAAI+B,IAAIk+F,UAAUhgG,IAAI8B,IAAI,GAAGk+F,UAAUjgG,IAAIkC,IAAI+9F,UAAUhgG,IAAIiC,IAAI,GAAG+9F,UAAUjgG,IAAImC,IAAI89F,UAAUhgG,IAAIkC,IAAI,GAAGmgF,UAAUC,QAAQhqF;MAE9M+oF,IAAI0E,YAAY1E,IAAI8e,mBAAmBD;MAEvC7e,IAAI0E,YAAY1E,IAAIgf,qBAAqBD;MAEzC/e,IAAI0E,YAAY1E,IAAIkf,oBAAoBD;MAExCjf,IAAI0E,YAAY1E,IAAIof,kBAAkBD;MAEtCnf,IAAI0E,YAAY1E,IAAIsf,oBAAoBD;;UAGpCnB,UAAU,KAAKK,WAAWz8E,iBAAiBk+D,IAAIW,eAAeie;MAClEpuC,MAAMuvB;;IAGP,KAAK0E,cAAc,UAAUl/D;MAC5B9C,SAASykE,aAAa3hE,SAAS;MAC/BirC,MAAMuvB;;IAGP,KAAKyf,aAAa;MACjBlL,yBAAyB;MACzBC,4BAA4B;MAC5BC,uBAAuB;MACvBhkC,MAAMmF;MACNpD,cAAcoD;;eAGJ8pC,uBAAuB;MACjCA,mBAAmB5rF,kBAAkB6rF,YAAY;QAChDC,QAAQ;;;;EAMX,6BAA6BC;EAE7BC,eAAerkF,UAAU06E,mBAAmB;EAE5C;IACCj3F,YAAYgB,OAAO8wF,UAAU;MAC5B,KAAKhsF,OAAO;MACZ,KAAK9E,YAAYuvC,MAAMvvC;MACvB,KAAK8wF,UAAUA;;IAGhB1vF;iBACYy+F,QAAQ,KAAK7/F,OAAO,KAAK8wF;;IAGrCzuE;;;QAIEzpB,MAAM;QACNoH,OAAO,KAAKA,MAAMkpC;QAClB4nD,SAAS,KAAKA;;;;EAMjB+O,QAAQtkF,UAAUkyD,YAAY;EAE9B;IACCzuE,YAAYgB,OAAO86B,OAAO,GAAGC,MAAM;MAClC,KAAKj2B,OAAO;MACZ,KAAK9E,YAAYuvC,MAAMvvC;MACvB,KAAK86B,OAAOA;MACZ,KAAKC,MAAMA;;IAGZ35B;iBACY6E,IAAI,KAAKjG,OAAO,KAAK86B,MAAM,KAAKC;;IAG5C1Y;;;QAIEzpB,MAAM;QACNoH,OAAO,KAAKA,MAAMkpC;QAClBpO,MAAM,KAAKA;QACXC,KAAK,KAAKA;;;;EAMb90B,IAAIsV,UAAUs1E,QAAQ;EAEtB,oBAAoB1zD;IACnBn+B;MACC;MACA,KAAKpG,OAAO;MACZ,KAAK82D,aAAa;MAClB,KAAK2d,cAAc;MACnB,KAAKrnE,MAAM;MACX,KAAK2vF,mBAAmB;MACxB,KAAKjhB,aAAa;;iBAEP8qB,uBAAuB;QACjCA,mBAAmB5rF,kBAAkB6rF,YAAY;UAChDC,QAAQ;;;;IAMX/mF,KAAKyJ,QAAQggB;MACZ,MAAMzpB,KAAKyJ,QAAQggB;UACfhgB,OAAOstC,eAAe,MAAM,KAAKA,aAAattC,OAAOstC,WAAWtuD;UAChEghB,OAAOirD,gBAAgB,MAAM,KAAKA,cAAcjrD,OAAOirD,YAAYjsE;UACnEghB,OAAOpc,QAAQ,MAAM,KAAKA,MAAMoc,OAAOpc,IAAI5E;UAC3CghB,OAAOuzE,qBAAqB,MAAM,KAAKA,mBAAmBvzE,OAAOuzE,iBAAiBv0F;MACtF,KAAKszE,aAAatyD,OAAOsyD;MACzB,KAAK9yD,mBAAmBQ,OAAOR;aACxB;;IAGRS,OAAOC;YACAtrB,OAAO,MAAMqrB,OAAOC;UACtB,KAAKotC,eAAe,MAAM14D,KAAK83B,OAAO4gC,aAAa,KAAKA,WAAWrtC,OAAOC;UAC1E,KAAK+qD,gBAAgB,MAAMr2E,KAAK83B,OAAOu+C,cAAc,KAAKA,YAAYhrD,OAAOC;UAC7E,KAAKtc,QAAQ,MAAMhP,KAAK83B,OAAO9oB,MAAM,KAAKA,IAAIqc;aAC3CrrB;;;EAKTqO,MAAMkW,UAAU21C,UAAU;EAE1B;IACClyD,YAAY6U,OAAO0gD;MAClB,KAAK1gD,QAAQA;MACb,KAAK0gD,SAASA;MACd,KAAKvyD,QAAQ6R,UAAUrc,YAAYqc,MAAMha,SAAS06D,SAAS;MAC3D,KAAKxkB,QAAQt9B;MACb,KAAKu9B;QACJl1B,QAAQ;QACR9Y,QAAQ;;MAET,KAAKigB,UAAU;MACf,KAAKvN,OAAOwC;;IAGb+4B;QAEI/sB,YAAYze;UACXA,UAAU,MAAM,KAAKwd;;IAG1BiuB,SAASzrC;MACR,KAAKsrC,QAAQtrC;aACN;;IAGRkU,KAAKyJ;MACJ,KAAKvO,YAAYuO,OAAOvO,MAAM7U,YAAYojB,OAAOvO;MACjD,KAAK7R,QAAQogB,OAAOpgB;MACpB,KAAKuyD,SAASnyC,OAAOmyC;MACrB,KAAKxkB,QAAQ3tB,OAAO2tB;aACb;;IAGRI,OAAOC,QAAQn1B,WAAWo1B;MACzBD,UAAU,KAAKmkB;MACflkB,UAAUp1B,UAAUs5C;eAEX36D,IAAI,GAAGma,IAAI,KAAKwgD,QAAQ36D,IAAIma,GAAGna;QACvC,KAAKia,MAAMu8B,SAASx2C,KAAKqhB,UAAUpH,MAAMw8B,SAASz2C;;aAG5C;;IAGRmM,IAAItB,OAAOqW,SAAS;MACnB,KAAKjH,MAAM9N,IAAItB,OAAOqW;aACf;;IAGR1Z,MAAMpK;UACDA,KAAK8oG,iBAAiBtoG;QACzBR,KAAK8oG;;UAGF,KAAKjsF,MAAMk+B,OAAOguD,UAAUvoG;QAC/B,KAAKqc,MAAMk+B,OAAOguD,QAAQ7oF;;UAGvBlgB,KAAK8oG,aAAa,KAAKjsF,MAAMk+B,OAAOguD,WAAWvoG;QAClDR,KAAK8oG,aAAa,KAAKjsF,MAAMk+B,OAAOguD,SAAS,KAAKlsF,MAAMC,MAAM,GAAGi+B;;YAG5Dl+B,YAAY,KAAKA,MAAM7U,YAAYhI,KAAK8oG,aAAa,KAAKjsF,MAAMk+B,OAAOguD;YACvEC,SAAS,KAAKhhG,YAAY6U,OAAO,KAAK0gD;MAC5CyrC,GAAG9vD,SAAS,KAAKH;aACViwD;;IAGRhvD,SAASrmB;MACR,KAAKslB,mBAAmBtlB;aACjB;;IAGRtI,OAAOrrB;UACFA,KAAK8oG,iBAAiBtoG;QACzBR,KAAK8oG;;;UAIF,KAAKjsF,MAAMk+B,OAAOguD,UAAUvoG;QAC/B,KAAKqc,MAAMk+B,OAAOguD,QAAQ7oF;;UAGvBlgB,KAAK8oG,aAAa,KAAKjsF,MAAMk+B,OAAOguD,WAAWvoG;QAClDR,KAAK8oG,aAAa,KAAKjsF,MAAMk+B,OAAOguD,SAAS7jG,MAAMqf,UAAUzH,MAAMhd,SAAS26C,YAAY,KAAK59B,MAAMk+B;;;;QAKnGr9B,MAAM,KAAKA;QACXq9B,QAAQ,KAAKl+B,MAAMk+B,OAAOguD;QAC1BnnG,MAAM,KAAKib,MAAM7U,YAAY8F;QAC7ByvD,QAAQ,KAAKA;;;;EAMhB0rC,kBAAkB1kF,UAAU2kF,sBAAsB;QAE5CC,6BAA6B/gG;EAEnC;IACCJ,YAAYohG,mBAAmBvwD,UAAU/0B,QAAQw0B;MAChD,KAAKxqC,OAAO;MACZ,KAAK9N,OAAOopG;MACZ,KAAKvwD,WAAWA;MAChB,KAAK/0B,SAASA;MACd,KAAKw0B,aAAaA,eAAe;;QAG9BttC;aACI,KAAKhL,KAAKgL;;QAGd6R;aACI,KAAK7c,KAAK6c;;QAGdqP,YAAYze;MACf,KAAKzN,KAAKksB,cAAcze;;IAGzBgf,aAAa5O;eACHjb,IAAI,GAAGma,IAAI,KAAK/c,KAAKgL,OAAOpI,IAAIma,GAAGna;QAC3CumG,UAAU3/F,IAAI,KAAK0a,KAAKthB;QACxBumG,UAAUx/F,IAAI,KAAKwa,KAAKvhB;QACxBumG,UAAUv/F,IAAI,KAAKkkB,KAAKlrB;QAExBumG,UAAU18E,aAAa5O;QAEvB,KAAKi8B,OAAOl3C,GAAGumG,UAAU3/F,GAAG2/F,UAAUx/F,GAAGw/F,UAAUv/F;;aAG7C;;IAGRuqB,kBAAkBtW;eACRjb,IAAI,GAAGma,IAAI,KAAK/R,OAAOpI,IAAIma,GAAGna;QACtCumG,UAAU3/F,IAAI,KAAK0a,KAAKthB;QACxBumG,UAAUx/F,IAAI,KAAKwa,KAAKvhB;QACxBumG,UAAUv/F,IAAI,KAAKkkB,KAAKlrB;QAExBumG,UAAUh1E,kBAAkBtW;QAE5B,KAAKi8B,OAAOl3C,GAAGumG,UAAU3/F,GAAG2/F,UAAUx/F,GAAGw/F,UAAUv/F;;aAG7C;;IAGRurB,mBAAmBtX;eACTjb,IAAI,GAAGma,IAAI,KAAK/R,OAAOpI,IAAIma,GAAGna;QACtCumG,UAAU3/F,IAAI,KAAK0a,KAAKthB;QACxBumG,UAAUx/F,IAAI,KAAKwa,KAAKvhB;QACxBumG,UAAUv/F,IAAI,KAAKkkB,KAAKlrB;QAExBumG,UAAUh0E,mBAAmBtX;QAE7B,KAAKi8B,OAAOl3C,GAAGumG,UAAU3/F,GAAG2/F,UAAUx/F,GAAGw/F,UAAUv/F;;aAG7C;;IAGR2X,KAAK7E,OAAOlT;MACX,KAAKxJ,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,UAAUta;aACnD;;IAGRgY,KAAK9E,OAAO/S;MACX,KAAK3J,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,SAAS,KAAKna;aACvD;;IAGR4iB,KAAK7P,OAAO9S;MACX,KAAK5J,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,SAAS,KAAKla;aACvD;;IAGR4iB,KAAK9P,OAAOkF;MACX,KAAK5hB,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,SAAS,KAAKlC;aACvD;;IAGRsC,KAAKxH;aACG,KAAK1c,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C;;IAGxDK,KAAKzH;aACG,KAAK1c,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,SAAS;;IAGjEgK,KAAKpR;aACG,KAAK1c,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,SAAS;;IAGjEiK,KAAKrR;aACG,KAAK1c,KAAK6c,MAAMH,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C,SAAS;;IAGjE+1B,MAAMn9B,OAAOlT,GAAGG;MACf+S,QAAQA,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C;MACxC,KAAK9jB,KAAK6c,MAAMH,QAAQ,KAAKlT;MAC7B,KAAKxJ,KAAK6c,MAAMH,QAAQ,KAAK/S;aACtB;;IAGRmwC,OAAOp9B,OAAOlT,GAAGG,GAAGC;MACnB8S,QAAQA,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C;MACxC,KAAK9jB,KAAK6c,MAAMH,QAAQ,KAAKlT;MAC7B,KAAKxJ,KAAK6c,MAAMH,QAAQ,KAAK/S;MAC7B,KAAK3J,KAAK6c,MAAMH,QAAQ,KAAK9S;aACtB;;IAGRmwC,QAAQr9B,OAAOlT,GAAGG,GAAGC,GAAGgY;MACvBlF,QAAQA,QAAQ,KAAK1c,KAAKu9D,SAAS,KAAKz5C;MACxC,KAAK9jB,KAAK6c,MAAMH,QAAQ,KAAKlT;MAC7B,KAAKxJ,KAAK6c,MAAMH,QAAQ,KAAK/S;MAC7B,KAAK3J,KAAK6c,MAAMH,QAAQ,KAAK9S;MAC7B,KAAK5J,KAAK6c,MAAMH,QAAQ,KAAKkF;aACtB;;IAGRxX,MAAMpK;UACDA,SAASQ;QACZiC,QAAQ6B,IAAI;cACNuY;iBAEGja,IAAI,GAAGA,IAAI,KAAKoI,OAAOpI;gBACzB8Z,QAAQ9Z,IAAI,KAAK5C,KAAKu9D,SAAS,KAAKz5C;mBAEjCiX,IAAI,GAAGA,IAAI,KAAK8d,UAAU9d;YAClCle,MAAMvc,KAAK,KAAKN,KAAK6c,MAAMH,QAAQqe;;;mBAI1Bkf,oBAAoB,KAAKp9B,MAAM7U,YAAY6U,QAAQ,KAAKg8B,UAAU,KAAKP;;YAE9Et4C,KAAKqpG,uBAAuB7oG;UAC/BR,KAAKqpG;;YAGFrpG,KAAKqpG,mBAAmB,KAAKrpG,KAAK0d,UAAUld;UAC/CR,KAAKqpG,mBAAmB,KAAKrpG,KAAK0d,QAAQ,KAAK1d,KAAKoK,MAAMpK;;mBAGhDspG,2BAA2BtpG,KAAKqpG,mBAAmB,KAAKrpG,KAAK0d,OAAO,KAAKm7B,UAAU,KAAK/0B,QAAQ,KAAKw0B;;;IAIlHjtB,OAAOrrB;UACFA,SAASQ;QACZiC,QAAQ6B,IAAI;cACNuY;iBAEGja,IAAI,GAAGA,IAAI,KAAKoI,OAAOpI;gBACzB8Z,QAAQ9Z,IAAI,KAAK5C,KAAKu9D,SAAS,KAAKz5C;mBAEjCiX,IAAI,GAAGA,IAAI,KAAK8d,UAAU9d;YAClCle,MAAMvc,KAAK,KAAKN,KAAK6c,MAAMH,QAAQqe;;;;;UAMpC8d,UAAU,KAAKA;UACfj3C,MAAM,KAAKib,MAAM7U,YAAY8F;UAC7B+O,OAAOA;UACPy7B,YAAY,KAAKA;;;;YAIdt4C,KAAKqpG,uBAAuB7oG;UAC/BR,KAAKqpG;;YAGFrpG,KAAKqpG,mBAAmB,KAAKrpG,KAAK0d,UAAUld;UAC/CR,KAAKqpG,mBAAmB,KAAKrpG,KAAK0d,QAAQ,KAAK1d,KAAKqrB,OAAOrrB;;;UAI3DmsD,8BAA8B;UAC9BtT,UAAU,KAAKA;UACf74C,MAAM,KAAKA,KAAK0d;UAChBoG,QAAQ,KAAKA;UACbw0B,YAAY,KAAKA;;;;;EAOrBgxD,2BAA2B/kF,UAAU4nC,+BAA+B;;;;;;;;;;EAYpE,6BAA6B1W;IAC5BztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;MACvB,KAAK7zC,MAAM;MACX,KAAKuuC,WAAW;MAChB,KAAKznC,WAAW;MAChB,KAAKspC,kBAAkB;MACvB,KAAKrF,cAAc;MACnB,KAAKmC,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKtE,MAAM0mB,OAAO1mB;MAClB,KAAKuuC,WAAW7nB,OAAO6nB;MACvB,KAAKznC,WAAW4f,OAAO5f;MACvB,KAAKspC,kBAAkB1pB,OAAO0pB;aACvB;;;EAKTihC,eAAexxD,UAAUg3E,mBAAmB;MAExCgO;QAEEC,mCAAmCphG;QAEnCqhG,+BAA+BrhG;QAE/BshG,+BAA+BthG;QAE/BuhG,oCAAoCrlF;QAEpCslF,oCAAoCtlF;QAEpCulF,oCAAoCtqE;QAEpCuqE,uBAAuB1hG;QAEvB2hG,uBAAuB3hG;QAEvB4hG,uBAAuB5hG;QAEvB6hG,wBAAwB3lF;QAExB4lF,wBAAwB5lF;QAExB6lF,wBAAwB7lF;EAE9B,qBAAqB6hB;IACpBn+B,YAAYc;MACX;MACA,KAAKlH,OAAO;UAER2nG,cAAc/oG;QACjB+oG,gBAAgB7pD;cACV0qD,mBAAmBxvD,eAAe,MAAM,KAAK,GAAG,GAAG,GAAG,MAAM,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,GAAG,GAAG,IAAI,KAAK,KAAK,GAAG,GAAG;cAC9GwuD,wBAAwBH,kBAAkBmB,cAAc;QAE9Db,UAAU3tD,UAAU,GAAG,GAAG,GAAG,GAAG,GAAG;QAEnC2tD,UAAU3jG,aAAa,gBAAgB0jG,2BAA2BF,mBAAmB,GAAG,GAAG;QAE3FG,UAAU3jG,aAAa,UAAU0jG,2BAA2BF,mBAAmB,GAAG,GAAG;;MAGtF,KAAK1gG,WAAW6gG;MAChB,KAAKzgG,WAAWA,aAAatI,YAAYsI,eAAeitE;MACxD,KAAK1xD,aAAaC,QAAQ,KAAK;;IAGhC6kB,QAAQsY,WAAWC;UACdD,UAAU5sB,WAAW;QACxBpyB,QAAQa,MAAM;;MAGfmmG,YAAYhzE,mBAAmB,KAAKvB;MAEpC20E,iBAAiBloF,KAAK8/B,UAAU5sB,OAAOK;MAEvC,KAAKwR,gBAAgB9gB,iBAAiB67B,UAAU5sB,OAAOC,oBAAoB,KAAKI;MAEhFw0E,YAAYlzE,sBAAsB,KAAKkQ;UAEnC+a,UAAU5sB,OAAOkyB,uBAAuB,KAAKj+C,SAASgsC,oBAAoB;QAC7E20D,YAAYz/F,gBAAgB0/F,YAAY9/F;;YAGnC4B,WAAW,KAAK1C,SAAS0C;UAC3B/B,KAAKC;UAEL8B,aAAa;QAChB9B,MAAM/B,KAAK+B,IAAI8B;QACf/B,MAAM9B,KAAK8B,IAAI+B;;YAGV6Y,SAAS,KAAKA;MACpBgmF,gBAAgBP,IAAI/6F,KAAK,MAAM,KAAK,IAAI26F,aAAarlF,QAAQolF,aAAahgG,KAAKC;MAC/E2gG,gBAAgBN,IAAIh7F,IAAI,MAAM,KAAK,IAAI26F,aAAarlF,QAAQolF,aAAahgG,KAAKC;MAC9E2gG,gBAAgBL,IAAIj7F,IAAI,KAAK,KAAK,IAAI26F,aAAarlF,QAAQolF,aAAahgG,KAAKC;MAE7EugG,KAAKl7F,IAAI,GAAG;MAEZm7F,KAAKn7F,IAAI,GAAG;MAEZo7F,KAAKp7F,IAAI,GAAG;;UAGRyrB,YAAYinB,UAAUnlB,IAAImC,kBAAkBqrE,KAAKC,KAAKC,KAAK,OAAOR;UAElEhvE,cAAc;;QAEjB6vE,gBAAgBN,IAAIh7F,KAAK,KAAK,KAAK,IAAI26F,aAAarlF,QAAQolF,aAAahgG,KAAKC;QAE9EwgG,KAAKn7F,IAAI,GAAG;QAEZyrB,YAAYinB,UAAUnlB,IAAImC,kBAAkBqrE,KAAKE,KAAKD,KAAK,OAAOP;YAE9DhvE,cAAc;;;;YAKb9tB,WAAW+0C,UAAUnlB,IAAI31B,OAAOmF,WAAW09F;UAC7C98F,WAAW+0C,UAAU3d,QAAQp3B,WAAW+0C,UAAU1d;MACtD2d,WAAWphD;QACVoM,UAAUA;QACV0rB,OAAOoxE,gBAAgBp/F;QACvB6hB,IAAI2iB,SAASZ,MAAMw7D,iBAAiBM,KAAKC,KAAKC,KAAKC,MAAMC,MAAMC,UAAU7lF;QACzE09B,MAAM;QACNlqB,QAAQ;;;IAIVnW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;UACPA,OAAO/G,WAAW7jB,WAAW,KAAK6jB,OAAO1C,KAAKyJ,OAAO/G;MACzD,KAAKvb,WAAWsiB,OAAOtiB;aAChB;;;EAKTwhG,OAAO/lF,UAAU0/E,WAAW;EAE5B,yBAAyBsG,gBAAgBC,YAAYnmF,QAAQmE,OAAO/e,KAAKC;;IAExEigG,iBAAiB19F,WAAWs+F,gBAAgBlmF,QAAQvC,UAAU,KAAKI,SAASsG;;QAGxE/e,QAAQjJ;MACXopG,iBAAiBpgG,IAAIE,MAAMigG,iBAAiBngG,IAAIC,MAAMkgG,iBAAiBhgG;MACvEigG,iBAAiBjgG,IAAIF,MAAMkgG,iBAAiBngG,IAAIE,MAAMigG,iBAAiBhgG;;MAEvEigG,iBAAiBjoF,KAAKgoF;;IAGvBY,eAAe5oF,KAAK6oF;IACpBD,eAAe/gG,KAAKogG,iBAAiBpgG;IACrC+gG,eAAe5gG,KAAKigG,iBAAiBjgG;;IAErC4gG,eAAe99E,aAAao9E;;QAGvBY,yBAAyBriG;QAEzBsiG,yBAAyBtiG;EAE/B,kBAAkB+9B;IACjBn+B;MACC;MACA,KAAK2iG,gBAAgB;MACrB,KAAK/oG,OAAO;MACZme,OAAOwmB,iBAAiB;QACvBqkE;UACCnkE,YAAY;UACZh5B;;QAEDk3F;UACCl3F,OAAO;;;MAGT,KAAKiwE,aAAa;;IAGnB/7D,KAAKyJ;MACJ,MAAMzJ,KAAKyJ,QAAQ;YACbw/E,SAASx/E,OAAOw/E;eAEbhoG,IAAI,GAAGma,IAAI6tF,OAAO/nG,QAAQD,IAAIma,GAAGna;cACnCqkG,QAAQ2D,OAAOhoG;QACrB,KAAKioG,SAAS5D,MAAMnvE,OAAO1tB,SAAS68F,MAAMv6F;;MAG3C,KAAKgxE,aAAatyD,OAAOsyD;aAClB;;IAGRmtB,SAAS/yE,QAAQprB,WAAW;MAC3BA,WAAW/E,KAAK4W,IAAI7R;YACdk+F,SAAS,KAAKA;UAChB7tF;WAECA,IAAI,GAAGA,IAAI6tF,OAAO/nG,QAAQka;YAC1BrQ,WAAWk+F,OAAO7tF,GAAGrQ;;;;MAK1Bk+F,OAAOjuF,OAAOI,GAAG;QAChBrQ,UAAUA;QACVorB,QAAQA;;MAET,KAAK7tB,IAAI6tB;aACF;;IAGRgzE;aACQ,KAAKH;;IAGbI,qBAAqBr+F;YACdk+F,SAAS,KAAKA;UAEhBA,OAAO/nG,SAAS;YACfD,GAAGma;cAEFna,IAAI,GAAGma,IAAI6tF,OAAO/nG,SAAQD,IAAIma,GAAGna;cACjC8J,WAAWk+F,OAAOhoG,GAAG8J;;;;eAKnBk+F,OAAOhoG,IAAI,GAAGk1B;;aAGf;;IAGRqR,QAAQsY,WAAWC;YACZkpD,SAAS,KAAKA;UAEhBA,OAAO/nG,SAAS;QACnB4nG,MAAMj0E,sBAAsB,KAAKtB;cAE3BxoB,WAAW+0C,UAAUnlB,IAAI31B,OAAOmF,WAAW2+F;QACjD,KAAKM,qBAAqBr+F,UAAUy8B,QAAQsY,WAAWC;;;IAIzDnwB,OAAOsD;YACA+1E,SAAS,KAAKA;UAEhBA,OAAO/nG,SAAS;QACnB4nG,MAAMj0E,sBAAsB3B,OAAOK;QAEnCw1E,MAAMl0E,sBAAsB,KAAKtB;cAE3BxoB,WAAW+9F,MAAM3+F,WAAW4+F,SAAS71E,OAAO0wB;QAClDqlD,OAAO,GAAG9yE,OAAOiP,UAAU;YACvBnkC,GAAGma;cAEFna,IAAI,GAAGma,IAAI6tF,OAAO/nG,SAAQD,IAAIma,GAAGna;cACjC8J,YAAYk+F,OAAOhoG,GAAG8J;YACzBk+F,OAAOhoG,IAAI,GAAGk1B,OAAOiP,UAAU;YAC/B6jE,OAAOhoG,GAAGk1B,OAAOiP,UAAU;;;;;QAM7B,KAAK4jE,gBAAgB/nG,IAAI;eAElBA,IAAIma,GAAGna;UACbgoG,OAAOhoG,GAAGk1B,OAAOiP,UAAU;;;;IAK9B1b,OAAOC;YACAtrB,OAAO,MAAMqrB,OAAOC;UACtB,KAAKoyD,eAAe,OAAO19E,KAAK83B,OAAO4lD,aAAa;MACxD19E,KAAK83B,OAAO8yE;YACNA,SAAS,KAAKA;eAEXhoG,IAAI,GAAGma,IAAI6tF,OAAO/nG,QAAQD,IAAIma,GAAGna;cACnCqkG,QAAQ2D,OAAOhoG;QACrB5C,KAAK83B,OAAO8yE,OAAOtqG;UAClBw3B,QAAQmvE,MAAMnvE,OAAOpa;UACrBhR,UAAUu6F,MAAMv6F;;;aAIX1M;;;QAKHgrG,iCAAiC5iG;QAEjC6iG,8BAA8Bj9E;QAE9Bk9E,+BAA+Bl9E;QAE/Bm9E,6BAA6B/iG;QAE7BgjG,2BAA2B7rE;EAEjC,0BAA0Br2B;IACzBlB,YAAYU,UAAUI;MACrB,MAAMJ,UAAUI;MAChB,KAAKlH,OAAO;MACZ,KAAKgpC,WAAW;MAChB,KAAKC,iBAAiBtL;MACtB,KAAK8rE,wBAAwB9rE;;IAG9B5d,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKwf,WAAWxf,OAAOwf;MACvB,KAAKC,WAAWlpB,KAAKyJ,OAAOyf;MAC5B,KAAKwgE,kBAAkB1pF,KAAKyJ,OAAOigF;MACnC,KAAKvgE,WAAW1f,OAAO0f;aAChB;;IAGRwgE,KAAKxgE,UAAUD;MACd,KAAKC,WAAWA;UAEZD,eAAerqC;QAClB,KAAK+oC,kBAAkB;QACvB,KAAKuB,SAASygE;QACd1gE,aAAa,KAAK3V;;MAGnB,KAAK2V,WAAWlpB,KAAKkpB;MACrB,KAAKwgE,kBAAkB1pF,KAAKkpB,YAAYxjB;;IAGzC0uE;MACC,KAAKjrD,SAASirD;;IAGfyV;YACOlzE,aAAatK;YACby9E,aAAa,KAAK/iG,SAAS4yC,WAAWmwD;eAEnC7oG,IAAI,GAAGma,IAAI0uF,WAAWzgG,OAAOpI,IAAIma,GAAGna;QAC5C01B,OAAO9uB,IAAIiiG,WAAWvnF,KAAKthB;QAC3B01B,OAAO3uB,IAAI8hG,WAAWtnF,KAAKvhB;QAC3B01B,OAAO1uB,IAAI6hG,WAAW39E,KAAKlrB;QAC3B01B,OAAO1W,IAAI6pF,WAAW19E,KAAKnrB;cACrB4lB,QAAQ,MAAM8P,OAAOtV;YAEvBwF,UAAUqO;UACbyB,OAAOtuB,eAAewe;;UAEtB8P,OAAOvpB,IAAI,GAAG,GAAG,GAAG;;QAGrB08F,WAAW1xD,QAAQn3C,GAAG01B,OAAO9uB,GAAG8uB,OAAO3uB,GAAG2uB,OAAO1uB,GAAG0uB,OAAO1W;;;IAI7D2nB,kBAAkBC;MACjB,MAAMD,kBAAkBC;UAEpB,KAAKoB,aAAa;QACrB,KAAKygE,kBAAkB1pF,KAAK,KAAKuT,aAAa7N;iBACpC,KAAKujB,aAAa;QAC5B,KAAKygE,kBAAkB1pF,KAAK,KAAKkpB,YAAYxjB;;QAE7C5kB,QAAQ0B,KAAK,+CAA+C,KAAKymC;;;IAInEwX,cAAc1lC,OAAOtQ;YACd0+B,WAAW,KAAKA;YAChBpiC,WAAW,KAAKA;MAEtBuiG,WAAWjnF,oBAAoBtb,SAAS4yC,WAAWowD,WAAWhvF;MAE9DwuF,YAAYlnF,oBAAoBtb,SAAS4yC,WAAWmwD,YAAY/uF;MAEhEsuF,cAAchnF,oBAAoBtb,SAAS4yC,WAAW/xC,UAAUmT,OAAO+P,aAAa,KAAKoe;MAEzFz+B,OAAO2C,IAAI,GAAG,GAAG;eAERnM,IAAI,GAAGA,IAAI,GAAGA;cAChB+oG,SAAST,YAAYxpF,aAAa9e;YAEpC+oG,WAAW;gBACRC,YAAYX,WAAWvpF,aAAa9e;UAE1CwoG,QAAQxlF,iBAAiBklB,SAASmrC,MAAM21B,WAAW12E,aAAa4V,SAAS+gE,aAAaD;UAEtFx/F,OAAO2V,gBAAgBopF,UAAUxpF,KAAKqpF,eAAev+E,aAAa2+E,UAAUO;;;aAIvEv/F,OAAOqgB,aAAa,KAAK4+E;;;EAKlCS,YAAYvnF,UAAUomB,gBAAgB;EAEtC,mBAAmBxE;IAClBn+B;MACC;MACA,KAAKpG,OAAO;;;EAKdmqG,KAAKxnF,UAAUynF,SAAS;EAExB,0BAA0BniF;IACzB7hB,YAAYhI,MAAMmhB,OAAOC,QAAQiJ,QAAQzoB,MAAMmoB,SAASE,OAAOC,OAAOC,WAAWC,WAAWE,YAAYC;MACvG,MAAM,MAAMR,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB,YAAYC;MACnF,KAAKvB;QACJhpB,MAAMA,QAAQ;QACdmhB,OAAOA,SAAS;QAChBC,QAAQA,UAAU;;MAEnB,KAAK+I,YAAYA,cAAc3pB,YAAY2pB,YAAYhW;MACvD,KAAKiW,YAAYA,cAAc5pB,YAAY4pB,YAAYjW;MACvD,KAAK0W,kBAAkB;MACvB,KAAKE,QAAQ;MACb,KAAKC,kBAAkB;MACvB,KAAKkB,cAAc;;;EAKrB+/E,YAAY1nF,UAAUuH,gBAAgB;QAEhCogF,iCAAiC3sE;QAEjC4sE,mCAAmC5sE;EAEzC;IACCv3B,YAAYiuE,YAAY41B;MACvB,KAAKnuF,OAAOwC;MACZ,KAAK+1D,QAAQA,MAAMn5D,MAAM;MACzB,KAAK+uF,eAAeA;MACpB,KAAKO,eAAe;MACpB,KAAKrG,cAAc;MACnB,KAAKE,kBAAkB;MACvB,KAAKz7C,SAAS;MACd,KAAK0X;;IAGNA;YACO+T,QAAQ,KAAKA;YACb41B,eAAe,KAAKA;MAC1B,KAAKO,mBAAmBxxD,aAAaq7B,MAAMpzE,SAAS;;UAEhDgpG,aAAahpG,WAAW;QAC3B,KAAK0oG;;;YAGDt1B,MAAMpzE,WAAWgpG,aAAahpG;UACjCJ,QAAQ0B,KAAK;UACb,KAAK0nG;mBAEIjpG,IAAI,GAAGksB,KAAK,KAAKmnD,MAAMpzE,QAAQD,IAAIksB,IAAIlsB;YAC/C,KAAKipG,aAAavrG,SAASi/B;;;;;IAM/BgsE;MACC,KAAKM,aAAahpG,SAAS;eAElBD,IAAI,GAAGksB,KAAK,KAAKmnD,MAAMpzE,QAAQD,IAAIksB,IAAIlsB;cACzCypG,cAAc9sE;YAEhB,KAAK02C,MAAMrzE;UACdypG,QAAQ1qF,KAAK,KAAKs0D,MAAMrzE,GAAGsyB,aAAa7N;;QAGzC,KAAKwkF,aAAavrG,KAAK+rG;;;IAIzBtW;;eAEUnzF,IAAI,GAAGksB,KAAK,KAAKmnD,MAAMpzE,QAAQD,IAAIksB,IAAIlsB;cACzC0pG,OAAO,KAAKr2B,MAAMrzE;YAEpB0pG;UACHA,KAAKp3E,YAAYvT,KAAK,KAAKkqF,aAAajpG,IAAIykB;;;;eAKrCzkB,IAAI,GAAGksB,KAAK,KAAKmnD,MAAMpzE,QAAQD,IAAIksB,IAAIlsB;cACzC0pG,OAAO,KAAKr2B,MAAMrzE;YAEpB0pG;cACCA,KAAKrrG,UAAUqrG,KAAKrrG,OAAO+qG;YAC9BM,KAAK3jF,OAAOhH,KAAK2qF,KAAKrrG,OAAOi0B,aAAa7N;YAC1CilF,KAAK3jF,OAAOzG,SAASoqF,KAAKp3E;;YAE1Bo3E,KAAK3jF,OAAOhH,KAAK2qF,KAAKp3E;;UAGvBo3E,KAAK3jF,OAAOya,UAAUkpE,KAAK/iG,UAAU+iG,KAAKl7E,YAAYk7E,KAAK9jF;;;;IAK9D+I;YACO0kD,QAAQ,KAAKA;YACb41B,eAAe,KAAKA;YACpBO,eAAe,KAAKA;YACpBrG,cAAc,KAAKA;;eAEhBnjG,IAAI,GAAGksB,KAAKmnD,MAAMpzE,QAAQD,IAAIksB,IAAIlsB;;cAEpC+lB,SAASstD,MAAMrzE,KAAKqzE,MAAMrzE,GAAGsyB,cAAci3E;QAEjDD,cAActmF,iBAAiB+C,QAAQkjF,aAAajpG;QAEpDspG,cAAcnoF,QAAQqoF,cAAcxpG,IAAI;;UAGrCmjG,gBAAgB;QACnBA,YAAY75E,cAAc;;;IAI5B9hB;iBACYmiG,SAAS,KAAKt2B,OAAO,KAAK41B;;IAGtC7F;;;;;;;UAOKj5F,OAAOpF,KAAKob,KAAK,KAAKkzD,MAAMpzE,SAAS;;MAEzCkK,OAAOiU,eAAejU;MACtBA,OAAOpF,KAAKF,IAAIsF,MAAM;YAChBq/F,mBAAmBxxD,aAAa7tC,OAAOA,OAAO;;MAEpDq/F,aAAar9F,IAAI,KAAKq9F;;YAEhBrG,kBAAkBkG,YAAYG,cAAcr/F,MAAMA,MAAM4I,YAAYR;MAC1E,KAAKi3F,eAAeA;MACpB,KAAKrG,cAAcA;MACnB,KAAKE,kBAAkBl5F;aAChB;;IAGRy/F,cAAc1+F;eACJlL,IAAI,GAAGksB,KAAK,KAAKmnD,MAAMpzE,QAAQD,IAAIksB,IAAIlsB;cACzC0pG,OAAO,KAAKr2B,MAAMrzE;YAEpB0pG,KAAKx+F,SAASA;iBACVw+F;;;aAIF9rG;;IAGRD;UACK,KAAKwlG,gBAAgB;QACxB,KAAKA,YAAYxlG;QACjB,KAAKwlG,cAAc;;;IAIrB0G,SAASC,MAAMz2B;MACd,KAAKv4D,OAAOgvF,KAAKhvF;eAER9a,IAAI,GAAGma,IAAI2vF,KAAKz2B,MAAMpzE,QAAQD,IAAIma,GAAGna;cACvC8a,OAAOgvF,KAAKz2B,MAAMrzE;YACpB0pG,OAAOr2B,MAAMv4D;YAEb4uF,SAAS9rG;UACZiC,QAAQ0B,KAAK,4CAA4CuZ;UACzD4uF,WAAWP;;QAGZ,KAAK91B,MAAM31E,KAAKgsG;QAChB,KAAKT,aAAavrG,SAASi/B,UAAU1b,UAAU6oF,KAAKb,aAAajpG;;MAGlE,KAAKs/D;aACE;;IAGR72C;YACOrrB;QACLyrB;UACCR,SAAS;UACTrpB,MAAM;UACN8pB,WAAW;;QAEZuqD;QACA41B;;MAED7rG,KAAK0d,OAAO,KAAKA;YACXu4D,QAAQ,KAAKA;YACb41B,eAAe,KAAKA;eAEjBjpG,IAAI,GAAGma,IAAIk5D,MAAMpzE,QAAQD,IAAIma,GAAGna;cAClC0pG,OAAOr2B,MAAMrzE;QACnB5C,KAAKi2E,MAAM31E,KAAKgsG,KAAK5uF;cACfivF,cAAcd,aAAajpG;QACjC5C,KAAK6rG,aAAavrG,KAAKqsG,YAAY5oF;;aAG7B/jB;;;QAKH4sG,wCAAwCrtE;QAExCstE,wCAAwCttE;QAExCutE;QAEAC,yBAAyB7jG;EAE/B,4BAA4BA;IAC3BlB,YAAYU,UAAUI,UAAUkC;MAC/B,MAAMtC,UAAUI;MAChB,KAAKmhC,qBAAqBgQ,oBAAoBW,aAAa5vC,QAAQ,KAAK;MACxE,KAAKk/B,gBAAgB;MACrB,KAAKl/B,QAAQA;MACb,KAAKk8B,gBAAgB;;IAGtBvlB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK6e,eAAetoB,KAAKyJ,OAAO6e;UAC5B7e,OAAO8e,kBAAkB,MAAM,KAAKA,gBAAgB9e,OAAO8e,cAAc9/B;MAC7E,KAAKY,QAAQogB,OAAOpgB;aACb;;IAGRgiG,WAAWtwF,OAAO1T;MACjBA,MAAM6a,UAAU,KAAKqmB,cAAcrtB,OAAOH,QAAQ;;IAGnDuwF,YAAYvwF,OAAOiM;MAClBA,OAAO9E,UAAU,KAAKomB,eAAeptB,OAAOH,QAAQ;;IAGrDysB,QAAQsY,WAAWC;YACZxsB,cAAc,KAAKA;YACnBg4E,eAAe,KAAKliG;MAC1B+hG,MAAMrkG,WAAW,KAAKA;MACtBqkG,MAAMjkG,WAAW,KAAKA;UAClBikG,MAAMjkG,aAAatI;eAEd2sG,aAAa,GAAGA,aAAaD,cAAcC;;QAEnD,KAAKF,YAAYE,YAAYP;QAE7BC,qBAAqBjnF,iBAAiBsP,aAAa03E;;QAGnDG,MAAM73E,cAAc23E;QAEpBE,MAAM5jE,QAAQsY,WAAWqrD;;iBAGhBlqG,IAAI,GAAGma,IAAI+vF,oBAAoBjqG,QAAQD,IAAIma,GAAGna;gBAChD43B,YAAYsyE,oBAAoBlqG;UACtC43B,UAAU2yE,aAAaA;UACvB3yE,UAAU1C,SAAS;UACnB4pB,WAAWphD,KAAKk6B;;QAGjBsyE,oBAAoBjqG,SAAS;;;IAI/BuqG,WAAW1wF,OAAO1T;UACb,KAAKkhC,kBAAkB;QAC1B,KAAKA,oBAAoB+P,oBAAoBW,aAAa,KAAK5vC,QAAQ,IAAI;;MAG5EhC,MAAM+a,QAAQ,KAAKmmB,cAAcrtB,OAAOH,QAAQ;;IAGjD2wF,YAAY3wF,OAAOiM;MAClBA,OAAO5E,QAAQ,KAAKkmB,eAAeptB,OAAOH,QAAQ;;IAGnDykC;IAEA5gD;MACC,KAAKqc;QACJhb,MAAM;;;;EAMT0rG,cAAc/oF,UAAUylB,kBAAkB;;;;;;;;;;;EAa1C,gCAAgCyL;IAC/BztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;MACvB,KAAKxD,YAAY;MACjB,KAAKw4D,UAAU;MACf,KAAKC,WAAW;MAChB,KAAKn4D,eAAe;MACpB,KAAKzD,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAK+rC,YAAY3pB,OAAO2pB;MACxB,KAAKw4D,UAAUniF,OAAOmiF;MACtB,KAAKC,WAAWpiF,OAAOoiF;MACvB,KAAKn4D,eAAejqB,OAAOiqB;aACpB;;;EAKTsgC,kBAAkBpxD,UAAU02E,sBAAsB;QAE5CwS,4BAA4BrlG;QAE5BslG,0BAA0BtlG;QAE1BulG,oCAAoCpuE;QAEpCquE,0BAA0BztD;QAE1B0tD,6BAA6BjxD;EAEnC,mBAAmBzW;IAClBn+B,YAAYU,eAAeg3C,kBAAkB52C,eAAe6sE;MAC3D;MACA,KAAK/zE,OAAO;MACZ,KAAK8G,WAAWA;MAChB,KAAKI,WAAWA;MAChB,KAAKq4C;;IAGNx/B,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKtiB,WAAWsiB,OAAOtiB;MACvB,KAAKJ,WAAW0iB,OAAO1iB;aAChB;;IAGRolG;YACOplG,WAAW,KAAKA;UAElBA,SAASu2C;;YAERv2C,SAASgU,UAAU;gBAChB4hC,oBAAoB51C,SAAS4yC,WAAW/xC;gBACxCwkG,iBAAiB;mBAEdnrG,IAAI,GAAGma,IAAIuhC,kBAAkBtzC,OAAOpI,IAAIma,GAAGna;YACnD6qG,SAASzpF,oBAAoBs6B,mBAAmB17C,IAAI;YAEpD8qG,OAAO1pF,oBAAoBs6B,mBAAmB17C;YAE9CmrG,cAAcnrG,KAAKmrG,cAAcnrG,IAAI;YACrCmrG,cAAcnrG,MAAM6qG,SAAS3hG,WAAW4hG;;UAGzChlG,SAAS9C,aAAa,oBAAoB22C,uBAAuBwxD,eAAe;;UAEhFtrG,QAAQ0B,KAAK;;iBAEJuE,SAASu5C;QACnBx/C,QAAQa,MAAM;;aAGR;;IAGR6lC,QAAQsY,WAAWC;YACZh5C,WAAW,KAAKA;YAChBwsB,cAAc,KAAKA;YACnBwgE,YAAYj0C,UAAUl3C,OAAOyjG,KAAKtY;YAClCh6C,YAAYhzC,SAASgzC;;UAEvBhzC,SAAS+D,mBAAmB,MAAM/D,SAAS8D;MAE/CqhG,UAAUlsF,KAAKjZ,SAAS+D;MAExBohG,UAAUphF,aAAayI;MAEvB24E,UAAUzkG,UAAUssF;UAChBj0C,UAAUnlB,IAAIpD,iBAAiB20E,eAAe;;MAElDF,iBAAiBhsF,KAAKuT,aAAa7N;MAEnCumF,OAAOjsF,KAAK8/B,UAAUnlB,KAAK7P,aAAakhF;YAElCM,iBAAiBvY,cAAc,KAAKltE,MAAMhf,IAAI,KAAKgf,MAAM7e,IAAI,KAAK6e,MAAM5e,KAAK;YAC7EskG,mBAAmBD,iBAAiBA;YACpCE,aAAa/lG;YACbgmG,WAAWhmG;YACXimG,mBAAmBjmG;YACnBkmG,eAAelmG;YACfoqB,OAAO,KAAKuxE,iBAAiB,IAAI;UAEnCr7F,SAASu2C;cACNviC,QAAQhU,SAASgU;cACjB4+B,aAAa5yC,SAAS4yC;cACtBgD,oBAAoBhD,WAAW/xC;YAEjCmT,UAAU;gBACPuvB,QAAQtkC,KAAKF,IAAI,GAAGi0C,UAAUzP;gBAC9BI,MAAM1kC,KAAKD,IAAIgV,MAAM1R,OAAO0wC,UAAUzP,QAAQyP,UAAU1wC;mBAErDpI,IAAIqpC,OAAOlvB,IAAIsvB,MAAM,GAAGzpC,IAAIma,GAAGna,KAAK4vB;kBACtCtT,IAAIxC,MAAMwH,KAAKthB;kBACfuc,IAAIzC,MAAMwH,KAAKthB,IAAI;YACzBurG,OAAOnqF,oBAAoBs6B,mBAAmBp/B;YAC9CkvF,KAAKpqF,oBAAoBs6B,mBAAmBn/B;kBAEtCovF,SAASX,OAAOhxE,oBAAoBuxE,QAAQC,MAAME,UAAUD;gBAE9DE,SAASL;YACbI,SAAS7hF,aAAa,KAAKyI;;kBAErBxoB,WAAW+0C,UAAUnlB,IAAI31B,OAAOmF,WAAWwiG;gBAC7C5hG,WAAW+0C,UAAU3d,QAAQp3B,WAAW+0C,UAAU1d;YACtD2d,WAAWphD;cACVoM,UAAUA;;;cAGV0rB,OAAOi2E,aAAajkG,QAAQqiB,aAAa,KAAKyI;cAC9CxY,OAAO9Z;cACPo/C,MAAM;cACND,WAAW;cACXjqB,QAAQ;;;;gBAIJmU,QAAQtkC,KAAKF,IAAI,GAAGi0C,UAAUzP;gBAC9BI,MAAM1kC,KAAKD,IAAI42C,kBAAkBtzC,OAAO0wC,UAAUzP,QAAQyP,UAAU1wC;mBAEjEpI,IAAIqpC,OAAOlvB,IAAIsvB,MAAM,GAAGzpC,IAAIma,GAAGna,KAAK4vB;YAC5C27E,OAAOnqF,oBAAoBs6B,mBAAmB17C;YAC9CwrG,KAAKpqF,oBAAoBs6B,mBAAmB17C,IAAI;kBAE1C2rG,SAASX,OAAOhxE,oBAAoBuxE,QAAQC,MAAME,UAAUD;gBAE9DE,SAASL;YACbI,SAAS7hF,aAAa,KAAKyI;;kBAErBxoB,WAAW+0C,UAAUnlB,IAAI31B,OAAOmF,WAAWwiG;gBAC7C5hG,WAAW+0C,UAAU3d,QAAQp3B,WAAW+0C,UAAU1d;YACtD2d,WAAWphD;cACVoM,UAAUA;;;cAGV0rB,OAAOi2E,aAAajkG,QAAQqiB,aAAa,KAAKyI;cAC9CxY,OAAO9Z;cACPo/C,MAAM;cACND,WAAW;cACXjqB,QAAQ;;;;iBAIDpvB,SAASu5C;QACnBx/C,QAAQa,MAAM;;;IAIhB69C;YACOz4C,WAAW,KAAKA;UAElBA,SAASu2C;cACN1D,kBAAkB7yC,SAAS6yC;cAC3BuE,OAAO//B,OAAO+/B,KAAKvE;YAErBuE,KAAKj9C,SAAS;gBACX65C,iBAAiBnB,gBAAgBuE,KAAK;cAExCpD,mBAAmBl8C;YACtB,KAAK4gD;YACL,KAAKC;qBAEIxjC,IAAI,GAAG0jC,KAAK7E,eAAe75C,QAAQgb,IAAI0jC,IAAI1jC;oBAC7C/P,OAAO4uC,eAAe7+B,GAAG/P,QAAQ0zC,OAAO3jC;cAC9C,KAAKujC,sBAAsB9gD,KAAK;cAChC,KAAK+gD,sBAAsBvzC,QAAQ+P;;;;;cAKhCw3B,eAAe3sC,SAAS2sC;YAE1BA,iBAAiB70C,aAAa60C,aAAaxyC,SAAS;UACvDJ,QAAQa,MAAM;;;;;EAOlB0qG,KAAKzpF,UAAU+lB,SAAS;QAElBkkE,0BAA0BpmG;QAE1BqmG,wBAAwBrmG;EAE9B,2BAA2B4lG;IAC1BhmG,YAAYU,UAAUI;MACrB,MAAMJ,UAAUI;MAChB,KAAKlH,OAAO;;IAGbksG;YACOplG,WAAW,KAAKA;UAElBA,SAASu2C;;YAERv2C,SAASgU,UAAU;gBAChB4hC,oBAAoB51C,SAAS4yC,WAAW/xC;gBACxCwkG;mBAEGnrG,IAAI,GAAGma,IAAIuhC,kBAAkBtzC,OAAOpI,IAAIma,GAAGna,KAAK;YACxD4rG,OAAOxqF,oBAAoBs6B,mBAAmB17C;YAE9C6rG,KAAKzqF,oBAAoBs6B,mBAAmB17C,IAAI;YAEhDmrG,cAAcnrG,KAAKA,MAAM,IAAI,IAAImrG,cAAcnrG,IAAI;YACnDmrG,cAAcnrG,IAAI,KAAKmrG,cAAcnrG,KAAK4rG,OAAO1iG,WAAW2iG;;UAG7D/lG,SAAS9C,aAAa,oBAAoB22C,uBAAuBwxD,eAAe;;UAEhFtrG,QAAQ0B,KAAK;;iBAEJuE,SAASu5C;QACnBx/C,QAAQa,MAAM;;aAGR;;;EAKTorG,aAAanqF,UAAUw/E,iBAAiB;EAExC,uBAAuBiK;IACtBhmG,YAAYU,UAAUI;MACrB,MAAMJ,UAAUI;MAChB,KAAKlH,OAAO;;;EAKd+sG,SAASpqF,UAAUy/E,aAAa;;;;;;;;;;;;;;EAgBhC,6BAA6BvuD;IAC5BztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;MACvB,KAAK7zC,MAAM;MACX,KAAKuuC,WAAW;MAChB,KAAKlmC,OAAO;MACZ,KAAK+nC,kBAAkB;MACvB,KAAKO,eAAe;MACpB,KAAKzD,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKtE,MAAM0mB,OAAO1mB;MAClB,KAAKuuC,WAAW7nB,OAAO6nB;MACvB,KAAKlmC,OAAOqe,OAAOre;MACnB,KAAK+nC,kBAAkB1pB,OAAO0pB;MAC9B,KAAKO,eAAejqB,OAAOiqB;aACpB;;;EAKTwgC,eAAetxD,UAAU82E,mBAAmB;QAEtCuT,kCAAkCrvE;QAElCsvE,wBAAwB1uD;QAExB2uD,2BAA2BlyD;QAE3BmyD,+BAA+B3mG;EAErC,qBAAqB+9B;IACpBn+B,YAAYU,eAAeg3C,kBAAkB52C,eAAe+sE;MAC3D;MACA,KAAKj0E,OAAO;MACZ,KAAK8G,WAAWA;MAChB,KAAKI,WAAWA;MAChB,KAAKq4C;;IAGNx/B,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKtiB,WAAWsiB,OAAOtiB;MACvB,KAAKJ,WAAW0iB,OAAO1iB;aAChB;;IAGRygC,QAAQsY,WAAWC;YACZh5C,WAAW,KAAKA;YAChBwsB,cAAc,KAAKA;YACnBwgE,YAAYj0C,UAAUl3C,OAAOykG,OAAOtZ;YACpCh6C,YAAYhzC,SAASgzC;;UAEvBhzC,SAAS+D,mBAAmB,MAAM/D,SAAS8D;MAE/CsiG,QAAQntF,KAAKjZ,SAAS+D;MAEtBqiG,QAAQriF,aAAayI;MAErB45E,QAAQ1lG,UAAUssF;UACdj0C,UAAUnlB,IAAIpD,iBAAiB41E,aAAa;;MAEhDF,eAAejtF,KAAKuT,aAAa7N;MAEjCwnF,KAAKltF,KAAK8/B,UAAUnlB,KAAK7P,aAAamiF;YAEhCX,iBAAiBvY,cAAc,KAAKltE,MAAMhf,IAAI,KAAKgf,MAAM7e,IAAI,KAAK6e,MAAM5e,KAAK;YAC7EskG,mBAAmBD,iBAAiBA;UAEtCvlG,SAASu2C;cACNviC,QAAQhU,SAASgU;cACjB4+B,aAAa5yC,SAAS4yC;cACtBgD,oBAAoBhD,WAAW/xC;YAEjCmT,UAAU;gBACPuvB,QAAQtkC,KAAKF,IAAI,GAAGi0C,UAAUzP;gBAC9BI,MAAM1kC,KAAKD,IAAIgV,MAAM1R,OAAO0wC,UAAUzP,QAAQyP,UAAU1wC;mBAErDpI,IAAIqpC,OAAOnd,KAAKud,KAAKzpC,IAAIksB,IAAIlsB;kBAC/Bsc,IAAIxC,MAAMwH,KAAKthB;YAErBmsG,YAAY/qF,oBAAoBs6B,mBAAmBp/B;YAEnD+vF,UAAUF,aAAa7vF,GAAGgvF,kBAAkBh5E,aAAausB,WAAWC,YAAY;;;gBAG3EzV,QAAQtkC,KAAKF,IAAI,GAAGi0C,UAAUzP;gBAC9BI,MAAM1kC,KAAKD,IAAI42C,kBAAkBtzC,OAAO0wC,UAAUzP,QAAQyP,UAAU1wC;mBAEjEpI,IAAIqpC,OAAOlvB,IAAIsvB,KAAKzpC,IAAIma,GAAGna;YACnCmsG,YAAY/qF,oBAAoBs6B,mBAAmB17C;YAEnDqsG,UAAUF,aAAansG,GAAGsrG,kBAAkBh5E,aAAausB,WAAWC,YAAY;;;;QAIlFj/C,QAAQa,MAAM;;;IAIhB69C;YACOz4C,WAAW,KAAKA;UAElBA,SAASu2C;cACN1D,kBAAkB7yC,SAAS6yC;cAC3BuE,OAAO//B,OAAO+/B,KAAKvE;YAErBuE,KAAKj9C,SAAS;gBACX65C,iBAAiBnB,gBAAgBuE,KAAK;cAExCpD,mBAAmBl8C;YACtB,KAAK4gD;YACL,KAAKC;qBAEIxjC,IAAI,GAAG0jC,KAAK7E,eAAe75C,QAAQgb,IAAI0jC,IAAI1jC;oBAC7C/P,OAAO4uC,eAAe7+B,GAAG/P,QAAQ0zC,OAAO3jC;cAC9C,KAAKujC,sBAAsB9gD,KAAK;cAChC,KAAK+gD,sBAAsBvzC,QAAQ+P;;;;;cAKhCw3B,eAAe3sC,SAAS2sC;YAE1BA,iBAAiB70C,aAAa60C,aAAaxyC,SAAS;UACvDJ,QAAQa,MAAM;;;;;EAOlB0rG,OAAOzqF,UAAUgmB,WAAW;EAE5B,mBAAmBnS,OAAO1b,OAAOwxF,kBAAkBh5E,aAAausB,WAAWC,YAAY5pB;UAChFo3E,qBAAqBL,KAAKlyE,kBAAkBvE;QAE9C82E,qBAAqBhB;YAClBiB,qBAAqB/mG;MAE3BymG,KAAKpyE,oBAAoBrE,OAAO+2E;MAEhCA,eAAe1iF,aAAayI;YACtBxoB,WAAW+0C,UAAUnlB,IAAI31B,OAAOmF,WAAWqjG;UAC7CziG,WAAW+0C,UAAU3d,QAAQp3B,WAAW+0C,UAAU1d;MACtD2d,WAAWphD;QACVoM,UAAUA;QACV0iG,eAAeznG,KAAKob,KAAKmsF;QACzB92E,OAAO+2E;QACPzyF,OAAOA;QACPslC,MAAM;QACNlqB,QAAQA;;;;EAKX,2BAA2BjO;IAC1B7hB,YAAYqnG,OAAOtlF,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB;MAC7E,MAAM+kF,OAAOtlF,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB;MACxE,KAAKD,SAASA,WAAW7pB,YAAY6pB,SAAS3U;MAC9C,KAAK0U,YAAYA,cAAc5pB,YAAY4pB,YAAY5V;MACvD,KAAK2V,YAAYA,cAAc3pB,YAAY2pB,YAAY3V;MACvD,KAAKqW,kBAAkB;YACjB43B,QAAQ;MAEd;QACCA,MAAMv2B,cAAc;QACpBmjF,MAAMC,0BAA0BC;;WAG7B,+BAA+BF;QAClCA,MAAMC,0BAA0BC;;;IAIlCnlG;iBACY,KAAKpC,YAAY,KAAKghB,OAAOrH,KAAK;;IAG9C4P;YACO89E,QAAQ,KAAKrmF;YACbwmF,yBAAyB,+BAA+BH;UAE1DG,0BAA0B,SAASH,MAAMI,cAAcJ,MAAMK;QAChE,KAAKxjF,cAAc;;;;EAMtByjF,aAAaprF,UAAUumE,iBAAiB;EAExC,gCAAgCjhE;IAC/B7hB,YAAYyiB,SAAStJ,OAAOC,QAAQiJ,QAAQzoB,MAAMmoB,SAASE,OAAOC,OAAOC,WAAWC,WAAWE,YAAYC;MAC1G,MAAM,MAAMR,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB,YAAYC;MACnF,KAAKvB;QACJ7H,OAAOA;QACPC,QAAQA;;MAET,KAAKqJ,UAAUA;;;MAGf,KAAKM,QAAQ;;;MAGb,KAAKF,kBAAkB;;;EAKzB+kF,kBAAkBrrF,UAAUuqE,sBAAsB;EAElD,4BAA4BjlE;IAC3B7hB,YAAYmhB,QAAQY,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB;MAC9E,MAAMnB,QAAQY,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB;MACzE,KAAK4B,cAAc;;;EAKrB2jF,cAActrF,UAAUurF,kBAAkB;EAE1C,2BAA2BjmF;IAC1B7hB,YAAYmZ,OAAOC,QAAQxf,MAAMmoB,SAASE,OAAOC,OAAOC,WAAWC,WAAWE,YAAYD;MACzFA,SAASA,WAAW7pB,YAAY6pB,SAAStU;UAErCsU,WAAWtU,eAAesU,WAAWrU;kBAC9BhI,MAAM;;UAGbpM,SAASpB,aAAa6pB,WAAWtU,aAAanU,OAAOoT;UACrDpT,SAASpB,aAAa6pB,WAAWrU,oBAAoBpU,OAAO4T;MAChE,MAAM,MAAMuU,SAASE,OAAOC,OAAOC,WAAWC,WAAWC,QAAQzoB,MAAM0oB;MACvE,KAAKtB;QACJ7H,OAAOA;QACPC,QAAQA;;MAET,KAAK+I,YAAYA,cAAc3pB,YAAY2pB,YAAYhW;MACvD,KAAKiW,YAAYA,cAAc5pB,YAAY4pB,YAAYjW;MACvD,KAAK4W,QAAQ;MACb,KAAKF,kBAAkB;;;EAKzBklF,aAAaxrF,UAAUgqE,iBAAiB;EAExC,6BAA6B7uC;IAC5B13C,YAAYoB,SAAS,GAAG4mG,WAAW,GAAGC,aAAa,GAAGC,cAAcvoG,KAAKyV,KAAK;MAC7E;MACA,KAAKxb,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACR4mG,UAAUA;QACVC,YAAYA;QACZC,aAAaA;;MAEdF,WAAWroG,KAAKF,IAAI,GAAGuoG;;YAEjBhzD;YACA0F;YACAxF;YACAC;;YAEAgzD,aAAa/nG;YACb6jB,SAAS3H;;MAEfo+B,SAASpiD,KAAK,GAAG,GAAG;MACpB48C,QAAQ58C,KAAK,GAAG,GAAG;MACnB68C,IAAI78C,KAAK,KAAK;eAELse,IAAI,GAAGhc,IAAI,GAAGgc,KAAKoxF,WAAUpxF,KAAKhc,KAAK;cACzCwtG,UAAUH,aAAarxF,IAAIoxF,WAAWE;;QAE5CC,OAAO3mG,IAAIJ,SAASzB,KAAK+B,IAAI0mG;QAC7BD,OAAOxmG,IAAIP,SAASzB,KAAK8B,IAAI2mG;QAC7B1tD,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;QAEzCszC,QAAQ58C,KAAK,GAAG,GAAG;;QAEnB2rB,GAAGziB,KAAKk5C,SAAS9/C,KAAKwG,SAAS,KAAK;QACpC6iB,GAAGtiB,KAAK+4C,SAAS9/C,IAAI,KAAKwG,SAAS,KAAK;QACxC+zC,IAAI78C,KAAK2rB,GAAGziB,GAAGyiB,GAAGtiB;;;eAIV/G,IAAI,GAAGA,KAAKotG,UAAUptG;QAC9Bo6C,QAAQ18C,KAAKsC,GAAGA,IAAI,GAAG;;;MAIxB,KAAKg5C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;;EAK1D,+BAA+BuC;IAC9B13C,YAAYqoG,YAAY,GAAGC,eAAe,GAAGlvF,SAAS,GAAGmvF,iBAAiB,GAAGhuD,iBAAiB,GAAGiuD,YAAY,OAAOP,aAAa,GAAGC,cAAcvoG,KAAKyV,KAAK;MAC3J;MACA,KAAKxb,OAAO;MACZ,KAAK6oC;QACJ4lE,WAAWA;QACXC,cAAcA;QACdlvF,QAAQA;QACRmvF,gBAAgBA;QAChBhuD,gBAAgBA;QAChBiuD,WAAWA;QACXP,YAAYA;QACZC,aAAaA;;YAERztD,QAAQ;MACd8tD,iBAAiB5oG,KAAKC,MAAM2oG;MAC5BhuD,iBAAiB56C,KAAKC,MAAM26C;;YAEtBvF;YACA0F;YACAxF;YACAC;;UAEFzgC,QAAQ;YACN+zF;YACAh4B,aAAar3D,SAAS;UACxBwhC,aAAa;;MAEjB8tD;UAEIF,cAAc;YACbH,YAAY,GAAGM,YAAY;YAC3BL,eAAe,GAAGK,YAAY;;;MAInC,KAAK/0D,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;MAExD;cACOlnB,aAAa7tB;cACb+nG,aAAa/nG;YACfs7C,aAAa;;cAEXktD,SAASN,eAAeD,aAAajvF;;iBAElCzX,IAAI,GAAGA,KAAK44C,gBAAgB54C;gBAC9BknG;gBACAzpG,IAAIuC,IAAI44C;;gBAERn5C,SAAShC,KAAKkpG,eAAeD,aAAaA;mBAEvC7mG,IAAI,GAAGA,KAAK+mG,gBAAgB/mG;kBAC9BukC,IAAIvkC,IAAI+mG;kBACRlnG,QAAQ0kC,IAAImiE,cAAcD;kBAC1Ba,WAAWnpG,KAAK8B,IAAIJ;kBACpB0nG,WAAWppG,KAAK+B,IAAIL;;YAE1B8mG,OAAO3mG,IAAIJ,SAAS0nG;YACpBX,OAAOxmG,KAAKvC,IAAIga,SAASq3D;YACzB03B,OAAOvmG,IAAIR,SAAS2nG;YACpBruD,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;YAEzCqsB,OAAOlnB,IAAI+hG,UAAUF,OAAOG,UAAU/kG;YACtCkxC,QAAQ58C,KAAK21B,OAAOzsB,GAAGysB,OAAOtsB,GAAGssB,OAAOrsB;;YAExCuzC,IAAI78C,KAAKytC,GAAG,IAAI3mC;;YAEhBypG,SAASvwG,KAAKoc;;;UAIf+zF,WAAWnwG,KAAKuwG;;;iBAIRrnG,IAAI,GAAGA,IAAI+mG,gBAAgB/mG;mBAC1BG,IAAI,GAAGA,IAAI44C,gBAAgB54C;;kBAE7BuV,IAAIuxF,WAAW9mG,GAAGH;kBAClB2V,IAAIsxF,WAAW9mG,IAAI,GAAGH;kBACtB4V,IAAIqxF,WAAW9mG,IAAI,GAAGH,IAAI;kBAC1BxE,IAAIyrG,WAAW9mG,GAAGH,IAAI;;YAE5BwzC,QAAQ18C,KAAK4e,GAAGC,GAAGna;YACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;YAEnB0+C,cAAc;;;;QAKhBjB,MAAMvG,SAAS0G,YAAYc,YAAY;;QAEvCd,cAAcc;;MAGf,qBAAqB9f;;cAEdotE,mBAAmBt0F;cACnBuP,SAAS3H;cACT6rF,aAAa/nG;YACfs7C,aAAa;cACXt6C,SAASw6B,QAAQ,OAAOysE,YAAYC;cACpC1xE,OAAOgF,QAAQ,OAAO,KAAK;;;;iBAIxBp6B,IAAI,GAAGA,KAAK+mG,gBAAgB/mG;;UAEpCk5C,SAASpiD,KAAK,GAAGm4E,aAAa75C,MAAM;;UAEpCse,QAAQ58C,KAAK,GAAGs+B,MAAM;;UAEtBue,IAAI78C,KAAK,KAAK;;UAEdoc;;;cAIKu0F,iBAAiBv0F;;iBAEdlT,IAAI,GAAGA,KAAK+mG,gBAAgB/mG;gBAC9BukC,IAAIvkC,IAAI+mG;gBACRlnG,QAAQ0kC,IAAImiE,cAAcD;gBAC1Bc,WAAWppG,KAAK+B,IAAIL;gBACpBynG,WAAWnpG,KAAK8B,IAAIJ;;UAE1B8mG,OAAO3mG,IAAIJ,SAAS0nG;UACpBX,OAAOxmG,IAAI8uE,aAAa75C;UACxBuxE,OAAOvmG,IAAIR,SAAS2nG;UACpBruD,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;UAEzCszC,QAAQ58C,KAAK,GAAGs+B,MAAM;;UAEtB3S,GAAGziB,IAAIunG,WAAW,MAAM;UACxB9kF,GAAGtiB,IAAImnG,WAAW,MAAMlyE,OAAO;UAC/Bue,IAAI78C,KAAK2rB,GAAGziB,GAAGyiB,GAAGtiB;;UAElB+S;;;iBAIQlT,IAAI,GAAGA,IAAI+mG,gBAAgB/mG;gBAC7B4V,IAAI4xF,mBAAmBxnG;gBACvB5G,IAAIquG,iBAAiBznG;cAEvBo6B,QAAQ;;YAEXoZ,QAAQ18C,KAAKsC,GAAGA,IAAI,GAAGwc;;;YAGvB49B,QAAQ18C,KAAKsC,IAAI,GAAGA,GAAGwc;;UAGxBskC,cAAc;;;QAIfjB,MAAMvG,SAAS0G,YAAYc,YAAY9f,QAAQ,OAAO,IAAI;;QAE1Dgf,cAAcc;;;;EAMjB,2BAA2B/6C;IAC1BX,YAAYoB,SAAS,GAAGgY,SAAS,GAAGmvF,iBAAiB,GAAGhuD,iBAAiB,GAAGiuD,YAAY,OAAOP,aAAa,GAAGC,cAAcvoG,KAAKyV,KAAK;MACtI,MAAM,GAAGhU,QAAQgY,QAAQmvF,gBAAgBhuD,gBAAgBiuD,WAAWP,YAAYC;MAChF,KAAKtuG,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRgY,QAAQA;QACRmvF,gBAAgBA;QAChBhuD,gBAAgBA;QAChBiuD,WAAWA;QACXP,YAAYA;QACZC,aAAaA;;;;EAMhB,iCAAiCxwD;IAChC13C,YAAY06C,UAAU1F,SAAS5zC,SAAS,GAAGs/F,SAAS;MACnD;MACA,KAAK9mG,OAAO;MACZ,KAAK6oC;QACJiY,UAAUA;QACV1F,SAASA;QACT5zC,QAAQA;QACRs/F,QAAQA;;;YAGHwI;YACAC;;MAENC,UAAU1I;;MAEV2I,YAAYjoG;;MAEZkoG;;MAEA,KAAK1rG,aAAa,gBAAgB22C,uBAAuB20D,cAAc;MACvE,KAAKtrG,aAAa,cAAc22C,uBAAuB20D,aAAap0F,SAAS;MAC7E,KAAKlX,aAAa,UAAU22C,uBAAuB40D,UAAU;UAEzDzI,WAAW;QACd,KAAKrqD;;QAEL,KAAKU;;;MAIN,mBAAmB2pD;cACZxpF,QAAQ9W;cACR+W,QAAQ/W;cACRgX,QAAQhX;;iBAELxF,IAAI,GAAGA,IAAIo6C,QAAQn6C,QAAQD,KAAK;;UAExC2uG,iBAAiBv0D,QAAQp6C,IAAI,IAAIsc;UACjCqyF,iBAAiBv0D,QAAQp6C,IAAI,IAAIuc;UACjCoyF,iBAAiBv0D,QAAQp6C,IAAI,IAAIwc;;UAEjCoyF,cAActyF,GAAGC,GAAGC,GAAGspF;;;MAIzB,uBAAuBxpF,GAAGC,GAAGC,GAAGspF;cACzB+I,OAAO/I,SAAS;;cAEhBthG;;iBAEGxE,IAAI,GAAGA,KAAK6uG,MAAM7uG;UAC1BwE,EAAExE;gBACI8uG,KAAKxyF,EAAE9U,QAAQiU,KAAKe,GAAGxc,IAAI6uG;gBAC3BE,KAAKxyF,EAAE/U,QAAQiU,KAAKe,GAAGxc,IAAI6uG;gBAC3BG,OAAOH,OAAO7uG;mBAEXm4B,IAAI,GAAGA,KAAK62E,MAAM72E;gBACtBA,MAAM,KAAKn4B,MAAM6uG;cACpBrqG,EAAExE,GAAGm4B,KAAK22E;;cAEVtqG,EAAExE,GAAGm4B,KAAK22E,GAAGtnG,QAAQiU,KAAKszF,IAAI52E,IAAI62E;;;;;iBAM5BhvG,IAAI,GAAGA,IAAI6uG,MAAM7uG;mBAChBm4B,IAAI,GAAGA,IAAI,KAAK02E,OAAO7uG,KAAK,GAAGm4B;kBACjCh2B,IAAI4C,KAAKC,MAAMmzB,IAAI;gBAErBA,IAAI,MAAM;cACb82E,WAAWzqG,EAAExE,GAAGmC,IAAI;cACpB8sG,WAAWzqG,EAAExE,IAAI,GAAGmC;cACpB8sG,WAAWzqG,EAAExE,GAAGmC;;cAEhB8sG,WAAWzqG,EAAExE,GAAGmC,IAAI;cACpB8sG,WAAWzqG,EAAExE,IAAI,GAAGmC,IAAI;cACxB8sG,WAAWzqG,EAAExE,IAAI,GAAGmC;;;;;MAMxB,qBAAqBqE;cACd+mG,aAAa/nG;;iBAEVxF,IAAI,GAAGA,IAAIsuG,aAAaruG,QAAQD,KAAK;UAC7CutG,OAAO3mG,IAAI0nG,aAAatuG,IAAI;UAC5ButG,OAAOxmG,IAAIunG,aAAatuG,IAAI;UAC5ButG,OAAOvmG,IAAIsnG,aAAatuG,IAAI;UAC5ButG,OAAOnkG,YAAYhC,eAAeZ;UAClC8nG,aAAatuG,IAAI,KAAKutG,OAAO3mG;UAC7B0nG,aAAatuG,IAAI,KAAKutG,OAAOxmG;UAC7BunG,aAAatuG,IAAI,KAAKutG,OAAOvmG;;;MAI/B;cACOumG,aAAa/nG;iBAEVxF,IAAI,GAAGA,IAAIsuG,aAAaruG,QAAQD,KAAK;UAC7CutG,OAAO3mG,IAAI0nG,aAAatuG,IAAI;UAC5ButG,OAAOxmG,IAAIunG,aAAatuG,IAAI;UAC5ButG,OAAOvmG,IAAIsnG,aAAatuG,IAAI;gBACtBmrC,IAAI+jE,QAAQ3B,UAAU,IAAIxoG,KAAKyV,KAAK;gBACpChW,IAAI2qG,YAAY5B,UAAUxoG,KAAKyV,KAAK;UAC1C+zF,SAAS7wG,KAAKytC,GAAG,IAAI3mC;;QAGtB4qG;QACAC;;MAGD;;iBAEUrvG,IAAI,GAAGA,IAAIuuG,SAAStuG,QAAQD,KAAK;;gBAEnCwtB,KAAK+gF,SAASvuG,IAAI;gBAClB4tB,KAAK2gF,SAASvuG,IAAI;gBAClBkgC,KAAKquE,SAASvuG,IAAI;gBAClB6E,MAAME,KAAKF,IAAI2oB,IAAII,IAAIsS;gBACvBp7B,MAAMC,KAAKD,IAAI0oB,IAAII,IAAIsS;;cAEzBr7B,MAAM,OAAOC,MAAM;gBAClB0oB,KAAK,KAAK+gF,SAASvuG,IAAI,MAAM;gBAC7B4tB,KAAK,KAAK2gF,SAASvuG,IAAI,MAAM;gBAC7BkgC,KAAK,KAAKquE,SAASvuG,IAAI,MAAM;;;;MAKpC,oBAAoButG;QACnBe,aAAa5wG,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;MAG9C,0BAA0B8S,OAAOyzF;cAC1B5yC,SAAS7gD,QAAQ;QACvByzF,OAAO3mG,IAAIk5C,SAAS6a,SAAS;QAC7B4yC,OAAOxmG,IAAI+4C,SAAS6a,SAAS;QAC7B4yC,OAAOvmG,IAAI84C,SAAS6a,SAAS;;MAG9B;cACOr+C,QAAQ9W;cACR+W,QAAQ/W;cACRgX,QAAQhX;cACR8pG,eAAe9pG;cACfu1C,UAAUr5B;cACVs5B,UAAUt5B;cACVu5B,UAAUv5B;iBAEP1hB,IAAI,GAAGm4B,IAAI,GAAGn4B,IAAIsuG,aAAaruG,SAAQD,KAAK,GAAGm4B,KAAK;UAC5D7b,EAAEnQ,IAAImiG,aAAatuG,IAAI,IAAIsuG,aAAatuG,IAAI,IAAIsuG,aAAatuG,IAAI;UACjEuc,EAAEpQ,IAAImiG,aAAatuG,IAAI,IAAIsuG,aAAatuG,IAAI,IAAIsuG,aAAatuG,IAAI;UACjEwc,EAAErQ,IAAImiG,aAAatuG,IAAI,IAAIsuG,aAAatuG,IAAI,IAAIsuG,aAAatuG,IAAI;UACjE+6C,IAAI5uC,IAAIoiG,SAASp2E,IAAI,IAAIo2E,SAASp2E,IAAI;UACtC6iB,IAAI7uC,IAAIoiG,SAASp2E,IAAI,IAAIo2E,SAASp2E,IAAI;UACtC8iB,IAAI9uC,IAAIoiG,SAASp2E,IAAI,IAAIo2E,SAASp2E,IAAI;UACtCm3E,SAASvwF,KAAKzC,GAAGjV,IAAIkV,GAAGlV,IAAImV,GAAGrT,aAAa;gBACtComG,MAAML,QAAQI;UACpBE,UAAUz0D,KAAK5iB,IAAI,GAAG7b,GAAGizF;UACzBC,UAAUx0D,KAAK7iB,IAAI,GAAG5b,GAAGgzF;UACzBC,UAAUv0D,KAAK9iB,IAAI,GAAG3b,GAAG+yF;;;MAI3B,mBAAmBlmF,IAAIsxC,QAAQjlC,QAAQw5E;YAClCA,UAAU,KAAK7lF,GAAGziB,MAAM;UAC3B2nG,SAAS5zC,UAAUtxC,GAAGziB,IAAI;;YAGvB8uB,OAAO9uB,MAAM,KAAK8uB,OAAO1uB,MAAM;UAClCunG,SAAS5zC,UAAUu0C,UAAU,IAAInqG,KAAKyV,KAAK;;;;MAK7C,iBAAiBkb;eACT3wB,KAAKub,MAAMoV,OAAO1uB,IAAI0uB,OAAO9uB;;;MAIrC,qBAAqB8uB;eACb3wB,KAAKub,OAAOoV,OAAO3uB,GAAGhC,KAAKob,KAAKuV,OAAO9uB,IAAI8uB,OAAO9uB,IAAI8uB,OAAO1uB,IAAI0uB,OAAO1uB;;;;EAMlF,mCAAmCyoG;IAClCrqG,YAAYoB,SAAS,GAAGs/F,SAAS;YAC1BxqF,KAAK,IAAIvW,KAAKob,KAAK,MAAM;YACzBiF,IAAI,IAAI9J;YACRwkC;OACL,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG;MACjF,IAAI16B,IAAI9J,GAAG,IAAI8J,GAAG9J,GAAG,GAAG8J,IAAI9J,GAAG,GAAG8J,GAAG9J;OACpC8J,IAAI9J,GAAG,IAAI8J,GAAG9J,GAAG,GAAG8J,IAAI9J,GAAG,GAAG8J,GAAG9J,GAAG;OACpCA,GAAG,IAAI8J,GAAG9J,GAAG,IAAI8J,IAAI9J,GAAG,GAAG8J,GAAG9J,GAAG,GAAG8J;YAC/Bg1B,WAAW,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG;MACpY,MAAM0F,UAAU1F,SAAS5zC,QAAQs/F;MACjC,KAAK9mG,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRs/F,QAAQA;;;;QAML4J,UAAUlqG;QAEVmqG,YAAYnqG;QAEZoqG,cAAcpqG;QAEdqqG,gBAAgB7jE;EAEtB,4BAA4B8Q;IAC3B13C,YAAYU,UAAUgqG;MACrB;MACA,KAAK9wG,OAAO;MACZ,KAAK6oC;QACJioE,gBAAgBA;;MAEjBA,iBAAiBA,mBAAmBlyG,YAAYkyG,iBAAiB;UAE7DhqG,SAASu5C,eAAe;QAC3Bx/C,QAAQa,MAAM;;;YAITqvG,kBAAkB;YAClB3hE,YAAYrpC,KAAKgF,IAAI,IAAIgmG;YACzBC,eAAejrG,KAAK+B,IAAIyT,UAAUu1F;YAClCG,YAAYnqG,SAASizC;YACrBm3D,eAAepqG,SAAS7C,aAAa;YACrCktG,aAAaF,YAAYA,UAAU7nG,QAAQ8nG,aAAa9nG;YACxDgoG,YAAY,GAAG,GAAG;YAClBC,YAAY,KAAK,KAAK;YACtBC,aAAahuG,MAAM;YACnBiuG;YACAzwD;eAEG9/C,IAAI,GAAGA,IAAImwG,YAAYnwG,KAAK;YAChCiwG;UACHG,SAAS,KAAKH,UAAU3uF,KAAKthB;UAC7BowG,SAAS,KAAKH,UAAU3uF,KAAKthB,IAAI;UACjCowG,SAAS,KAAKH,UAAU3uF,KAAKthB,IAAI;;UAEjCowG,SAAS,KAAKpwG;UACdowG,SAAS,KAAKpwG,IAAI;UAClBowG,SAAS,KAAKpwG,IAAI;;eAIlBsc,GACAC,GACAC,KACGqzF;QACJvzF,EAAE8E,oBAAoB8uF,cAAcE,SAAS;QAC7C7zF,EAAE6E,oBAAoB8uF,cAAcE,SAAS;QAC7C5zF,EAAE4E,oBAAoB8uF,cAAcE,SAAS;QAE7CP,UAAUplE,UAAUmlE;;QAGpBU,OAAO,MAAM,EAAEvrG,KAAK8a,MAAMvD,EAAE1V,IAAIwnC,WAAW,GAAGrpC,KAAK8a,MAAMvD,EAAEvV,IAAIqnC,WAAW,GAAGrpC,KAAK8a,MAAMvD,EAAEtV,IAAIonC,WAAW;QACzGkiE,OAAO,MAAM,EAAEvrG,KAAK8a,MAAMtD,EAAE3V,IAAIwnC,WAAW,GAAGrpC,KAAK8a,MAAMtD,EAAExV,IAAIqnC,WAAW,GAAGrpC,KAAK8a,MAAMtD,EAAEvV,IAAIonC,WAAW;QACzGkiE,OAAO,MAAM,EAAEvrG,KAAK8a,MAAMrD,EAAE5V,IAAIwnC,WAAW,GAAGrpC,KAAK8a,MAAMrD,EAAEzV,IAAIqnC,WAAW,GAAGrpC,KAAK8a,MAAMrD,EAAExV,IAAIonC,WAAW;;YAErGkiE,OAAO,OAAOA,OAAO,MAAMA,OAAO,OAAOA,OAAO,MAAMA,OAAO,OAAOA,OAAO;;;;iBAKtEn4E,IAAI,GAAGA,IAAI,GAAGA;;gBAEhBq4E,SAASr4E,IAAI,KAAK;gBAClBs4E,WAAWH,OAAOn4E;gBAClBu4E,WAAWJ,OAAOE;gBAClBv4E,KAAK43E,UAAUQ,SAASl4E;gBACxBrX,KAAK+uF,UAAUQ,SAASG;gBACxBp6B,QAAQ,EAAEq6B,SAAS,GAAGC,SAAS;gBAC/BC,eAAe,EAAED,SAAS,GAAGD,SAAS;eAExCE,eAAeJ,aAAYA,SAASI;;;gBAGnCf,QAAQ5vF,IAAIuwF,SAASI,aAAat9E,WAAW28E;cAChDlwD,SAASpiD,KAAKu6B,GAAGrxB,GAAGqxB,GAAGlxB,GAAGkxB,GAAGjxB;cAC7B84C,SAASpiD,KAAKojB,GAAGla,GAAGka,GAAG/Z,GAAG+Z,GAAG9Z;;YAG9BupG,SAASI,eAAe;wBACZv6B,QAAQm6B;;YAEpBA,SAASn6B;cACRw6B,QAAQR,SAASj4E;cACjBqe,QAAQ45D,SAASI;cACjBn9E,QAAQu8E,QAAQpoG;;;;;;iBAOT+gC,OAAOgoE;YACbA,SAAShoE;iBAEXqoE,QACAp6D,UACG+5D,SAAShoE;UAEbmnE,IAAItuF,oBAAoB8uF,cAAcU;UAEtCjB,MAAMvuF,oBAAoB8uF,cAAc15D;UAExCsJ,SAASpiD,KAAKgyG,IAAI9oG,GAAG8oG,IAAI3oG,GAAG2oG,IAAI1oG;UAChC84C,SAASpiD,KAAKiyG,MAAM/oG,GAAG+oG,MAAM5oG,GAAG4oG,MAAM3oG;;;MAIxC,KAAKhE,aAAa,gBAAgB22C,uBAAuBmG,UAAU;;;;;;QAQ/D+wD;IACLC,aAAa,UAAU1zG,MAAM2zG,aAAaC;MACzCA,MAAMA,OAAO;YACPC,WAAWF,eAAeA,YAAY9wG;YACtCixG,WAAWD,WAAWF,YAAY,KAAKC,MAAM5zG,KAAK6C;UACpDkxG,YAAYC,WAAWh0G,MAAM,GAAG8zG,UAAUF,KAAK;YAC7CzvC;WACD4vC,aAAaA,UAAU1nC,SAAS0nC,UAAUE,aAAa9vC;UACxDptC,MAAMC,MAAME,MAAMC,MAAM3tB,GAAGG,GAAGuqG;UAC9BL,UAAUE,YAAYI,eAAen0G,MAAM2zG,aAAaI,WAAWH;;UAEnE5zG,KAAK6C,SAAS,KAAK+wG;QACtB78E,OAAOG,OAAOl3B,KAAK;QACnBg3B,OAAOG,OAAOn3B,KAAK;iBAEV4C,IAAIgxG,KAAKhxG,IAAIkxG,UAAUlxG,KAAKgxG;UACpCpqG,IAAIxJ,KAAK4C;UACT+G,IAAI3J,KAAK4C,IAAI;cACT4G,IAAIutB,MAAMA,OAAOvtB;cACjBG,IAAIqtB,MAAMA,OAAOrtB;cACjBH,IAAI0tB,MAAMA,OAAO1tB;cACjBG,IAAIwtB,MAAMA,OAAOxtB;;;QAItBuqG,UAAUvsG,KAAKF,IAAIyvB,OAAOH,MAAMI,OAAOH;QACvCk9E,UAAUA,YAAY,IAAI,IAAIA,UAAU;;MAGzCE,aAAaL,WAAW5vC,WAAWyvC,KAAK78E,MAAMC,MAAMk9E;aAC7C/vC;;;;EAIT,oBAAoBnkE,MAAMisC,OAAOI,KAAKunE,KAAKS;QACtCzxG,GAAG0xG;QAEHD,cAAcE,WAAWv0G,MAAMisC,OAAOI,KAAKunE,OAAO;WAChDhxG,IAAIqpC,OAAOrpC,IAAIypC,KAAKzpC,KAAKgxG,KAAKU,OAAOE,WAAW5xG,GAAG5C,KAAK4C,IAAI5C,KAAK4C,IAAI,IAAI0xG;;WAEzE1xG,IAAIypC,MAAMunE,KAAKhxG,KAAKqpC,OAAOrpC,KAAKgxG,KAAKU,OAAOE,WAAW5xG,GAAG5C,KAAK4C,IAAI5C,KAAK4C,IAAI,IAAI0xG;;QAGlFA,QAAQ1wF,OAAO0wF,MAAMA,KAAKjoC;MAC7BooC,WAAWH;MACXA,OAAOA,KAAKjoC;;WAGNioC;;;EAIR,sBAAsBroE,OAAOI;SACvBJ,cAAcA;SACdI,KAAKA,MAAMJ;QACZvZ,IAAIuZ,OACNyoE;;MAGDA,QAAQ;WAEHhiF,EAAEiiF,YAAY/wF,OAAO8O,GAAGA,EAAE25C,SAASuoC,KAAKliF,EAAEuhF,MAAMvhF,GAAGA,EAAE25C,UAAU;QACnEooC,WAAW/hF;QACXA,IAAI2Z,MAAM3Z,EAAEuhF;YACRvhF,MAAMA,EAAE25C;QACZqoC,QAAQ;;QAERhiF,IAAIA,EAAE25C;;aAECqoC,SAAShiF,MAAM2Z;WAEjBA;;;EAIR,sBAAsBwoE,KAAK1wC,WAAWyvC,KAAK78E,MAAMC,MAAMk9E,SAASY;SAC1DD;;SAEAC,QAAQZ,SAASa,WAAWF,KAAK99E,MAAMC,MAAMk9E;QAC9CvpD,OAAOkqD,KACTZ,MACA5nC;;WAEKwoC,IAAIZ,SAASY,IAAIxoC;MACvB4nC,OAAOY,IAAIZ;MACX5nC,OAAOwoC,IAAIxoC;UAEP6nC,UAAUc,YAAYH,KAAK99E,MAAMC,MAAMk9E,WAAWe,MAAMJ;;QAE3D1wC,UAAU7jE,KAAK2zG,KAAKrxG,IAAIgxG;QACxBzvC,UAAU7jE,KAAKu0G,IAAIjyG,IAAIgxG;QACvBzvC,UAAU7jE,KAAK+rE,KAAKzpE,IAAIgxG;QACxBa,WAAWI;;QAEXA,MAAMxoC,KAAKA;QACX1hB,OAAO0hB,KAAKA;;;MAIbwoC,MAAMxoC;;UAEFwoC,QAAQlqD;;aAENmqD;UACJV,aAAac,aAAaL,MAAM1wC,WAAWyvC,KAAK78E,MAAMC,MAAMk9E,SAAS;mBAC3DY,SAAS;UACnBD,MAAMM,uBAAuBD,aAAaL,MAAM1wC,WAAWyvC;UAC3DQ,aAAaS,KAAK1wC,WAAWyvC,KAAK78E,MAAMC,MAAMk9E,SAAS;mBAC7CY,SAAS;UACnBM,YAAYP,KAAK1wC,WAAWyvC,KAAK78E,MAAMC,MAAMk9E;;;;;;;EASjD,eAAeW;UACR31F,IAAI21F,IAAIZ,MACX90F,IAAI01F,KACJz1F,IAAIy1F,IAAIxoC;QACPuoC,KAAK11F,GAAGC,GAAGC,MAAM,UAAU;;;QAG3BsT,IAAImiF,IAAIxoC,KAAKA;WAEV35C,MAAMmiF,IAAIZ;UACZoB,gBAAgBn2F,EAAE1V,GAAG0V,EAAEvV,GAAGwV,EAAE3V,GAAG2V,EAAExV,GAAGyV,EAAE5V,GAAG4V,EAAEzV,GAAG+oB,EAAElpB,GAAGkpB,EAAE/oB,MAAMirG,KAAKliF,EAAEuhF,MAAMvhF,GAAGA,EAAE25C,SAAS,UAAU;MACpG35C,IAAIA,EAAE25C;;WAGA;;EAGR,qBAAqBwoC,KAAK99E,MAAMC,MAAMk9E;UAC/Bh1F,IAAI21F,IAAIZ,MACX90F,IAAI01F,KACJz1F,IAAIy1F,IAAIxoC;QACPuoC,KAAK11F,GAAGC,GAAGC,MAAM,UAAU;;;UAGzBk2F,QAAQp2F,EAAE1V,IAAI2V,EAAE3V,IAAI0V,EAAE1V,IAAI4V,EAAE5V,IAAI0V,EAAE1V,IAAI4V,EAAE5V,IAAI2V,EAAE3V,IAAI4V,EAAE5V,IAAI2V,EAAE3V,IAAI4V,EAAE5V,GACnE+rG,QAAQr2F,EAAEvV,IAAIwV,EAAExV,IAAIuV,EAAEvV,IAAIyV,EAAEzV,IAAIuV,EAAEvV,IAAIyV,EAAEzV,IAAIwV,EAAExV,IAAIyV,EAAEzV,IAAIwV,EAAExV,IAAIyV,EAAEzV,GAChE6rG,QAAQt2F,EAAE1V,IAAI2V,EAAE3V,IAAI0V,EAAE1V,IAAI4V,EAAE5V,IAAI0V,EAAE1V,IAAI4V,EAAE5V,IAAI2V,EAAE3V,IAAI4V,EAAE5V,IAAI2V,EAAE3V,IAAI4V,EAAE5V,GAChEisG,QAAQv2F,EAAEvV,IAAIwV,EAAExV,IAAIuV,EAAEvV,IAAIyV,EAAEzV,IAAIuV,EAAEvV,IAAIyV,EAAEzV,IAAIwV,EAAExV,IAAIyV,EAAEzV,IAAIwV,EAAExV,IAAIyV,EAAEzV;;UAE7DstB,OAAOy+E,OAAOJ,OAAOC,OAAOx+E,MAAMC,MAAMk9E,UAC3C98E,OAAOs+E,OAAOF,OAAOC,OAAO1+E,MAAMC,MAAMk9E;QACvCxhF,IAAImiF,IAAIc,OACV/3F,IAAIi3F,IAAIe;;WAEHljF,KAAKA,EAAE9oB,KAAKqtB,QAAQrZ,KAAKA,EAAEhU,KAAKwtB;UAClC1E,MAAMmiF,IAAIZ,QAAQvhF,MAAMmiF,IAAIxoC,QAAQgpC,gBAAgBn2F,EAAE1V,GAAG0V,EAAEvV,GAAGwV,EAAE3V,GAAG2V,EAAExV,GAAGyV,EAAE5V,GAAG4V,EAAEzV,GAAG+oB,EAAElpB,GAAGkpB,EAAE/oB,MAAMirG,KAAKliF,EAAEuhF,MAAMvhF,GAAGA,EAAE25C,SAAS,UAAU;MACxI35C,IAAIA,EAAEijF;UACF/3F,MAAMi3F,IAAIZ,QAAQr2F,MAAMi3F,IAAIxoC,QAAQgpC,gBAAgBn2F,EAAE1V,GAAG0V,EAAEvV,GAAGwV,EAAE3V,GAAG2V,EAAExV,GAAGyV,EAAE5V,GAAG4V,EAAEzV,GAAGiU,EAAEpU,GAAGoU,EAAEjU,MAAMirG,KAAKh3F,EAAEq2F,MAAMr2F,GAAGA,EAAEyuD,SAAS,UAAU;MACxIzuD,IAAIA,EAAEg4F;;;WAIAljF,KAAKA,EAAE9oB,KAAKqtB;UACdvE,MAAMmiF,IAAIZ,QAAQvhF,MAAMmiF,IAAIxoC,QAAQgpC,gBAAgBn2F,EAAE1V,GAAG0V,EAAEvV,GAAGwV,EAAE3V,GAAG2V,EAAExV,GAAGyV,EAAE5V,GAAG4V,EAAEzV,GAAG+oB,EAAElpB,GAAGkpB,EAAE/oB,MAAMirG,KAAKliF,EAAEuhF,MAAMvhF,GAAGA,EAAE25C,SAAS,UAAU;MACxI35C,IAAIA,EAAEijF;;;WAIA/3F,KAAKA,EAAEhU,KAAKwtB;UACdxZ,MAAMi3F,IAAIZ,QAAQr2F,MAAMi3F,IAAIxoC,QAAQgpC,gBAAgBn2F,EAAE1V,GAAG0V,EAAEvV,GAAGwV,EAAE3V,GAAG2V,EAAExV,GAAGyV,EAAE5V,GAAG4V,EAAEzV,GAAGiU,EAAEpU,GAAGoU,EAAEjU,MAAMirG,KAAKh3F,EAAEq2F,MAAMr2F,GAAGA,EAAEyuD,SAAS,UAAU;MACxIzuD,IAAIA,EAAEg4F;;WAGA;;;EAIR,gCAAgC3pE,OAAOk4B,WAAWyvC;QAC7ClhF,IAAIuZ;;YAGD/sB,IAAIwT,EAAEuhF,MACT90F,IAAIuT,EAAE25C,KAAKA;WAETzoD,OAAO1E,GAAGC,MAAMuiC,WAAWxiC,GAAGwT,GAAGA,EAAE25C,MAAMltD,MAAM02F,cAAc32F,GAAGC,MAAM02F,cAAc12F,GAAGD;QAC3FilD,UAAU7jE,KAAK4e,EAAEtc,IAAIgxG;QACrBzvC,UAAU7jE,KAAKoyB,EAAE9vB,IAAIgxG;QACrBzvC,UAAU7jE,KAAK6e,EAAEvc,IAAIgxG;;QAErBa,WAAW/hF;QACX+hF,WAAW/hF,EAAE25C;QACb35C,IAAIuZ,QAAQ9sB;;MAGbuT,IAAIA,EAAE25C;aACE35C,MAAMuZ;WAERipE,aAAaxiF;;;EAIrB,qBAAqBuZ,OAAOk4B,WAAWyvC,KAAK78E,MAAMC,MAAMk9E;;QAEnDh1F,IAAI+sB;;UAGH9sB,IAAID,EAAEmtD,KAAKA;aAERltD,MAAMD,EAAE+0F;YACV/0F,EAAEtc,MAAMuc,EAAEvc,KAAKkzG,gBAAgB52F,GAAGC;;cAEjCC,IAAI22F,aAAa72F,GAAGC;;UAExBD,IAAIg2F,aAAah2F,GAAGA,EAAEmtD;UACtBjtD,IAAI81F,aAAa91F,GAAGA,EAAEitD;;UAEtB+nC,aAAal1F,GAAGilD,WAAWyvC,KAAK78E,MAAMC,MAAMk9E;UAC5CE,aAAah1F,GAAG+kD,WAAWyvC,KAAK78E,MAAMC,MAAMk9E;;;QAI7C/0F,IAAIA,EAAEktD;;MAGPntD,IAAIA,EAAEmtD;aACEntD,MAAM+sB;;;EAIhB,wBAAwBjsC,MAAM2zG,aAAaI,WAAWH;UAC/CoC;QACFpzG,GAAGouB,KAAKib,OAAOI,KAAKisC;UAEnB11E,IAAI,GAAGouB,MAAM2iF,YAAY9wG,SAAQD,IAAIouB,KAAKpuB;MAC9CqpC,QAAQ0nE,YAAY/wG,KAAKgxG;MACzBvnE,MAAMzpC,IAAIouB,MAAM,IAAI2iF,YAAY/wG,IAAI,KAAKgxG,MAAM5zG,KAAK6C;MACpDy1E,OAAO07B,WAAWh0G,MAAMisC,OAAOI,KAAKunE,KAAK;UACrCt7B,SAASA,KAAKjM,MAAMiM,KAAKq8B,UAAU;MACvCqB,MAAM11G,KAAK21G,YAAY39B;;IAGxB09B,MAAM/wC,KAAKixC;;SAENtzG,IAAI,GAAGA,IAAIozG,MAAMnzG,QAAQD;MAC7BuzG,cAAcH,MAAMpzG,IAAImxG;MACxBA,YAAYmB,aAAanB,WAAWA,UAAU1nC;;WAGxC0nC;;EAGR,kBAAkB70F,GAAGC;WACbD,EAAE1V,IAAI2V,EAAE3V;;;EAIhB,uBAAuB4sG,MAAMrC;IAC5BA,YAAYsC,eAAeD,MAAMrC;QAE7BA;YACG50F,IAAI42F,aAAahC,WAAWqC;;MAElClB,aAAanB,WAAWA,UAAU1nC;MAClC6oC,aAAa/1F,GAAGA,EAAEktD;;;;EAKpB,wBAAwB+pC,MAAMrC;QACzBrhF,IAAIqhF;UACFuC,KAAKF,KAAK5sG;UACV+sG,KAAKH,KAAKzsG;QACZyqB,MAAMyC,UACRhZ;;;;UAIG04F,MAAM7jF,EAAE/oB,KAAK4sG,MAAM7jF,EAAE25C,KAAK1iE,KAAK+oB,EAAE25C,KAAK1iE,MAAM+oB,EAAE/oB;cAC3CH,IAAIkpB,EAAElpB,KAAK+sG,KAAK7jF,EAAE/oB,MAAM+oB,EAAE25C,KAAK7iE,IAAIkpB,EAAElpB,MAAMkpB,EAAE25C,KAAK1iE,IAAI+oB,EAAE/oB;YAE1DH,KAAK8sG,MAAM9sG,IAAI4qB;UAClBA,KAAK5qB;cAEDA,MAAM8sG;gBACLC,OAAO7jF,EAAE/oB,UAAU+oB;gBACnB6jF,OAAO7jF,EAAE25C,KAAK1iE,UAAU+oB,EAAE25C;;UAG/BxuD,IAAI6U,EAAElpB,IAAIkpB,EAAE25C,KAAK7iE,IAAIkpB,IAAIA,EAAE25C;;;MAI7B35C,IAAIA,EAAE25C;aACE35C,MAAMqhF;SAEVl2F,UAAU;QACXy4F,OAAOliF,WAAWvW;;;;;UAKhB8sC,OAAO9sC,GACV24F,KAAK34F,EAAErU,GACPitG,KAAK54F,EAAElU;QACN+sG,SAAS7/E,UACXsvB;IACFzzB,IAAI7U;;UAGCy4F,MAAM5jF,EAAElpB,KAAKkpB,EAAElpB,KAAKgtG,MAAMF,OAAO5jF,EAAElpB,KAAK6rG,gBAAgBkB,KAAKE,KAAKH,KAAKliF,IAAImiF,IAAIC,IAAIC,IAAIF,KAAKE,KAAKriF,KAAKkiF,IAAIC,IAAI7jF,EAAElpB,GAAGkpB,EAAE/oB;QACxHw8C,MAAMx+C,KAAK4W,IAAIg4F,KAAK7jF,EAAE/oB,MAAM2sG,KAAK5jF,EAAElpB;;YAE/BqsG,cAAcnjF,GAAG0jF,UAAUjwD,MAAMuwD,UAAUvwD,QAAQuwD,WAAWhkF,EAAElpB,IAAIqU,EAAErU,KAAKkpB,EAAElpB,MAAMqU,EAAErU,KAAKmtG,qBAAqB94F,GAAG6U;UACrH7U,IAAI6U;UACJgkF,SAASvwD;;;MAIXzzB,IAAIA,EAAE25C;aACE35C,MAAMi4B;WAER9sC;;;EAIR,8BAA8BA,GAAG6U;WACzBkiF,KAAK/2F,EAAEo2F,MAAMp2F,GAAG6U,EAAEuhF,QAAQ,KAAKW,KAAKliF,EAAE25C,MAAMxuD,GAAGA,EAAEwuD,QAAQ;;;EAIjE,oBAAoBpgC,OAAOlV,MAAMC,MAAMk9E;QAClCxhF,IAAIuZ;;UAGHvZ,EAAE9oB,MAAM,MAAM8oB,EAAE9oB,IAAI8rG,OAAOhjF,EAAElpB,GAAGkpB,EAAE/oB,GAAGotB,MAAMC,MAAMk9E;MACrDxhF,EAAEijF,QAAQjjF,EAAEuhF;MACZvhF,EAAEkjF,QAAQljF,EAAE25C;MACZ35C,IAAIA,EAAE25C;aACE35C,MAAMuZ;IAEfvZ,EAAEijF,MAAMC,QAAQ;IAChBljF,EAAEijF,QAAQ;IACViB,WAAWlkF;;;;EAKZ,oBAAoB4lD;QACf11E,GACF8vB,GACAzT,GACAhb,GACA4yG,MACAC,WACAC,OACAC,OACAC,SAAS;;MAGVvkF,IAAI4lD;MACJA,OAAO;MACPu+B,OAAO;MACPC,YAAY;aAELpkF;QACNokF;QACA73F,IAAIyT;QACJqkF,QAAQ;aAEHn0G,IAAI,GAAGA,IAAIq0G,QAAQr0G;UACvBm0G;UACA93F,IAAIA,EAAE22F;eACD32F;;QAGN+3F,QAAQC;eAEDF,QAAQ,KAAKC,QAAQ,KAAK/3F;cAC5B83F,UAAU,MAAMC,UAAU,MAAM/3F,KAAKyT,EAAE9oB,KAAKqV,EAAErV;YACjD3F,IAAIyuB;YACJA,IAAIA,EAAEkjF;YACNmB;;YAEA9yG,IAAIgb;YACJA,IAAIA,EAAE22F;YACNoB;;cAGGH,MAAMA,KAAKjB,QAAQ3xG,QAAOq0E,OAAOr0E;UACrCA,EAAE0xG,QAAQkB;UACVA,OAAO5yG;;QAGRyuB,IAAIzT;;MAGL43F,KAAKjB,QAAQ;MACbqB,UAAU;aACFH,YAAY;WAEdx+B;;;EAIR,gBAAgB9uE,GAAGG,GAAGotB,MAAMC,MAAMk9E;;IAEjC1qG,IAAI,SAASA,IAAIutB,QAAQm9E;IACzBvqG,IAAI,SAASA,IAAIqtB,QAAQk9E;IACzB1qG,KAAKA,IAAIA,KAAK,KAAK;IACnBA,KAAKA,IAAIA,KAAK,KAAK;IACnBA,KAAKA,IAAIA,KAAK,KAAK;IACnBA,KAAKA,IAAIA,KAAK,KAAK;IACnBG,KAAKA,IAAIA,KAAK,KAAK;IACnBA,KAAKA,IAAIA,KAAK,KAAK;IACnBA,KAAKA,IAAIA,KAAK,KAAK;IACnBA,KAAKA,IAAIA,KAAK,KAAK;WACZH,IAAIG,KAAK;;;EAIjB,qBAAqBsiC;QAChBvZ,IAAIuZ,OACNirE,WAAWjrE;;UAGRvZ,EAAElpB,IAAI0tG,SAAS1tG,KAAKkpB,EAAElpB,MAAM0tG,SAAS1tG,KAAKkpB,EAAE/oB,IAAIutG,SAASvtG,GAAGutG,WAAWxkF;MAC3EA,IAAIA,EAAE25C;aACE35C,MAAMuZ;WAERirE;;;EAIR,yBAAyB7hF,IAAIC,IAAIE,IAAIC,IAAInN,IAAIC,IAAI4uF,IAAIC;YAC5C9uF,KAAK6uF,OAAO7hF,KAAK8hF,OAAO/hF,KAAK8hF,OAAO5uF,KAAK6uF,OAAO,MAAM/hF,KAAK8hF,OAAO1hF,KAAK2hF,OAAO5hF,KAAK2hF,OAAO7hF,KAAK8hF,OAAO,MAAM5hF,KAAK2hF,OAAO5uF,KAAK6uF,OAAO9uF,KAAK6uF,OAAO1hF,KAAK2hF,OAAO;;;EAIrK,yBAAyBl4F,GAAGC;WACpBD,EAAEmtD,KAAKzpE,MAAMuc,EAAEvc,KAAKsc,EAAE+0F,KAAKrxG,MAAMuc,EAAEvc,MAAMy0G,kBAAkBn4F,GAAGC;IACrE02F,cAAc32F,GAAGC,MAAM02F,cAAc12F,GAAGD,MAAMo4F,aAAap4F,GAAGC;IAC9Dy1F,KAAK11F,EAAE+0F,MAAM/0F,GAAGC,EAAE80F,SAASW,KAAK11F,GAAGC,EAAE80F,MAAM90F;IAC3CyE,OAAO1E,GAAGC,MAAMy1F,KAAK11F,EAAE+0F,MAAM/0F,GAAGA,EAAEmtD,QAAQ,KAAKuoC,KAAKz1F,EAAE80F,MAAM90F,GAAGA,EAAEktD,QAAQ;;;EAI1E,cAAc35C,GAAGzT,GAAG+I;YACX/I,EAAEtV,IAAI+oB,EAAE/oB,MAAMqe,EAAExe,IAAIyV,EAAEzV,MAAMyV,EAAEzV,IAAIkpB,EAAElpB,MAAMwe,EAAEre,IAAIsV,EAAEtV;;;EAI3D,gBAAgBsxB,IAAIC;WACZD,GAAGzxB,MAAM0xB,GAAG1xB,KAAKyxB,GAAGtxB,MAAMuxB,GAAGvxB;;;EAIrC,oBAAoBsxB,IAAIs8E,IAAIr8E,IAAIs8E;UACzBC,KAAK74E,KAAKg2E,KAAK35E,IAAIs8E,IAAIr8E;UACvBw8E,KAAK94E,KAAKg2E,KAAK35E,IAAIs8E,IAAIC;UACvBG,KAAK/4E,KAAKg2E,KAAK15E,IAAIs8E,IAAIv8E;UACvB28E,KAAKh5E,KAAKg2E,KAAK15E,IAAIs8E,IAAID;QACzBE,OAAOC,MAAMC,OAAOC,WAAW;;QAE/BH,OAAO,KAAKI,UAAU58E,IAAIC,IAAIq8E,YAAY;;QAE1CG,OAAO,KAAKG,UAAU58E,IAAIu8E,IAAID,YAAY;;QAE1CI,OAAO,KAAKE,UAAU38E,IAAID,IAAIu8E,YAAY;;QAE1CI,OAAO,KAAKC,UAAU38E,IAAIq8E,IAAIC,YAAY;;WAEvC;;;EAIR,mBAAmB9kF,GAAGzT,GAAG+I;WACjB/I,EAAEzV,KAAK7B,KAAKF,IAAIirB,EAAElpB,GAAGwe,EAAExe,MAAMyV,EAAEzV,KAAK7B,KAAKD,IAAIgrB,EAAElpB,GAAGwe,EAAExe,MAAMyV,EAAEtV,KAAKhC,KAAKF,IAAIirB,EAAE/oB,GAAGqe,EAAEre,MAAMsV,EAAEtV,KAAKhC,KAAKD,IAAIgrB,EAAE/oB,GAAGqe,EAAEre;;EAGtH,cAAcmuG;WACNA,MAAM,IAAI,IAAIA,MAAM,KAAK,IAAI;;;EAIrC,2BAA2B54F,GAAGC;QACzBuT,IAAIxT;;UAGHwT,EAAE9vB,MAAMsc,EAAEtc,KAAK8vB,EAAE25C,KAAKzpE,MAAMsc,EAAEtc,KAAK8vB,EAAE9vB,MAAMuc,EAAEvc,KAAK8vB,EAAE25C,KAAKzpE,MAAMuc,EAAEvc,KAAK8+C,WAAWhvB,GAAGA,EAAE25C,MAAMntD,GAAGC,WAAW;MAC9GuT,IAAIA,EAAE25C;aACE35C,MAAMxT;WAER;;;EAIR,uBAAuBA,GAAGC;WAClBy1F,KAAK11F,EAAE+0F,MAAM/0F,GAAGA,EAAEmtD,QAAQ,IAAIuoC,KAAK11F,GAAGC,GAAGD,EAAEmtD,SAAS,KAAKuoC,KAAK11F,GAAGA,EAAE+0F,MAAM90F,MAAM,IAAIy1F,KAAK11F,GAAGC,GAAGD,EAAE+0F,QAAQ,KAAKW,KAAK11F,GAAGA,EAAEmtD,MAAMltD,KAAK;;;EAI1I,sBAAsBD,GAAGC;QACpBuT,IAAIxT,GACN64F,SAAS;UACLZ,MAAMj4F,EAAE1V,IAAI2V,EAAE3V,KAAK,GACtB4tG,MAAMl4F,EAAEvV,IAAIwV,EAAExV,KAAK;;UAGjB+oB,EAAE/oB,IAAIytG,OAAO1kF,EAAE25C,KAAK1iE,IAAIytG,MAAM1kF,EAAE25C,KAAK1iE,MAAM+oB,EAAE/oB,KAAKwtG,MAAMzkF,EAAE25C,KAAK7iE,IAAIkpB,EAAElpB,MAAM4tG,KAAK1kF,EAAE/oB,MAAM+oB,EAAE25C,KAAK1iE,IAAI+oB,EAAE/oB,KAAK+oB,EAAElpB,GAAGuuG,UAAUA;MAC7HrlF,IAAIA,EAAE25C;aACE35C,MAAMxT;WAER64F;;;;EAKR,sBAAsB74F,GAAGC;UAClBpB,SAASi6F,KAAK94F,EAAEtc,GAAGsc,EAAE1V,GAAG0V,EAAEvV,IAC7BsU,SAAS+5F,KAAK74F,EAAEvc,GAAGuc,EAAE3V,GAAG2V,EAAExV,IAC1BsuG,KAAK/4F,EAAEmtD,MACP6rC,KAAK/4F,EAAE80F;IACV/0F,EAAEmtD,OAAOltD;IACTA,EAAE80F,OAAO/0F;IACTnB,GAAGsuD,OAAO4rC;IACVA,GAAGhE,OAAOl2F;IACVE,GAAGouD,OAAOtuD;IACVA,GAAGk2F,OAAOh2F;IACVi6F,GAAG7rC,OAAOpuD;IACVA,GAAGg2F,OAAOiE;WACHj6F;;;EAIR,oBAAoBrb,GAAG4G,GAAGG,GAAG2qG;UACtB5hF,QAAQslF,KAAKp1G,GAAG4G,GAAGG;SAEpB2qG;MACJ5hF,EAAEuhF,OAAOvhF;MACTA,EAAE25C,OAAO35C;;MAETA,EAAE25C,OAAOioC,KAAKjoC;MACd35C,EAAEuhF,OAAOK;MACTA,KAAKjoC,KAAK4nC,OAAOvhF;MACjB4hF,KAAKjoC,OAAO35C;;WAGNA;;EAGR,oBAAoBA;IACnBA,EAAE25C,KAAK4nC,OAAOvhF,EAAEuhF;IAChBvhF,EAAEuhF,KAAK5nC,OAAO35C,EAAE25C;QACZ35C,EAAEijF,OAAOjjF,EAAEijF,MAAMC,QAAQljF,EAAEkjF;QAC3BljF,EAAEkjF,OAAOljF,EAAEkjF,MAAMD,QAAQjjF,EAAEijF;;EAGhC,cAAc/yG,GAAG4G,GAAGG;;IAEnB,KAAK/G,IAAIA;;IAET,KAAK4G,IAAIA;IACT,KAAKG,IAAIA;;IAET,KAAKsqG,OAAO;IACZ,KAAK5nC,OAAO;;IAEZ,KAAKziE,IAAI;;IAET,KAAK+rG,QAAQ;IACb,KAAKC,QAAQ;;IAEb,KAAKjB,UAAU;;EAGhB,oBAAoB30G,MAAMisC,OAAOI,KAAKunE;QACjCuE,MAAM;aAEDv1G,IAAIqpC,OAAOlR,IAAIsR,MAAMunE,KAAKhxG,IAAIypC,KAAKzpC,KAAKgxG;MAChDuE,QAAQn4G,KAAK+6B,KAAK/6B,KAAK4C,OAAO5C,KAAK4C,IAAI,KAAK5C,KAAK+6B,IAAI;MACrDA,IAAIn4B;;WAGEu1G;;EAGR;;WAEQvD,KAAKwD;YACLx6F,IAAIw6F,QAAQv1G;UACdqc,IAAI;eAECwT,IAAI9U,IAAI,GAAGqB,IAAI,GAAGA,IAAIrB,GAAG8U,IAAIzT;QACrCC,KAAKk5F,QAAQ1lF,GAAGlpB,IAAI4uG,QAAQn5F,GAAGtV,IAAIyuG,QAAQn5F,GAAGzV,IAAI4uG,QAAQ1lF,GAAG/oB;;aAGvDuV,IAAI;;WAGLm5F,YAAYC;aACXC,WAAW3D,KAAK0D,OAAO;;WAGxBE,iBAAiBJ,SAASK;YAC1B/1D;;YAEAixD;;YAEA+E;;MAENC,gBAAgBP;MAChBQ,WAAWl2D,UAAU01D;;UAEjBS,YAAYT,QAAQv1G;MACxB41G,MAAMt2G,QAAQw2G;eAEL/1G,IAAI,GAAGA,IAAI61G,MAAM51G,QAAQD;QACjC+wG,YAAYrzG,KAAKu4G;QACjBA,aAAaJ,MAAM71G,GAAGC;QACtB+1G,WAAWl2D,UAAU+1D,MAAM71G;;;YAItBuhE,YAAYsvC,OAAOC,YAAYhxD,UAAUixD;;eAEtC/wG,IAAI,GAAGA,IAAIuhE,UAAUthE,QAAQD,KAAK;QAC1C81G,MAAMp4G,KAAK6jE,UAAUrnD,MAAMla,GAAGA,IAAI;;aAG5B81G;;;EAKT,yBAAyBnhF;UAClBxa,IAAIwa,OAAO10B;QAEbka,IAAI,KAAKwa,OAAOxa,IAAI,GAAG6G,OAAO2T,OAAO;MACxCA,OAAO2/C;;;EAIT,oBAAoBx0B,UAAU01D;aACpBx1G,IAAI,GAAGA,IAAIw1G,QAAQv1G,QAAQD;MACnC8/C,SAASpiD,KAAK83G,QAAQx1G,GAAG4G;MACzBk5C,SAASpiD,KAAK83G,QAAQx1G,GAAG+G;;;;;;;;;;;;;;;;;;;;;;;;EA0B3B,8BAA8B+1C;IAC7B13C,YAAY6hC,QAAQh8B;MACnB;MACA,KAAKjM,OAAO;MACZ,KAAK6oC;QACJZ,QAAQA;QACRh8B,SAASA;;MAEVg8B,SAAS3kC,MAAMC,QAAQ0kC,UAAUA,UAAUA;YACrC4Y,QAAQ;YACRq2D;YACA1V;eAEGxgG,IAAI,GAAGma,IAAI8sB,OAAOhnC,QAAQD,IAAIma,GAAGna;cACnC8nC,QAAQb,OAAOjnC;QACrBm2G,SAASruE;;;MAIV,KAAK9kC,aAAa,gBAAgB22C,uBAAuBu8D,eAAe;MACxE,KAAKlzG,aAAa,UAAU22C,uBAAuB6mD,SAAS;MAC5D,KAAK/kD;;MAEL,kBAAkB3T;cACXsuE;;cAEAC,gBAAgBprG,QAAQorG,kBAAkBz4G,YAAYqN,QAAQorG,gBAAgB;cAC9EC,QAAQrrG,QAAQqrG,UAAU14G,YAAYqN,QAAQqrG,QAAQ;YACxDhrF,QAAQrgB,QAAQqgB,UAAU1tB,YAAYqN,QAAQqgB,QAAQ;YACtDirF,eAAetrG,QAAQsrG,iBAAiB34G,YAAYqN,QAAQsrG,eAAe;YAC3EC,iBAAiBvrG,QAAQurG,mBAAmB54G,YAAYqN,QAAQurG,iBAAiB;YACjFC,YAAYxrG,QAAQwrG,cAAc74G,YAAYqN,QAAQwrG,YAAYD,iBAAiB;YACnFE,cAAczrG,QAAQyrG,gBAAgB94G,YAAYqN,QAAQyrG,cAAc;YACxEC,gBAAgB1rG,QAAQ0rG,kBAAkB/4G,YAAYqN,QAAQ0rG,gBAAgB;cAC5EC,cAAc3rG,QAAQ2rG;cACtBC,QAAQ5rG,QAAQ6rG,gBAAgBl5G,YAAYqN,QAAQ6rG,cAAcC;;YAEpE9rG,QAAQ+rG,WAAWp5G;UACtBiC,QAAQ0B,KAAK;UACb+pB,QAAQrgB,QAAQ+rG;;;YAIbC,YACFC,gBAAgB;YACdC,YAAYC,UAAU/jF,QAAQgkF;YAE9BT;UACHK,aAAaL,YAAYU,gBAAgBhB;UACzCY,gBAAgB;UAChBX,eAAe;;;;UAIfY,aAAaP,YAAYW,oBAAoBjB,OAAO;;UAEpDc,eAAe5xG;UACf6tB,aAAa7tB;UACb6xG,gBAAgB7xG;;;aAIZ+wG;UACJI,gBAAgB;UAChBH,iBAAiB;UACjBC,YAAY;UACZC,cAAc;;;cAITc,cAAc1vE,MAAM2vE,cAAcpB;YACpCv2D,WAAW03D,YAAY1vE;cACrB+tE,QAAQ2B,YAAY3B;cACpB6B,WAAW/B,WAAWF,YAAY31D;YAEpC43D;UACH53D,WAAWA,SAAS43D;;mBAEXlzF,IAAI,GAAGmzF,KAAK9B,MAAM51G,QAAQukB,IAAImzF,IAAInzF;kBACpCozF,QAAQ/B,MAAMrxF;gBAEhBmxF,WAAWF,YAAYmC;cAC1B/B,MAAMrxF,KAAKozF,MAAMF;;;;cAKd5B,QAAQH,WAAWC,iBAAiB91D,UAAU+1D;;cAG9CL,UAAU11D;;iBAEPt7B,IAAI,GAAGmzF,KAAK9B,MAAM51G,QAAQukB,IAAImzF,IAAInzF;gBACpCozF,QAAQ/B,MAAMrxF;UACpBs7B,WAAWA,SAASt9C,OAAOo1G;;QAG5B,kBAAkBC,IAAIC,KAAK3tG;eACrB2tG,KAAKj4G,QAAQa,MAAM;iBACjBo3G,IAAItwG,QAAQJ,eAAe+C,MAAM9C,IAAIwwG;;cAGvCE,OAAOj4D,SAAS7/C,QACnB+3G,OAAOlC,MAAM71G;;QAEhB,qBAAqBg4G,MAAMC,QAAQC;;;;;;;cAO9BC,WAAWC,WAAWC;;;;gBAIpBC,WAAWN,KAAKrxG,IAAIsxG,OAAOtxG,GAC9B4xG,WAAWP,KAAKlxG,IAAImxG,OAAOnxG;gBACxB0xG,WAAWN,OAAOvxG,IAAIqxG,KAAKrxG,GAC9B8xG,WAAWP,OAAOpxG,IAAIkxG,KAAKlxG;gBACxB4xG,eAAeJ,WAAWA,WAAWC,WAAWA;;gBAEhDI,aAAaL,WAAWG,WAAWF,WAAWC;cAEhD1zG,KAAK4W,IAAIi9F,cAAc1qF,OAAOC;;;kBAG3B0qF,aAAa9zG,KAAKob,KAAKw4F;kBACvBG,aAAa/zG,KAAKob,KAAKs4F,WAAWA,WAAWC,WAAWA;;kBAExDK,gBAAgBb,OAAOtxG,IAAI4xG,WAAWK;kBACtCG,gBAAgBd,OAAOnxG,IAAIwxG,WAAWM;kBACtCI,gBAAgBd,OAAOvxG,IAAI8xG,WAAWI;kBACtCI,gBAAgBf,OAAOpxG,IAAI0xG,WAAWK;;kBAEtCK,OAAOF,gBAAgBF,iBAAiBL,YAAYQ,gBAAgBF,iBAAiBP,aAAaF,WAAWG,WAAWF,WAAWC;;YAEzIL,YAAYW,gBAAgBR,WAAWY,KAAKlB,KAAKrxG;YACjDyxG,YAAYW,gBAAgBR,WAAWW,KAAKlB,KAAKlxG;;;kBAG3CqyG,gBAAgBhB,YAAYA,YAAYC,YAAYA;gBAEtDe,iBAAiB;yBACT13F,QAAQ02F,WAAWC;;cAE9BC,YAAYvzG,KAAKob,KAAKi5F,gBAAgB;;;;gBAInCC,eAAe;;gBAEfd,WAAWrqF,OAAOC;kBACjBsqF,WAAWvqF,OAAOC;gBACrBkrF,eAAe;;;kBAGZd,YAAYrqF,OAAOC;oBAClBsqF,YAAYvqF,OAAOC;kBACtBkrF,eAAe;;;oBAGZt0G,KAAKi3B,KAAKw8E,cAAczzG,KAAKi3B,KAAK08E;kBACrCW,eAAe;;;;gBAKdA;;cAEHjB,aAAaI;cACbH,YAAYE;cACZD,YAAYvzG,KAAKob,KAAKw4F;;;cAGtBP,YAAYG;cACZF,YAAYG;cACZF,YAAYvzG,KAAKob,KAAKw4F,eAAe;;;qBAI5Bj3F,QAAQ02F,YAAYE,WAAWD,YAAYC;;cAGjDgB;iBAEGt5G,IAAI,GAAGksB,KAAKspF,QAAQv1G,QAAQk4B,IAAIjM,KAAK,GAAG/pB,IAAInC,IAAI,GAAGA,IAAIksB,KAAIlsB,KAAKm4B,KAAKh2B;cACzEg2B,MAAMjM,IAAIiM,IAAI;cACdh2B,MAAM+pB,IAAI/pB,IAAI;;;UAGlBm3G,iBAAiBt5G,KAAKu5G,YAAY/D,QAAQx1G,IAAIw1G,QAAQr9E,IAAIq9E,QAAQrzG;;cAG7Dq3G;YACFC,kBACFC,oBAAoBJ,iBAAiB92G;iBAE9BgiB,IAAI,GAAGmzF,KAAK9B,MAAM51G,QAAQukB,IAAImzF,IAAInzF;gBACpCozF,QAAQ/B,MAAMrxF;UACpBi1F;mBAESz5G,IAAI,GAAGksB,KAAK0rF,MAAM33G,QAAQk4B,IAAIjM,KAAK,GAAG/pB,IAAInC,IAAI,GAAGA,IAAIksB,KAAIlsB,KAAKm4B,KAAKh2B;gBACvEg2B,MAAMjM,IAAIiM,IAAI;gBACdh2B,MAAM+pB,IAAI/pB,IAAI;;YAElBs3G,iBAAiBz5G,KAAKu5G,YAAY3B,MAAM53G,IAAI43G,MAAMz/E,IAAIy/E,MAAMz1G;;UAG7Dq3G,eAAe97G,KAAK+7G;UACpBC,oBAAoBA,kBAAkBl3G,OAAOi3G;;;iBAIrCl9F,IAAI,GAAGA,IAAIo6F,eAAep6F;;gBAE5BjB,IAAIiB,IAAIo6F;gBACR3vG,IAAIwvG,iBAAiBzxG,KAAK+B,IAAIwU,IAAIvW,KAAKyV,KAAK;gBAC5Cm/F,KAAKlD,YAAY1xG,KAAK8B,IAAIyU,IAAIvW,KAAKyV,KAAK,KAAKk8F;;mBAE1C12G,IAAI,GAAGksB,KAAKspF,QAAQv1G,QAAQD,IAAIksB,IAAIlsB;kBACtC45G,OAAOC,SAASrE,QAAQx1G,IAAIs5G,iBAAiBt5G,IAAI25G;YACvDn1G,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,IAAIC;;;mBAIXwd,IAAI,GAAGmzF,KAAK9B,MAAM51G,QAAQukB,IAAImzF,IAAInzF;kBACpCozF,QAAQ/B,MAAMrxF;YACpBi1F,mBAAmBD,eAAeh1F;qBAEzBxkB,IAAI,GAAGksB,KAAK0rF,MAAM33G,QAAQD,IAAIksB,IAAIlsB;oBACpC45G,OAAOC,SAASjC,MAAM53G,IAAIy5G,iBAAiBz5G,IAAI25G;cACrDn1G,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,IAAIC;;;;cAKhB2yG,KAAKlD,YAAYC;;iBAEd12G,IAAI,GAAGA,IAAI+3G,MAAM/3G;gBACnB45G,OAAOrD,eAAesD,SAAS/5D,SAAS9/C,IAAI05G,kBAAkB15G,IAAI25G,MAAM75D,SAAS9/C;eAElFk3G;YACJ1yG,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,GAAG;;;YAGlBssB,OAAOtU,KAAKo4F,WAAW78D,QAAQ,IAAIlzC,eAAewyG,KAAKhzG;YACvDwwG,SAASr4F,KAAKo4F,WAAW2C,UAAU,IAAI1yG,eAAewyG,KAAK7yG;YAC3DswG,UAAUt4F,KAAKk4F,WAAW,IAAI5vG,IAAIgsB,QAAQhsB,IAAI+vG;YAC9C5yG,EAAE6yG,UAAUzwG,GAAGywG,UAAUtwG,GAAGswG,UAAUrwG;;;;;iBAM/BgV,IAAI,GAAGA,KAAKs6F,OAAOt6F;mBAClBhc,IAAI,GAAGA,IAAI+3G,MAAM/3G;kBACnB45G,OAAOrD,eAAesD,SAAS/5D,SAAS9/C,IAAI05G,kBAAkB15G,IAAI25G,MAAM75D,SAAS9/C;iBAElFk3G;cACJ1yG,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,GAAGukB,QAAQgrF,QAAQt6F;;;cAGlCqX,OAAOtU,KAAKo4F,WAAW78D,QAAQt+B,IAAI5U,eAAewyG,KAAKhzG;cACvDwwG,SAASr4F,KAAKo4F,WAAW2C,UAAU99F,IAAI5U,eAAewyG,KAAK7yG;cAC3DswG,UAAUt4F,KAAKk4F,WAAWj7F,IAAI3U,IAAIgsB,QAAQhsB,IAAI+vG;cAC9C5yG,EAAE6yG,UAAUzwG,GAAGywG,UAAUtwG,GAAGswG,UAAUrwG;;;;;;iBAOhCuV,IAAIo6F,gBAAgB,GAAGp6F,KAAK,GAAGA;gBACjCjB,IAAIiB,IAAIo6F;gBACR3vG,IAAIwvG,iBAAiBzxG,KAAK+B,IAAIwU,IAAIvW,KAAKyV,KAAK;gBAC5Cm/F,KAAKlD,YAAY1xG,KAAK8B,IAAIyU,IAAIvW,KAAKyV,KAAK,KAAKk8F;;mBAE1C12G,IAAI,GAAGksB,KAAKspF,QAAQv1G,QAAQD,IAAIksB,IAAIlsB;kBACtC45G,OAAOC,SAASrE,QAAQx1G,IAAIs5G,iBAAiBt5G,IAAI25G;YACvDn1G,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,GAAGukB,QAAQtkB;;;mBAIlBwd,IAAI,GAAGmzF,KAAK9B,MAAM51G,QAAQukB,IAAImzF,IAAInzF;kBACpCozF,QAAQ/B,MAAMrxF;YACpBi1F,mBAAmBD,eAAeh1F;qBAEzBxkB,IAAI,GAAGksB,KAAK0rF,MAAM33G,QAAQD,IAAIksB,IAAIlsB;oBACpC45G,OAAOC,SAASjC,MAAM53G,IAAIy5G,iBAAiBz5G,IAAI25G;mBAEhDzC;gBACJ1yG,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,GAAGukB,QAAQtkB;;gBAE1BxC,EAAEo1G,KAAKhzG,GAAGgzG,KAAK7yG,IAAIkwG,WAAWX,QAAQ,GAAGvvG,GAAGkwG,WAAWX,QAAQ,GAAG1vG,IAAII;;;;;;;QAS1E+yG;;QAEAC;;QAEA;gBACO3wE,QAAQ6sE,cAAcj2G,SAAS;cAEjCs2G;gBACC9S,QAAQ;;gBAERviF,SAAS62F,OAAOtU;;qBAEXzjG,IAAI,GAAGA,IAAIg4G,MAAMh4G;oBACnBo/C,OAAO02D,MAAM91G;cACnBi6G,GAAG76D,KAAK,KAAKl+B,QAAQk+B,KAAK,KAAKl+B,QAAQk+B,KAAK,KAAKl+B;;YAGlDuiF,QAAQ6S,QAAQK,gBAAgB;YAChCz1F,SAAS62F,OAAOtU;;qBAEPzjG,IAAI,GAAGA,IAAIg4G,MAAMh4G;oBACnBo/C,OAAO02D,MAAM91G;cACnBi6G,GAAG76D,KAAK,KAAKl+B,QAAQk+B,KAAK,KAAKl+B,QAAQk+B,KAAK,KAAKl+B;;;;qBAIzClhB,IAAI,GAAGA,IAAIg4G,MAAMh4G;oBACnBo/C,OAAO02D,MAAM91G;cACnBi6G,GAAG76D,KAAK,IAAIA,KAAK,IAAIA,KAAK;;;qBAIlBp/C,IAAI,GAAGA,IAAIg4G,MAAMh4G;oBACnBo/C,OAAO02D,MAAM91G;cACnBi6G,GAAG76D,KAAK,KAAK24D,OAAOzB,OAAOl3D,KAAK,KAAK24D,OAAOzB,OAAOl3D,KAAK,KAAK24D,OAAOzB;;;UAItEz2D,MAAMvG,SAASjQ,OAAO6sE,cAAcj2G,SAAS,IAAIopC,OAAO;;;QAIzD;gBACOA,QAAQ6sE,cAAcj2G,SAAS;cACjCi6G,cAAc;UAClBC,UAAU3E,SAAS0E;UACnBA,eAAe1E,QAAQv1G;mBAEdukB,IAAI,GAAGmzF,KAAK9B,MAAM51G,QAAQukB,IAAImzF,IAAInzF;kBACpCozF,QAAQ/B,MAAMrxF;YACpB21F,UAAUvC,OAAOsC;;YAEjBA,eAAetC,MAAM33G;;UAGtB4/C,MAAMvG,SAASjQ,OAAO6sE,cAAcj2G,SAAS,IAAIopC,OAAO;;QAGzD,mBAAmBmsE,SAAS0E;cACvBl6G,IAAIw1G,QAAQv1G;mBAEPD,KAAK;kBACPm4B,IAAIn4B;gBACNmC,IAAInC,IAAI;gBACRmC,IAAI,GAAGA,IAAIqzG,QAAQv1G,SAAS;;qBAEvB+b,IAAI,GAAGo+F,KAAK9D,QAAQK,gBAAgB,GAAG36F,IAAIo+F,IAAIp+F;oBACjDq+F,QAAQtC,OAAO/7F;oBACfs+F,QAAQvC,QAAQ/7F,IAAI;oBACpBM,IAAI49F,cAAc/hF,IAAIkiF,OACzB99F,IAAI29F,cAAc/3G,IAAIk4G,OACtB79F,IAAI09F,cAAc/3G,IAAIm4G,OACtBl4G,IAAI83G,cAAc/hF,IAAImiF;cACzBC,GAAGj+F,GAAGC,GAAGC,GAAGpa;;;;QAKf,WAAWwE,GAAGG,GAAGC;UAChBovG,YAAY14G,KAAKkJ;UACjBwvG,YAAY14G,KAAKqJ;UACjBqvG,YAAY14G,KAAKsJ;;QAGlB,YAAYsV,GAAGC,GAAGC;UACjBg+F,UAAUl+F;UACVk+F,UAAUj+F;UACVi+F,UAAUh+F;gBACJi+F,YAAYvE,cAAcj2G,SAAS;gBACnCs6C,MAAMs8D,MAAM6D,cAAc76D,OAAOq2D,eAAeuE,YAAY,GAAGA,YAAY,GAAGA,YAAY;UAChGE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;;QAGX,YAAYj+B,GAAGC,GAAGC,GAAGpa;UACpBo4G,UAAUl+F;UACVk+F,UAAUj+F;UACVi+F,UAAUp4G;UACVo4G,UAAUj+F;UACVi+F,UAAUh+F;UACVg+F,UAAUp4G;gBACJq4G,YAAYvE,cAAcj2G,SAAS;gBACnCs6C,MAAMs8D,MAAM+D,mBAAmB/6D,OAAOq2D,eAAeuE,YAAY,GAAGA,YAAY,GAAGA,YAAY,GAAGA,YAAY;UACpHE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;UACVogE,MAAMpgE,IAAI;;QAGX,mBAAmBzgC;UAClBo8F,cAAcx4G,KAAK04G,YAAYt8F,QAAQ,IAAI;UAC3Co8F,cAAcx4G,KAAK04G,YAAYt8F,QAAQ,IAAI;UAC3Co8F,cAAcx4G,KAAK04G,YAAYt8F,QAAQ,IAAI;;QAG5C,eAAe+gG;UACdra,QAAQ9iG,KAAKm9G,QAAQj0G;UACrB45F,QAAQ9iG,KAAKm9G,QAAQ9zG;;;;IAKxB0hB;YACOrrB,OAAO,MAAMqrB;YACbwe,SAAS,KAAKY,WAAWZ;YACzBh8B,UAAU,KAAK48B,WAAW58B;aACzB6vG,SAAS7zE,QAAQh8B,SAAS7N;;;QAK7B25G;IACL2D,eAAe,UAAU50G,UAAUg6C,UAAUi7D,QAAQC,QAAQC;YACtDC,MAAMp7D,SAASi7D,SAAS;YACxBI,MAAMr7D,SAASi7D,SAAS,IAAI;YAC5BK,MAAMt7D,SAASk7D,SAAS;YACxBK,MAAMv7D,SAASk7D,SAAS,IAAI;YAC5BM,MAAMx7D,SAASm7D,SAAS;YACxBM,MAAMz7D,SAASm7D,SAAS,IAAI;kBACtBv5F,QAAQw5F,KAAKC,UAAUz5F,QAAQ05F,KAAKC,UAAU35F,QAAQ45F,KAAKC;;IAExEX,oBAAoB,UAAU90G,UAAUg6C,UAAUi7D,QAAQC,QAAQC,QAAQO;YACnEN,MAAMp7D,SAASi7D,SAAS;YACxBI,MAAMr7D,SAASi7D,SAAS,IAAI;YAC5BU,MAAM37D,SAASi7D,SAAS,IAAI;YAC5BK,MAAMt7D,SAASk7D,SAAS;YACxBK,MAAMv7D,SAASk7D,SAAS,IAAI;YAC5BU,MAAM57D,SAASk7D,SAAS,IAAI;YAC5BM,MAAMx7D,SAASm7D,SAAS;YACxBM,MAAMz7D,SAASm7D,SAAS,IAAI;YAC5BU,MAAM77D,SAASm7D,SAAS,IAAI;YAC5BW,MAAM97D,SAAS07D,SAAS;YACxBK,MAAM/7D,SAAS07D,SAAS,IAAI;YAC5BM,MAAMh8D,SAAS07D,SAAS,IAAI;UAE9Bz2G,KAAK4W,IAAIw/F,MAAME,OAAOt2G,KAAK4W,IAAIu/F,MAAME;oBAC5B15F,QAAQw5F,KAAK,IAAIO,UAAU/5F,QAAQ05F,KAAK,IAAIM,UAAUh6F,QAAQ45F,KAAK,IAAIK,UAAUj6F,QAAQk6F,KAAK,IAAIE;;oBAElGp6F,QAAQy5F,KAAK,IAAIM,UAAU/5F,QAAQ25F,KAAK,IAAIK,UAAUh6F,QAAQ65F,KAAK,IAAII,UAAUj6F,QAAQm6F,KAAK,IAAIC;;;;EAKjH,kBAAkB70E,QAAQh8B,SAAS7N;IAClCA,KAAK6pC;QAED3kC,MAAMC,QAAQ0kC;eACRjnC,IAAI,GAAGma,IAAI8sB,OAAOhnC,QAAQD,IAAIma,GAAGna;cACnC8nC,QAAQb,OAAOjnC;QACrB5C,KAAK6pC,OAAOvpC,KAAKoqC,MAAMhtB;;;MAGxB1d,KAAK6pC,OAAOvpC,KAAKupC,OAAOnsB;;QAGrB7P,QAAQ2rG,gBAAgBh5G,WAAWR,KAAK6N,QAAQ2rG,cAAc3rG,QAAQ2rG,YAAYnuF;WAC/ErrB;;EAGR,kCAAkCqyG;IACjCrqG,YAAYoB,SAAS,GAAGs/F,SAAS;YAC1BxqF,KAAK,IAAIvW,KAAKob,KAAK,MAAM;YACzB2/B,aAAa,GAAGxkC,GAAG,GAAG,GAAGA,GAAG,IAAI,IAAIA,GAAG,GAAG,IAAIA,GAAG,GAAG,IAAI,GAAGA,GAAG,GAAG,GAAGA,GAAG,IAAI,IAAIA,GAAG,GAAG,IAAIA,GAAGA,GAAG,IAAI,GAAGA,GAAG,GAAG,IAAIA,GAAG,IAAI,IAAIA,GAAG,GAAG;YACjI8+B,WAAW,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG;MAC5M,MAAM0F,UAAU1F,SAAS5zC,QAAQs/F;MACjC,KAAK9mG,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRs/F,QAAQA;;;;EAMX,4BAA4BhpD;IAC3B13C,YAAYuvB,QAAQy4E,WAAW,IAAI2O,WAAW,GAAGC,YAAYj3G,KAAKyV,KAAK;MACtE;MACA,KAAKxb,OAAO;MACZ,KAAK6oC;QACJlT,QAAQA;QACRy4E,UAAUA;QACV2O,UAAUA;QACVC,WAAWA;;MAEZ5O,WAAWroG,KAAKC,MAAMooG;;MAEtB4O,YAAYz+F,MAAMy+F,WAAW,GAAGj3G,KAAKyV,KAAK;;YAEpC4/B;YACA0F;YACAvF;;YAEA0hE,kBAAkB,MAAM7O;YACxBG,aAAa/nG;YACb6jB,SAAS3H;;eAEN1hB,IAAI,GAAGA,KAAKotG,UAAUptG;cACxB0G,MAAMq1G,WAAW/7G,IAAIi8G,kBAAkBD;cACvCn1G,MAAM9B,KAAK8B,IAAIH;cACfI,MAAM/B,KAAK+B,IAAIJ;iBAEZyxB,IAAI,GAAGA,KAAKxD,OAAO10B,SAAS,GAAGk4B;;UAEvCo1E,OAAO3mG,IAAI+tB,OAAOwD,GAAGvxB,IAAIC;UACzB0mG,OAAOxmG,IAAI4tB,OAAOwD,GAAGpxB;UACrBwmG,OAAOvmG,IAAI2tB,OAAOwD,GAAGvxB,IAAIE;UACzBg5C,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;UAEzCqiB,GAAGziB,IAAI5G,IAAIotG;UACX/jF,GAAGtiB,IAAIoxB,KAAKxD,OAAO10B,SAAS;UAC5Bs6C,IAAI78C,KAAK2rB,GAAGziB,GAAGyiB,GAAGtiB;;;;eAKX/G,IAAI,GAAGA,IAAIotG,UAAUptG;iBACpBm4B,IAAI,GAAGA,IAAIxD,OAAO10B,SAAS,GAAGk4B;gBAChC+jF,OAAO/jF,IAAIn4B,IAAI20B,OAAO10B;gBACtBqc,IAAI4/F;gBACJ3/F,IAAI2/F,OAAOvnF,OAAO10B;gBAClBuc,IAAI0/F,OAAOvnF,OAAO10B,SAAS;gBAC3BmC,IAAI85G,OAAO;;UAEjB9hE,QAAQ18C,KAAK4e,GAAGC,GAAGna;UACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAKrB,KAAK42C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,UAAU22C,uBAAuBY,KAAK;;MAExD,KAAKkB;;;UAGDugE,cAAcj3G,KAAKyV,KAAK;cACrB8/B,UAAU,KAAK5B,WAAWrlB,OAAOpZ;cACjCkiG,SAAS32G;cACT+1C,SAAS/1C;cACTwV,QAAQxV;;cAER02G,OAAO9O,WAAWz4E,OAAO10B,SAAS;iBAE/BD,IAAI,GAAGm4B,IAAI,GAAGn4B,IAAI20B,OAAO10B,SAAQD,KAAKm4B,KAAK;;UAEnDgkF,GAAGv1G,IAAI0zC,QAAQniB,IAAI;UACnBgkF,GAAGp1G,IAAIuzC,QAAQniB,IAAI;UACnBgkF,GAAGn1G,IAAIszC,QAAQniB,IAAI;;UAEnBojB,GAAG30C,IAAI0zC,QAAQ4hE,OAAO/jF,IAAI;UAC1BojB,GAAGx0C,IAAIuzC,QAAQ4hE,OAAO/jF,IAAI;UAC1BojB,GAAGv0C,IAAIszC,QAAQ4hE,OAAO/jF,IAAI;;UAE1Bnd,EAAEiE,WAAWk9F,IAAI5gE,IAAInyC;;UAErBkxC,QAAQniB,IAAI,KAAKmiB,QAAQ4hE,OAAO/jF,IAAI,KAAKnd,EAAEpU;UAC3C0zC,QAAQniB,IAAI,KAAKmiB,QAAQ4hE,OAAO/jF,IAAI,KAAKnd,EAAEjU;UAC3CuzC,QAAQniB,IAAI,KAAKmiB,QAAQ4hE,OAAO/jF,IAAI,KAAKnd,EAAEhU;;;;;EAO/C,iCAAiCyoG;IAChCrqG,YAAYoB,SAAS,GAAGs/F,SAAS;YAC1BhmD,YAAY,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI;YAClE1F,WAAW,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;MACtF,MAAM0F,UAAU1F,SAAS5zC,QAAQs/F;MACjC,KAAK9mG,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRs/F,QAAQA;;;;;;;;EAWX,iCAAiChpD;IAChC13C,YAAYg3G,MAAMC,QAAQC;MACzB;MACA,KAAKt9G,OAAO;MACZ,KAAK6oC;QACJu0E,MAAMA;QACNC,QAAQA;QACRC,QAAQA;;;YAGHliE;YACA0F;YACAxF;YACAC;YACAgiE,MAAM;YACNlpF,aAAa7tB;YACb4yB,SAAS5yB,WACZ6yB,SAAS7yB;YACNg3G,SAASh3G,WACZi3G,SAASj3G;UAER42G,KAAKn8G,SAAS;QACjBJ,QAAQa,MAAM;;;YAITg8G,aAAaL,SAAS;eAEnBr8G,IAAI,GAAGA,KAAKs8G,QAAQt8G;cACtBwE,IAAIxE,IAAIs8G;iBAELnkF,IAAI,GAAGA,KAAKkkF,QAAQlkF;gBACtBgT,IAAIhT,IAAIkkF;;UAEdD,KAAKjxE,GAAG3mC,GAAG4zB;UACX0nB,SAASpiD,KAAK06B,GAAGxxB,GAAGwxB,GAAGrxB,GAAGqxB,GAAGpxB;;;cAGzBmkC,IAAIoxE,OAAO;YACdH,KAAKjxE,IAAIoxE,KAAK/3G,GAAG6zB;YACjBmkF,GAAGnzG,WAAW+uB,IAAIC;;YAElB+jF,KAAKjxE,IAAIoxE,KAAK/3G,GAAG6zB;YACjBmkF,GAAGnzG,WAAWgvB,IAAID;;cAGf5zB,IAAI+3G,OAAO;YACdH,KAAKjxE,GAAG3mC,IAAI+3G,KAAKlkF;YACjBokF,GAAGpzG,WAAW+uB,IAAIC;;YAElB+jF,KAAKjxE,GAAG3mC,IAAI+3G,KAAKlkF;YACjBokF,GAAGpzG,WAAWgvB,IAAID;;;UAInB/E,OAAOb,aAAagqF,IAAIC,IAAIrzG;UAC5BkxC,QAAQ58C,KAAK21B,OAAOzsB,GAAGysB,OAAOtsB,GAAGssB,OAAOrsB;;UAExCuzC,IAAI78C,KAAKytC,GAAG3mC;;;;eAKLxE,IAAI,GAAGA,IAAIs8G,QAAQt8G;iBAClBm4B,IAAI,GAAGA,IAAIkkF,QAAQlkF;gBACrB7b,IAAItc,IAAI08G,aAAavkF;gBACrB5b,IAAIvc,IAAI08G,aAAavkF,IAAI;gBACzB3b,KAAKxc,IAAI,KAAK08G,aAAavkF,IAAI;gBAC/B/1B,KAAKpC,IAAI,KAAK08G,aAAavkF;;UAEjCiiB,QAAQ18C,KAAK4e,GAAGC,GAAGna;UACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAKrB,KAAK42C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;;EAK1D,2BAA2BuC;IAC1B13C,YAAYu3G,cAAc,KAAKC,cAAc,GAAGC,gBAAgB,GAAGC,cAAc,GAAGzP,aAAa,GAAGC,cAAcvoG,KAAKyV,KAAK;MAC3H;MACA,KAAKxb,OAAO;MACZ,KAAK6oC;QACJ80E,aAAaA;QACbC,aAAaA;QACbC,eAAeA;QACfC,aAAaA;QACbzP,YAAYA;QACZC,aAAaA;;MAEduP,gBAAgB93G,KAAKF,IAAI,GAAGg4G;MAC5BC,cAAc/3G,KAAKF,IAAI,GAAGi4G;;YAEpB1iE;YACA0F;YACAxF;YACAC;;UAEF/zC,SAASm2G;YACPI,cAAcH,cAAcD,eAAeG;YAC3CvP,aAAa/nG;YACb6jB,SAAS3H;;eAENyW,IAAI,GAAGA,KAAK2kF,aAAa3kF;iBACxBn4B,IAAI,GAAGA,KAAK68G,eAAe78G;;gBAE7BwtG,UAAUH,aAAartG,IAAI68G,gBAAgBvP;;UAEjDC,OAAO3mG,IAAIJ,SAASzB,KAAK+B,IAAI0mG;UAC7BD,OAAOxmG,IAAIP,SAASzB,KAAK8B,IAAI2mG;UAC7B1tD,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;UAEzCszC,QAAQ58C,KAAK,GAAG,GAAG;;UAEnB2rB,GAAGziB,KAAK2mG,OAAO3mG,IAAIg2G,cAAc,KAAK;UACtCvzF,GAAGtiB,KAAKwmG,OAAOxmG,IAAI61G,cAAc,KAAK;UACtCriE,IAAI78C,KAAK2rB,GAAGziB,GAAGyiB,GAAGtiB;;;QAInBP,UAAUu2G;;;eAIF5kF,IAAI,GAAGA,IAAI2kF,aAAa3kF;cAC1B6kF,oBAAoB7kF,KAAK0kF,gBAAgB;iBAEtC78G,IAAI,GAAGA,IAAI68G,eAAe78G;gBAC5BwtG,UAAUxtG,IAAIg9G;gBACd1gG,IAAIkxF;gBACJjxF,IAAIixF,UAAUqP,gBAAgB;gBAC9BrgG,IAAIgxF,UAAUqP,gBAAgB;gBAC9Bz6G,IAAIorG,UAAU;;UAEpBpzD,QAAQ18C,KAAK4e,GAAGC,GAAGna;UACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAKrB,KAAK42C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;;EAK1D,4BAA4BuC;IAC3B13C,YAAY6hC,QAAQovE,gBAAgB;MACnC;MACA,KAAKr3G,OAAO;MACZ,KAAK6oC;QACJZ,QAAQA;QACRovE,eAAeA;;;YAGVj8D;YACA0F;YACAxF;YACAC;;UAEFyF,aAAa;UACbc,aAAa;;UAEbx+C,MAAMC,QAAQ0kC,YAAY;QAC7BkvE,SAASlvE;;iBAEAjnC,IAAI,GAAGA,IAAIinC,OAAOhnC,QAAQD;UAClCm2G,SAASlvE,OAAOjnC;UAChB,KAAKs5C,SAAS0G,YAAYc,YAAY9gD;;UAEtCggD,cAAcc;UACdA,aAAa;;;;MAKf,KAAK9H,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;MAExD,kBAAkBzS;cACXm1E,cAAcn9D,SAAS7/C,SAAS;cAChC00B,SAASmT,MAAM2vE,cAAcpB;YAC/B6G,gBAAgBvoF,OAAOmT;cACrBq1E,aAAaxoF,OAAOkhF;;YAEtBF,WAAWF,YAAYyH,mBAAmB;UAC7CA,gBAAgBA,cAAcxF;;iBAGtB13G,IAAI,GAAGma,IAAIgjG,WAAWl9G,QAAQD,IAAIma,GAAGna;gBACvCo9G,YAAYD,WAAWn9G;cAEzB21G,WAAWF,YAAY2H,eAAe;YACzCD,WAAWn9G,KAAKo9G,UAAU1F;;;cAItB5B,QAAQH,WAAWC,iBAAiBsH,eAAeC;;iBAEhDn9G,IAAI,GAAGma,IAAIgjG,WAAWl9G,QAAQD,IAAIma,GAAGna;gBACvCo9G,YAAYD,WAAWn9G;UAC7Bk9G,gBAAgBA,cAAc16G,OAAO46G;;;iBAI7Bp9G,IAAI,GAAGma,IAAI+iG,cAAcj9G,QAAQD,IAAIma,GAAGna;gBAC1CutG,SAAS2P,cAAcl9G;UAC7B8/C,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAG;UAClCuzC,QAAQ58C,KAAK,GAAG,GAAG;UACnB68C,IAAI78C,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG;;;iBAIlB/G,IAAI,GAAGma,IAAI27F,MAAM71G,QAAQD,IAAIma,GAAGna;gBAClCo/C,OAAO02D,MAAM91G;gBACbsc,IAAI8iC,KAAK,KAAK69D;gBACd1gG,IAAI6iC,KAAK,KAAK69D;gBACdzgG,IAAI4iC,KAAK,KAAK69D;UACpB7iE,QAAQ18C,KAAK4e,GAAGC,GAAGC;UACnBskC,cAAc;;;;IAKjBr4B;YACOrrB,OAAO,MAAMqrB;YACbwe,SAAS,KAAKY,WAAWZ;aACxBxe,OAAOwe,QAAQ7pC;;;EAKxB,gBAAgB6pC,QAAQ7pC;IACvBA,KAAK6pC;QAED3kC,MAAMC,QAAQ0kC;eACRjnC,IAAI,GAAGma,IAAI8sB,OAAOhnC,QAAQD,IAAIma,GAAGna;cACnC8nC,QAAQb,OAAOjnC;QACrB5C,KAAK6pC,OAAOvpC,KAAKoqC,MAAMhtB;;;MAGxB1d,KAAK6pC,OAAOvpC,KAAKupC,OAAOnsB;;WAGlB1d;;EAGR,6BAA6B0/C;IAC5B13C,YAAYoB,SAAS,GAAGk5C,gBAAgB,GAAGC,iBAAiB,GAAGo8D,WAAW,GAAGC,YAAYj3G,KAAKyV,KAAK,GAAG6yF,aAAa,GAAGC,cAAcvoG,KAAKyV;MACxI;MACA,KAAKxb,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRk5C,eAAeA;QACfC,gBAAgBA;QAChBo8D,UAAUA;QACVC,WAAWA;QACX3O,YAAYA;QACZC,aAAaA;;MAEd5tD,gBAAgB36C,KAAKF,IAAI,GAAGE,KAAKC,MAAM06C;MACvCC,iBAAiB56C,KAAKF,IAAI,GAAGE,KAAKC,MAAM26C;YAClC09D,WAAWt4G,KAAKD,IAAIuoG,aAAaC,aAAavoG,KAAKyV;UACrDV,QAAQ;YACNwjG;YACA/P,aAAa/nG;YACb6tB,aAAa7tB;;YAEb40C;YACA0F;YACAxF;YACAC;;eAEG1oB,KAAK,GAAGA,MAAM8tB,gBAAgB9tB;cAChC0rF;cACA/4G,IAAIqtB,KAAK8tB;;YAEX69D,UAAU;YAEV3rF,MAAM,KAAKw7E,cAAc;UAC5BmQ,UAAU,MAAM99D;mBACN7tB,MAAM8tB,kBAAkB09D,YAAYt4G,KAAKyV;UACnDgjG,WAAW,MAAM99D;;iBAGT9tB,KAAK,GAAGA,MAAM8tB,eAAe9tB;gBAC/BuZ,IAAIvZ,KAAK8tB;;UAEf6tD,OAAO3mG,KAAKJ,SAASzB,KAAK+B,IAAIi1G,WAAW5wE,IAAI6wE,aAAaj3G,KAAK8B,IAAIwmG,aAAa7oG,IAAI8oG;UACpFC,OAAOxmG,IAAIP,SAASzB,KAAK+B,IAAIumG,aAAa7oG,IAAI8oG;UAC9CC,OAAOvmG,IAAIR,SAASzB,KAAK8B,IAAIk1G,WAAW5wE,IAAI6wE,aAAaj3G,KAAK8B,IAAIwmG,aAAa7oG,IAAI8oG;UACnFxtD,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;UAEzCqsB,OAAOtU,KAAKwuF,QAAQnkG;UACpBkxC,QAAQ58C,KAAK21B,OAAOzsB,GAAGysB,OAAOtsB,GAAGssB,OAAOrsB;;UAExCuzC,IAAI78C,KAAKytC,IAAIqyE,SAAS,IAAIh5G;UAC1B+4G,YAAY7/G,KAAKoc;;QAGlBwjG,KAAK5/G,KAAK6/G;;;eAIF1rF,KAAK,GAAGA,KAAK8tB,gBAAgB9tB;iBAC5BD,KAAK,GAAGA,KAAK8tB,eAAe9tB;gBAC9BtV,IAAIghG,KAAKzrF,IAAID,KAAK;gBAClBrV,IAAI+gG,KAAKzrF,IAAID;gBACbpV,IAAI8gG,KAAKzrF,KAAK,GAAGD;gBACjBxvB,IAAIk7G,KAAKzrF,KAAK,GAAGD,KAAK;cACxBC,OAAO,KAAKw7E,aAAa,GAAGjzD,QAAQ18C,KAAK4e,GAAGC,GAAGna;cAC/CyvB,OAAO8tB,iBAAiB,KAAK09D,WAAWt4G,KAAKyV,IAAI4/B,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAK1E,KAAK42C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;;EAK1D,kCAAkCk1D;IACjCrqG,YAAYoB,SAAS,GAAGs/F,SAAS;YAC1BhmD,YAAY,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI;YACnD1F,WAAW,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;MAClD,MAAM0F,UAAU1F,SAAS5zC,QAAQs/F;MACjC,KAAK9mG,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRs/F,QAAQA;;;;;;;;;;;;;;;;;;;;EAuBX,2BAA2B2X;IAC1Br4G,YAAYs4G,MAAM71E;YACX81E,OAAO91E,WAAW81E;YAElBA,QAAQA,KAAKC;QAClB/9G,QAAQa,MAAM;mBACHo8C;;YAGN7V,SAAS02E,KAAKE,eAAeH,MAAM71E,WAAW19B;;MAEpD09B,WAAWvc,QAAQuc,WAAWrpB,WAAW5gB,YAAYiqC,WAAWrpB,SAAS;;UAErEqpB,WAAW2uE,mBAAmB54G,WAAWiqC,WAAW2uE,iBAAiB;UACrE3uE,WAAW4uE,cAAc74G,WAAWiqC,WAAW4uE,YAAY;UAC3D5uE,WAAW0uE,iBAAiB34G,WAAWiqC,WAAW0uE,eAAe;MACrE,MAAMtvE,QAAQY;MACd,KAAK7oC,OAAO;;;EAKd,4BAA4B89C;IAC3B13C,YAAYoB,SAAS,GAAGs3G,OAAO,KAAKnQ,iBAAiB,GAAGoQ,kBAAkB,GAAGC,MAAMj5G,KAAKyV,KAAK;MAC5F;MACA,KAAKxb,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRs3G,MAAMA;QACNnQ,gBAAgBA;QAChBoQ,iBAAiBA;QACjBC,KAAKA;;MAENrQ,iBAAiB5oG,KAAKC,MAAM2oG;MAC5BoQ,kBAAkBh5G,KAAKC,MAAM+4G;;YAEvB3jE;YACA0F;YACAxF;YACAC;;YAEA94B,aAAajc;YACb+nG,aAAa/nG;YACb6tB,aAAa7tB;;eAEV2yB,IAAI,GAAGA,KAAKw1E,gBAAgBx1E;iBAC3Bn4B,IAAI,GAAGA,KAAK+9G,iBAAiB/9G;gBAC/BmrC,IAAInrC,IAAI+9G,kBAAkBC;gBAC1Bx5G,IAAI2zB,IAAIw1E,iBAAiB5oG,KAAKyV,KAAK;;UAEzC+yF,OAAO3mG,KAAKJ,SAASs3G,OAAO/4G,KAAK+B,IAAItC,MAAMO,KAAK+B,IAAIqkC;UACpDoiE,OAAOxmG,KAAKP,SAASs3G,OAAO/4G,KAAK+B,IAAItC,MAAMO,KAAK8B,IAAIskC;UACpDoiE,OAAOvmG,IAAI82G,OAAO/4G,KAAK8B,IAAIrC;UAC3Bs7C,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;UAEzCya,OAAO7a,IAAIJ,SAASzB,KAAK+B,IAAIqkC;UAC7B1pB,OAAO1a,IAAIP,SAASzB,KAAK8B,IAAIskC;UAC7B9X,OAAOhqB,WAAWkkG,QAAQ9rF,QAAQrY;UAClCkxC,QAAQ58C,KAAK21B,OAAOzsB,GAAGysB,OAAOtsB,GAAGssB,OAAOrsB;;UAExCuzC,IAAI78C,KAAKsC,IAAI+9G;UACbxjE,IAAI78C,KAAKy6B,IAAIw1E;;;;eAKNx1E,IAAI,GAAGA,KAAKw1E,gBAAgBx1E;iBAC3Bn4B,IAAI,GAAGA,KAAK+9G,iBAAiB/9G;;gBAE/Bsc,KAAKyhG,kBAAkB,KAAK5lF,IAAIn4B,IAAI;gBACpCuc,KAAKwhG,kBAAkB,MAAM5lF,IAAI,KAAKn4B,IAAI;gBAC1Cwc,KAAKuhG,kBAAkB,MAAM5lF,IAAI,KAAKn4B;gBACtCoC,KAAK27G,kBAAkB,KAAK5lF,IAAIn4B;;UAEtCo6C,QAAQ18C,KAAK4e,GAAGC,GAAGna;UACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAKrB,KAAK42C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;;EAK1D,gCAAgCuC;IAC/B13C,YAAYoB,SAAS,GAAGs3G,OAAO,KAAKC,kBAAkB,IAAIpQ,iBAAiB,GAAG79E,IAAI,GAAGzT,IAAI;MACxF;MACA,KAAKrd,OAAO;MACZ,KAAK6oC;QACJrhC,QAAQA;QACRs3G,MAAMA;QACNC,iBAAiBA;QACjBpQ,gBAAgBA;QAChB79E,GAAGA;QACHzT,GAAGA;;MAEJ0hG,kBAAkBh5G,KAAKC,MAAM+4G;MAC7BpQ,iBAAiB5oG,KAAKC,MAAM2oG;;YAEtBvzD;YACA0F;YACAxF;YACAC;;YAEAgzD,aAAa/nG;YACb6tB,aAAa7tB;YACby4G,SAASz4G;YACT04G,SAAS14G;YACT24G,QAAQ34G;YACR44G,QAAQ54G;YACR64G,QAAQ74G;;eAELxF,IAAI,GAAGA,KAAK+9G,mBAAmB/9G;;cAEjCmrC,IAAInrC,IAAI+9G,kBAAkBjuF,IAAI/qB,KAAKyV,KAAK;;;QAG9C8jG,yBAAyBnzE,GAAGrb,GAAGzT,GAAG7V,QAAQy3G;QAC1CK,yBAAyBnzE,IAAI,MAAMrb,GAAGzT,GAAG7V,QAAQ03G;;QAEjDE,EAAE/0G,WAAW60G,IAAID;QACjBI,EAAEp/F,WAAWi/F,IAAID;QACjBE,EAAE3rF,aAAa4rF,GAAGC;QAClBA,EAAE7rF,aAAa2rF,GAAGC;;QAElBD,EAAE/0G;QACFi1G,EAAEj1G;iBAEO+uB,IAAI,GAAGA,KAAKw1E,kBAAkBx1E;;;gBAGhC3zB,IAAI2zB,IAAIw1E,iBAAiB5oG,KAAKyV,KAAK;gBACnCkL,MAAMo4F,OAAO/4G,KAAK+B,IAAItC;gBACtBmhB,KAAKm4F,OAAO/4G,KAAK8B,IAAIrC;;;UAG3B+oG,OAAO3mG,IAAIq3G,GAAGr3G,KAAK8e,KAAK24F,EAAEz3G,IAAI+e,KAAKw4F,EAAEv3G;UACrC2mG,OAAOxmG,IAAIk3G,GAAGl3G,KAAK2e,KAAK24F,EAAEt3G,IAAI4e,KAAKw4F,EAAEp3G;UACrCwmG,OAAOvmG,IAAIi3G,GAAGj3G,KAAK0e,KAAK24F,EAAEr3G,IAAI2e,KAAKw4F,EAAEn3G;UACrC84C,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;UAEzCqsB,OAAOhqB,WAAWkkG,QAAQ0Q,IAAI70G;UAC9BkxC,QAAQ58C,KAAK21B,OAAOzsB,GAAGysB,OAAOtsB,GAAGssB,OAAOrsB;;UAExCuzC,IAAI78C,KAAKsC,IAAI+9G;UACbxjE,IAAI78C,KAAKy6B,IAAIw1E;;;;eAKNx1E,IAAI,GAAGA,KAAK4lF,iBAAiB5lF;iBAC5Bn4B,IAAI,GAAGA,KAAK2tG,gBAAgB3tG;;gBAE9Bsc,KAAKqxF,iBAAiB,MAAMx1E,IAAI,MAAMn4B,IAAI;gBAC1Cuc,KAAKoxF,iBAAiB,KAAKx1E,KAAKn4B,IAAI;gBACpCwc,KAAKmxF,iBAAiB,KAAKx1E,IAAIn4B;gBAC/BoC,KAAKurG,iBAAiB,MAAMx1E,IAAI,KAAKn4B;;UAE3Co6C,QAAQ18C,KAAK4e,GAAGC,GAAGna;UACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAKrB,KAAK42C,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;MAExD,kCAAkCpP,GAAGrb,GAAGzT,GAAG7V,QAAQG;cAC5C43G,KAAKx5G,KAAK+B,IAAIqkC;cACdqzE,KAAKz5G,KAAK8B,IAAIskC;cACdszE,UAAUpiG,IAAIyT,IAAIqb;cAClBuzE,KAAK35G,KAAK+B,IAAI23G;QACpB93G,SAASC,IAAIJ,UAAU,IAAIk4G,MAAM,MAAMH;QACvC53G,SAASI,IAAIP,UAAU,IAAIk4G,MAAMF,KAAK;QACtC73G,SAASK,IAAIR,SAASzB,KAAK8B,IAAI43G,WAAW;;;;EAM7C,2BAA2B3hE;IAC1B13C,YAAY4jE,MAAM+0C,kBAAkB,IAAIv3G,SAAS,GAAGmnG,iBAAiB,GAAGgR,SAAS;MAChF;MACA,KAAK3/G,OAAO;MACZ,KAAK6oC;QACJmhC,MAAMA;QACN+0C,iBAAiBA;QACjBv3G,QAAQA;QACRmnG,gBAAgBA;QAChBgR,QAAQA;;YAEHC,SAAS51C,KAAKuuC,oBAAoBwG,iBAAiBY;;MAEzD,KAAKlkE,WAAWmkE,OAAOnkE;MACvB,KAAKH,UAAUskE,OAAOtkE;MACtB,KAAKw/D,YAAY8E,OAAO9E;;YAElBvM,aAAa/nG;YACb6tB,aAAa7tB;YACb6jB,SAAS3H;UACXm9F,QAAQr5G;;YAENs6C;YACAxF;YACAC;YACAH;;MAEN0kE;;MAEA,KAAK9lE,SAASoB;MACd,KAAKp3C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACnE,KAAK98C,aAAa,cAAc22C,uBAAuBW,SAAS;MAChE,KAAKt3C,aAAa,UAAU22C,uBAAuBY,KAAK;;MAExD;iBACUv6C,IAAI,GAAGA,IAAI+9G,iBAAiB/9G;UACpC++G,gBAAgB/+G;;;;;;QAOjB++G,gBAAgBJ,WAAW,QAAQZ,kBAAkB;;;QAGrDrP;;QAEAsQ;;MAGD,yBAAyBh/G;;QAExB6+G,IAAI71C,KAAKi2C,WAAWj/G,IAAI+9G,iBAAiBc;;cAEnCR,IAAIO,OAAOtkE,QAAQt6C;cACnBm+G,IAAIS,OAAO9E,UAAU95G;;iBAElBm4B,IAAI,GAAGA,KAAKw1E,gBAAgBx1E;gBAC9B3zB,IAAI2zB,IAAIw1E,iBAAiB5oG,KAAKyV,KAAK;gBACnC3T,MAAM9B,KAAK8B,IAAIrC;gBACfsC,OAAO/B,KAAK+B,IAAItC;;UAEtB6uB,OAAOzsB,IAAIE,MAAMu3G,EAAEz3G,IAAIC,MAAMs3G,EAAEv3G;UAC/BysB,OAAOtsB,IAAID,MAAMu3G,EAAEt3G,IAAIF,MAAMs3G,EAAEp3G;UAC/BssB,OAAOrsB,IAAIF,MAAMu3G,EAAEr3G,IAAIH,MAAMs3G,EAAEn3G;UAC/BqsB,OAAOjqB;UACPkxC,QAAQ58C,KAAK21B,OAAOzsB,GAAGysB,OAAOtsB,GAAGssB,OAAOrsB;;UAExCumG,OAAO3mG,IAAIi4G,EAAEj4G,IAAIJ,SAAS6sB,OAAOzsB;UACjC2mG,OAAOxmG,IAAI83G,EAAE93G,IAAIP,SAAS6sB,OAAOtsB;UACjCwmG,OAAOvmG,IAAI63G,EAAE73G,IAAIR,SAAS6sB,OAAOrsB;UACjC84C,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;;MAI3C;iBACUmxB,IAAI,GAAGA,KAAK4lF,iBAAiB5lF;mBAC5Bn4B,IAAI,GAAGA,KAAK2tG,gBAAgB3tG;kBAC9Bsc,KAAKqxF,iBAAiB,MAAMx1E,IAAI,MAAMn4B,IAAI;kBAC1Cuc,KAAKoxF,iBAAiB,KAAKx1E,KAAKn4B,IAAI;kBACpCwc,KAAKmxF,iBAAiB,KAAKx1E,IAAIn4B;kBAC/BoC,KAAKurG,iBAAiB,MAAMx1E,IAAI,KAAKn4B;;YAE3Co6C,QAAQ18C,KAAK4e,GAAGC,GAAGna;YACnBg4C,QAAQ18C,KAAK6e,GAAGC,GAAGpa;;;;MAKtB;iBACUpC,IAAI,GAAGA,KAAK+9G,iBAAiB/9G;mBAC5Bm4B,IAAI,GAAGA,KAAKw1E,gBAAgBx1E;YACpC9O,GAAGziB,IAAI5G,IAAI+9G;YACX10F,GAAGtiB,IAAIoxB,IAAIw1E;YACXpzD,IAAI78C,KAAK2rB,GAAGziB,GAAGyiB,GAAGtiB;;;;;IAMtB0hB;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK4rE,OAAO,KAAKnhC,WAAWmhC,KAAKvgD;aAC1BrrB;;;EAKT,gCAAgC0/C;IAC/B13C,YAAYU;MACX;MACA,KAAK9G,OAAO;UAER8G,SAASu5C,eAAe;QAC3Bx/C,QAAQa,MAAM;;;;YAKTo/C;;YAEAo/D,QAAQ,GAAG,IACdC;YACG5R,aAAa/nG;UAEfM,SAASgU,UAAU;;cAEhBnT,WAAWb,SAAS4yC,WAAW/xC;cAC/ByzC,UAAUt0C,SAASgU;YACrB++B,SAAS/yC,SAAS+yC;YAElBA,OAAO54C,WAAW;UACrB44C;YACCxP,OAAO;YACPjhC,OAAOgyC,QAAQhyC;YACfmxC,eAAe;;;;iBAKR6lE,IAAI,GAAGC,KAAKxmE,OAAO54C,QAAQm/G,IAAIC,MAAMD;gBACvCl3G,QAAQ2wC,OAAOumE;gBACf/1E,QAAQnhC,MAAMmhC;gBACdjhC,QAAQF,MAAME;mBAEXpI,IAAIqpC,OAAOlvB,IAAIkvB,QAAQjhC,OAAOpI,IAAIma,GAAGna,KAAK;qBACzCm4B,IAAI,GAAGA,IAAI,GAAGA;oBAChBmnF,QAAQllE,QAAQ94B,KAAKthB,IAAIm4B;oBACzBonF,QAAQnlE,QAAQ94B,KAAKthB,KAAKm4B,IAAI,KAAK;cACzC+mF,KAAK,KAAKn6G,KAAKD,IAAIw6G,OAAOC;;cAE1BL,KAAK,KAAKn6G,KAAKF,IAAIy6G,OAAOC;oBACpBh3E,MAAM22E,KAAK,KAAK,MAAMA,KAAK;kBAE7BC,MAAM52E,SAAS3qC;gBAClBuhH,MAAM52E;kBACLiO,QAAQ0oE,KAAK;kBACbzoE,QAAQyoE,KAAK;;;;;;;mBAQP32E,OAAO42E;gBACX99G,IAAI89G,MAAM52E;UAChBglE,OAAOnsF,oBAAoBza,UAAUtF,EAAEm1C;UACvCsJ,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;UACzCumG,OAAOnsF,oBAAoBza,UAAUtF,EAAEo1C;UACvCqJ,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;;;cAIpCL,WAAWb,SAAS4yC,WAAW/xC;iBAE5B3G,IAAI,GAAGma,IAAIxT,SAASyB,QAAQ,GAAGpI,IAAIma,GAAGna;mBACrCm4B,IAAI,GAAGA,IAAI,GAAGA;;;kBAGhBqe,SAAS,IAAIx2C,IAAIm4B;YACvBo1E,OAAOnsF,oBAAoBza,UAAU6vC;YACrCsJ,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;kBACnCyvC,SAAS,IAAIz2C,KAAKm4B,IAAI,KAAK;YACjCo1E,OAAOnsF,oBAAoBza,UAAU8vC;YACrCqJ,SAASpiD,KAAK6vG,OAAO3mG,GAAG2mG,OAAOxmG,GAAGwmG,OAAOvmG;;;;;MAM5C,KAAKhE,aAAa,gBAAgB22C,uBAAuBmG,UAAU;;;MAKjE0/D,0BAA0BriG,OAAOC;IACpCC,WAAW;IACXjT,aAAaA;IACbq1G,mBAAmBr1G;IACnBs1G,gBAAgBA;IAChBC,sBAAsBD;IACtBE,cAAcA;IACdC,oBAAoBD;IACpB75G,kBAAkBA;IAClB+5G,wBAAwB/5G;IACxBg6G,sBAAsBA;IACtBC,4BAA4BD;IAC5BE,eAAeA;IACfxC,iBAAiBA;IACjByC,uBAAuBzC;IACvB0C,qBAAqBA;IACrBC,2BAA2BD;IAC3BE,eAAeA;IACfC,qBAAqBD;IACrBE,oBAAoBA;IACpBC,0BAA0BD;IAC1BE,oBAAoBA;IACpBC,0BAA0BD;IAC1BxoD,eAAeA;IACf0oD,qBAAqB1oD;IACrBw3C,oBAAoBA;IACpBmR,0BAA0BnR;IAC1BoR,cAAcA;IACdC,oBAAoBD;IACpBE,eAAeA;IACfC,qBAAqBD;IACrBE,gBAAgBA;IAChBC,sBAAsBD;IACtBE,qBAAqBA;IACrBC,2BAA2BD;IAC3BE,cAAcA;IACdC,oBAAoBD;IACpBE,eAAeA;IACfC,qBAAqBD;IACrBE,mBAAmBA;IACnBC,yBAAyBD;IACzBE,cAAcA;IACdC,oBAAoBD;IACpBE,mBAAmBA;;;;;;;EASpB,6BAA6BhvE;IAC5BztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;MACvB,KAAK9I,cAAc;MACnB,KAAKmC,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;aAChB;;;EAKT8sE,eAAevxD,UAAUk3E,mBAAmB;EAE5C,gCAAgCv2C;IAC/Bl9C,YAAYyiC;MACX,MAAMA;MACN,KAAK7oC,OAAO;;;EAKd8iH,kBAAkBngG,UAAU8sD,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqDlD,mCAAmC57B;IAClCztC,YAAYyiC;MACX;MACA,KAAK0Z;QACJ,YAAY;;MAEb,KAAKviD,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;;MAEvB,KAAKpG,YAAY;MACjB,KAAKC,YAAY;MACjB,KAAK1tC,MAAM;MACX,KAAKwuC,WAAW;MAChB,KAAKC,oBAAoB;MACzB,KAAKC,QAAQ;MACb,KAAKC,iBAAiB;MACtB,KAAKf,eAAeiG,MAAM;MAC1B,KAAKhG,oBAAoB;MACzB,KAAKyB,cAAc;MACnB,KAAKV,UAAU;MACf,KAAKC,YAAY;MACjB,KAAKC,YAAY;MACjB,KAAKC,gBAAgBl5B;MACrB,KAAKm5B,kBAAkBpvB,QAAQ,GAAG;MAClC,KAAKqvB,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKd,WAAW;MAChB,KAAKiB,SAAS;MACd,KAAKE,kBAAkB;MACvB,KAAKE,kBAAkB;MACvB,KAAKpnC,YAAY;MACjB,KAAKgoC,qBAAqB;MAC1B,KAAKC,mBAAmB;MACxB,KAAKC,oBAAoB;MACzB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKxD,cAAc;MACnB,KAAKigC,iBAAiB;MACtB,KAAKngC,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK+4B;QACJ,YAAY;;MAEb,KAAKn7C,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKmpC,YAAY/mB,OAAO+mB;MACxB,KAAKC,YAAYhnB,OAAOgnB;MACxB,KAAK1tC,MAAM0mB,OAAO1mB;MAClB,KAAKwuC,WAAW9nB,OAAO8nB;MACvB,KAAKC,oBAAoB/nB,OAAO+nB;MAChC,KAAKC,QAAQhoB,OAAOgoB;MACpB,KAAKC,iBAAiBjoB,OAAOioB;MAC7B,KAAKf,SAAS3wB,KAAKyJ,OAAOknB;MAC1B,KAAK0B,cAAc5oB,OAAO4oB;MAC1B,KAAKzB,oBAAoBnnB,OAAOmnB;MAChC,KAAKe,UAAUloB,OAAOkoB;MACtB,KAAKC,YAAYnoB,OAAOmoB;MACxB,KAAKC,YAAYpoB,OAAOooB;MACxB,KAAKC,gBAAgBroB,OAAOqoB;MAC5B,KAAKC,YAAY/xB,KAAKyJ,OAAOsoB;MAC7B,KAAKC,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;MAC/B,KAAKC,eAAe1oB,OAAO0oB;MAC3B,KAAKC,eAAe3oB,OAAO2oB;MAC3B,KAAKd,WAAW7nB,OAAO6nB;MACvB,KAAKiB,SAAS9oB,OAAO8oB;MACrB,KAAKE,kBAAkBhpB,OAAOgpB;MAC9B,KAAKE,kBAAkBlpB,OAAOkpB;MAC9B,KAAKpnC,YAAYke,OAAOle;MACxB,KAAKgoC,qBAAqB9pB,OAAO8pB;MACjC,KAAKC,mBAAmB/pB,OAAO+pB;MAC/B,KAAKC,oBAAoBhqB,OAAOgqB;MAChC,KAAKC,eAAejqB,OAAOiqB;MAC3B,KAAKC,eAAelqB,OAAOkqB;MAC3B,KAAKxD,cAAc1mB,OAAO0mB;MAC1B,KAAKigC,iBAAiB3mD,OAAO2mD;aACtB;;;EAKTyD,qBAAqBjxD,UAAU+xD,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;EA0BxD,mCAAmCd;IAClCxtE,YAAYyiC;MACX;MACA,KAAK0Z;QACJ,YAAY;QACZ,YAAY;;MAEb,KAAKviD,OAAO;MACZ,KAAK8wC,YAAY;MACjB,KAAKE,eAAe;MACpB,KAAKD,qBAAqB;MAC1B,KAAKE,wBAAwB;MAC7B,KAAKE,2BAA2BzuB,QAAQ,GAAG;MAC3C,KAAKwuB,qBAAqB;MAC1B,KAAKuB,eAAe;;MAEpBt0B,OAAOyK,eAAe,MAAM;QAC3B4hC,KAAK;kBACI,IAAI,MAAM,KAAK/X,iBAAiB,IAAI,MAAM,KAAKA;;QAExDtlC,KAAK,UAAU41G;UACd,KAAKtwE,eAAel0B,MAAM,OAAOwkG,MAAM,MAAMA,MAAM,IAAI,GAAG;;;MAG5D,KAAKtyE,QAAQ;;MAEb,KAAKmC,eAAe;MACpB,KAAKC,kBAAkB;MACvB,KAAKC,YAAY;MACjB,KAAKC,eAAe;MACpB,KAAKC,sBAAsB;MAC3B,KAAKC,uBAAuB0D,MAAM,GAAG,GAAG;MACxC,KAAK3G,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK+4B;QACJ,YAAY;QACZ,YAAY;;MAEb,KAAKzR,YAAYtnB,OAAOsnB;MACxB,KAAKE,eAAexnB,OAAOwnB;MAC3B,KAAKD,qBAAqBvnB,OAAOunB;MACjC,KAAKE,wBAAwBznB,OAAOynB;MACpC,KAAKC,qBAAqB1nB,OAAO0nB;MACjC,KAAKC,qBAAqBpxB,KAAKyJ,OAAO2nB;MACtC,KAAKsB,eAAejpB,OAAOipB;UAEvBjpB,OAAOinB;QACV,KAAKA,SAAS,KAAKA,aAAakG,SAAS52B,KAAKyJ,OAAOinB;;QAErD,KAAKA,QAAQ;;MAGd,KAAKmC,eAAeppB,OAAOopB;MAC3B,KAAKC,kBAAkBrpB,OAAOqpB;MAC9B,KAAKC,YAAYtpB,OAAOspB;MACxB,KAAKC,eAAevpB,OAAOupB;MAC3B,KAAKC,sBAAsBxpB,OAAOwpB;MAClC,KAAKC,iBAAiBlzB,KAAKyJ,OAAOypB;aAC3B;;;EAKT4gC,qBAAqBlxD,UAAUi2E,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmDxD,gCAAgC/kD;IAC/BztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;;MAEvB,KAAK/F,eAAe+F,MAAM;MAC1B,KAAK9F,YAAY;MACjB,KAAK/tC,MAAM;MACX,KAAKwuC,WAAW;MAChB,KAAKC,oBAAoB;MACzB,KAAKC,QAAQ;MACb,KAAKC,iBAAiB;MACtB,KAAKf,eAAeiG,MAAM;MAC1B,KAAKhG,oBAAoB;MACzB,KAAKyB,cAAc;MACnB,KAAKV,UAAU;MACf,KAAKC,YAAY;MACjB,KAAKC,YAAY;MACjB,KAAKC,gBAAgBl5B;MACrB,KAAKm5B,kBAAkBpvB,QAAQ,GAAG;MAClC,KAAKqvB,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAKI,cAAc;MACnB,KAAKhB,WAAW;MAChB,KAAKiB,SAAS;MACd,KAAKC,UAAUnhC;MACf,KAAKqhC,eAAe;MACpB,KAAKC,kBAAkB;MACvB,KAAKpnC,YAAY;MACjB,KAAKgoC,qBAAqB;MAC1B,KAAKC,mBAAmB;MACxB,KAAKC,oBAAoB;MACzB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKxD,cAAc;MACnB,KAAKF,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKwpC,SAAS7wB,KAAKyJ,OAAOonB;MAC1B,KAAKC,YAAYrnB,OAAOqnB;MACxB,KAAK/tC,MAAM0mB,OAAO1mB;MAClB,KAAKwuC,WAAW9nB,OAAO8nB;MACvB,KAAKC,oBAAoB/nB,OAAO+nB;MAChC,KAAKC,QAAQhoB,OAAOgoB;MACpB,KAAKC,iBAAiBjoB,OAAOioB;MAC7B,KAAKf,SAAS3wB,KAAKyJ,OAAOknB;MAC1B,KAAK0B,cAAc5oB,OAAO4oB;MAC1B,KAAKzB,oBAAoBnnB,OAAOmnB;MAChC,KAAKe,UAAUloB,OAAOkoB;MACtB,KAAKC,YAAYnoB,OAAOmoB;MACxB,KAAKC,YAAYpoB,OAAOooB;MACxB,KAAKC,gBAAgBroB,OAAOqoB;MAC5B,KAAKC,YAAY/xB,KAAKyJ,OAAOsoB;MAC7B,KAAKC,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;MAC/B,KAAKI,cAAc7oB,OAAO6oB;MAC1B,KAAKhB,WAAW7nB,OAAO6nB;MACvB,KAAKiB,SAAS9oB,OAAO8oB;MACrB,KAAKC,UAAU/oB,OAAO+oB;MACtB,KAAKE,eAAejpB,OAAOipB;MAC3B,KAAKC,kBAAkBlpB,OAAOkpB;MAC9B,KAAKpnC,YAAYke,OAAOle;MACxB,KAAKgoC,qBAAqB9pB,OAAO8pB;MACjC,KAAKC,mBAAmB/pB,OAAO+pB;MAC/B,KAAKC,oBAAoBhqB,OAAOgqB;MAChC,KAAKC,eAAejqB,OAAOiqB;MAC3B,KAAKC,eAAelqB,OAAOkqB;MAC3B,KAAKxD,cAAc1mB,OAAO0mB;aACnB;;;EAKT/oC,kBAAkBwb,UAAU+1E,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwClD,+BAA+B7kD;IAC9BztC,YAAYyiC;MACX;MACA,KAAK0Z;QACJ,QAAQ;;MAET,KAAKviD,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;MACvB,KAAK7zC,MAAM;MACX,KAAK6vC,cAAc;MACnB,KAAKrB,WAAW;MAChB,KAAKC,oBAAoB;MACzB,KAAKC,QAAQ;MACb,KAAKC,iBAAiB;MACtB,KAAKf,eAAeiG,MAAM;MAC1B,KAAKhG,oBAAoB;MACzB,KAAKyB,cAAc;MACnB,KAAKV,UAAU;MACf,KAAKC,YAAY;MACjB,KAAKC,YAAY;MACjB,KAAKC,gBAAgBl5B;MACrB,KAAKm5B,kBAAkBpvB,QAAQ,GAAG;MAClC,KAAKqvB,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAKZ,WAAW;MAChB,KAAK/lC,YAAY;MACjB,KAAKgoC,qBAAqB;MAC1B,KAAKC,mBAAmB;MACxB,KAAKC,oBAAoB;MACzB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAK1D,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKtE,MAAM0mB,OAAO1mB;MAClB,KAAK6vC,cAAcnpB,OAAOmpB;MAC1B,KAAKrB,WAAW9nB,OAAO8nB;MACvB,KAAKC,oBAAoB/nB,OAAO+nB;MAChC,KAAKC,QAAQhoB,OAAOgoB;MACpB,KAAKC,iBAAiBjoB,OAAOioB;MAC7B,KAAKf,SAAS3wB,KAAKyJ,OAAOknB;MAC1B,KAAK0B,cAAc5oB,OAAO4oB;MAC1B,KAAKzB,oBAAoBnnB,OAAOmnB;MAChC,KAAKe,UAAUloB,OAAOkoB;MACtB,KAAKC,YAAYnoB,OAAOmoB;MACxB,KAAKC,YAAYpoB,OAAOooB;MACxB,KAAKC,gBAAgBroB,OAAOqoB;MAC5B,KAAKC,YAAY/xB,KAAKyJ,OAAOsoB;MAC7B,KAAKC,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;MAC/B,KAAKZ,WAAW7nB,OAAO6nB;MACvB,KAAK/lC,YAAYke,OAAOle;MACxB,KAAKgoC,qBAAqB9pB,OAAO8pB;MACjC,KAAKC,mBAAmB/pB,OAAO+pB;MAC/B,KAAKC,oBAAoBhqB,OAAOgqB;MAChC,KAAKC,eAAejqB,OAAOiqB;MAC3B,KAAKC,eAAelqB,OAAOkqB;aACpB;;;EAKTigC,iBAAiBhxD,UAAU61E,qBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;EA2BhD,iCAAiC3kD;IAChCztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAK0xC,UAAU;MACf,KAAKC,YAAY;MACjB,KAAKC,YAAY;MACjB,KAAKC,gBAAgBl5B;MACrB,KAAKm5B,kBAAkBpvB,QAAQ,GAAG;MAClC,KAAKqvB,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAK3mC,YAAY;MACjB,KAAKgoC,qBAAqB;MAC1B,KAAKlmC,MAAM;MACX,KAAKqmC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKxD,cAAc;MACnB,KAAKF,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKkoB,UAAUloB,OAAOkoB;MACtB,KAAKC,YAAYnoB,OAAOmoB;MACxB,KAAKC,YAAYpoB,OAAOooB;MACxB,KAAKC,gBAAgBroB,OAAOqoB;MAC5B,KAAKC,YAAY/xB,KAAKyJ,OAAOsoB;MAC7B,KAAKC,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;MAC/B,KAAK3mC,YAAYke,OAAOle;MACxB,KAAKgoC,qBAAqB9pB,OAAO8pB;MACjC,KAAKG,eAAejqB,OAAOiqB;MAC3B,KAAKC,eAAelqB,OAAOkqB;MAC3B,KAAKxD,cAAc1mB,OAAO0mB;aACnB;;;EAKT7kC,mBAAmBsX,UAAUw2E,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAoCpD,kCAAkCtlD;IACjCztC,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;;MAEvB,KAAK7zC,MAAM;MACX,KAAKwuC,WAAW;MAChB,KAAKC,oBAAoB;MACzB,KAAKC,QAAQ;MACb,KAAKC,iBAAiB;MACtB,KAAKf,eAAeiG,MAAM;MAC1B,KAAKhG,oBAAoB;MACzB,KAAKyB,cAAc;MACnB,KAAKC,cAAc;MACnB,KAAKhB,WAAW;MAChB,KAAKiB,SAAS;MACd,KAAKC,UAAUnhC;MACf,KAAKqhC,eAAe;MACpB,KAAKC,kBAAkB;MACvB,KAAKpnC,YAAY;MACjB,KAAKgoC,qBAAqB;MAC1B,KAAKC,mBAAmB;MACxB,KAAKC,oBAAoB;MACzB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAK1D,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKtE,MAAM0mB,OAAO1mB;MAClB,KAAKwuC,WAAW9nB,OAAO8nB;MACvB,KAAKC,oBAAoB/nB,OAAO+nB;MAChC,KAAKC,QAAQhoB,OAAOgoB;MACpB,KAAKC,iBAAiBjoB,OAAOioB;MAC7B,KAAKf,SAAS3wB,KAAKyJ,OAAOknB;MAC1B,KAAK0B,cAAc5oB,OAAO4oB;MAC1B,KAAKzB,oBAAoBnnB,OAAOmnB;MAChC,KAAK0B,cAAc7oB,OAAO6oB;MAC1B,KAAKhB,WAAW7nB,OAAO6nB;MACvB,KAAKiB,SAAS9oB,OAAO8oB;MACrB,KAAKC,UAAU/oB,OAAO+oB;MACtB,KAAKE,eAAejpB,OAAOipB;MAC3B,KAAKC,kBAAkBlpB,OAAOkpB;MAC9B,KAAKpnC,YAAYke,OAAOle;MACxB,KAAKgoC,qBAAqB9pB,OAAO8pB;MACjC,KAAKC,mBAAmB/pB,OAAO+pB;MAC/B,KAAKC,oBAAoBhqB,OAAOgqB;MAChC,KAAKC,eAAejqB,OAAOiqB;MAC3B,KAAKC,eAAelqB,OAAOkqB;aACpB;;;EAKTggC,oBAAoB/wD,UAAU21E,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BtD,iCAAiCzkD;IAChCztC,YAAYyiC;MACX;MACA,KAAK0Z;QACJ,UAAU;;MAEX,KAAKviD,OAAO;MACZ,KAAKoH,YAAYuvC,MAAM;;MAEvB,KAAKvF,SAAS;MACd,KAAKtuC,MAAM;MACX,KAAK4uC,UAAU;MACf,KAAKC,YAAY;MACjB,KAAKC,YAAY;MACjB,KAAKC,gBAAgBl5B;MACrB,KAAKm5B,kBAAkBpvB,QAAQ,GAAG;MAClC,KAAKqvB,kBAAkB;MACvB,KAAKC,oBAAoB;MACzB,KAAKC,mBAAmB;MACxB,KAAKZ,WAAW;MAChB,KAAKoC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKxD,cAAc;MACnB,KAAKF,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK+4B;QACJ,UAAU;;MAEX,KAAKn7C,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAKgqC,SAAS5nB,OAAO4nB;MACrB,KAAKtuC,MAAM0mB,OAAO1mB;MAClB,KAAK4uC,UAAUloB,OAAOkoB;MACtB,KAAKC,YAAYnoB,OAAOmoB;MACxB,KAAKC,YAAYpoB,OAAOooB;MACxB,KAAKC,gBAAgBroB,OAAOqoB;MAC5B,KAAKC,YAAY/xB,KAAKyJ,OAAOsoB;MAC7B,KAAKC,kBAAkBvoB,OAAOuoB;MAC9B,KAAKC,oBAAoBxoB,OAAOwoB;MAChC,KAAKC,mBAAmBzoB,OAAOyoB;MAC/B,KAAKZ,WAAW7nB,OAAO6nB;MACvB,KAAKoC,eAAejqB,OAAOiqB;MAC3B,KAAKC,eAAelqB,OAAOkqB;MAC3B,KAAKxD,cAAc1mB,OAAO0mB;aACnB;;;EAKT4jC,mBAAmBnxD,UAAUo2E,uBAAuB;;;;;;;;;;;;;EAepD,iCAAiChlB;IAChC3tE,YAAYyiC;MACX;MACA,KAAK7oC,OAAO;MACZ,KAAK4mB,QAAQ;MACb,KAAKwsB,WAAW;MAChB,KAAKC,UAAU;MACf,KAAKrD,UAAUnH;;IAGhB9oB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK5C,QAAQ4C,OAAO5C;MACpB,KAAKwsB,WAAW5pB,OAAO4pB;MACvB,KAAKC,UAAU7pB,OAAO6pB;aACf;;;EAKT2gC,mBAAmBrxD,UAAU42E,uBAAuB;MAEhDypB,yBAAyB7kG,OAAOC;IACnCC,WAAW;IACX61D,gBAAgBA;IAChBC,gBAAgBA;IAChB2uC,mBAAmBA;IACnBx/D,gBAAgBA;IAChB2wB,gBAAgBA;IAChBJ,sBAAsBA;IACtBD,sBAAsBA;IACtBzsE,mBAAmBA;IACnBwsE,kBAAkBA;IAClBtoE,oBAAoBA;IACpBqoE,qBAAqBA;IACrBF,mBAAmBA;IACnBC,sBAAsBA;IACtB58B,mBAAmBA;IACnBi9B,oBAAoBA;IACpBE,oBAAoBA;IACpBD,mBAAmBA;IACnBlgC,UAAUA;;QAGLovE;;IAELC,YAAY,UAAUjoG,OAAOkoG,MAAMC;UAC9BH,eAAeI,aAAapoG;;;mBAGpBA,MAAM7U,YAAY6U,MAAMqvC,SAAS64D,MAAMC,OAAOxkH,YAAYwkH,KAAKnoG,MAAMha;;aAG1Ega,MAAMC,MAAMioG,MAAMC;;;IAG1BE,cAAc,UAAUroG,OAAOjb,MAAMujH;WAC/BtoG;OACJsoG,cAActoG,MAAM7U,gBAAgBpG,aAAaib;iBAEvCjb,KAAKoqD,sBAAsB;mBAC1BpqD,KAAKib;;aAGV3X,MAAMqf,UAAUzH,MAAMhd,KAAK+c;;IAEnCooG,cAAc,UAAUntF;aAChBstF,YAAYC,OAAOvtF,aAAaA,kBAAkBwtF;;;IAG1DC,kBAAkB,UAAUC;MAC3B,qBAAqB5iH,GAAGm4B;eAChByqF,MAAM5iH,KAAK4iH,MAAMzqF;;YAGnBnd,IAAI4nG,MAAM3iH;YACVq8E,aAAah6E,MAAM0Y;eAEhBhb,IAAI,GAAGA,MAAMgb,KAAKhb,GAAGs8E,OAAOt8E,KAAKA;MAE1Cs8E,OAAOja,KAAKwgD;aACLvmC;;;IAGRwmC,aAAa,UAAUx6E,QAAQqyB,QAAQl+C;YAChCsmG,UAAUz6E,OAAOroC;YACjBq8E,aAAah0C,OAAOljC,YAAY29G;eAE7B/iH,IAAI,GAAGmtB,YAAY,GAAGA,cAAc41F,WAAW/iH;cACjDgjH,YAAYvmG,MAAMzc,KAAK26D;iBAEpBxiC,IAAI,GAAGA,MAAMwiC,UAAUxiC;UAC/BmkD,OAAOnvD,eAAemb,OAAO06E,YAAY7qF;;;aAIpCmkD;;;IAGR2mC,aAAa,UAAUC,UAAUN,OAAOt6E,QAAQ66E;UAC3CnjH,IAAI,GACNuoC,MAAM26E,SAAS;aAEV36E,QAAQ3qC,aAAa2qC,IAAI46E,uBAAuBvlH;QACtD2qC,MAAM26E,SAASljH;;UAGZuoC,QAAQ3qC;;UAERiN,QAAQ09B,IAAI46E;UACZt4G,UAAUjN;;UAEV0E,MAAMC,QAAQsI;;UAEhBA,QAAQ09B,IAAI46E;cAERt4G,UAAUjN;YACbglH,MAAMllH,KAAK6qC,IAAIrhC;YACfohC,OAAO5qC,KAAKiH,MAAM2jC,QAAQz9B;;UAG3B09B,MAAM26E,SAASljH;iBACPuoC,QAAQ3qC;iBACPiN,MAAMsW,YAAYvjB;;;UAG3BiN,QAAQ09B,IAAI46E;cAERt4G,UAAUjN;YACbglH,MAAMllH,KAAK6qC,IAAIrhC;YACf2D,MAAMsW,QAAQmnB,QAAQA,OAAOroC;;UAG9BsoC,MAAM26E,SAASljH;iBACPuoC,QAAQ3qC;;;;UAIhBiN,QAAQ09B,IAAI46E;cAERt4G,UAAUjN;YACbglH,MAAMllH,KAAK6qC,IAAIrhC;YACfohC,OAAO5qC,KAAKmN;;UAGb09B,MAAM26E,SAASljH;iBACPuoC,QAAQ3qC;;;IAGnBwlH,SAAS,UAAUC,YAAYn4G,MAAMo4G,YAAYC,UAAUC,MAAM;YAC1DC,OAAOJ,WAAW77G;MACxBi8G,KAAKv4G,OAAOA;YACNw4G;eAEG1jH,IAAI,GAAGA,IAAIyjH,KAAKC,OAAOzjH,UAAUD;cACnC2jH,QAAQF,KAAKC,OAAO1jH;cACpB4jH,YAAYD,MAAME;cAClBjB;cACAt6E;iBAEGnQ,IAAI,GAAGA,IAAIwrF,MAAMf,MAAM3iH,UAAUk4B;gBACnCyvB,QAAQ+7D,MAAMf,MAAMzqF,KAAKqrF;cAC3B57D,QAAQ07D,cAAc17D,SAAS27D;UACnCX,MAAMllH,KAAKimH,MAAMf,MAAMzqF;mBAEdh2B,IAAI,GAAGA,IAAIyhH,aAAazhH;YAChCmmC,OAAO5qC,KAAKimH,MAAMr7E,OAAOnQ,IAAIyrF,YAAYzhH;;;YAIvCygH,MAAM3iH,WAAW;QACrB0jH,MAAMf,QAAQX,eAAeK,aAAaM,OAAOe,MAAMf,MAAMx9G;QAC7Du+G,MAAMr7E,SAAS25E,eAAeK,aAAah6E,QAAQq7E,MAAMr7E,OAAOljC;QAChEs+G,OAAOhmH,KAAKimH;;MAGbF,KAAKC,SAASA;;UAEVI,eAAe7vF;eAEVj0B,IAAI,GAAGA,IAAIyjH,KAAKC,OAAOzjH,UAAUD;YACrC8jH,eAAeL,KAAKC,OAAO1jH,GAAG4iH,MAAM;UACvCkB,eAAeL,KAAKC,OAAO1jH,GAAG4iH,MAAM;;;;eAK7B5iH,IAAI,GAAGA,IAAIyjH,KAAKC,OAAOzjH,UAAUD;QACzCyjH,KAAKC,OAAO1jH,GAAGs8F,OAAO,IAAIwnB;;MAG3BL,KAAKM;aACEN;;IAERO,kBAAkB,UAAUC,YAAYC,iBAAiB,GAAGC,gBAAgBF,YAAYT,MAAM;UACzFA,OAAO,GAAGA,MAAM;YACdY,YAAYD,cAAcT,OAAOzjH;YACjCokH,gBAAgBH,iBAAiBV;;eAE9BxjH,IAAI,GAAGA,IAAIokH,aAAapkH;cAC1BskH,iBAAiBH,cAAcT,OAAO1jH;cACtCukH,qBAAqBD,eAAeE;;YAEtCD,uBAAuB,UAAUA,uBAAuB;;cAEtDE,cAAcR,WAAWP,OAAOgB,KAAK,UAAUf;iBAC7CA,MAAMz4G,SAASo5G,eAAep5G,QAAQy4G,MAAMa,kBAAkBD;;YAElEE,gBAAgB7mH;YAChB+mH,kBAAkB;cAChBC,qBAAqBN,eAAeT;YAEtCS,eAAeO,kBAAkBC;UACpCH,kBAAkBC,qBAAqB;;YAGpCG,eAAe;cACbC,kBAAkBP,YAAYZ;YAEhCY,YAAYI,kBAAkBC;UACjCC,eAAeC,kBAAkB;;cAG5B97C,YAAYo7C,eAAe1B,MAAM3iH,SAAS;YAC5CglH;;YAEAZ,iBAAiBC,eAAe1B,MAAM;;gBAEnCsC,aAAaP;gBACbQ,WAAWP,qBAAqBD;UACtCM,iBAAiBhD,eAAeC,WAAWoC,eAAeh8E,QAAQ48E,YAAYC;mBACpEd,iBAAiBC,eAAe1B,MAAM15C;;gBAE1Cg8C,aAAah8C,YAAY07C,qBAAqBD;gBAC9CQ,WAAWD,aAAaN,qBAAqBD;UACnDM,iBAAiBhD,eAAeC,WAAWoC,eAAeh8E,QAAQ48E,YAAYC;;;gBAGxEC,cAAcd,eAAeO;gBAC7BK,aAAaP;gBACbQ,WAAWP,qBAAqBD;UACtCS,YAAYC,SAAShB;UACrBY,iBAAiBhD,eAAeC,WAAWkD,YAAYE,cAAcJ,YAAYC;;;YAI9EZ,uBAAuB;gBACpBgB,oBAAoBv0F,aAAa/P,UAAUgkG,gBAAgB77G,YAAYymB;UAC7E01F,cAAcpkG,QAAQ8jG;;;cAIjBO,WAAWf,YAAY7B,MAAM3iH;iBAE1Bk4B,IAAI,GAAGA,IAAIqtF,YAAYrtF;gBACzBstF,aAAattF,IAAI6sF,kBAAkBD;cAErCR,uBAAuB;;YAE1BvzF,WAAW1C,wBAAwBm2F,YAAYn8E,QAAQm9E,YAAYR,gBAAgB,GAAGR,YAAYn8E,QAAQm9E;;kBAEpGC,WAAWV,kBAAkBD,eAAe;;qBAEzC5iH,IAAI,GAAGA,IAAIujH,YAAYvjH;cAC/BsiH,YAAYn8E,OAAOm9E,aAAatjH,MAAM8iH,eAAe9iH;;;;;MAMzD8hH,WAAW0B,YAAY9uG;aAChBotG;;;;;;;;;;;;;;;;;;;;;;;EAwBT;IACC7+G,YAAYwgH,oBAAoBC,cAAcC,YAAYR;MACzD,KAAKM,qBAAqBA;MAC1B,KAAKG,eAAe;MACpB,KAAKT,eAAeA,iBAAiB1nH,YAAY0nH,mBAAmBO,aAAazgH,YAAY0gH;MAC7F,KAAKD,eAAeA;MACpB,KAAKjC,YAAYkC;MACjB,KAAKE,WAAW;MAChB,KAAKC;;IAGNZ,SAAS/pG;YACF4qG,KAAK,KAAKN;UACZh6E,KAAK,KAAKm6E,cACZhrF,KAAKmrF,GAAGt6E,KACR9Q,KAAKorF,GAAGt6E,KAAK;MAEfu6E;QACCv+G;cACKm5B;UAEJqlF;;;;;YAKCC,oBAAoB/qG,IAAIyf;uBACdurF,WAAW16E,KAAK;oBACpB7Q,OAAOn9B;sBACN0d,IAAIwf,UAAUurF;;kBAElBz6E,KAAKs6E,GAAGjmH;kBACR,KAAK8lH,eAAen6E;yBACb,KAAK26E,UAAU36E,KAAK,GAAGtwB,GAAGwf;;oBAG9B8Q,OAAO06E;;gBAEXxrF,KAAKC;gBACLA,KAAKmrF,KAAKt6E;oBAENtwB,IAAIyf;;wBAEDnzB;;;;cAKRm5B,QAAQmlF,GAAGjmH;oBACLmmH;;;;kBAKD9qG,KAAKwf;;oBAEJ0rF,WAAWN,GAAG;kBAEhB5qG,IAAIkrG;gBACP56E,KAAK;;gBAEL9Q,KAAK0rF;;;uBAIGF,WAAW16E,KAAK;oBACpB9Q,OAAOl9B;;kBAEV,KAAKmoH,eAAe;yBACb,KAAKU,aAAa,GAAGnrG,GAAGyf;;oBAG5B6Q,OAAO06E;;gBAEXvrF,KAAKD;gBACLA,KAAKorF,KAAKt6E,KAAK;oBAEXtwB,KAAKwf;;wBAEFlzB;;;;cAKRm5B,QAAQ6K;cACRA,KAAK;oBACCw6E;;;kBAIDD;;;;iBAKAv6E,KAAK7K;kBACL2lF,MAAM96E,KAAK7K,UAAU;gBAEvBzlB,IAAI4qG,GAAGQ;cACV3lF,QAAQ2lF;;cAER96E,KAAK86E,MAAM;;;UAIb3rF,KAAKmrF,GAAGt6E;UACR9Q,KAAKorF,GAAGt6E,KAAK;;cAET9Q,OAAOl9B;YACV,KAAKmoH,eAAe;mBACb,KAAKU,aAAa,GAAGnrG,GAAGyf;;cAG5BA,OAAOn9B;YACVguC,KAAKs6E,GAAGjmH;YACR,KAAK8lH,eAAen6E;mBACb,KAAK26E,UAAU36E,KAAK,GAAG9Q,IAAIxf;;;;QAKpC,KAAKyqG,eAAen6E;QACpB,KAAK+6E,iBAAiB/6E,IAAI9Q,IAAIC;;;aAIxB,KAAK6rF,aAAah7E,IAAI9Q,IAAIxf,GAAGyf;;IAGrC8rF;aACQ,KAAKb,YAAY,KAAKC;;IAG9Ba,iBAAiBhtG;;YAEVwiE,SAAS,KAAKgpC,cACjBh9E,SAAS,KAAKu9E,cACdlrD,SAAS,KAAKipD,WACd1iG,SAASpH,QAAQ6gD;eAEX36D,IAAI,GAAGA,MAAM26D,UAAU36D;QAC/Bs8E,OAAOt8E,KAAKsoC,OAAOpnB,SAASlhB;;aAGtBs8E;;;IAIRsqC;;gBAGWx7G,MAAM;;IAGjBu7G;;;;EAQDI,YAAYplG,UAAU8kG,eAAeM,YAAYplG,UAAUmlG;EAC3DC,YAAYplG,UAAU4kG,YAAYQ,YAAYplG,UAAUmlG;;;;;;;;EAUxD,+BAA+BC;IAC9B3hH,YAAYwgH,oBAAoBC,cAAcC,YAAYR;MACzD,MAAMM,oBAAoBC,cAAcC,YAAYR;MACpD,KAAK0B,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKC,eAAe;MACpB,KAAKlB;QACJmB,aAAa3wG;QACb4wG,WAAW5wG;;;IAIbkwG,iBAAiB/6E,IAAI9Q,IAAIC;YAClBmrF,KAAK,KAAKN;UACZ0B,QAAQ17E,KAAK,GACf27E,QAAQ37E,KAAK,GACb47E,QAAQtB,GAAGoB,QACXG,QAAQvB,GAAGqB;UAETC,UAAU5pH;gBACL,KAAKipH,eAAeO;eACtB1wG;;YAEJ4wG,QAAQ17E;YACR47E,QAAQ,IAAI1sF,KAAKC;;eAGbpkB;;YAEJ2wG,QAAQpB,GAAGjmH,SAAS;YACpBunH,QAAQ1sF,KAAKorF,GAAGoB,SAASpB,GAAGoB,QAAQ;;;;;YAMpCA,QAAQ17E;YACR47E,QAAQzsF;;;UAIP0sF,UAAU7pH;gBACL,KAAKipH,eAAeQ;eACtB3wG;;YAEJ6wG,QAAQ37E;YACR67E,QAAQ,IAAI1sF,KAAKD;;eAGbnkB;;YAEJ4wG,QAAQ;YACRE,QAAQ1sF,KAAKmrF,GAAG,KAAKA,GAAG;;;;;YAMxBqB,QAAQ37E,KAAK;YACb67E,QAAQ3sF;;;YAIL4sF,UAAU3sF,KAAKD,MAAM,KACxB6/B,SAAS,KAAKipD;MACjB,KAAKoD,cAAcU,UAAU5sF,KAAK0sF;MAClC,KAAKN,cAAcQ,UAAUD,QAAQ1sF;MACrC,KAAKksF,cAAcK,QAAQ3sD;MAC3B,KAAKwsD,cAAcI,QAAQ5sD;;IAG5BisD,aAAah7E,IAAI9Q,IAAIxf,GAAGyf;YACjBuhD,SAAS,KAAKgpC,cACjBh9E,SAAS,KAAKu9E,cACdlrD,SAAS,KAAKipD,WACd/O,KAAKjpE,KAAK+uB,QACVgtD,KAAK9S,KAAKl6C,QACVitD,KAAK,KAAKX,aACVY,KAAK,KAAKV,aACVW,KAAK,KAAKd,aACVe,KAAK,KAAKb,aACVp3F,KAAKxU,IAAIwf,OAAOC,KAAKD,KACrBorF,KAAKp2F,IAAIA,GACTk4F,MAAM9B,KAAKp2F;;YAERm4F,MAAMH,KAAKE,MAAM,IAAIF,KAAK5B,KAAK4B,KAAKh4F;YACpCwK,MAAM,IAAIwtF,MAAME,QAAQ,MAAM,IAAIF,MAAM5B,OAAO,MAAM4B,MAAMh4F,IAAI;YAC/Dd,OAAO,IAAI+4F,MAAMC,OAAO,MAAMD,MAAM7B,KAAK,MAAMp2F;YAC/Co4F,KAAKH,KAAKC,MAAMD,KAAK7B;;eAElBlmH,IAAI,GAAGA,MAAM26D,UAAU36D;QAC/Bs8E,OAAOt8E,KAAKioH,KAAK3/E,OAAOs/E,KAAK5nH,KAAKs6B,KAAKgO,OAAOq/E,KAAK3nH,KAAKgvB,KAAKsZ,OAAOusE,KAAK70G,KAAKkoH,KAAK5/E,OAAOu/E,KAAK7nH;;aAGzFs8E;;;EAKT,gCAAgCyqC;IAC/B3hH,YAAYwgH,oBAAoBC,cAAcC,YAAYR;MACzD,MAAMM,oBAAoBC,cAAcC,YAAYR;;IAGrDsB,aAAah7E,IAAI9Q,IAAIxf,GAAGyf;YACjBuhD,SAAS,KAAKgpC,cACjBh9E,SAAS,KAAKu9E,cACdlrD,SAAS,KAAKipD,WACduE,UAAUv8E,KAAK+uB,QACfytD,UAAUD,UAAUxtD,QACpB0tD,WAAW/sG,IAAIwf,OAAOC,KAAKD,KAC3BwtF,UAAU,IAAID;eAERroH,IAAI,GAAGA,MAAM26D,UAAU36D;QAC/Bs8E,OAAOt8E,KAAKsoC,OAAO8/E,UAAUpoH,KAAKsoH,UAAUhgF,OAAO6/E,UAAUnoH,KAAKqoH;;aAG5D/rC;;;;;;;;EAWT,kCAAkCyqC;IACjC3hH,YAAYwgH,oBAAoBC,cAAcC,YAAYR;MACzD,MAAMM,oBAAoBC,cAAcC,YAAYR;;IAGrDsB,aAAah7E;;aAGL,KAAKk7E,iBAAiBl7E,KAAK;;;EAKpC;IACCxmC,YAAY8F,MAAM03G,OAAOt6E,QAAQigF;UAC5Br9G,SAAStN,qBAAqBwN,MAAM;UACpCw3G,UAAUhlH,aAAaglH,MAAM3iH,WAAW,aAAamL,MAAM,sDAAsDF;MACrH,KAAKA,OAAOA;MACZ,KAAK03G,QAAQX,eAAeK,aAAaM,OAAO,KAAK4F;MACrD,KAAKlgF,SAAS25E,eAAeK,aAAah6E,QAAQ,KAAKmgF;MACvD,KAAKC,iBAAiBH,iBAAiB,KAAKI;;;;WAKtClgG,OAAOk7F;YACPiF,YAAYjF,MAAMv+G;UACpB0kG;;UAEA8e,UAAUngG,WAAW,KAAKA;QAC7BqhF,OAAO8e,UAAUngG,OAAOk7F;;;QAGxB7Z;UACC,QAAQ6Z,MAAMz4G;UACd,SAAS+2G,eAAeK,aAAaqB,MAAMf,OAAOtgH;UAClD,UAAU2/G,eAAeK,aAAaqB,MAAMr7E,QAAQhmC;;cAE/CimH,gBAAgB5E,MAAMkF;YAExBN,kBAAkB5E,MAAMgF;UAC3B7e,KAAKye,gBAAgBA;;;MAIvBze,KAAK9qG,OAAO2kH,MAAMa;;aAEX1a;;IAGRgf,iCAAiCxsC;iBACrBysC,oBAAoB,KAAKnG,OAAO,KAAKt6E,QAAQ,KAAKu7E,gBAAgBvnC;;IAG9E0sC,+BAA+B1sC;iBACnB2sC,kBAAkB,KAAKrG,OAAO,KAAKt6E,QAAQ,KAAKu7E,gBAAgBvnC;;IAG5E4sC,+BAA+B5sC;iBACnB6sC,iBAAiB,KAAKvG,OAAO,KAAKt6E,QAAQ,KAAKu7E,gBAAgBvnC;;IAG3EosC,iBAAiBH;UACZa;cAEIb;aACFjyG;UACJ8yG,gBAAgB,KAAKN;;aAGjBvyG;UACJ6yG,gBAAgB,KAAKJ;;aAGjBxyG;UACJ4yG,gBAAgB,KAAKF;;;UAInBE,kBAAkBxrH;cACf+C,UAAU,mCAAmC,KAAK6jH,gBAAgB,2BAA2B,KAAKt5G;YAEpG,KAAK25G,sBAAsBjnH;;cAE1B2qH,kBAAkB,KAAKI;YAC1B,KAAKD,iBAAiB,KAAKC;;sBAEjBv9G,MAAMzK;;;QAIlBd,QAAQ0B,KAAK,wBAAwBZ;eAC9B;;MAGR,KAAKkkH,oBAAoBuE;aAClB;;IAGRP;cACS,KAAKhE;aACP,KAAKiE;iBACFxyG;aAEH,KAAK0yG;iBACFzyG;aAEH,KAAK2yG;iBACF1yG;;;IAIVqtG;aACQ,KAAKv7E,OAAOroC,SAAS,KAAK2iH,MAAM3iH;;;IAIxCq8F,MAAM+sB;UACDA,eAAe;cACZzG,QAAQ,KAAKA;iBAEV5iH,IAAI,GAAGgb,IAAI4nG,MAAM3iH,QAAQD,MAAMgb,KAAKhb;UAC5C4iH,MAAM5iH,MAAMqpH;;;aAIP;;;IAIRzjG,MAAM0jG;UACDA,cAAc;cACX1G,QAAQ,KAAKA;iBAEV5iH,IAAI,GAAGgb,IAAI4nG,MAAM3iH,QAAQD,MAAMgb,KAAKhb;UAC5C4iH,MAAM5iH,MAAMspH;;;aAIP;;;;IAKR3+C,KAAK4+C,WAAWC;YACT5G,QAAQ,KAAKA,OAChB6G,QAAQ7G,MAAM3iH;UACbkiH,OAAO,GACTC,KAAKqH,QAAQ;aAERtH,SAASsH,SAAS7G,MAAMT,QAAQoH;UACpCpH;;aAGIC,QAAQ,KAAKQ,MAAMR,MAAMoH;UAC7BpH;;QAGDA;;UAEED,SAAS,KAAKC,OAAOqH;;YAEpBtH,QAAQC;UACXA,KAAKr9G,KAAKF,IAAIu9G,IAAI;UAClBD,OAAOC,KAAK;;cAGPznD,SAAS,KAAKkpD;QACpB,KAAKjB,QAAQX,eAAeC,WAAWU,OAAOT,MAAMC;QACpD,KAAK95E,SAAS25E,eAAeC,WAAW,KAAK55E,QAAQ65E,OAAOxnD,QAAQynD,KAAKznD;;aAGnE;;;IAIR+uD;UACKC,QAAQ;YACN/F,YAAY,KAAKC;UAEnBD,YAAY7+G,KAAKC,MAAM4+G,eAAe;QACzC/jH,QAAQa,MAAM,qDAAqD;QACnEipH,QAAQ;;YAGH/G,QAAQ,KAAKA,OAChBt6E,SAAS,KAAKA,QACdmhF,QAAQ7G,MAAM3iH;UAEbwpH,UAAU;QACb5pH,QAAQa,MAAM,wCAAwC;QACtDipH,QAAQ;;UAGLC,WAAW;eAEN5pH,IAAI,GAAGA,MAAMypH,OAAOzpH;cACtB6pH,WAAWjH,MAAM5iH;mBAEZ6pH,aAAa,YAAY9vE,MAAM8vE;UACzChqH,QAAQa,MAAM,oDAAoD,MAAMV,GAAG6pH;UAC3EF,QAAQ;;;YAILC,aAAa,QAAQA,WAAWC;UACnChqH,QAAQa,MAAM,2CAA2C,MAAMV,GAAG6pH,UAAUD;UAC5ED,QAAQ;;;QAITC,WAAWC;;UAGRvhF,WAAW1qC;YACVqkH,eAAeI,aAAa/5E;mBACtBtoC,IAAI,GAAGgb,IAAIstB,OAAOroC,QAAQD,MAAMgb,KAAKhb;kBACvC6K,QAAQy9B,OAAOtoC;gBAEjB+5C,MAAMlvC;cACThL,QAAQa,MAAM,qDAAqD,MAAMV,GAAG6K;cAC5E8+G,QAAQ;;;;;;aAOLA;;;;IAKRG;;YAEOlH,QAAQX,eAAeC,WAAW,KAAKU,QAC1Ct6E,SAAS25E,eAAeC,WAAW,KAAK55E,SACxCqyB,SAAS,KAAKkpD,gBACdkG,sBAAsB,KAAKlB,uBAAuBryG,mBAClD0yD,YAAY05C,MAAM3iH,SAAS;UAC1B+pH,aAAa;eAERhqH,IAAI,GAAGA,IAAIkpE,aAAalpE;YAC5BiqH,OAAO;cACL/iH,OAAO07G,MAAM5iH;cACbkqH,WAAWtH,MAAM5iH,IAAI;;YAEvBkH,SAASgjH,aAAalqH,MAAM,KAAKkH,SAAS07G,MAAM;eAC9CmH;;kBAEE7oG,SAASlhB,IAAI26D,QAChBwvD,UAAUjpG,SAASy5C,QACnByvD,UAAUlpG,SAASy5C;qBAEbxiC,IAAI,GAAGA,MAAMwiC,UAAUxiC;oBACzBttB,QAAQy9B,OAAOpnB,SAASiX;kBAE1BttB,UAAUy9B,OAAO6hF,UAAUhyF,MAAMttB,UAAUy9B,OAAO8hF,UAAUjyF;gBAC/D8xF,OAAO;;;;;YAKTA,OAAO;;;;YAKLA;cACCjqH,MAAMgqH;YACTpH,MAAMoH,cAAcpH,MAAM5iH;kBACpBqqH,aAAarqH,IAAI26D,QACpB2vD,cAAcN,aAAarvD;qBAErBxiC,IAAI,GAAGA,MAAMwiC,UAAUxiC;cAC/BmQ,OAAOgiF,cAAcnyF,KAAKmQ,OAAO+hF,aAAalyF;;;YAI9C6xF;;;;UAKA9gD,YAAY;QACf05C,MAAMoH,cAAcpH,MAAM15C;iBAEjBmhD,aAAanhD,YAAYvO,QAAQ2vD,cAAcN,aAAarvD,QAAQxiC,IAAI,GAAGA,MAAMwiC,UAAUxiC;UACnGmQ,OAAOgiF,cAAcnyF,KAAKmQ,OAAO+hF,aAAalyF;;UAG7C6xF;;UAGCA,eAAepH,MAAM3iH;QACxB,KAAK2iH,QAAQX,eAAeC,WAAWU,OAAO,GAAGoH;QACjD,KAAK1hF,SAAS25E,eAAeC,WAAW55E,QAAQ,GAAG0hF,aAAarvD;;QAEhE,KAAKioD,QAAQA;QACb,KAAKt6E,SAASA;;aAGR;;IAGR9gC;YACOo7G,QAAQX,eAAeC,WAAW,KAAKU,OAAO;YAC9Ct6E,SAAS25E,eAAeC,WAAW,KAAK55E,QAAQ;YAChDiiF,qBAAqB,KAAKnlH;YAC1Bu+G,YAAY4G,mBAAmB,KAAKr/G,MAAM03G,OAAOt6E;;MAEvDq7E,MAAMkB,oBAAoB,KAAKA;aACxBlB;;;EAKT6G,cAAc7oG,UAAU6mG,iBAAiBxwE;EACzCwyE,cAAc7oG,UAAU8mG,kBAAkBzwE;EAC1CwyE,cAAc7oG,UAAUgnG,uBAAuBpyG;;;;EAM/C,mCAAmCi0G;EAEnCC,qBAAqB9oG,UAAU6iG,gBAAgB;EAC/CiG,qBAAqB9oG,UAAU8mG,kBAAkBnmH;EACjDmoH,qBAAqB9oG,UAAUgnG,uBAAuBryG;EACtDm0G,qBAAqB9oG,UAAUqnG,iCAAiCprH;EAChE6sH,qBAAqB9oG,UAAUunG,iCAAiCtrH;;;;;EAMhE,iCAAiC4sH;EAEjCE,mBAAmB/oG,UAAU6iG,gBAAgB;;;;;EAM7C,kCAAkCgG;EAElCG,oBAAoBhpG,UAAU6iG,gBAAgB;;;;;EAM9C,0CAA0CuC;IACzC3hH,YAAYwgH,oBAAoBC,cAAcC,YAAYR;MACzD,MAAMM,oBAAoBC,cAAcC,YAAYR;;IAGrDsB,aAAah7E,IAAI9Q,IAAIxf,GAAGyf;YACjBuhD,SAAS,KAAKgpC,cACjBh9E,SAAS,KAAKu9E,cACdlrD,SAAS,KAAKipD,WACdhjG,SAAStF,IAAIwf,OAAOC,KAAKD;UACxB5Z,SAAS0qB,KAAK+uB;eAETlxB,MAAMvoB,SAASy5C,QAAQz5C,WAAWuoB,KAAKvoB,UAAU;QACzD8P,WAAW/D,UAAUqvD,QAAQ,GAAGh0C,QAAQpnB,SAASy5C,QAAQryB,QAAQpnB,QAAQN;;aAGnE07D;;;;;;EAST,sCAAsCkuC;IACrCxB,+BAA+B1sC;iBACnBsuC,4BAA4B,KAAKhI,OAAO,KAAKt6E,QAAQ,KAAKu7E,gBAAgBvnC;;;EAKvFuuC,wBAAwBlpG,UAAU6iG,gBAAgB;;EAElDqG,wBAAwBlpG,UAAUgnG,uBAAuBpyG;EACzDs0G,wBAAwBlpG,UAAUunG,iCAAiCtrH;;;;EAMnE,kCAAkC4sH;EAElCM,oBAAoBnpG,UAAU6iG,gBAAgB;EAC9CsG,oBAAoBnpG,UAAU8mG,kBAAkBnmH;EAChDwoH,oBAAoBnpG,UAAUgnG,uBAAuBryG;EACrDw0G,oBAAoBnpG,UAAUqnG,iCAAiCprH;EAC/DktH,oBAAoBnpG,UAAUunG,iCAAiCtrH;;;;EAM/D,kCAAkC4sH;EAElCO,oBAAoBppG,UAAU6iG,gBAAgB;;EAE9C;IACCp/G,YAAY8F,MAAM8/G,YAAY,GAAGtH,QAAQiC,YAAY/uG;MACpD,KAAK1L,OAAOA;MACZ,KAAKw4G,SAASA;MACd,KAAKsH,WAAWA;MAChB,KAAKrF,YAAYA;MACjB,KAAK7qG,OAAOwC;;UAER,KAAK0tG,WAAW;QACnB,KAAKjH;;;WAIAhlH,MAAM+qG;YACN4Z,aACHuH,aAAanhB,KAAK4Z,QAClBwH,YAAY,OAAOphB,KAAK0Z,OAAO;eAEzBxjH,IAAI,GAAGgb,IAAIiwG,WAAWhrH,QAAQD,MAAMgb,KAAKhb;QACjD0jH,OAAOhmH,KAAKytH,mBAAmBF,WAAWjrH,IAAI4lB,MAAMslG;;YAG/CzH,WAAW,KAAK3Z,KAAK5+F,MAAM4+F,KAAKkhB,UAAUtH,QAAQ5Z,KAAK6b;MAC7DlC,KAAK3oG,OAAOgvF,KAAKhvF;aACV2oG;;WAGDh7F,OAAOg7F;YACPC,aACH0H,aAAa3H,KAAKC;YACf5Z;QACL,QAAQ2Z,KAAKv4G;QACb,YAAYu4G,KAAKuH;QACjB,UAAUtH;QACV,QAAQD,KAAK3oG;QACb,aAAa2oG,KAAKkC;;eAGV3lH,IAAI,GAAGgb,IAAIowG,WAAWnrH,QAAQD,MAAMgb,KAAKhb;QACjD0jH,OAAOhmH,KAAK8sH,cAAc/hG,OAAO2iG,WAAWprH;;aAGtC8pG;;WAGDuhB,8BAA8BngH,MAAMogH,qBAAqB9H,KAAK+H;YAC9DC,kBAAkBF,oBAAoBrrH;YACtCyjH;eAEG1jH,IAAI,GAAGA,IAAIwrH,iBAAiBxrH;YAChC4iH;YACAt6E;QACJs6E,MAAMllH,MAAMsC,IAAIwrH,kBAAkB,KAAKA,iBAAiBxrH,IAAIA,IAAI,KAAKwrH;QACrEljF,OAAO5qC,KAAK,GAAG,GAAG;cACZ+e,QAAQwlG,eAAeU,iBAAiBC;QAC9CA,QAAQX,eAAea,YAAYF,OAAO,GAAGnmG;QAC7C6rB,SAAS25E,eAAea,YAAYx6E,QAAQ,GAAG7rB;;;aAG1C8uG,UAAU3I,MAAM,OAAO;UAC3BA,MAAMllH,KAAK8tH;UACXljF,OAAO5qC,KAAK4qC,OAAO;;QAGpBo7E,OAAOhmH,SAASitH,oBAAoB,4BAA4BW,oBAAoBtrH,GAAGkL,OAAO,KAAK03G,OAAOt6E,QAAQ1iB,MAAM,MAAM49F;;iBAGpH,KAAKt4G,OAAO,GAAGw4G;;WAGpB+H,WAAWC,mBAAmBxgH;UAChCygH,YAAYD;WAEXppH,MAAMC,QAAQmpH;cACZtM,IAAIsM;QACVC,YAAYvM,EAAEt5G,YAAYs5G,EAAEt5G,SAAS0+B,cAAc46E,EAAE56E;;eAG7CxkC,IAAI,GAAGA,IAAI2rH,UAAU1rH,QAAQD;YACjC2rH,UAAU3rH,GAAGkL,SAASA;iBAClBygH,UAAU3rH;;;aAIZ;;WAGD4rH,oCAAoCn5E,cAAc+wE,KAAK+H;YACvDM;;;YAGAC,UAAU;;;eAGP9rH,IAAI,GAAGksB,KAAKumB,aAAaxyC,QAAQD,IAAIksB,IAAIlsB;cAC3C+rH,cAAct5E,aAAazyC;cAC3BgsH,QAAQD,YAAY7gH,KAAKi+D,MAAM2iD;YAEjCE,SAASA,MAAM/rH,SAAS;gBACrBiL,OAAO8gH,MAAM;cACfC,wBAAwBJ,wBAAwB3gH;eAE/C+gH;YACJJ,wBAAwB3gH,QAAQ+gH;;UAGjCA,sBAAsBvuH,KAAKquH;;;YAIvBG;iBAEKhhH,QAAQ2gH;QAClBK,MAAMxuH,KAAK,KAAK2tH,8BAA8BngH,MAAM2gH,wBAAwB3gH,OAAOs4G,KAAK+H;;aAGlFW;;;WAIDC,eAAe/jF,WAAWirC;WAC3BjrC;QACJvoC,QAAQa,MAAM;eACP;;YAGF0rH,mBAAmB,UAAUxD,WAAWyD,WAAWC,eAAeC,cAAcC;;YAEjFF,cAAcrsH,WAAW;gBACtB2iH;gBACAt6E;UACN25E,eAAegB,YAAYqJ,eAAe1J,OAAOt6E,QAAQikF;;cAErD3J,MAAM3iH,WAAW;YACpBusH,WAAW9uH,SAASkrH,UAAUyD,WAAWzJ,OAAOt6E;;;;YAK7Co7E;YACA+I,WAAWrkF,UAAUl9B,QAAQ;YAC7Bs4G,MAAMp7E,UAAUo7E,OAAO;YACvBmC,YAAYv9E,UAAUu9E;;UAExBqF,WAAW5iF,UAAUnoC,WAAW;YAC9BysH,kBAAkBtkF,UAAUukF;eAEzBnoG,IAAI,GAAGA,IAAIkoG,gBAAgBzsH,QAAQukB;cACrC8nG,gBAAgBI,gBAAgBloG,GAAG04B;;aAEpCovE,iBAAiBA,cAAcrsH,WAAW;;YAE3CqsH,cAAc,GAAG75E;;gBAEdm6E;cACFzqH;eAECA,IAAI,GAAGA,IAAImqH,cAAcrsH,QAAQkC;gBACjCmqH,cAAcnqH,GAAGswC;uBACXx3B,IAAI,GAAGA,IAAIqxG,cAAcnqH,GAAGswC,aAAaxyC,QAAQgb;gBACzD2xG,iBAAiBN,cAAcnqH,GAAGswC,aAAax3B,OAAO;;;;;;;qBAQ9C4xG,mBAAmBD;kBACvBhK;kBACAt6E;qBAEGrtB,IAAI,GAAGA,MAAMqxG,cAAcnqH,GAAGswC,aAAaxyC,UAAUgb;oBACvD6xG,eAAeR,cAAcnqH;cACnCygH,MAAMllH,KAAKovH,aAAa5lH;cACxBohC,OAAO5qC,KAAKovH,aAAaf,gBAAgBc,kBAAkB,IAAI;;YAGhEnJ,OAAOhmH,SAASitH,oBAAoB,2BAA2BkC,kBAAkB,KAAKjK,OAAOt6E;;UAG9F0iF,WAAW4B,iBAAiB3sH,UAAUujH,OAAO;;;gBAGvCuJ,WAAW,YAAY15C,MAAM7uD,GAAGtZ,OAAO;UAC7CkhH,iBAAiBrB,qBAAqBgC,WAAW,aAAaT,eAAe,OAAO5I;UACpF0I,iBAAiBvB,yBAAyBkC,WAAW,eAAeT,eAAe,OAAO5I;UAC1F0I,iBAAiBrB,qBAAqBgC,WAAW,UAAUT,eAAe,OAAO5I;;;UAI/EA,OAAOzjH,WAAW;eACd;;YAGFwjH,WAAW,KAAKgJ,UAAUzB,UAAUtH,QAAQiC;aAC3ClC;;IAGRM;YACOL,SAAS,KAAKA;UAChBsH,WAAW;eAENhrH,IAAI,GAAGgb,IAAI0oG,OAAOzjH,QAAQD,MAAMgb,KAAKhb;cACvC2jH,QAAQ,KAAKD,OAAO1jH;QAC1BgrH,WAAWjmH,KAAKF,IAAImmH,UAAUrH,MAAMf,MAAMe,MAAMf,MAAM3iH,SAAS;;MAGhE,KAAK+qH,WAAWA;aACT;;IAGRrgD;eACU3qE,IAAI,GAAGA,IAAI,KAAK0jH,OAAOzjH,QAAQD;QACvC,KAAK0jH,OAAO1jH,GAAG2qE,KAAK,GAAG,KAAKqgD;;aAGtB;;IAGRtB;UACKC,QAAQ;eAEH3pH,IAAI,GAAGA,IAAI,KAAK0jH,OAAOzjH,QAAQD;QACvC2pH,QAAQA,SAAS,KAAKjG,OAAO1jH,GAAG0pH;;aAG1BC;;IAGRG;eACU9pH,IAAI,GAAGA,IAAI,KAAK0jH,OAAOzjH,QAAQD;QACvC,KAAK0jH,OAAO1jH,GAAG8pH;;aAGT;;IAGRtiH;YACOk8G;eAEG1jH,IAAI,GAAGA,IAAI,KAAK0jH,OAAOzjH,QAAQD;QACvC0jH,OAAOhmH,KAAK,KAAKgmH,OAAO1jH,GAAGwH;;iBAGjB,KAAKpC,YAAY,KAAK8F,MAAM,KAAK8/G,UAAUtH,QAAQ,KAAKiC;;IAGpEl9F;aACQ,KAAKrjB,YAAYqjB,OAAO;;;EAKjC,sCAAsCukG;YAC7BA,SAAS/4E;WACX;WACA;WACA;WACA;WACA;eACG02E;WAEH;WACA;WACA;WACA;eACGI;WAEH;eACGL;WAEH;eACGG;WAEH;WACA;eACGJ;WAEH;eACGK;;cAGC1/G,MAAM,gDAAgD4hH;;EAGjE,4BAA4BljB;QACvBA,KAAK9qG,SAASpB;gBACPwN,MAAM;;UAGXw9G,YAAYqE,6BAA6BnjB,KAAK9qG;QAEhD8qG,KAAK8Y,UAAUhlH;YACZglH,YACHt6E;MACH25E,eAAegB,YAAYnZ,KAAK5sD,MAAM0lE,OAAOt6E,QAAQ;MACrDwhE,KAAK8Y,QAAQA;MACb9Y,KAAKxhE,SAASA;;;QAIXsgF,UAAU7pH,UAAUnB;aAChBgrH,UAAU7pH,MAAM+qG;;;iBAGZ8e,UAAU9e,KAAK5+F,MAAM4+F,KAAK8Y,OAAO9Y,KAAKxhE,QAAQwhE,KAAKye;;;QAI1D2E;IACLrpE,SAAS;IACTspE;IACA9lH,KAAK,UAAUkhC,KAAK6kF;UACf,KAAKvpE,YAAY;;MAErB,KAAKspE,MAAM5kF,OAAO6kF;;IAEnB5jE,KAAK,UAAUjhB;UACV,KAAKsb,YAAY;;aAEd,KAAKspE,MAAM5kF;;IAEnB9mC,QAAQ,UAAU8mC;aACV,KAAK4kF,MAAM5kF;;IAEnBzoC,OAAO;MACN,KAAKqtH;;;EAIP;IACC/nH,YAAYioH,QAAQC,YAAYC;YACzB1tE,QAAQ;UACV2tE,YAAY;UACZC,cAAc;UACdC,aAAa;UACbC,cAAc/vH;YACZgwH;;;MAGN,KAAKC,UAAUjwH;MACf,KAAKyvH,SAASA;MACd,KAAKC,aAAaA;MAClB,KAAKC,UAAUA;MAEf,KAAKO,YAAY,UAAU7kG;QAC1BykG;YAEIF,cAAc;cACb3tE,MAAMguE,YAAYjwH;YACrBiiD,MAAMguE,QAAQ5kG,KAAKwkG,aAAaC;;;QAIlCF,YAAY;;MAGb,KAAKO,UAAU,UAAU9kG;QACxBwkG;YAEI5tE,MAAMytE,eAAe1vH;UACxBiiD,MAAMytE,WAAWrkG,KAAKwkG,aAAaC;;YAGhCD,gBAAgBC;UACnBF,YAAY;cAER3tE,MAAMwtE,WAAWzvH;YACpBiiD,MAAMwtE;;;;MAKT,KAAKW,YAAY,UAAU/kG;YACtB42B,MAAM0tE,YAAY3vH;UACrBiiD,MAAM0tE,QAAQtkG;;;MAIhB,KAAKglG,aAAa,UAAUhlG;YACvB0kG;iBACIA,YAAY1kG;;eAGbA;;MAGR,KAAKilG,iBAAiB,UAAU97B;QAC/Bu7B,cAAcv7B;eACP;;MAGR,KAAK+7B,aAAa,UAAUC,OAAOC;QAClCT,SAASlwH,KAAK0wH,OAAOC;eACd;;MAGR,KAAKC,gBAAgB,UAAUF;cACxBt0G,QAAQ8zG,SAAS1vH,QAAQkwH;YAE3Bt0G,WAAW;UACd8zG,SAAS7zG,OAAOD,OAAO;;eAGjB;;MAGR,KAAKy0G,aAAa,UAAUnB;iBAClBptH,IAAI,GAAGma,IAAIyzG,SAAS3tH,QAAQD,IAAIma,GAAGna,KAAK;gBAC1CouH,QAAQR,SAAS5tH;gBACjBquH,SAAST,SAAS5tH,IAAI;cACxBouH,MAAM7hH,QAAQ6hH,MAAMllD,YAAY;;cAEhCklD,MAAM1vH,KAAK0uH;mBACPiB;;;eAIF;;;;QAMJG,4BAA4BC;EAElC;IACCrpH,YAAYspH;MACX,KAAKA,UAAUA,YAAY9wH,YAAY8wH,UAAUF;MACjD,KAAKG,cAAc;MACnB,KAAKC,kBAAkB;MACvB,KAAK5lD,OAAO;MACZ,KAAK6lD,eAAe;MACpB,KAAKC;;IAGNC;;IAIAC,UAAU/lG,KAAKqkG;YACRztE,QAAQ;iBACHovE,QAAQ,UAAUC,SAASC;QACrCtvE,MAAMkvE,KAAK9lG,KAAKimG,SAAS5B,YAAY6B;;;IAIvCpwH;;IAIAqwH,eAAeT;MACd,KAAKA,cAAcA;aACZ;;IAGRU,mBAAmBxkH;MAClB,KAAK+jH,kBAAkB/jH;aAChB;;IAGRykH,QAAQtmD;MACP,KAAKA,OAAOA;aACL;;IAGRumD,gBAAgBV;MACf,KAAKA,eAAeA;aACb;;IAGRW,iBAAiBV;MAChB,KAAKA,gBAAgBA;aACd;;;QAKHW;EAEN,yBAAyBC;IACxBtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;UACzBtkG,QAAQrrB,WAAWqrB,MAAM;UACzB,KAAK+/C,SAASprE,WAAWqrB,MAAM,KAAK+/C,OAAO//C;MAC/CA,MAAM,KAAKylG,QAAQT,WAAWhlG;YACxB42B,QAAQ;YACRx7C,SAAS6oH,MAAM1jE,IAAIvgC;UAErB5kB,WAAWzG;QACdiiD,MAAM6uE,QAAQZ,UAAU7kG;QACxBzlB,WAAW;cACN6pH,QAAQA,OAAOhpH;UACnBw7C,MAAM6uE,QAAQX,QAAQ9kG;WACpB;eACI5kB;;;UAIJorH,QAAQxmG,SAASrrB;QACpB6xH,QAAQxmG,KAAKvrB;UACZ2vH,QAAQA;UACRC,YAAYA;UACZC,SAASA;;;;;YAMLoC,eAAe;YACfC,qBAAqB3mG,IAAIkgD,MAAMwmD;UACjCE;;UAEAD;cACGE,WAAWF,mBAAmB;cAC9BG,aAAaH,mBAAmB;YAClCxyH,OAAOwyH,mBAAmB;QAC9BxyH,OAAO4yH,mBAAmB5yH;YACtB2yH,UAAU3yH,OAAO6yH,KAAK7yH;;cAGrB8yH;gBACEC,gBAAgB,KAAKA,gBAAgB,IAAIl8E;kBAEvCk8E;iBACF;iBACA;oBACEttE,WAAWrL,WAAWp6C,KAAK6C;uBAExBD,IAAI,GAAGA,IAAI5C,KAAK6C,QAAQD;gBAChC6iD,KAAK7iD,KAAK5C,KAAKgzH,WAAWpwH;;kBAGvBmwH,iBAAiB;gBACpBD,eAAeG,MAAMxtE,KAAK1K;kBACzBn5C,MAAM8wH;;;gBAGPI,WAAWrtE,KAAK1K;;;iBAKb;oBACEm4E,aAAaC;cACnBL,WAAWI,OAAOE,gBAAgBpzH,MAAM0yH;;iBAGpC;cACJI,WAAWpxH,KAAKC,MAAM3B;;;;cAKtB8yH,WAAW9yH;;;;UAKboG,WAAW;gBACN6pH,QAAQA,OAAO6C;YACnBrwE,MAAM6uE,QAAQX,QAAQ9kG;aACpB;iBACKvoB;;UAER8C,WAAW;gBACN+pH,SAASA,QAAQ7sH;YACrBm/C,MAAM6uE,QAAQV,UAAU/kG;YACxB42B,MAAM6uE,QAAQX,QAAQ9kG;aACpB;;;;QAIJwmG,QAAQxmG;QACRwmG,QAAQxmG,KAAKvrB;UACZ2vH,QAAQA;UACRC,YAAYA;UACZC,SAASA;;QAEVsC,cAAcY;QACdZ,QAAQa,KAAK,OAAOznG,KAAK;QACzB4mG,QAAQllH,iBAAiB,QAAQ,UAAU9L;gBACpCqxH,WAAW,KAAKA;gBAChBS,YAAYlB,QAAQxmG;iBACnBwmG,QAAQxmG;cAEX,KAAKshD,WAAW,OAAO,KAAKA,WAAW;;;gBAGtC,KAAKA,WAAW,GAAG1qE,QAAQ0B,KAAK;;;YAGpC2rH,MAAM7lH,IAAI4hB,KAAKinG;qBAENlwH,IAAI,GAAGksB,KAAKykG,UAAU1wH,QAAQD,IAAIksB,IAAIlsB;oBACxC+wB,WAAW4/F,UAAU3wH;kBACvB+wB,SAASs8F,QAAQt8F,SAASs8F,OAAO6C;;YAGtCrwE,MAAM6uE,QAAQX,QAAQ9kG;;qBAEbjpB,IAAI,GAAGksB,KAAKykG,UAAU1wH,QAAQD,IAAIksB,IAAIlsB;oBACxC+wB,WAAW4/F,UAAU3wH;kBACvB+wB,SAASw8F,SAASx8F,SAASw8F,QAAQ1uH;;YAGxCghD,MAAM6uE,QAAQV,UAAU/kG;YACxB42B,MAAM6uE,QAAQX,QAAQ9kG;;WAErB;QACH4mG,QAAQllH,iBAAiB,YAAY,UAAU9L;gBACxC8xH,YAAYlB,QAAQxmG;mBAEjBjpB,IAAI,GAAGksB,KAAKykG,UAAU1wH,QAAQD,IAAIksB,IAAIlsB;kBACxC+wB,WAAW4/F,UAAU3wH;gBACvB+wB,SAASu8F,YAAYv8F,SAASu8F,WAAWzuH;;WAE5C;QACHgxH,QAAQllH,iBAAiB,SAAS,UAAU9L;gBACrC8xH,YAAYlB,QAAQxmG;iBACnBwmG,QAAQxmG;mBAENjpB,IAAI,GAAGksB,KAAKykG,UAAU1wH,QAAQD,IAAIksB,IAAIlsB;kBACxC+wB,WAAW4/F,UAAU3wH;gBACvB+wB,SAASw8F,SAASx8F,SAASw8F,QAAQ1uH;;UAGxCghD,MAAM6uE,QAAQV,UAAU/kG;UACxB42B,MAAM6uE,QAAQX,QAAQ9kG;WACpB;QACH4mG,QAAQllH,iBAAiB,SAAS,UAAU9L;gBACrC8xH,YAAYlB,QAAQxmG;iBACnBwmG,QAAQxmG;mBAENjpB,IAAI,GAAGksB,KAAKykG,UAAU1wH,QAAQD,IAAIksB,IAAIlsB;kBACxC+wB,WAAW4/F,UAAU3wH;gBACvB+wB,SAASw8F,SAASx8F,SAASw8F,QAAQ1uH;;UAGxCghD,MAAM6uE,QAAQV,UAAU/kG;UACxB42B,MAAM6uE,QAAQX,QAAQ9kG;WACpB;YACC,KAAKknG,iBAAiBvyH,WAAWiyH,QAAQM,eAAe,KAAKA;YAC7D,KAAKvB,oBAAoBhxH,WAAWiyH,QAAQjB,kBAAkB,KAAKA;YACnEiB,QAAQe,kBAAkBf,QAAQe,iBAAiB,KAAKd,aAAalyH,YAAY,KAAKkyH,WAAW;mBAE1Fe,UAAU,KAAK/B;UACzBe,QAAQL,iBAAiBqB,QAAQ,KAAK/B,cAAc+B;;QAGrDhB,QAAQiB,KAAK;;MAGdjxE,MAAM6uE,QAAQZ,UAAU7kG;aACjB4mG;;IAGRkB,gBAAgBlmH;MACf,KAAKslH,eAAetlH;aACb;;IAGRmmH,YAAYnmH;MACX,KAAKilH,WAAWjlH;aACT;;;EAKT,8BAA8B6kH;IAC7BtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRwuE,aAAa4C,WAAW,KAAKvC;MACnCL,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAOmB,iBAAiB,KAAKV;MAC7BT,OAAOgB,mBAAmB,KAAKT;MAC/BP,OAAOU,KAAK9lG,KAAK,UAAUy0F;;UAEzB2P,OAAOxtE,MAAM9gD,MAAMD,KAAKC,MAAM2+G;iBACtBr8G;cACJksH;YACHA,QAAQlsH;;YAERxB,QAAQa,MAAMW;;UAGfw+C,MAAM6uE,QAAQV,UAAU/kG;;SAEvBqkG,YAAYC;;IAGhBxuH,MAAM+qG;YACCtlE;eAEGxkC,IAAI,GAAGA,IAAI8pG,KAAK7pG,QAAQD;cAC1ByjH,OAAOyN,cAAcnyH,MAAM+qG,KAAK9pG;QACtCwkC,WAAW9mC,KAAK+lH;;aAGVj/E;;;;;;;;EAWT,sCAAsCkrF;IACrCtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACR72B;YACA0C,cAAcshF;YACdqhB,aAAa4C,WAAW,KAAKvC;MACnCL,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAO0C,gBAAgB;MACvB1C,OAAOmB,iBAAiB,KAAKV;MAC7BT,OAAOgB,mBAAmBxvE,MAAM+uE;UAC5BuC,SAAS;MAEb,qBAAqBnxH;QACpBquH,OAAOU,KAAK9lG,IAAIjpB,IAAI,UAAUm4C;gBACvBi5E,WAAWvxE,MAAM9gD,MAAMo5C,QAAQ;UACrCnvB,OAAOhpB;YACNue,OAAO6yG,SAAS7yG;YAChBC,QAAQ4yG,SAAS5yG;YACjBiJ,QAAQ2pG,SAAS3pG;YACjBI,SAASupG,SAASvpG;;UAEnBspG,UAAU;cAENA,WAAW;gBACVC,SAASC,gBAAgB,GAAG3lG,QAAQlE,YAAY5V;YACpD8Z,QAAQtF,QAAQ4C;YAChB0C,QAAQjE,SAAS2pG,SAAS3pG;YAC1BiE,QAAQpC,cAAc;gBAClB+jG,QAAQA,OAAO3hG;;WAElB4hG,YAAYC;;UAGZjrH,MAAMC,QAAQ0mB;iBACRjpB,IAAI,GAAGksB,KAAKjD,IAAIhpB,QAAQD,IAAIksB,MAAMlsB;UAC1CsxH,YAAYtxH;;;;QAIbquH,OAAOU,KAAK9lG,KAAK,UAAUkvB;gBACpBi5E,WAAWvxE,MAAM9gD,MAAMo5C,QAAQ;cAEjCi5E,SAASG;kBACNzb,QAAQsb,SAASvpG,QAAQ5nB,SAASmxH,SAASC;qBAExC3pH,IAAI,GAAGA,IAAIouG,OAAOpuG;cAC1BshB,OAAOthB;gBACNmgB;;uBAGQ7nB,IAAI,GAAGA,IAAIoxH,SAASC,aAAarxH;gBACzCgpB,OAAOthB,GAAGmgB,QAAQnqB,KAAK0zH,SAASvpG,QAAQngB,IAAI0pH,SAASC,cAAcrxH;gBACnEgpB,OAAOthB,GAAG+f,SAAS2pG,SAAS3pG;gBAC5BuB,OAAOthB,GAAG6W,QAAQ6yG,SAAS7yG;gBAC3ByK,OAAOthB,GAAG8W,SAAS4yG,SAAS5yG;;;YAI9BkN,QAAQtF,QAAQ4C;;YAEhB0C,QAAQtF,MAAM7H,QAAQ6yG,SAAS7yG;YAC/BmN,QAAQtF,MAAM5H,SAAS4yG,SAAS5yG;YAChCkN,QAAQ7D,UAAUupG,SAASvpG;;cAGxBupG,SAASC,gBAAgB;YAC5B3lG,QAAQlE,YAAY5V;;UAGrB8Z,QAAQjE,SAAS2pG,SAAS3pG;UAC1BiE,QAAQpC,cAAc;cAClB+jG,QAAQA,OAAO3hG;WACjB4hG,YAAYC;;aAGT7hG;;;EAKT,0BAA0BgkG;IACzBtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;UACzB,KAAKvkD,SAASprE,WAAWqrB,MAAM,KAAK+/C,OAAO//C;MAC/CA,MAAM,KAAKylG,QAAQT,WAAWhlG;YACxB42B,QAAQ;YACRx7C,SAAS6oH,MAAM1jE,IAAIvgC;UAErB5kB,WAAWzG;QACdiiD,MAAM6uE,QAAQZ,UAAU7kG;QACxBzlB,WAAW;cACN6pH,QAAQA,OAAOhpH;UACnBw7C,MAAM6uE,QAAQX,QAAQ9kG;WACpB;eACI5kB;;YAGF+hB,QAAQnlB,SAASulB,gBAAgB,gCAAgC;MAEvE;QACCJ,MAAMxM,oBAAoB,QAAQ43G,aAAa;QAC/CprG,MAAMxM,oBAAoB,SAAS63G,cAAc;QACjDvE,MAAM7lH,IAAI4hB,KAAK;YACXokG,QAAQA,OAAO;QACnBxtE,MAAM6uE,QAAQX,QAAQ9kG;;MAGvB,sBAAsBpqB;QACrBunB,MAAMxM,oBAAoB,QAAQ43G,aAAa;QAC/CprG,MAAMxM,oBAAoB,SAAS63G,cAAc;YAC7ClE,SAASA,QAAQ1uH;QACrBghD,MAAM6uE,QAAQV,UAAU/kG;QACxB42B,MAAM6uE,QAAQX,QAAQ9kG;;MAGvB7C,MAAMzb,iBAAiB,QAAQ6mH,aAAa;MAC5CprG,MAAMzb,iBAAiB,SAAS8mH,cAAc;UAE1CxoG,IAAIyoG,OAAO,GAAG,OAAO;YACpB,KAAK/C,gBAAgB/wH,WAAWwoB,MAAMuoG,cAAc,KAAKA;;MAG9D9uE,MAAM6uE,QAAQZ,UAAU7kG;MACxB7C,MAAMC,MAAM4C;aACL7C;;;EAKT,gCAAgCspG;IAC/BtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK4C,MAAMtE,QAAQC,YAAYC;YACxB7hG,cAAcy5B;YACdkpE,aAAauD,YAAY,KAAKlD;MACpCL,OAAOe,eAAe,KAAKT;MAC3BN,OAAOiB,QAAQ,KAAKtmD;UAChBmoD,SAAS;MAEb,qBAAqBnxH;QACpBquH,OAAOU,KAAK4C,KAAK3xH,IAAI,UAAUomB;UAC9BsF,QAAQ1C,OAAOhpB,KAAKomB;UACpB+qG;cAEIA,WAAW;YACdzlG,QAAQpC,cAAc;gBAClB+jG,QAAQA,OAAO3hG;;WAElB9tB,WAAW2vH;;eAGNvtH,IAAI,GAAGA,IAAI2xH,KAAK1xH,UAAUD;QAClCsxH,YAAYtxH;;aAGN0rB;;;;;;;;EAWT,gCAAgCgkG;IAC/BtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRn0B,cAAc29E;YACdglB,aAAa4C,WAAW,KAAKvC;MACnCL,OAAO0C,gBAAgB;MACvB1C,OAAOmB,iBAAiB,KAAKV;MAC7BT,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAOgB,mBAAmBxvE,MAAM+uE;MAChCP,OAAOU,KAAK9lG,KAAK,UAAUkvB;cACpB05E,UAAUhyE,MAAM9gD,MAAMo5C;aACvB05E;YAEDA,QAAQzrG,UAAUxoB;UACrB8tB,QAAQtF,QAAQyrG,QAAQzrG;mBACdyrG,QAAQz0H,SAASQ;UAC3B8tB,QAAQtF,MAAM7H,QAAQszG,QAAQtzG;UAC9BmN,QAAQtF,MAAM5H,SAASqzG,QAAQrzG;UAC/BkN,QAAQtF,MAAMhpB,OAAOy0H,QAAQz0H;;QAG9BsuB,QAAQrE,QAAQwqG,QAAQxqG,UAAUzpB,YAAYi0H,QAAQxqG,QAAQhW;QAC9Dqa,QAAQpE,QAAQuqG,QAAQvqG,UAAU1pB,YAAYi0H,QAAQvqG,QAAQjW;QAC9Dqa,QAAQnE,YAAYsqG,QAAQtqG,cAAc3pB,YAAYi0H,QAAQtqG,YAAY3V;QAC1E8Z,QAAQlE,YAAYqqG,QAAQrqG,cAAc5pB,YAAYi0H,QAAQrqG,YAAY5V;QAC1E8Z,QAAQhE,aAAamqG,QAAQnqG,eAAe9pB,YAAYi0H,QAAQnqG,aAAa;YAEzEmqG,QAAQlqG,aAAa/pB;UACxB8tB,QAAQ/D,WAAWkqG,QAAQlqG;;YAGxBkqG,QAAQ1pG,UAAUvqB;UACrB8tB,QAAQvD,QAAQ0pG,QAAQ1pG;;YAGrB0pG,QAAQpqG,WAAW7pB;UACtB8tB,QAAQjE,SAASoqG,QAAQpqG;;YAGtBoqG,QAAQ7yH,SAASpB;UACpB8tB,QAAQ1sB,OAAO6yH,QAAQ7yH;;YAGpB6yH,QAAQhqG,YAAYjqB;UACvB8tB,QAAQ7D,UAAUgqG,QAAQhqG;UAC1B6D,QAAQlE,YAAYzV;;YAGjB8/G,QAAQR,gBAAgB;UAC3B3lG,QAAQlE,YAAY5V;;YAGjBigH,QAAQ5pG,oBAAoBrqB;UAC/B8tB,QAAQzD,kBAAkB4pG,QAAQ5pG;;QAGnCyD,QAAQpC,cAAc;YAClB+jG,QAAQA,OAAO3hG,SAASmmG;SAC1BvE,YAAYC;aACR7hG;;;EAKT,4BAA4BgkG;IAC3BtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB7hG,cAAczE;YACdonG,aAAauD,YAAY,KAAKlD;MACpCL,OAAOe,eAAe,KAAKT;MAC3BN,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAOU,KAAK9lG,KAAK,UAAU7C;QAC1BsF,QAAQtF,QAAQA;;cAEV0rG,SAAS7oG,IAAI8oG,OAAO,oBAAoB,KAAK9oG,IAAI8oG,OAAO,0BAA0B;QACxFrmG,QAAQjE,SAASqqG,SAASh/G,YAAYC;QACtC2Y,QAAQpC,cAAc;YAElB+jG,WAAWzvH;UACdyvH,OAAO3hG;;SAEN4hG,YAAYC;aACR7hG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmCT;IACCtmB;MACC,KAAKpG,OAAO;MACZ,KAAKgzH,qBAAqB;;;;IAK3BC;;MAGCpyH,QAAQ0B,KAAK;aACN;;;;IAKR09G,WAAW9zE,GAAG+mF;YACP52G,IAAI,KAAK62G,eAAehnF;aACvB,KAAK8mF,SAAS32G,GAAG42G;;;IAIzBE,UAAUC,YAAY;YACf19F;eAEGvyB,IAAI,GAAGA,KAAKiwH,WAAWjwH;QAC/BuyB,OAAOj3B,KAAK,KAAKu0H,SAAS7vH,IAAIiwH;;aAGxB19F;;;IAIR2iF,gBAAgB+a,YAAY;YACrB19F;eAEGvyB,IAAI,GAAGA,KAAKiwH,WAAWjwH;QAC/BuyB,OAAOj3B,KAAK,KAAKuhH,WAAW78G,IAAIiwH;;aAG1B19F;;;IAIR29F;YACOC,UAAU,KAAKC;aACdD,QAAQA,QAAQtyH,SAAS;;;IAIjCuyH,WAAWH,YAAY,KAAKL;UACvB,KAAKS,mBAAmB,KAAKA,gBAAgBxyH,WAAWoyH,YAAY,MAAM,KAAK/oG;eAC3E,KAAKmpG;;MAGb,KAAKnpG,cAAc;YACbhlB;UACFouH,SACFhhB,OAAO,KAAKugB,SAAS;UACnB1c,MAAM;MACVjxG,MAAM5G,KAAK;eAEFoyB,IAAI,GAAGA,KAAKuiG,WAAWviG;QAC/B4iG,UAAU,KAAKT,SAASniG,IAAIuiG;QAC5B9c,OAAOmd,QAAQxpH,WAAWwoG;QAC1BptG,MAAM5G,KAAK63G;QACX7D,OAAOghB;;MAGR,KAAKD,kBAAkBnuH;aAChBA;;IAGRquH;MACC,KAAKrpG,cAAc;MACnB,KAAKkpG;;;IAINL,eAAehnF,GAAGrhC;YACX8oH,aAAa,KAAKJ;UACpBxyH,IAAI;YACFksB,KAAK0mG,WAAW3yH;UAClB4yH;;UAEA/oH;QACH+oH,kBAAkB/oH;;QAElB+oH,kBAAkB1nF,IAAIynF,WAAW1mG,KAAK;;;UAInCrQ,MAAM,GACRC,OAAOoQ,KAAK,GACZ4mG;aAEKj3G,OAAOC;QACb9b,IAAI+E,KAAKC,MAAM6W,OAAOC,OAAOD,OAAO;;QAEpCi3G,aAAaF,WAAW5yH,KAAK6yH;YAEzBC,aAAa;UAChBj3G,MAAM7b,IAAI;mBACA8yH,aAAa;UACvBh3G,OAAO9b,IAAI;;UAEX8b,OAAO9b;;;;MAKTA,IAAI8b;UAEA82G,WAAW5yH,OAAO6yH;eACd7yH,KAAKksB,KAAK;;;YAIZ6mG,eAAeH,WAAW5yH;YAC1BgzH,cAAcJ,WAAW5yH,IAAI;YAC7BizH,gBAAgBD,cAAcD;;YAE9BG,mBAAmBL,kBAAkBE,gBAAgBE;;YAErD33G,KAAKtb,IAAIkzH,oBAAoBhnG,KAAK;aACjC5Q;;;;;;IAOR63G,WAAW73G,GAAG42G;YACP9oF,QAAQ;UACVrO,KAAKzf,IAAI8tB;UACTgqF,KAAK93G,IAAI8tB;;UAETrO,KAAK,GAAGA,KAAK;UACbq4F,KAAK,GAAGA,KAAK;YACXC,MAAM,KAAKpB,SAASl3F;YACpBu4F,MAAM,KAAKrB,SAASmB;YACpB15E,UAAUw4E,mBAAmBmB,IAAIzxG,gBAAgBF,gBAAgBlc;MACvEk0C,QAAQ36B,KAAKu0G,KAAKl0G,IAAIi0G,KAAKjqH;aACpBswC;;IAGR65E,aAAapoF,GAAG+mF;YACT52G,IAAI,KAAK62G,eAAehnF;aACvB,KAAKgoF,WAAW73G,GAAG42G;;IAG3B3a,oBAAoBnK,UAAUuR;;YAEvBtrF,aAAa7tB;YACbi1C;YACAH;YACAw/D;YACAhC,UAAUtyG;YACVguH,UAAU72F;;eAEP38B,IAAI,GAAGA,KAAKotG,UAAUptG;cACxBmrC,IAAInrC,IAAIotG;QACd3yD,SAASz6C,KAAK,KAAKuzH,aAAapoF,OAAO3lC;QACvCi1C,SAASz6C,GAAGoJ;;;;MAKbkxC,QAAQ,SAAS90C;MACjBs0G,UAAU,SAASt0G;UACfV,MAAMopB,OAAOulG;YACXnuG,KAAKvgB,KAAK4W,IAAI8+B,SAAS,GAAG7zC;YAC1B2e,KAAKxgB,KAAK4W,IAAI8+B,SAAS,GAAG1zC;YAC1B2sH,KAAK3uH,KAAK4W,IAAI8+B,SAAS,GAAGzzC;UAE5Bse,MAAMxgB;QACTA,MAAMwgB;QACN+N,OAAOlnB,IAAI,GAAG,GAAG;;UAGdoZ,MAAMzgB;QACTA,MAAMygB;QACN8N,OAAOlnB,IAAI,GAAG,GAAG;;UAGdunH,MAAM5uH;QACTuuB,OAAOlnB,IAAI,GAAG,GAAG;;MAGlB2rG,IAAItlF,aAAaioB,SAAS,IAAIpnB,QAAQjqB;MACtCkxC,QAAQ,GAAG9nB,aAAaioB,SAAS,IAAIq9D;MACrCgC,UAAU,GAAGtnF,aAAaioB,SAAS,IAAIH,QAAQ;;eAEtCt6C,IAAI,GAAGA,KAAKotG,UAAUptG;QAC9Bs6C,QAAQt6C,KAAKs6C,QAAQt6C,IAAI,GAAGwH;QAC5BsyG,UAAU95G,KAAK85G,UAAU95G,IAAI,GAAGwH;QAChCswG,IAAItlF,aAAaioB,SAASz6C,IAAI,IAAIy6C,SAASz6C;YAEvC83G,IAAI73G,WAAWiuB,OAAOC;UACzB2pF,IAAI1uG;gBACE3C,QAAQ1B,KAAKglB,KAAKxM,MAAMk9B,SAASz6C,IAAI,GAAGggB,IAAIy6B,SAASz6C,MAAM,GAAG;;UAEpEs6C,QAAQt6C,GAAG6pB,aAAa2pG,IAAI5zF,iBAAiBk4E,KAAKrxG;;QAGnDqzG,UAAU95G,GAAGwyB,aAAaioB,SAASz6C,IAAIs6C,QAAQt6C;;;UAI5C2+G,WAAW;YACVl4G,QAAQ1B,KAAKglB,KAAKxM,MAAM+8B,QAAQ,GAAGt6B,IAAIs6B,QAAQ8yD,aAAa,GAAG;QACnE3mG,SAAS2mG;YAEL3yD,SAAS,GAAGz6B,IAAI83F,IAAItlF,aAAa8nB,QAAQ,IAAIA,QAAQ8yD,cAAc;UACtE3mG,SAASA;;iBAGDzG,IAAI,GAAGA,KAAKotG,UAAUptG;;UAE9Bs6C,QAAQt6C,GAAG6pB,aAAa2pG,IAAI5zF,iBAAiB6a,SAASz6C,IAAIyG,QAAQzG;UAClE85G,UAAU95G,GAAGwyB,aAAaioB,SAASz6C,IAAIs6C,QAAQt6C;;;;QAKhDy6C,UAAUA;QACVH,SAASA;QACTw/D,WAAWA;;;IAIbtyG;iBACY,KAAKpC,cAAc2Z,KAAK;;IAGpCA,KAAKyJ;MACJ,KAAKwpG,qBAAqBxpG,OAAOwpG;aAC1B;;IAGRvpG;YACOrrB;QACLyrB;UACCR,SAAS;UACTrpB,MAAM;UACN8pB,WAAW;;;MAGb1rB,KAAK40H,qBAAqB,KAAKA;MAC/B50H,KAAK4B,OAAO,KAAKA;aACV5B;;IAGRysG,SAASC;MACR,KAAKkoB,qBAAqBloB,KAAKkoB;aACxB;;;EAKT,2BAA2B2B;IAC1BvuH,YAAYwuH,KAAK,GAAGC,KAAK,GAAGC,UAAU,GAAGC,UAAU,GAAGC,cAAc,GAAGC,YAAYlvH,KAAKyV,KAAK,GAAG05G,aAAa,OAAOC,YAAY;MAC/H;MACA,KAAKn1H,OAAO;MACZ,KAAK40H,KAAKA;MACV,KAAKC,KAAKA;MACV,KAAKC,UAAUA;MACf,KAAKC,UAAUA;MACf,KAAKC,cAAcA;MACnB,KAAKC,YAAYA;MACjB,KAAKC,aAAaA;MAClB,KAAKC,YAAYA;;IAGlBlC,SAAS32G,GAAG42G;YACL18F,QAAQ08F,sBAAsBxwG;YAC9B0yG,QAAQrvH,KAAKyV,KAAK;UACpB65G,aAAa,KAAKJ,YAAY,KAAKD;YACjCM,aAAavvH,KAAK4W,IAAI04G,cAAcnmG,OAAOC;;aAE1CkmG,aAAa,GAAGA,cAAcD;aAE9BC,aAAaD,OAAOC,cAAcD;UAErCC,aAAanmG,OAAOC;YACnBmmG;UACHD,aAAa;;UAEbA,aAAaD;;;UAIX,KAAKF,eAAe,SAASI;YAC5BD,eAAeD;UAClBC,cAAcD;;UAEdC,aAAaA,aAAaD;;;YAItB/zG,QAAQ,KAAK2zG,cAAc14G,IAAI+4G;UACjCztH,IAAI,KAAKgtH,KAAK,KAAKE,UAAU/uH,KAAK+B,IAAIuZ;UACtCtZ,IAAI,KAAK8sH,KAAK,KAAKE,UAAUhvH,KAAK8B,IAAIwZ;UAEtC,KAAK8zG,cAAc;cAChBrtH,MAAM/B,KAAK+B,IAAI,KAAKqtH;cACpBttH,MAAM9B,KAAK8B,IAAI,KAAKstH;cACpB7uG,KAAK1e,IAAI,KAAKgtH;cACdruG,KAAKxe,IAAI,KAAK8sH;;QAEpBjtH,IAAI0e,KAAKxe,MAAMye,KAAK1e,MAAM,KAAK+sH;QAC/B7sH,IAAIue,KAAKze,MAAM0e,KAAKze,MAAM,KAAK+sH;;aAGzBr+F,MAAMrpB,IAAIvF,GAAGG;;IAGrBgY,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKorG,KAAKprG,OAAOorG;MACjB,KAAKC,KAAKrrG,OAAOqrG;MACjB,KAAKC,UAAUtrG,OAAOsrG;MACtB,KAAKC,UAAUvrG,OAAOurG;MACtB,KAAKC,cAAcxrG,OAAOwrG;MAC1B,KAAKC,YAAYzrG,OAAOyrG;MACxB,KAAKC,aAAa1rG,OAAO0rG;MACzB,KAAKC,YAAY3rG,OAAO2rG;aACjB;;IAGR1rG;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAKw2H,KAAK,KAAKA;MACfx2H,KAAKy2H,KAAK,KAAKA;MACfz2H,KAAK02H,UAAU,KAAKA;MACpB12H,KAAK22H,UAAU,KAAKA;MACpB32H,KAAK42H,cAAc,KAAKA;MACxB52H,KAAK62H,YAAY,KAAKA;MACtB72H,KAAK82H,aAAa,KAAKA;MACvB92H,KAAK+2H,YAAY,KAAKA;aACf/2H;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAK8pB,KAAK9pB,KAAK8pB;MACf,KAAKC,KAAK/pB,KAAK+pB;MACf,KAAKC,UAAUhqB,KAAKgqB;MACpB,KAAKC,UAAUjqB,KAAKiqB;MACpB,KAAKC,cAAclqB,KAAKkqB;MACxB,KAAKC,YAAYnqB,KAAKmqB;MACtB,KAAKC,aAAapqB,KAAKoqB;MACvB,KAAKC,YAAYrqB,KAAKqqB;aACf;;;EAKTI,aAAa5yG,UAAU6yG,iBAAiB;EAExC,uBAAuBD;IACtBnvH,YAAYwuH,IAAIC,IAAIY,SAAST,aAAaC,WAAWC;MACpD,MAAMN,IAAIC,IAAIY,SAASA,SAAST,aAAaC,WAAWC;MACxD,KAAKl1H,OAAO;;;EAKd01H,SAAS/yG,UAAUgzG,aAAa;;;;;;;;;;;;;;;;;;EAqBhC;QACKC,KAAK,GACP9lG,KAAK,GACLpS,KAAK,GACLqS,KAAK;;;;;;;;;IAUP,cAAcvB,IAAII,IAAIkN,IAAIC;MACzB65F,KAAKpnG;MACLsB,KAAKgM;MACLpe,MAAM,IAAI8Q,KAAK,IAAII,KAAK,IAAIkN,KAAKC;MACjChM,KAAK,IAAIvB,KAAK,IAAII,KAAKkN,KAAKC;;;MAI5B85F,gBAAgB,UAAUrnG,IAAII,IAAIsS,IAAI40F,IAAIC;QACzCz1D,KAAK1xC,IAAIsS,IAAI60F,WAAW70F,KAAK1S,KAAKunG,WAAWD,KAAKlnG;;MAEnDonG,0BAA0B,UAAUxnG,IAAII,IAAIsS,IAAI40F,IAAIG,KAAKC,KAAKC;;YAEzDp6F,MAAMnN,KAAKJ,MAAMynG,OAAO/0F,KAAK1S,OAAOynG,MAAMC,QAAQh1F,KAAKtS,MAAMsnG;YAC7D9B,MAAMlzF,KAAKtS,MAAMsnG,OAAOJ,KAAKlnG,OAAOsnG,MAAMC,QAAQL,KAAK50F,MAAMi1F;;QAEjEp6F,MAAMm6F;QACN9B,MAAM8B;QACN51D,KAAK1xC,IAAIsS,IAAInF,IAAIq4F;;MAElBgC,MAAM,UAAU95G;cACT83G,KAAK93G,IAAIA;cACT+5G,KAAKjC,KAAK93G;eACTs5G,KAAK9lG,KAAKxT,IAAIoB,KAAK02G,KAAKrkG,KAAKsmG;;;;;QAMjCrwG,UAAUxf;QACV+uG,SAAS+gB,aACZ9gB,SAAS8gB,aACTC,SAASD;EAEZ,+BAA+B3B;IAC9BvuH,YAAYuvB,aAAagqF,SAAS,OAAO6W,YAAY,eAAeT,UAAU;MAC7E;MACA,KAAK/1H,OAAO;MACZ,KAAK21B,SAASA;MACd,KAAKgqF,SAASA;MACd,KAAK6W,YAAYA;MACjB,KAAKT,UAAUA;;IAGhB9C,SAAS32G,GAAG42G,qBAAqB1sH;YAC1BgwB,QAAQ08F;YACRv9F,SAAS,KAAKA;YACdxa,IAAIwa,OAAO10B;YACX6vB,KAAK3V,KAAK,KAAKwkG,SAAS,IAAI,MAAMrjG;UACpCm6G,WAAW1wH,KAAKC,MAAM8qB;UACtBi5E,SAASj5E,IAAI2lG;UAEb,KAAK9W;QACR8W,YAAYA,WAAW,IAAI,KAAK1wH,KAAKC,MAAMD,KAAK4W,IAAI85G,YAAYt7G,KAAK,KAAKA;iBAChE4uF,WAAW,KAAK0sB,aAAat7G,IAAI;QAC3Cs7G,WAAWt7G,IAAI;QACf4uF,SAAS;;UAGN3wE,IAAIiT;;UAEJ,KAAKszE,UAAU8W,WAAW;QAC7Br9F,KAAKzD,QAAQ8gG,WAAW,KAAKt7G;;;QAG7B6K,IAAI3b,WAAWsrB,OAAO,IAAIA,OAAO,IAAIttB,IAAIstB,OAAO;QAChDyD,KAAKpT;;YAGAqT,KAAK1D,OAAO8gG,WAAWt7G;YACvBme,KAAK3D,QAAQ8gG,WAAW,KAAKt7G;UAE/B,KAAKwkG,UAAU8W,WAAW,IAAIt7G;QACjCkxB,KAAK1W,QAAQ8gG,WAAW,KAAKt7G;;;QAG7B6K,IAAI3b,WAAWsrB,OAAOxa,IAAI,IAAIwa,OAAOxa,IAAI,IAAI9S,IAAIstB,OAAOxa,IAAI;QAC5DkxB,KAAKrmB;;UAGF,KAAKwwG,cAAc,iBAAiB,KAAKA,cAAc;;cAEpDzrH,MAAM,KAAKyrH,cAAc,YAAY,MAAM;YAC7CP,MAAMlwH,KAAKgF,IAAIquB,GAAG7X,kBAAkB8X,KAAKtuB;YACzCmrH,MAAMnwH,KAAKgF,IAAIsuB,GAAG9X,kBAAkB+X,KAAKvuB;YACzCorH,MAAMpwH,KAAKgF,IAAIuuB,GAAG/X,kBAAkB8qB,KAAKthC;;YAEzCmrH,MAAM,MAAMA,MAAM;YAClBD,MAAM,MAAMA,MAAMC;YAClBC,MAAM,MAAMA,MAAMD;QACtB3gB,GAAGygB,yBAAyB58F,GAAGxxB,GAAGyxB,GAAGzxB,GAAG0xB,GAAG1xB,GAAGykC,GAAGzkC,GAAGquH,KAAKC,KAAKC;QAC9D3gB,GAAGwgB,yBAAyB58F,GAAGrxB,GAAGsxB,GAAGtxB,GAAGuxB,GAAGvxB,GAAGskC,GAAGtkC,GAAGkuH,KAAKC,KAAKC;QAC9DI,GAAGP,yBAAyB58F,GAAGpxB,GAAGqxB,GAAGrxB,GAAGsxB,GAAGtxB,GAAGqkC,GAAGrkC,GAAGiuH,KAAKC,KAAKC;iBACpD,KAAKK,cAAc;QAC7BjhB,GAAGsgB,eAAez8F,GAAGxxB,GAAGyxB,GAAGzxB,GAAG0xB,GAAG1xB,GAAGykC,GAAGzkC,GAAG,KAAKmuH;QAC/CvgB,GAAGqgB,eAAez8F,GAAGrxB,GAAGsxB,GAAGtxB,GAAGuxB,GAAGvxB,GAAGskC,GAAGtkC,GAAG,KAAKguH;QAC/CQ,GAAGV,eAAez8F,GAAGpxB,GAAGqxB,GAAGrxB,GAAGsxB,GAAGtxB,GAAGqkC,GAAGrkC,GAAG,KAAK+tH;;MAGhDv/F,MAAMrpB,IAAIooG,GAAG6gB,KAAKrsB,SAASyL,GAAG4gB,KAAKrsB,SAASwsB,GAAGH,KAAKrsB;aAC7CvzE;;IAGRzW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKmM;eAEI30B,IAAI,GAAGma,IAAIqO,OAAOmM,OAAO10B,QAAQD,IAAIma,GAAGna;cAC1Cw1B,QAAQhN,OAAOmM,OAAO30B;QAC5B,KAAK20B,OAAOj3B,KAAK83B,MAAMhuB;;MAGxB,KAAKm3G,SAASn2F,OAAOm2F;MACrB,KAAK6W,YAAYhtG,OAAOgtG;MACxB,KAAKT,UAAUvsG,OAAOusG;aACf;;IAGRtsG;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAKu3B;eAEI30B,IAAI,GAAGma,IAAI,KAAKwa,OAAO10B,QAAQD,IAAIma,GAAGna;cACxCw1B,QAAQ,KAAKb,OAAO30B;QAC1B5C,KAAKu3B,OAAOj3B,KAAK83B,MAAMrU;;MAGxB/jB,KAAKuhH,SAAS,KAAKA;MACnBvhH,KAAKo4H,YAAY,KAAKA;MACtBp4H,KAAK23H,UAAU,KAAKA;aACb33H;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKn1E;eAEI30B,IAAI,GAAGma,IAAI2vF,KAAKn1E,OAAO10B,QAAQD,IAAIma,GAAGna;cACxCw1B,QAAQs0E,KAAKn1E,OAAO30B;QAC1B,KAAK20B,OAAOj3B,SAAS8H,UAAUyb,UAAUuU;;MAG1C,KAAKmpF,SAAS7U,KAAK6U;MACnB,KAAK6W,YAAY1rB,KAAK0rB;MACtB,KAAKT,UAAUjrB,KAAKirB;aACb;;;EAKTW,iBAAiB/zG,UAAUg0G,qBAAqB;;;;;EAMhD,oBAAoBr6G,GAAG8c,IAAIC,IAAIC,IAAI+S;UAC5BpT,MAAMK,KAAKF,MAAM;UACjBtX,MAAMuqB,KAAKhT,MAAM;UACjB+6F,KAAK93G,IAAIA;UACT+5G,KAAK/5G,IAAI83G;YACP,IAAI/6F,KAAK,IAAIC,KAAKL,KAAKnX,MAAMu0G,OAAO,IAAIh9F,KAAK,IAAIC,KAAK,IAAIL,KAAKnX,MAAMsyG,KAAKn7F,KAAK3c,IAAI+c;;;EAI5F,2BAA2B/c,GAAGwU;UACvB3tB,IAAI,IAAImZ;WACPnZ,IAAIA,IAAI2tB;;EAGhB,2BAA2BxU,GAAGwU;WACtB,KAAK,IAAIxU,KAAKA,IAAIwU;;EAG1B,2BAA2BxU,GAAGwU;WACtBxU,IAAIA,IAAIwU;;EAGhB,yBAAyBxU,GAAG8c,IAAIC,IAAIC;WAC5Bs9F,kBAAkBt6G,GAAG8c,MAAMy9F,kBAAkBv6G,GAAG+c,MAAMy9F,kBAAkBx6G,GAAGgd;;;EAInF,uBAAuBhd,GAAGwU;UACnB3tB,IAAI,IAAImZ;WACPnZ,IAAIA,IAAIA,IAAI2tB;;EAGpB,uBAAuBxU,GAAGwU;UACnB3tB,IAAI,IAAImZ;WACP,IAAInZ,IAAIA,IAAImZ,IAAIwU;;EAGxB,uBAAuBxU,GAAGwU;WAClB,KAAK,IAAIxU,KAAKA,IAAIA,IAAIwU;;EAG9B,uBAAuBxU,GAAGwU;WAClBxU,IAAIA,IAAIA,IAAIwU;;EAGpB,qBAAqBxU,GAAG8c,IAAIC,IAAIC,IAAI+S;WAC5B0qF,cAAcz6G,GAAG8c,MAAM49F,cAAc16G,GAAG+c,MAAM49F,cAAc36G,GAAGgd,MAAM49F,cAAc56G,GAAG+vB;;EAG9F,+BAA+BsoF;IAC9BvuH,YAAY6yB,SAASvW,WAAWZ,SAASY,WAAWX,SAASW,WAAWy0G,SAASz0G;MAChF;MACA,KAAK1iB,OAAO;MACZ,KAAKi5B,KAAKA;MACV,KAAKnX,KAAKA;MACV,KAAKC,KAAKA;MACV,KAAKo1G,KAAKA;;IAGXlE,SAAS32G,GAAG42G,qBAAqBxwG;YAC1B8T,QAAQ08F;YACRj6F,KAAK,KAAKA,IACbnX,KAAK,KAAKA,IACVC,KAAK,KAAKA,IACVo1G,KAAK,KAAKA;MACb3gG,MAAMrpB,IAAIiqH,YAAY96G,GAAG2c,GAAGrxB,GAAGka,GAAGla,GAAGma,GAAGna,GAAGuvH,GAAGvvH,IAAIwvH,YAAY96G,GAAG2c,GAAGlxB,GAAG+Z,GAAG/Z,GAAGga,GAAGha,GAAGovH,GAAGpvH;aAC/EyuB;;IAGRzW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKyP,GAAGlZ,KAAKyJ,OAAOyP;MACpB,KAAKnX,GAAG/B,KAAKyJ,OAAO1H;MACpB,KAAKC,GAAGhC,KAAKyJ,OAAOzH;MACpB,KAAKo1G,GAAGp3G,KAAKyJ,OAAO2tG;aACb;;IAGR1tG;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK66B,KAAK,KAAKA,GAAG9W;MAClB/jB,KAAK0jB,KAAK,KAAKA,GAAGK;MAClB/jB,KAAK2jB,KAAK,KAAKA,GAAGI;MAClB/jB,KAAK+4H,KAAK,KAAKA,GAAGh1G;aACX/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAK7xE,GAAGhX,UAAU6oF,KAAK7xE;MACvB,KAAKnX,GAAGG,UAAU6oF,KAAKhpF;MACvB,KAAKC,GAAGE,UAAU6oF,KAAK/oF;MACvB,KAAKo1G,GAAGl1G,UAAU6oF,KAAKqsB;aAChB;;;EAKTE,iBAAiB10G,UAAU20G,qBAAqB;EAEhD,gCAAgC3C;IAC/BvuH,YAAY6yB,SAASzyB,WAAWsb,SAAStb,WAAWub,SAASvb,WAAW2wH,SAAS3wH;MAChF;MACA,KAAKxG,OAAO;MACZ,KAAKi5B,KAAKA;MACV,KAAKnX,KAAKA;MACV,KAAKC,KAAKA;MACV,KAAKo1G,KAAKA;;IAGXlE,SAAS32G,GAAG42G,qBAAqB1sH;YAC1BgwB,QAAQ08F;YACRj6F,KAAK,KAAKA,IACbnX,KAAK,KAAKA,IACVC,KAAK,KAAKA,IACVo1G,KAAK,KAAKA;MACb3gG,MAAMrpB,IAAIiqH,YAAY96G,GAAG2c,GAAGrxB,GAAGka,GAAGla,GAAGma,GAAGna,GAAGuvH,GAAGvvH,IAAIwvH,YAAY96G,GAAG2c,GAAGlxB,GAAG+Z,GAAG/Z,GAAGga,GAAGha,GAAGovH,GAAGpvH,IAAIqvH,YAAY96G,GAAG2c,GAAGjxB,GAAG8Z,GAAG9Z,GAAG+Z,GAAG/Z,GAAGmvH,GAAGnvH;aACvHwuB;;IAGRzW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKyP,GAAGlZ,KAAKyJ,OAAOyP;MACpB,KAAKnX,GAAG/B,KAAKyJ,OAAO1H;MACpB,KAAKC,GAAGhC,KAAKyJ,OAAOzH;MACpB,KAAKo1G,GAAGp3G,KAAKyJ,OAAO2tG;aACb;;IAGR1tG;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK66B,KAAK,KAAKA,GAAG9W;MAClB/jB,KAAK0jB,KAAK,KAAKA,GAAGK;MAClB/jB,KAAK2jB,KAAK,KAAKA,GAAGI;MAClB/jB,KAAK+4H,KAAK,KAAKA,GAAGh1G;aACX/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAK7xE,GAAGhX,UAAU6oF,KAAK7xE;MACvB,KAAKnX,GAAGG,UAAU6oF,KAAKhpF;MACvB,KAAKC,GAAGE,UAAU6oF,KAAK/oF;MACvB,KAAKo1G,GAAGl1G,UAAU6oF,KAAKqsB;aAChB;;;EAKTI,kBAAkB50G,UAAU60G,sBAAsB;EAElD,wBAAwB7C;IACvBvuH,YAAY0b,SAASY,WAAWX,SAASW;MACxC;MACA,KAAK1iB,OAAO;MACZ,KAAK8hB,KAAKA;MACV,KAAKC,KAAKA;;IAGXkxG,SAAS32G,GAAG42G,qBAAqBxwG;YAC1B8T,QAAQ08F;UAEV52G,MAAM;QACTka,MAAMzW,KAAK,KAAKgC;;QAEhByU,MAAMzW,KAAK,KAAKgC,IAAI3B,IAAI,KAAK0B;QAC7B0U,MAAMpuB,eAAekU,GAAGjU,IAAI,KAAKyZ;;aAG3B0U;;;IAIRypF,WAAW9zE,GAAG+mF;aACN,KAAKD,SAAS9mF,GAAG+mF;;IAGzBiB,WAAW73G,GAAG42G;YACPx4E,UAAUw4E,sBAAsBxwG;MACtCg4B,QAAQ36B,KAAK,KAAKgC,IAAI3B,IAAI,KAAK0B,IAAI1X;aAC5BswC;;IAGR36B,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK1H,GAAG/B,KAAKyJ,OAAO1H;MACpB,KAAKC,GAAGhC,KAAKyJ,OAAOzH;aACb;;IAGR0H;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK0jB,KAAK,KAAKA,GAAGK;MAClB/jB,KAAK2jB,KAAK,KAAKA,GAAGI;aACX/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKhpF,GAAGG,UAAU6oF,KAAKhpF;MACvB,KAAKC,GAAGE,UAAU6oF,KAAK/oF;aAChB;;;EAKT01G,UAAU90G,UAAU+0G,cAAc;EAElC,yBAAyB/C;IACxBvuH,YAAY0b,SAAStb,WAAWub,SAASvb;MACxC;MACA,KAAKxG,OAAO;MACZ,KAAK23H,eAAe;MACpB,KAAK71G,KAAKA;MACV,KAAKC,KAAKA;;IAGXkxG,SAAS32G,GAAG42G,qBAAqB1sH;YAC1BgwB,QAAQ08F;UAEV52G,MAAM;QACTka,MAAMzW,KAAK,KAAKgC;;QAEhByU,MAAMzW,KAAK,KAAKgC,IAAI3B,IAAI,KAAK0B;QAC7B0U,MAAMpuB,eAAekU,GAAGjU,IAAI,KAAKyZ;;aAG3B0U;;;IAIRypF,WAAW9zE,GAAG+mF;aACN,KAAKD,SAAS9mF,GAAG+mF;;IAGzBnzG,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK1H,GAAG/B,KAAKyJ,OAAO1H;MACpB,KAAKC,GAAGhC,KAAKyJ,OAAOzH;aACb;;IAGR0H;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK0jB,KAAK,KAAKA,GAAGK;MAClB/jB,KAAK2jB,KAAK,KAAKA,GAAGI;aACX/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKhpF,GAAGG,UAAU6oF,KAAKhpF;MACvB,KAAKC,GAAGE,UAAU6oF,KAAK/oF;aAChB;;;EAKT,mCAAmC4yG;IAClCvuH,YAAY6yB,SAASvW,WAAWZ,SAASY,WAAWX,SAASW;MAC5D;MACA,KAAK1iB,OAAO;MACZ,KAAKi5B,KAAKA;MACV,KAAKnX,KAAKA;MACV,KAAKC,KAAKA;;IAGXkxG,SAAS32G,GAAG42G,qBAAqBxwG;YAC1B8T,QAAQ08F;YACRj6F,KAAK,KAAKA,IACbnX,KAAK,KAAKA,IACVC,KAAK,KAAKA;MACbyU,MAAMrpB,IAAIyqH,gBAAgBt7G,GAAG2c,GAAGrxB,GAAGka,GAAGla,GAAGma,GAAGna,IAAIgwH,gBAAgBt7G,GAAG2c,GAAGlxB,GAAG+Z,GAAG/Z,GAAGga,GAAGha;aAC3EyuB;;IAGRzW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKyP,GAAGlZ,KAAKyJ,OAAOyP;MACpB,KAAKnX,GAAG/B,KAAKyJ,OAAO1H;MACpB,KAAKC,GAAGhC,KAAKyJ,OAAOzH;aACb;;IAGR0H;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK66B,KAAK,KAAKA,GAAG9W;MAClB/jB,KAAK0jB,KAAK,KAAKA,GAAGK;MAClB/jB,KAAK2jB,KAAK,KAAKA,GAAGI;aACX/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAK7xE,GAAGhX,UAAU6oF,KAAK7xE;MACvB,KAAKnX,GAAGG,UAAU6oF,KAAKhpF;MACvB,KAAKC,GAAGE,UAAU6oF,KAAK/oF;aAChB;;;EAKT81G,qBAAqBl1G,UAAUm1G,yBAAyB;EAExD,oCAAoCnD;IACnCvuH,YAAY6yB,SAASzyB,WAAWsb,SAAStb,WAAWub,SAASvb;MAC5D;MACA,KAAKxG,OAAO;MACZ,KAAKi5B,KAAKA;MACV,KAAKnX,KAAKA;MACV,KAAKC,KAAKA;;IAGXkxG,SAAS32G,GAAG42G,qBAAqB1sH;YAC1BgwB,QAAQ08F;YACRj6F,KAAK,KAAKA,IACbnX,KAAK,KAAKA,IACVC,KAAK,KAAKA;MACbyU,MAAMrpB,IAAIyqH,gBAAgBt7G,GAAG2c,GAAGrxB,GAAGka,GAAGla,GAAGma,GAAGna,IAAIgwH,gBAAgBt7G,GAAG2c,GAAGlxB,GAAG+Z,GAAG/Z,GAAGga,GAAGha,IAAI6vH,gBAAgBt7G,GAAG2c,GAAGjxB,GAAG8Z,GAAG9Z,GAAG+Z,GAAG/Z;aACjHwuB;;IAGRzW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKyP,GAAGlZ,KAAKyJ,OAAOyP;MACpB,KAAKnX,GAAG/B,KAAKyJ,OAAO1H;MACpB,KAAKC,GAAGhC,KAAKyJ,OAAOzH;aACb;;IAGR0H;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK66B,KAAK,KAAKA,GAAG9W;MAClB/jB,KAAK0jB,KAAK,KAAKA,GAAGK;MAClB/jB,KAAK2jB,KAAK,KAAKA,GAAGI;aACX/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAK7xE,GAAGhX,UAAU6oF,KAAK7xE;MACvB,KAAKnX,GAAGG,UAAU6oF,KAAKhpF;MACvB,KAAKC,GAAGE,UAAU6oF,KAAK/oF;aAChB;;;EAKTg2G,sBAAsBp1G,UAAUq1G,0BAA0B;EAE1D,0BAA0BrD;IACzBvuH,YAAYuvB;MACX;MACA,KAAK31B,OAAO;MACZ,KAAK21B,SAASA;;IAGfs9F,SAAS32G,GAAG42G,qBAAqBxwG;YAC1B8T,QAAQ08F;YACRv9F,SAAS,KAAKA;YACd7E,KAAK6E,OAAO10B,SAAS,KAAKqb;YAC1Bm6G,WAAW1wH,KAAKC,MAAM8qB;YACtBi5E,SAASj5E,IAAI2lG;YACbr9F,KAAKzD,OAAO8gG,aAAa,IAAIA,WAAWA,WAAW;YACnDp9F,KAAK1D,OAAO8gG;YACZn9F,KAAK3D,OAAO8gG,WAAW9gG,OAAO10B,SAAS,IAAI00B,OAAO10B,SAAS,IAAIw1H,WAAW;YAC1EpqF,KAAK1W,OAAO8gG,WAAW9gG,OAAO10B,SAAS,IAAI00B,OAAO10B,SAAS,IAAIw1H,WAAW;MAChFjgG,MAAMrpB,IAAI8qH,WAAWluB,QAAQ3wE,GAAGxxB,GAAGyxB,GAAGzxB,GAAG0xB,GAAG1xB,GAAGykC,GAAGzkC,IAAIqwH,WAAWluB,QAAQ3wE,GAAGrxB,GAAGsxB,GAAGtxB,GAAGuxB,GAAGvxB,GAAGskC,GAAGtkC;aACvFyuB;;IAGRzW,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKmM;eAEI30B,IAAI,GAAGma,IAAIqO,OAAOmM,OAAO10B,QAAQD,IAAIma,GAAGna;cAC1Cw1B,QAAQhN,OAAOmM,OAAO30B;QAC5B,KAAK20B,OAAOj3B,KAAK83B,MAAMhuB;;aAGjB;;IAGRihB;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAKu3B;eAEI30B,IAAI,GAAGma,IAAI,KAAKwa,OAAO10B,QAAQD,IAAIma,GAAGna;cACxCw1B,QAAQ,KAAKb,OAAO30B;QAC1B5C,KAAKu3B,OAAOj3B,KAAK83B,MAAMrU;;aAGjB/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKn1E;eAEI30B,IAAI,GAAGma,IAAI2vF,KAAKn1E,OAAO10B,QAAQD,IAAIma,GAAGna;cACxCw1B,QAAQs0E,KAAKn1E,OAAO30B;QAC1B,KAAK20B,OAAOj3B,SAASgkB,UAAUT,UAAUuU;;aAGnC;;;EAKT0hG,YAAYv1G,UAAUw1G,gBAAgB;MAElCC,sBAAsBj6G,OAAOC;IAChCC,WAAW;IACXq3G,UAAUA;IACVgB,kBAAkBA;IAClBW,kBAAkBA;IAClBE,mBAAmBA;IACnBhC,cAAcA;IACdkC,WAAWA;IACXY,YAAYA;IACZR,sBAAsBA;IACtBE,uBAAuBA;IACvBG,aAAaA;;;;;;EAQd,wBAAwBvD;IACvBvuH;MACC;MACA,KAAKpG,OAAO;MACZ,KAAKs4H;MACL,KAAKC,YAAY;;IAGlBlwH,IAAImwH;MACH,KAAKF,OAAO55H,KAAK85H;;IAGlBC;;YAEOC,aAAa,KAAKJ,OAAO,GAAGrF,SAAS;YACrC0F,WAAW,KAAKL,OAAO,KAAKA,OAAOr3H,SAAS,GAAGgyH,SAAS;WAEzDyF,WAAW12G,OAAO22G;QACtB,KAAKL,OAAO55H,SAAS+4H,UAAUkB,UAAUD;;;;;;;;;;IAW3CzF,SAAS32G;YACFlZ,IAAIkZ,IAAI,KAAKg3G;YACbsF,eAAe,KAAKC;UACtB73H,IAAI;;aAEDA,IAAI43H,aAAa33H;YACnB23H,aAAa53H,MAAMoC;gBAChB01H,OAAOF,aAAa53H,KAAKoC;gBACzBo1H,QAAQ,KAAKF,OAAOt3H;gBACpBizH,gBAAgBuE,MAAMlF;gBACtBnnF,IAAI8nF,kBAAkB,IAAI,IAAI,IAAI6E,OAAO7E;iBACxCuE,MAAMvY,WAAW9zE;;QAGzBnrC;;aAGM;;;;;IAMRsyH;YACOyF,OAAO,KAAKF;aACXE,KAAKA,KAAK93H,SAAS;;;IAI3B0yH;MACC,KAAKrpG,cAAc;MACnB,KAAK0uG,eAAe;MACpB,KAAKH;;;;IAKNA;;UAEK,KAAKG,gBAAgB,KAAKA,aAAa/3H,WAAW,KAAKq3H,OAAOr3H;eAC1D,KAAK+3H;;;;YAKPzF;UACF0F,OAAO;eAEFj4H,IAAI,GAAGma,IAAI,KAAKm9G,OAAOr3H,QAAQD,IAAIma,GAAGna;QAC9Ci4H,QAAQ,KAAKX,OAAOt3H,GAAGsyH;QACvBC,QAAQ70H,KAAKu6H;;MAGd,KAAKD,eAAezF;aACbA;;IAGRjb,gBAAgB+a,YAAY;YACrB19F;eAEG30B,IAAI,GAAGA,KAAKqyH,WAAWryH;QAC/B20B,OAAOj3B,KAAK,KAAKu0H,SAASjyH,IAAIqyH;;UAG3B,KAAKkF;QACR5iG,OAAOj3B,KAAKi3B,OAAO;;aAGbA;;IAGRy9F,UAAUC,YAAY;YACf19F;UACF+8E;eAEK1xG,IAAI,GAAGs3H,SAAS,KAAKA,QAAQt3H,IAAIs3H,OAAOr3H,QAAQD;cAClDw3H,QAAQF,OAAOt3H;cACfy6E,aAAa+8C,SAASA,MAAMhD,iBAAiBnC,YAAY,IAAImF,UAAUA,MAAMd,eAAec,MAAMb,gBAAgB,IAAIa,SAASA,MAAML,gBAAgB9E,YAAYmF,MAAM7iG,OAAO10B,SAASoyH;cACvL3c,MAAM8hB,MAAMpF,UAAU33C;iBAEnBtiD,IAAI,GAAGA,IAAIu9E,IAAIz1G,QAAQk4B;gBACzB3C,QAAQkgF,IAAIv9E;cACdu5E,QAAQA,KAAK1wF,OAAOwU;;UAExBb,OAAOj3B,KAAK83B;UACZk8E,OAAOl8E;;;UAIL,KAAK+hG,aAAa5iG,OAAO10B,SAAS,MAAM00B,OAAOA,OAAO10B,SAAS,GAAG+gB,OAAO2T,OAAO;QACnFA,OAAOj3B,KAAKi3B,OAAO;;aAGbA;;IAGR5V,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK8uG;eAEIt3H,IAAI,GAAGma,IAAIqO,OAAO8uG,OAAOr3H,QAAQD,IAAIma,GAAGna;cAC1Cw3H,QAAQhvG,OAAO8uG,OAAOt3H;QAC5B,KAAKs3H,OAAO55H,KAAK85H,MAAMhwH;;MAGxB,KAAK+vH,YAAY/uG,OAAO+uG;aACjB;;IAGR9uG;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAKm6H,YAAY,KAAKA;MACtBn6H,KAAKk6H;eAEIt3H,IAAI,GAAGma,IAAI,KAAKm9G,OAAOr3H,QAAQD,IAAIma,GAAGna;cACxCw3H,QAAQ,KAAKF,OAAOt3H;QAC1B5C,KAAKk6H,OAAO55H,KAAK85H,MAAM/uG;;aAGjBrrB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKytB,YAAYztB,KAAKytB;MACtB,KAAKD;eAEIt3H,IAAI,GAAGma,IAAI2vF,KAAKwtB,OAAOr3H,QAAQD,IAAIma,GAAGna;cACxCw3H,QAAQ1tB,KAAKwtB,OAAOt3H;QAC1B,KAAKs3H,OAAO55H,SAAS05H,OAAOI,MAAMx4H,QAAQ6qG,SAAS2tB;;aAG7C;;;EAKT,mBAAmBU;IAClB9yH,YAAYuvB;MACX;MACA,KAAK31B,OAAO;MACZ,KAAKm5H,mBAAmBz2G;UAEpBiT;QACH,KAAKD,cAAcC;;;IAIrBD,cAAcC;MACb,KAAKyjG,OAAOzjG,OAAO,GAAG/tB,GAAG+tB,OAAO,GAAG5tB;eAE1B/G,IAAI,GAAGma,IAAIwa,OAAO10B,QAAQD,IAAIma,GAAGna;QACzC,KAAKq4H,OAAO1jG,OAAO30B,GAAG4G,GAAG+tB,OAAO30B,GAAG+G;;aAG7B;;IAGRqxH,OAAOxxH,GAAGG;MACT,KAAKoxH,aAAahsH,IAAIvF,GAAGG;;aAElB;;IAGRsxH,OAAOzxH,GAAGG;YACHywH,YAAYf,UAAU,KAAK0B,aAAa3wH,aAAaka,QAAQ9a,GAAGG;MACtE,KAAKuwH,OAAO55H,KAAK85H;MACjB,KAAKW,aAAahsH,IAAIvF,GAAGG;aAClB;;IAGRuxH,iBAAiBC,MAAMC,MAAM5E,IAAIC;YAC1B2D,YAAYX,qBAAqB,KAAKsB,aAAa3wH,aAAaka,QAAQ62G,MAAMC,WAAW92G,QAAQkyG,IAAIC;MAC3G,KAAKyD,OAAO55H,KAAK85H;MACjB,KAAKW,aAAahsH,IAAIynH,IAAIC;aACnB;;IAGR4E,cAAcC,OAAOC,OAAOC,OAAOC,OAAOjF,IAAIC;YACvC2D,YAAYnB,iBAAiB,KAAK8B,aAAa3wH,aAAaka,QAAQg3G,OAAOC,YAAYj3G,QAAQk3G,OAAOC,YAAYn3G,QAAQkyG,IAAIC;MACpI,KAAKyD,OAAO55H,KAAK85H;MACjB,KAAKW,aAAahsH,IAAIynH,IAAIC;aACnB;;IAGRiF,WAAWpjB;;YAGJqjB,QAAQ,KAAKZ,aAAa3wH,SAAShF,OAAOkzG;YAC1C8hB,YAAYN,YAAY6B;MAC9B,KAAKzB,OAAO55H,KAAK85H;MACjB,KAAKW,aAAap5G,KAAK22F,IAAIA,IAAIz1G,SAAS;aACjC;;IAGR+9G,IAAI4V,IAAIC,IAAIY,SAAST,aAAaC,WAAWC;YACtC1mG,KAAK,KAAK2qG,aAAavxH;YACvB6mB,KAAK,KAAK0qG,aAAapxH;MAC7B,KAAKiyH,OAAOpF,KAAKpmG,IAAIqmG,KAAKpmG,IAAIgnG,SAAST,aAAaC,WAAWC;aACxD;;IAGR8E,OAAOpF,IAAIC,IAAIY,SAAST,aAAaC,WAAWC;MAC/C,KAAK+E,WAAWrF,IAAIC,IAAIY,SAASA,SAAST,aAAaC,WAAWC;aAC3D;;IAGRgF,QAAQtF,IAAIC,IAAIC,SAASC,SAASC,aAAaC,WAAWC,YAAYC;YAC/D3mG,KAAK,KAAK2qG,aAAavxH;YACvB6mB,KAAK,KAAK0qG,aAAapxH;MAC7B,KAAKkyH,WAAWrF,KAAKpmG,IAAIqmG,KAAKpmG,IAAIqmG,SAASC,SAASC,aAAaC,WAAWC,YAAYC;aACjF;;IAGR8E,WAAWrF,IAAIC,IAAIC,SAASC,SAASC,aAAaC,WAAWC,YAAYC;YAClEqD,YAAYjD,aAAaX,IAAIC,IAAIC,SAASC,SAASC,aAAaC,WAAWC,YAAYC;UAEzF,KAAKmD,OAAOr3H,SAAS;;cAElBk5H,aAAa3B,MAAMvF,SAAS;aAE7BkH,WAAWn4G,OAAO,KAAKm3G;UAC3B,KAAKE,OAAOc,WAAWvyH,GAAGuyH,WAAWpyH;;;MAIvC,KAAKuwH,OAAO55H,KAAK85H;YACX4B,YAAY5B,MAAMvF,SAAS;MACjC,KAAKkG,aAAap5G,KAAKq6G;aAChB;;IAGRr6G,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK2vG,aAAap5G,KAAKyJ,OAAO2vG;aACvB;;IAGR1vG;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK+6H,eAAe,KAAKA,aAAah3G;aAC/B/jB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKquB,aAAal3G,UAAU6oF,KAAKquB;aAC1B;;;EAKT,oBAAoBkB;IACnBj0H,YAAYuvB;MACX,MAAMA;MACN,KAAK7Z,OAAOwC;MACZ,KAAKte,OAAO;MACZ,KAAK62G;;IAGNyjB,eAAejH;YACRkH;eAEGv5H,IAAI,GAAGma,IAAI,KAAK07F,MAAM51G,QAAQD,IAAIma,GAAGna;QAC7Cu5H,SAASv5H,KAAK,KAAK61G,MAAM71G,GAAGoyH,UAAUC;;aAGhCkH;;;IAIR9hB,cAAc4a;;QAEZvqF,OAAO,KAAKsqF,UAAUC;QACtBxc,OAAO,KAAKyjB,eAAejH;;;IAI7BtzG,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKqtF;eAEI71G,IAAI,GAAGma,IAAIqO,OAAOqtF,MAAM51G,QAAQD,IAAIma,GAAGna;cACzCwzG,OAAOhrF,OAAOqtF,MAAM71G;QAC1B,KAAK61G,MAAMn4G,KAAK81G,KAAKhsG;;aAGf;;IAGRihB;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAK0d,OAAO,KAAKA;MACjB1d,KAAKy4G;eAEI71G,IAAI,GAAGma,IAAI,KAAK07F,MAAM51G,QAAQD,IAAIma,GAAGna;cACvCwzG,OAAO,KAAKqC,MAAM71G;QACxB5C,KAAKy4G,MAAMn4G,KAAK81G,KAAK/qF;;aAGfrrB;;IAGRysG,SAASC;MACR,MAAMD,SAASC;MACf,KAAKhvF,OAAOgvF,KAAKhvF;MACjB,KAAK+6F;eAEI71G,IAAI,GAAGma,IAAI2vF,KAAK+L,MAAM51G,QAAQD,IAAIma,GAAGna;cACvCwzG,OAAO1J,KAAK+L,MAAM71G;QACxB,KAAK61G,MAAMn4G,SAAS27H,OAAOxvB,SAAS2J;;aAG9B;;;EAKT,oBAAoBjwE;IACnBn+B,YAAYgB,OAAO4F,YAAY;MAC9B;MACA,KAAKhN,OAAO;MACZ,KAAKoH,YAAYuvC,MAAMvvC;MACvB,KAAK4F,YAAYA;;IAGlBrO;IAGAohB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKpiB,MAAM2Y,KAAKyJ,OAAOpiB;MACvB,KAAK4F,YAAYwc,OAAOxc;aACjB;;IAGRyc,OAAOC;YACAtrB,OAAO,MAAMqrB,OAAOC;MAC1BtrB,KAAK83B,OAAO9uB,QAAQ,KAAKA,MAAMkpC;MAC/BlyC,KAAK83B,OAAOlpB,YAAY,KAAKA;UACzB,KAAKkpD,gBAAgBt3D,WAAWR,KAAK83B,OAAOggC,cAAc,KAAKA,YAAY5lB;UAC3E,KAAKxlC,aAAalM,WAAWR,KAAK83B,OAAOprB,WAAW,KAAKA;UACzD,KAAKuW,UAAUziB,WAAWR,KAAK83B,OAAO7U,QAAQ,KAAKA;UACnD,KAAKi0C,UAAU12D,WAAWR,KAAK83B,OAAOo/B,QAAQ,KAAKA;UACnD,KAAK2jB,aAAar6E,WAAWR,KAAK83B,OAAO+iD,WAAW,KAAKA;UACzD,KAAK3hB,WAAW14D,WAAWR,KAAK83B,OAAOohC,SAAS,KAAKA,OAAO7tC;aACzDrrB;;;EAKTo8H,MAAM73G,UAAUgkB,UAAU;EAE1B,8BAA8B6zF;IAC7Bp0H,YAAY6vD,UAAUC,aAAalpD;MAClC,MAAMipD,UAAUjpD;MAChB,KAAKhN,OAAO;MACZ,KAAK2H,SAASoY,KAAKwkB,SAASC;MAC5B,KAAKjb;MACL,KAAK2sC,kBAAkBvf,MAAMuf;;IAG9Bn2C,KAAKyJ;MACJgxG,MAAM73G,UAAU5C,KAAK7hB,KAAK,MAAMsrB;MAChC,KAAK0sC,YAAYn2C,KAAKyJ,OAAO0sC;aACtB;;;EAKTukE,gBAAgB93G,UAAUy2D,oBAAoB;QAExCshD,uCAAuC/8F;QAEvCg9F,yCAAyCn0H;QAEzCo0H,iCAAiCp0H;EAEvC;IACCJ,YAAY6sB;MACX,KAAKA,SAASA;MACd,KAAK4lD,OAAO;MACZ,KAAKC,aAAa;MAClB,KAAKtxE,SAAS;MACd,KAAKuxE,cAAcr2D,QAAQ,KAAK;MAChC,KAAK5f,MAAM;MACX,KAAK65E,UAAU;MACf,KAAK51D,aAAa4W;MAClB,KAAKm+C,aAAa;MAClB,KAAKxxD,cAAc;MACnB,KAAKswD,eAAeC;MACpB,KAAKggD,oBAAoBn4G,QAAQ,GAAG;MACpC,KAAKo4G,iBAAiB;MACtB,KAAKC,kBAAkB3uG,QAAQ,GAAG,GAAG,GAAG;;IAGzCywD;aACQ,KAAKi+C;;IAGb79C;aACQ,KAAKrC;;IAGboC,eAAe/vE;YACRgxE,eAAe,KAAKhrD;YACpB+nG,eAAe,KAAKj0G;MAE1B4zG,sBAAsB/lG,sBAAsB3nB,MAAMqmB;MAElD2qD,aAAat2E,SAASoY,KAAK46G;MAE3BC,cAAchmG,sBAAsB3nB,MAAMzC,OAAO8oB;MAEjD2qD,aAAax1E,OAAOmyH;MACpB38C,aAAat2C;MAEb+yF,oBAAoB12G,iBAAiBi6D,aAAa9qD,kBAAkB8qD,aAAa/qD;MAEjF,KAAK0nD,SAASxzB,wBAAwBszE;MAEtCM,aAAa7tH,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;MAC5F6tH,aAAa16G,SAAS29D,aAAa9qD;MACnC6nG,aAAa16G,SAAS29D,aAAa/qD;;IAGpC6pD,YAAYk+C;aACJ,KAAKF,WAAWE;;IAGxBz+C;aACQ,KAAKq+C;;IAGbl8H;UACK,KAAKmE;QACR,KAAKA,IAAInE;;UAGN,KAAKg+E;QACR,KAAKA,QAAQh+E;;;IAIfohB,KAAKyJ;MACJ,KAAKyJ,SAASzJ,OAAOyJ,OAAOzqB;MAC5B,KAAKqwE,OAAOrvD,OAAOqvD;MACnB,KAAKrxE,SAASgiB,OAAOhiB;MACrB,KAAKuxE,QAAQh5D,KAAKyJ,OAAOuvD;aAClB;;IAGRvwE;iBACY,KAAKpC,cAAc2Z,KAAK;;IAGpC0J;YACOyM;UACF,KAAK2iD,SAAS,GAAG3iD,OAAO2iD,OAAO,KAAKA;UACpC,KAAKC,eAAe,GAAG5iD,OAAO4iD,aAAa,KAAKA;UAChD,KAAKtxE,WAAW,GAAG0uB,OAAO1uB,SAAS,KAAKA;UACxC,KAAKuxE,QAAQnxE,MAAM,OAAO,KAAKmxE,QAAQhxE,MAAM,KAAKmuB,OAAO6iD,UAAU,KAAKA,QAAQ52D;MACpF+T,OAAOjD,SAAS,KAAKA,OAAOxJ,OAAO,OAAOyM;aACnCA,OAAOjD,OAAOlM;aACdmP;;;EAKT,8BAA8BglG;IAC7B90H;MACC,UAAU8+C,kBAAkB,IAAI,GAAG,KAAK;MACxC,KAAKtB,QAAQ;;IAGdo5B,eAAe/vE;YACRgmB,SAAS,KAAKA;YACdwwB,MAAMhoC,UAAU,IAAIxO,MAAMoU,QAAQ,KAAKuiC;YACvCF,SAAS,KAAKq1B,QAAQx5D,QAAQ,KAAKw5D,QAAQv5D;YAC3C2iB,MAAMl1B,MAAMnC,YAAYmoB,OAAOkP;UAEjCshB,QAAQxwB,OAAOwwB,OAAOC,WAAWzwB,OAAOywB,UAAUvhB,QAAQlP,OAAOkP;QACpElP,OAAOwwB,MAAMA;QACbxwB,OAAOywB,SAASA;QAChBzwB,OAAOkP,MAAMA;QACblP,OAAO+wB;;MAGR,MAAMg5B,eAAe/vE;;IAGtB8S,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKo6B,QAAQp6B,OAAOo6B;aACb;;;EAKTu3E,gBAAgBx4G,UAAUy4G,oBAAoB;EAE9C,wBAAwBZ;IACvBp0H,YAAYgB,OAAO4F,WAAWlC,WAAW,GAAGuW,QAAQtb,KAAKyV,KAAK,GAAGy9D,WAAW,GAAG3jB,QAAQ;MACtF,MAAMluD,OAAO4F;MACb,KAAKhN,OAAO;MACZ,KAAK2H,SAASoY,KAAKwkB,SAASC;MAC5B,KAAKjb;MACL,KAAK/e,aAAa+5B;MAClB,KAAKz5B,WAAWA;MAChB,KAAKuW,QAAQA;MACb,KAAK43D,WAAWA;MAChB,KAAK3jB,QAAQA;;MAEb,KAAKgC,aAAa6jE;;QAGfE;;;aAGI,KAAKruH,YAAYjH,KAAKyV;;QAG1B6/G,MAAMA;;;MAGT,KAAKruH,YAAYquH,QAAQt1H,KAAKyV;;IAG/B7c;MACC,KAAK24D,OAAO34D;;IAGbohB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK1e,WAAW0e,OAAO1e;MACvB,KAAKuW,QAAQmI,OAAOnI;MACpB,KAAK43D,WAAWzvD,OAAOyvD;MACvB,KAAK3jB,QAAQ9rC,OAAO8rC;MACpB,KAAK9qD,SAASgf,OAAOhf,OAAOhC;MAC5B,KAAK8uD,SAAS9tC,OAAO8tC,OAAO9uD;aACrB;;;EAKT8yH,UAAU34G,UAAUq2D,cAAc;QAE5B4jB,qCAAqCj/D;QAErC49F,uCAAuC/0H;QAEvCg1H,+BAA+Bh1H;EAErC,+BAA+B00H;IAC9B90H;MACC,UAAU8+C,kBAAkB,IAAI,GAAG,KAAK;MACxC,KAAK21E,oBAAoBn4G,QAAQ,GAAG;MACpC,KAAKo4G,iBAAiB;MACtB,KAAKC;;;;;;;;;;;;;UAaD3uG,QAAQ,GAAG,GAAG,GAAG;UACjBA,QAAQ,GAAG,GAAG,GAAG;UACjBA,QAAQ,GAAG,GAAG,GAAG;UACjBA,QAAQ,GAAG,GAAG,GAAG;UACjBA,QAAQ,GAAG,GAAG,GAAG;UACjBA,QAAQ,GAAG,GAAG,GAAG;MACrB,KAAKqvG,uBAAuBj1H,QAAQ,GAAG,GAAG,QAAQA,SAAS,GAAG,GAAG,QAAQA,QAAQ,GAAG,GAAG,QAAQA,QAAQ,GAAG,IAAI,QAAQA,QAAQ,GAAG,GAAG,QAAQA,QAAQ,IAAI,GAAG;MAC3J,KAAKk1H,gBAAgBl1H,QAAQ,GAAG,GAAG,QAAQA,QAAQ,GAAG,GAAG,QAAQA,QAAQ,GAAG,GAAG,QAAQA,QAAQ,GAAG,GAAG,QAAQA,QAAQ,GAAG,GAAG,QAAQA,QAAQ,GAAG,IAAI;;IAGnJw2E,eAAe/vE,OAAOguH,gBAAgB;YAC/BhoG,SAAS,KAAKA;YACd+nG,eAAe,KAAKj0G;YACpBob,MAAMl1B,MAAMnC,YAAYmoB,OAAOkP;UAEjCA,QAAQlP,OAAOkP;QAClBlP,OAAOkP,MAAMA;QACblP,OAAO+wB;;MAGRu3E,oBAAoB3mG,sBAAsB3nB,MAAMqmB;MAEhDL,OAAOtrB,SAASoY,KAAKw7G;MAErBC,YAAYz7G,KAAKkT,OAAOtrB;MAExB6zH,YAAYnzH,IAAI,KAAKozH,gBAAgBR;MAErChoG,OAAOmM,GAAGrf,KAAK,KAAK27G,SAAST;MAC7BhoG,OAAOxqB,OAAO+yH;MACdvoG,OAAO0U;MACPqzF,aAAax6F,iBAAiB+6F,oBAAoB3zH,IAAI2zH,oBAAoBxzH,IAAIwzH,oBAAoBvzH;MAElG40F,kBAAkB54E,iBAAiBiP,OAAOE,kBAAkBF,OAAOC;MAEnE,KAAK0nD,SAASxzB,wBAAwBw1C;;;EAKxC++B,iBAAiBh5G,UAAU85D,qBAAqB;EAEhD,yBAAyB+9C;IACxBp0H,YAAYgB,OAAO4F,WAAWlC,WAAW,GAAGwqD,QAAQ;MACnD,MAAMluD,OAAO4F;MACb,KAAKhN,OAAO;MACZ,KAAK8K,WAAWA;MAChB,KAAKwqD,QAAQA;;MAEb,KAAKgC,aAAaqkE;;QAGfN;;;aAGI,KAAKruH,YAAY,IAAIjH,KAAKyV;;QAG9B6/G,MAAMA;;;MAGT,KAAKruH,YAAYquH,SAAS,IAAIt1H,KAAKyV;;IAGpC7c;MACC,KAAK24D,OAAO34D;;IAGbohB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAK1e,WAAW0e,OAAO1e;MACvB,KAAKwqD,QAAQ9rC,OAAO8rC;MACpB,KAAKgC,SAAS9tC,OAAO8tC,OAAO9uD;aACrB;;;EAKTozH,WAAWj5G,UAAUw2D,eAAe;EAEpC,iCAAiC31B;IAChCp9C,YAAY07B,QAAQ,GAAGC,QAAQ,GAAGC,MAAM,GAAGC,UAAU,GAAGC,OAAO,KAAKC,MAAM;MACzE;MACA,KAAKniC,OAAO;MACZ,KAAK2jD,OAAO;MACZ,KAAKE,OAAO;MACZ,KAAK/hB,OAAOA;MACZ,KAAKC,QAAQA;MACb,KAAKC,MAAMA;MACX,KAAKC,SAASA;MACd,KAAKC,OAAOA;MACZ,KAAKC,MAAMA;MACX,KAAK6hB;;IAGNjkC,KAAKyJ,QAAQggB;MACZ,MAAMzpB,KAAKyJ,QAAQggB;MACnB,KAAK1H,OAAOtY,OAAOsY;MACnB,KAAKC,QAAQvY,OAAOuY;MACpB,KAAKC,MAAMxY,OAAOwY;MAClB,KAAKC,SAASzY,OAAOyY;MACrB,KAAKC,OAAO1Y,OAAO0Y;MACnB,KAAKC,MAAM3Y,OAAO2Y;MAClB,KAAKwhB,OAAOn6B,OAAOm6B;MACnB,KAAKE,OAAOr6B,OAAOq6B,SAAS,OAAO,OAAO1lC,OAAOuhC,WAAWl2B,OAAOq6B;aAC5D;;IAGRa,cAAcC,WAAWC,YAAYh9C,GAAGG,GAAGwX,OAAOC;UAC7C,KAAKqkC,SAAS;QACjB,KAAKA;UACJgB,SAAS;UACTF,WAAW;UACXC,YAAY;UACZE,SAAS;UACTC,SAAS;UACTxlC,OAAO;UACPC,QAAQ;;;MAIV,KAAKqkC,KAAKgB,UAAU;MACpB,KAAKhB,KAAKc,YAAYA;MACtB,KAAKd,KAAKe,aAAaA;MACvB,KAAKf,KAAKiB,UAAUl9C;MACpB,KAAKi8C,KAAKkB,UAAUh9C;MACpB,KAAK87C,KAAKtkC,QAAQA;MAClB,KAAKskC,KAAKrkC,SAASA;MACnB,KAAKwkC;;IAGNgB;UACK,KAAKnB,SAAS;QACjB,KAAKA,KAAKgB,UAAU;;MAGrB,KAAKb;;IAGNA;YACOxiC,MAAM,KAAKugB,QAAQ,KAAKD,SAAS,IAAI,KAAK6hB;YAC1CliC,MAAM,KAAKugB,MAAM,KAAKC,WAAW,IAAI,KAAK0hB;YAC1Cj9B,MAAM,KAAKqb,QAAQ,KAAKD,QAAQ;YAChCnb,MAAM,KAAKqb,MAAM,KAAKC,UAAU;UAClCH,OAAOpb,KAAKlF;UACZugB,QAAQrb,KAAKlF;UACbwgB,MAAMrb,KAAKlF;UACXwgB,SAAStb,KAAKlF;UAEd,KAAKoiC,SAAS,QAAQ,KAAKA,KAAKgB;cAC7Bg3E,UAAU,KAAK95F,QAAQ,KAAKD,QAAQ,KAAK+hB,KAAKc,YAAY,KAAKhB;cAC/Dm4E,UAAU,KAAK95F,MAAM,KAAKC,UAAU,KAAK4hB,KAAKe,aAAa,KAAKjB;QACtE7hB,QAAQ+5F,SAAS,KAAKh4E,KAAKiB;QAC3B/iB,QAAQD,OAAO+5F,SAAS,KAAKh4E,KAAKtkC;QAClCyiB,OAAO85F,SAAS,KAAKj4E,KAAKkB;QAC1B9iB,SAASD,MAAM85F,SAAS,KAAKj4E,KAAKrkC;;MAGnC,KAAK2T,iBAAiBiP,iBAAiBN,MAAMC,OAAOC,KAAKC,QAAQ,KAAKC,MAAM,KAAKC;MACjF,KAAK9O,wBAAwBtT,KAAK,KAAKoT,kBAAkB1N;;IAG1DgE,OAAOC;YACAtrB,OAAO,MAAMqrB,OAAOC;MAC1BtrB,KAAK83B,OAAOytB,OAAO,KAAKA;MACxBvlD,KAAK83B,OAAO4L,OAAO,KAAKA;MACxB1jC,KAAK83B,OAAO6L,QAAQ,KAAKA;MACzB3jC,KAAK83B,OAAO8L,MAAM,KAAKA;MACvB5jC,KAAK83B,OAAO+L,SAAS,KAAKA;MAC1B7jC,KAAK83B,OAAOgM,OAAO,KAAKA;MACxB9jC,KAAK83B,OAAOiM,MAAM,KAAKA;UACnB,KAAK0hB,SAAS,MAAMzlD,KAAK83B,OAAO2tB,OAAO1lC,OAAOuhC,WAAW,KAAKmE;aAC3DzlD;;;EAKT29H,mBAAmBp5G,UAAUuhF,uBAAuB;EAEpD,qCAAqCg3B;IACpC90H;MACC,UAAU21H,oBAAoB,GAAG,GAAG,IAAI,GAAG,KAAK;;;EAKlDC,uBAAuBr5G,UAAUs5G,2BAA2B;EAE5D,+BAA+BzB;IAC9Bp0H,YAAYgB,OAAO4F;MAClB,MAAM5F,OAAO4F;MACb,KAAKhN,OAAO;MACZ,KAAK2H,SAASoY,KAAKwkB,SAASC;MAC5B,KAAKjb;MACL,KAAK/e,aAAa+5B;MAClB,KAAK+yB,aAAa0kE;;IAGnBr9H;MACC,KAAK24D,OAAO34D;;IAGbohB,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKhf,SAASgf,OAAOhf,OAAOhC;MAC5B,KAAK8uD,SAAS9tC,OAAO8tC,OAAO9uD;aACrB;;;EAKT0E,iBAAiByV,UAAUg2D,qBAAqB;EAEhD,2BAA2B6hD;IAC1Bp0H,YAAYgB,OAAO4F;MAClB,MAAM5F,OAAO4F;MACb,KAAKhN,OAAO;;;EAKd+M,aAAa4V,UAAU41D,iBAAiB;EAExC,4BAA4BiiD;IAC3Bp0H,YAAYgB,OAAO4F,WAAWuS,QAAQ,IAAIC,SAAS;MAClD,MAAMpY,OAAO4F;MACb,KAAKhN,OAAO;MACZ,KAAKuf,QAAQA;MACb,KAAKC,SAASA;;IAGfO,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKjK,QAAQiK,OAAOjK;MACpB,KAAKC,SAASgK,OAAOhK;aACd;;IAGRiK,OAAOC;YACAtrB,OAAO,MAAMqrB,OAAOC;MAC1BtrB,KAAK83B,OAAO3W,QAAQ,KAAKA;MACzBnhB,KAAK83B,OAAO1W,SAAS,KAAKA;aACnBphB;;;EAKT89H,cAAcv5G,UAAUu2D,kBAAkB;;;;;;;;;EAW1C;IACC9yE;MACC,KAAKsyE;eAEI13E,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAah6E,SAAS8H;;;IAI7B2G,IAAIurE;eACM13E,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAa13E,GAAG+e,KAAK24D,aAAa13E;;aAGjC;;IAGRm7H;eACUn7H,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAa13E,GAAGmM,IAAI,GAAG,GAAG;;aAGzB;;;;IAKRivH,MAAM/nG,QAAQ7pB;;YAEP5C,IAAIysB,OAAOzsB,GACdG,IAAIssB,OAAOtsB,GACXC,IAAIqsB,OAAOrsB;YACRq0H,QAAQ,KAAK3jD;;MAEnBluE,OAAOuV,KAAKs8G,MAAM,IAAIj0H,eAAe;;MAErCoC,OAAO2V,gBAAgBk8G,MAAM,IAAI,WAAWt0H;MAC5CyC,OAAO2V,gBAAgBk8G,MAAM,IAAI,WAAWr0H;MAC5CwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,WAAWz0H;;MAE5C4C,OAAO2V,gBAAgBk8G,MAAM,IAAI,YAAYz0H,IAAIG;MACjDyC,OAAO2V,gBAAgBk8G,MAAM,IAAI,YAAYt0H,IAAIC;MACjDwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,YAAY,MAAMr0H,IAAIA,IAAI;MAC3DwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,YAAYz0H,IAAII;MACjDwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,YAAYz0H,IAAIA,IAAIG,IAAIA;aAClDyC;;;;;IAMR8xH,gBAAgBjoG,QAAQ7pB;;YAEjB5C,IAAIysB,OAAOzsB,GACdG,IAAIssB,OAAOtsB,GACXC,IAAIqsB,OAAOrsB;YACRq0H,QAAQ,KAAK3jD;;MAEnBluE,OAAOuV,KAAKs8G,MAAM,IAAIj0H,eAAe;;;MAGrCoC,OAAO2V,gBAAgBk8G,MAAM,IAAI,MAAM,WAAWt0H;;MAElDyC,OAAO2V,gBAAgBk8G,MAAM,IAAI,MAAM,WAAWr0H;MAClDwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,MAAM,WAAWz0H;;MAElD4C,OAAO2V,gBAAgBk8G,MAAM,IAAI,MAAM,WAAWz0H,IAAIG;;MAEtDyC,OAAO2V,gBAAgBk8G,MAAM,IAAI,MAAM,WAAWt0H,IAAIC;MACtDwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,WAAWr0H,IAAIA,IAAI;;MAEpDwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,MAAM,WAAWz0H,IAAII;MACtDwC,OAAO2V,gBAAgBk8G,MAAM,IAAI,YAAYz0H,IAAIA,IAAIG,IAAIA;;aAElDyC;;IAGRnC,IAAIowE;eACMz3E,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAa13E,GAAGqH,IAAIowE,GAAGC,aAAa13E;;aAGnC;;IAGRu7H,YAAY9jD,IAAIz7D;eACNhc,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAa13E,GAAGmf,gBAAgBs4D,GAAGC,aAAa13E,IAAIgc;;aAGnD;;IAGR4J,MAAM5J;eACIhc,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAa13E,GAAGoH,eAAe4U;;aAG9B;;IAGRP,KAAKg8D,IAAI72D;eACC5gB,IAAI,GAAGA,IAAI,GAAGA;QACtB,KAAK03E,aAAa13E,GAAGyb,KAAKg8D,GAAGC,aAAa13E,IAAI4gB;;aAGxC;;IAGRI,OAAOy2D;eACGz3E,IAAI,GAAGA,IAAI,GAAGA;aACjB,KAAK03E,aAAa13E,GAAGghB,OAAOy2D,GAAGC,aAAa13E;iBACzC;;;aAIF;;IAGR+e,KAAK04D;aACG,KAAKtrE,IAAIsrE,GAAGC;;IAGpBlwE;iBACY,KAAKpC,cAAc2Z,KAAK;;IAGpCkC,UAAUhH,OAAOiH,SAAS;YACnBw2D,eAAe,KAAKA;eAEjB13E,IAAI,GAAGA,IAAI,GAAGA;QACtB03E,aAAa13E,GAAGihB,UAAUhH,OAAOiH,SAASlhB,IAAI;;aAGxC;;IAGRmhB,QAAQlH,YAAYiH,SAAS;YACtBw2D,eAAe,KAAKA;eAEjB13E,IAAI,GAAGA,IAAI,GAAGA;QACtB03E,aAAa13E,GAAGmhB,QAAQlH,OAAOiH,SAASlhB,IAAI;;aAGtCia;;;;WAKDuhH,WAAWnoG,QAAQooG;;YAEnB70H,IAAIysB,OAAOzsB,GACdG,IAAIssB,OAAOtsB,GACXC,IAAIqsB,OAAOrsB;;MAEdy0H,QAAQ,KAAK;;MAEbA,QAAQ,KAAK,WAAW10H;MACxB00H,QAAQ,KAAK,WAAWz0H;MACxBy0H,QAAQ,KAAK,WAAW70H;;MAExB60H,QAAQ,KAAK,WAAW70H,IAAIG;MAC5B00H,QAAQ,KAAK,WAAW10H,IAAIC;MAC5By0H,QAAQ,KAAK,YAAY,IAAIz0H,IAAIA,IAAI;MACrCy0H,QAAQ,KAAK,WAAW70H,IAAII;MAC5By0H,QAAQ,KAAK,YAAY70H,IAAIA,IAAIG,IAAIA;;;EAKvC20H,oBAAoB/5G,UAAUg6G,wBAAwB;EAEtD,yBAAyBnC;IACxBp0H,YAAYqyE,SAASikD,uBAAuB1vH,YAAY;MACvD,MAAMpO,WAAWoO;MACjB,KAAKyrE,KAAKA;;IAGX14D,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKivD,GAAG14D,KAAKyJ,OAAOivD;aACb;;IAGRoyB,SAASC;MACR,KAAK99F,YAAY89F,KAAK99F;;MAEtB,KAAKyrE,GAAGx2D,UAAU6oF,KAAKryB;aAChB;;IAGRhvD,OAAOC;YACAtrB,OAAO,MAAMqrB,OAAOC;MAC1BtrB,KAAK83B,OAAOuiD,KAAK,KAAKA,GAAGt2D;aAClB/jB;;;EAKTw+H,WAAWj6G,UAAU61D,eAAe;EAEpC,6BAA6Bk4C;IAC5BtqH,YAAYspH;MACX,MAAMA;MACN,KAAK9lG;;IAGNmmG,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRwuE,aAAa4C,WAAWpxE,MAAM6uE;MACpCL,OAAOiB,QAAQzvE,MAAMmpB;MACrBqlD,OAAOmB,iBAAiB3vE,MAAMivE;MAC9BT,OAAOgB,mBAAmBxvE,MAAM+uE;MAChCP,OAAOU,KAAK9lG,KAAK,UAAUy0F;;UAEzB2P,OAAOxtE,MAAM9gD,MAAMD,KAAKC,MAAM2+G;iBACtBr8G;cACJksH;YACHA,QAAQlsH;;YAERxB,QAAQa,MAAMW;;UAGfw+C,MAAM6uE,QAAQV,UAAU/kG;;SAEvBqkG,YAAYC;;IAGhBxuH,MAAM+qG;YACClhF,WAAW,KAAKA;MAEtB,oBAAoB1d;YACf0d,SAAS1d,UAAUtN;UACtBiC,QAAQ0B,KAAK,2CAA2C2J;;eAGlD0d,SAAS1d;;YAGXhF,eAAe87G,UAAUlY,KAAK9qG;UAChC8qG,KAAKhvF,SAASld,WAAWsI,SAAS4U,OAAOgvF,KAAKhvF;UAC9CgvF,KAAK5+F,SAAStN,WAAWsI,SAASgF,OAAO4+F,KAAK5+F;UAC9C4+F,KAAK1jG,UAAUxI,aAAasI,SAASE,UAAUxI,WAAWsI,SAASE,MAAM+sC,OAAO22D,KAAK1jG;UACrF0jG,KAAKv6D,cAAc3xC,WAAWsI,SAASqpC,YAAYu6D,KAAKv6D;UACxDu6D,KAAKt6D,cAAc5xC,WAAWsI,SAASspC,YAAYs6D,KAAKt6D;UACxDs6D,KAAKr6D,UAAU7xC,WAAWsI,SAASupC,YAAYkG,QAAQxC,OAAO22D,KAAKr6D;UACnEq6D,KAAKp6D,aAAa9xC,aAAasI,SAASwpC,aAAa9xC,WAAWsI,SAASwpC,SAASyD,OAAO22D,KAAKp6D;UAC9Fo6D,KAAKl6D,aAAahyC,aAAasI,SAAS0pC,aAAahyC,WAAWsI,SAAS0pC,SAASuD,OAAO22D,KAAKl6D;UAC9Fk6D,KAAKj6D,cAAcjyC,WAAWsI,SAAS2pC,YAAYi6D,KAAKj6D;UACxDi6D,KAAKh6D,cAAclyC,WAAWsI,SAAS4pC,YAAYg6D,KAAKh6D;UACxDg6D,KAAK/5D,uBAAuBnyC,WAAWsI,SAAS6pC,qBAAqB+5D,KAAK/5D;UAC1E+5D,KAAKl4D,iBAAiBh0C,WAAWsI,SAAS0rC,eAAek4D,KAAKl4D;UAC9Dk4D,KAAKh4D,cAAcl0C,WAAWsI,SAAS4rC,YAAYg4D,KAAKh4D;UACxDg4D,KAAK93D,wBAAwBp0C,WAAWsI,SAAS8rC,sBAAsB83D,KAAK93D;UAC5E83D,KAAK73D,qBAAqBr0C,aAAasI,SAAS+rC,qBAAqBr0C,WAAWsI,SAAS+rC,iBAAiBkB,OAAO22D,KAAK73D;UACtH63D,KAAK19F,QAAQxO,WAAWsI,SAASkG,MAAM09F,KAAK19F;UAC5C09F,KAAK56D,gBAAgBtxC,WAAWsI,SAASgpC,cAAc46D,KAAK56D;UAC5D46D,KAAKr9D,aAAa7uC,WAAWsI,SAASumC,WAAWq9D,KAAKr9D;UACtDq9D,KAAKv4D,YAAY3zC,WAAWsI,SAASqrC,UAAUu4D,KAAKv4D;UACpDu4D,KAAKp9D,SAAS9uC,WAAWsI,SAASwmC,OAAOo9D,KAAKp9D;UAC9Co9D,KAAK57D,eAAetwC,WAAWsI,SAASgoC,aAAa47D,KAAK57D;UAC1D47D,KAAKl9D,YAAYhvC,WAAWsI,SAAS0mC,UAAUk9D,KAAKl9D;UACpDk9D,KAAKj9D,gBAAgBjvC,WAAWsI,SAAS2mC,cAAci9D,KAAKj9D;UAC5Di9D,KAAKr7D,cAAc7wC,WAAWsI,SAASuoC,YAAYq7D,KAAKr7D;UACxDq7D,KAAKz8D,cAAczvC,WAAWsI,SAASmnC,YAAYy8D,KAAKz8D;UACxDy8D,KAAKx8D,eAAe1vC,WAAWsI,SAASonC,aAAaw8D,KAAKx8D;UAC1Dw8D,KAAK37D,eAAevwC,WAAWsI,SAASioC,aAAa27D,KAAK37D;UAC1D27D,KAAKh8D,iBAAiBlwC,WAAWsI,SAAS4nC,eAAeg8D,KAAKh8D;UAC9Dg8D,KAAKv8D,qBAAqB3vC,WAAWsI,SAASqnC,mBAAmBu8D,KAAKv8D;UACtEu8D,KAAKt8D,gBAAgB5vC,WAAWsI,SAASsnC,cAAcs8D,KAAKt8D;UAC5Ds8D,KAAKr8D,eAAe7vC,WAAWsI,SAASunC,aAAaq8D,KAAKr8D;UAC1Dq8D,KAAKp8D,oBAAoB9vC,WAAWsI,SAASwnC,kBAAkBo8D,KAAKp8D;UACpEo8D,KAAKn8D,gBAAgB/vC,WAAWsI,SAASynC,cAAcm8D,KAAKn8D;UAC5Dm8D,KAAKl8D,iBAAiBhwC,WAAWsI,SAAS0nC,eAAek8D,KAAKl8D;UAC9Dk8D,KAAKj8D,iBAAiBjwC,WAAWsI,SAAS2nC,eAAei8D,KAAKj8D;UAC9Di8D,KAAKx/F,cAAc1M,WAAWsI,SAASoE,YAAYw/F,KAAKx/F;UACxDw/F,KAAKx3D,uBAAuB10C,WAAWsI,SAASosC,qBAAqBw3D,KAAKx3D;UAC1Ew3D,KAAKv3D,qBAAqB30C,WAAWsI,SAASqsC,mBAAmBu3D,KAAKv3D;UACtEu3D,KAAKt3D,sBAAsB50C,WAAWsI,SAASssC,oBAAoBs3D,KAAKt3D;UACxEs3D,KAAKlhG,aAAahL,WAAWsI,SAAS0C,WAAWkhG,KAAKlhG;UACtDkhG,KAAK33D,cAAc,GAAGjsC,SAASisC,YAAY23D,KAAK33D;UAChD23D,KAAK13D,aAAax0C,WAAWsI,SAASksC,WAAW03D,KAAK13D;UACtD03D,KAAKz3D,YAAYz0C,WAAWsI,SAASmsC,UAAUy3D,KAAKz3D;UACpDy3D,KAAKlkF,UAAUhoB,WAAWsI,SAAS0f,QAAQkkF,KAAKlkF;UAChDkkF,KAAKz7D,kBAAkBzwC,WAAWsI,SAASmoC,gBAAgBy7D,KAAKz7D;UAChEy7D,KAAKx7D,wBAAwB1wC,WAAWsI,SAASooC,sBAAsBw7D,KAAKx7D;UAC5Ew7D,KAAKv7D,uBAAuB3wC,WAAWsI,SAASqoC,qBAAqBu7D,KAAKv7D;UAC1Eu7D,KAAKr3D,iBAAiB70C,WAAWsI,SAASusC,eAAeq3D,KAAKr3D;UAC9Dq3D,KAAKp3D,iBAAiB90C,WAAWsI,SAASwsC,eAAeo3D,KAAKp3D;UAC9Do3D,KAAKt7D,cAAc5wC,WAAWsI,SAASsoC,YAAYs7D,KAAKt7D;UACxDs7D,KAAKp7D,oBAAoB9wC,WAAWsI,SAASwoC,kBAAkBo7D,KAAKp7D;UACpEo7D,KAAKn7D,uBAAuB/wC,WAAWsI,SAASyoC,qBAAqBm7D,KAAKn7D;UAC1Em7D,KAAK36B,mBAAmBvxE,WAAWsI,SAASipE,iBAAiB26B,KAAK36B;UAClE26B,KAAK3lE,YAAYvmC,WAAWsI,SAASi+B,UAAU2lE,KAAK3lE;UACpD2lE,KAAKl7D,eAAehxC,WAAWsI,SAAS0oC,aAAak7D,KAAKl7D;UAC1Dk7D,KAAKrlE,aAAa7mC,WAAWsI,SAASu+B,WAAWqlE,KAAKrlE;UAEtDqlE,KAAKn9D,iBAAiB/uC;mBACdksG,KAAKn9D,iBAAiB;UAChCzmC,SAASymC,eAAem9D,KAAKn9D,eAAe,IAAI,OAAO;;UAEvDzmC,SAASymC,eAAem9D,KAAKn9D;;;;UAK3Bm9D,KAAK9oD,aAAapjD;mBACVsN,QAAQ4+F,KAAK9oD;gBACjBqB,UAAUynD,KAAK9oD,SAAS91C;UAC9BhF,SAAS86C,SAAS91C;kBAEVm3C,QAAQrjD;iBACV;cACJkH,SAAS86C,SAAS91C,MAAML,QAAQgxH,WAAWx5E,QAAQx3C;;iBAG/C;cACJ3E,SAAS86C,SAAS91C,MAAML,YAAY8qC,QAAQxC,OAAOkP,QAAQx3C;;iBAGvD;cACJ3E,SAAS86C,SAAS91C,MAAML,YAAY6W,UAAUT,UAAUohC,QAAQx3C;;iBAG5D;cACJ3E,SAAS86C,SAAS91C,MAAML,YAAYrF,UAAUyb,UAAUohC,QAAQx3C;;iBAG5D;cACJ3E,SAAS86C,SAAS91C,MAAML,YAAYugB,UAAUnK,UAAUohC,QAAQx3C;;iBAG5D;cACJ3E,SAAS86C,SAAS91C,MAAML,YAAYmb,UAAU/E,UAAUohC,QAAQx3C;;iBAG5D;cACJ3E,SAAS86C,SAAS91C,MAAML,YAAY8xB,UAAU1b,UAAUohC,QAAQx3C;;;cAIhE3E,SAAS86C,SAAS91C,MAAML,QAAQw3C,QAAQx3C;;;;UAKxCi/F,KAAKvoD,YAAY3jD,WAAWsI,SAASq7C,UAAUuoD,KAAKvoD;UACpDuoD,KAAKtoD,iBAAiB5jD,WAAWsI,SAASs7C,eAAesoD,KAAKtoD;UAC9DsoD,KAAKroD,mBAAmB7jD,WAAWsI,SAASu7C,iBAAiBqoD,KAAKroD;UAElEqoD,KAAKloD,eAAehkD;mBACZ2qC,OAAOuhE,KAAKloD;UACtB17C,SAAS07C,WAAWrZ,OAAOuhE,KAAKloD,WAAWrZ;;;;UAKzCuhE,KAAKgyB,YAAYl+H,WAAWsI,SAASgpC,cAAc46D,KAAKgyB,YAAY;;;UAGpEhyB,KAAK3/F,SAASvM,WAAWsI,SAASiE,OAAO2/F,KAAK3/F;UAC9C2/F,KAAK53D,oBAAoBt0C,WAAWsI,SAASgsC,kBAAkB43D,KAAK53D;;UAEpE43D,KAAKhoG,QAAQlE,WAAWsI,SAASpE,MAAM+5H,WAAW/xB,KAAKhoG;UACvDgoG,KAAK15D,WAAWxyC,WAAWsI,SAASkqC,SAASyrF,WAAW/xB,KAAK15D;UAC7D05D,KAAKz5D,aAAazyC,WAAWsI,SAASmqC,WAAWwrF,WAAW/xB,KAAKz5D;UACjEy5D,KAAKp5D,YAAY9yC,WAAWsI,SAASwqC,UAAUmrF,WAAW/xB,KAAKp5D;UAC/Do5D,KAAKn5D,cAAc/yC,WAAWsI,SAASyqC,YAAYm5D,KAAKn5D;UACxDm5D,KAAKl5D,cAAchzC,WAAWsI,SAAS0qC,YAAYirF,WAAW/xB,KAAKl5D;UACnEk5D,KAAKj5D,kBAAkBjzC,WAAWsI,SAAS2qC,gBAAgBi5D,KAAKj5D;UAEhEi5D,KAAKh5D,gBAAgBlzC;YACpBkzC,cAAcg5D,KAAKh5D;YAEnBxuC,MAAMC,QAAQuuC,iBAAiB;;UAElCA,eAAeA,aAAaA;;QAG7B5qC,SAAS4qC,kBAAkBpvB,UAAUT,UAAU6vB;;UAG5Cg5D,KAAK/4D,oBAAoBnzC,WAAWsI,SAAS6qC,kBAAkB8qF,WAAW/xB,KAAK/4D;UAC/E+4D,KAAK94D,sBAAsBpzC,WAAWsI,SAAS8qC,oBAAoB84D,KAAK94D;UACxE84D,KAAK74D,qBAAqBrzC,WAAWsI,SAAS+qC,mBAAmB64D,KAAK74D;UACtE64D,KAAK54D,iBAAiBtzC,WAAWsI,SAASgrC,eAAe2qF,WAAW/xB,KAAK54D;UACzE44D,KAAK34D,iBAAiBvzC,WAAWsI,SAASirC,eAAe0qF,WAAW/xB,KAAK34D;UACzE24D,KAAK14D,gBAAgBxzC,WAAWsI,SAASkrC,cAAcyqF,WAAW/xB,KAAK14D;UACvE04D,KAAKn6D,sBAAsB/xC,WAAWsI,SAASypC,oBAAoBm6D,KAAKn6D;UACxEm6D,KAAKz4D,gBAAgBzzC,WAAWsI,SAASmrC,cAAcwqF,WAAW/xB,KAAKz4D;UACvEy4D,KAAKx4D,WAAW1zC,WAAWsI,SAASorC,SAASuqF,WAAW/xB,KAAKx4D;UAC7Dw4D,KAAKt4D,oBAAoB5zC,WAAWsI,SAASsrC,kBAAkBs4D,KAAKt4D;UACpEs4D,KAAKr4D,iBAAiB7zC,WAAWsI,SAASurC,eAAeq4D,KAAKr4D;UAC9Dq4D,KAAKp4D,oBAAoB9zC,WAAWsI,SAASwrC,kBAAkBo4D,KAAKp4D;UACpEo4D,KAAKx5D,aAAa1yC,WAAWsI,SAASoqC,WAAWurF,WAAW/xB,KAAKx5D;UACjEw5D,KAAKv5D,sBAAsB3yC,WAAWsI,SAASqqC,oBAAoBu5D,KAAKv5D;UACxEu5D,KAAKt5D,UAAU5yC,WAAWsI,SAASsqC,QAAQqrF,WAAW/xB,KAAKt5D;UAC3Ds5D,KAAKr5D,mBAAmB7yC,WAAWsI,SAASuqC,iBAAiBq5D,KAAKr5D;UAClEq5D,KAAKn4D,gBAAgB/zC,WAAWsI,SAASyrC,cAAckqF,WAAW/xB,KAAKn4D;UACvEm4D,KAAK95D,iBAAiBpyC,WAAWsI,SAAS8pC,eAAe6rF,WAAW/xB,KAAK95D;UACzE85D,KAAK75D,0BAA0BryC,WAAWsI,SAAS+pC,wBAAwB4rF,WAAW/xB,KAAK75D;UAC3F65D,KAAK55D,uBAAuBtyC,WAAWsI,SAASgqC,qBAAqB2rF,WAAW/xB,KAAK55D;UACrF45D,KAAK35D,yBAAyBvyC,WAAWsI,SAASiqC,2BAA2BzuB,UAAUT,UAAU6oF,KAAK35D;UACtG25D,KAAKj4D,oBAAoBj0C,WAAWsI,SAAS2rC,kBAAkBgqF,WAAW/xB,KAAKj4D;UAC/Ei4D,KAAK/3D,iBAAiBn0C,WAAWsI,SAAS6rC,eAAe8pF,WAAW/xB,KAAK/3D;aACtE7rC;;IAGR61H,YAAYlxH;MACX,KAAK+d,WAAW/d;aACT;;;EAKT;WACQmxH,WAAW/hH;iBACNgiH,gBAAgB;mBACfA,cAAcC,OAAOjiH;;;;UAK7B+B,IAAI;eAEChc,IAAI,GAAGksB,KAAKjS,MAAMha,QAAQD,IAAIksB,IAAIlsB;;QAE1Cgc,KAAK4iC,OAAOu9E,aAAaliH,MAAMja;;;;eAKxBgwH,mBAAmBoM,OAAOpgH;eACzB3a;;eAED2a;;;WAIFqgH,eAAepzG;YACfnP,QAAQmP,IAAIqzG,YAAY;UAC1BxiH,WAAW,UAAU;aAClBmP,IAAIyoG,OAAO,GAAG53G,QAAQ;;;EAK/B,sCAAsCgjC;IACrC13C;MACC;MACA,KAAKpG,OAAO;MACZ,KAAKyiE,gBAAgBxtC;;IAGtBlV,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKi5C,gBAAgBj5C,OAAOi5C;aACrB;;IAGRj6D;iBACY,KAAKpC,cAAc2Z,KAAK;;IAGpC0J;YACOrrB,OAAO,MAAMqrB,OAAO;MAC1BrrB,KAAKqkE,gBAAgB,KAAKA;MAC1BrkE,KAAK09D,4BAA4B;aAC1B19D;;;EAKTm/H,wBAAwB56G,UAAUm5C,4BAA4B;EAE9D,uCAAuCzjB;IACtCjyC,YAAY6U,OAAOg8B,UAAUP,YAAY8kB;iBAC7B9kB,eAAe;QACzB8kB,mBAAmB9kB;QACnBA,aAAa;QACb71C,QAAQa,MAAM;;MAGf,MAAMuZ,OAAOg8B,UAAUP;MACvB,KAAK8kB,mBAAmBA,oBAAoB;;IAG7Cz7C,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKgyC,mBAAmBhyC,OAAOgyC;aACxB;;IAGR/xC;YACOrrB,OAAO,MAAMqrB;MACnBrrB,KAAKo9D,mBAAmB,KAAKA;MAC7Bp9D,KAAKo+D,6BAA6B;aAC3Bp+D;;;EAKTo/H,yBAAyB76G,UAAU65C,6BAA6B;EAEhE,mCAAmCk0D;IAClCtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRwuE,aAAa4C,WAAWpxE,MAAM6uE;MACpCL,OAAOiB,QAAQzvE,MAAMmpB;MACrBqlD,OAAOmB,iBAAiB3vE,MAAMivE;MAC9BT,OAAOgB,mBAAmBxvE,MAAM+uE;MAChCP,OAAOU,KAAK9lG,KAAK,UAAUy0F;;UAEzB2P,OAAOxtE,MAAM9gD,MAAMD,KAAKC,MAAM2+G;iBACtBr8G;cACJksH;YACHA,QAAQlsH;;YAERxB,QAAQa,MAAMW;;UAGfw+C,MAAM6uE,QAAQV,UAAU/kG;;SAEvBqkG,YAAYC;;IAGhBxuH,MAAM+qG;YACC2yB;YACAC;MAEN,8BAA8B5yB,MAAMhvF;YAC/B2hH,qBAAqB3hH,UAAUld,kBAAkB6+H,qBAAqB3hH;cACpE2rF,qBAAqBqD,KAAKrD;cAC1BD,oBAAoBC,mBAAmB3rF;cACvCq9B,SAASwkF,eAAe7yB,MAAMtD,kBAAkBruD;cAChDl+B,QAAQ2iH,cAAcp2B,kBAAkBxnG,MAAMm5C;cAC9CiuD,SAASC,kBAAkBpsF,OAAOusF,kBAAkB7rC;QAC1DyrC,GAAGtrF,OAAO0rF,kBAAkB1rF;QAC5B2hH,qBAAqB3hH,QAAQsrF;eACtBA;;MAGR,wBAAwB0D,MAAMhvF;YACzB4hH,eAAe5hH,UAAUld,kBAAkB8+H,eAAe5hH;cACxDorF,eAAe4D,KAAK5D;cACpB22B,cAAc32B,aAAaprF;cAC3BohC,SAASrE,YAAYglF,aAAa1kF;QACxCukF,eAAe5hH,QAAQohC;eAChBA;;YAGFp2C,WAAWgkG,KAAKhvC,gCAAgCyhE,gCAAgCz/E;YAChFhjC,QAAQgwF,KAAK1sG,KAAK0c;UAEpBA,UAAUlc;cACPk/H,aAAaF,cAAc9iH,MAAM9a,MAAM8a,MAAMG;QACnDnU,SAASkzC,aAAa3B,gBAAgBylF,YAAY;;YAG7CpkF,aAAaoxD,KAAK1sG,KAAKs7C;iBAElBnQ,OAAOmQ;cACXr3B,YAAYq3B,WAAWnQ;YACzBw0F;YAEA17G,UAAUkoC;gBACPi9C,oBAAoBw2B,qBAAqBlzB,KAAK1sG,MAAMikB,UAAUjkB;UACpE2/H,sBAAsBr2B,2BAA2BF,mBAAmBnlF,UAAU40B,UAAU50B,UAAUH,QAAQG,UAAUq0B;;gBAE9GonF,aAAaF,cAAcv7G,UAAUriB,MAAMqiB,UAAUpH;gBACrDgjH,wBAAwB57G,UAAUm6C,6BAA6BghE,2BAA2BnlF;UAChG0lF,sBAAsBE,sBAAsBH,YAAYz7G,UAAU40B,UAAU50B,UAAUq0B;;YAGnFr0B,UAAUnW,SAAStN,WAAWm/H,gBAAgB7xH,OAAOmW,UAAUnW;YAC/DmW,UAAU80B,UAAUv4C,WAAWm/H,gBAAgBzmF,SAASj1B,UAAU80B;YAElE90B,UAAU+0B,gBAAgBx4C;UAC7Bm/H,gBAAgB3mF,YAAYl1B,SAASG,UAAU+0B,YAAYl1B;UAC3D67G,gBAAgB3mF,YAAYhuC,QAAQiZ,UAAU+0B,YAAYhuC;;QAG3DtC,SAAS9C,aAAaulC,KAAKw0F;;YAGtBpkF,kBAAkBmxD,KAAK1sG,KAAKu7C;UAE9BA;mBACQpQ,OAAOoQ;gBACXyE,iBAAiBzE,gBAAgBpQ;gBACjCtuB;mBAEGja,IAAI,GAAGksB,KAAKkxB,eAAen9C,QAAQD,IAAIksB,IAAIlsB;kBAC7CqhB,YAAY+7B,eAAep9C;gBAC7B+8H;gBAEA17G,UAAUkoC;oBACPi9C,oBAAoBw2B,qBAAqBlzB,KAAK1sG,MAAMikB,UAAUjkB;cACpE2/H,sBAAsBr2B,2BAA2BF,mBAAmBnlF,UAAU40B,UAAU50B,UAAUH,QAAQG,UAAUq0B;;oBAE9GonF,aAAaF,cAAcv7G,UAAUriB,MAAMqiB,UAAUpH;cAC3D8iH,sBAAsB1lF,gBAAgBylF,YAAYz7G,UAAU40B,UAAU50B,UAAUq0B;;gBAG7Er0B,UAAUnW,SAAStN,WAAWm/H,gBAAgB7xH,OAAOmW,UAAUnW;YACnE+O,MAAMvc,KAAKq/H;;UAGZj3H,SAAS6yC,gBAAgBpQ,OAAOtuB;;;YAI5B2+B,uBAAuBkxD,KAAK1sG,KAAKw7C;UAEnCA;QACH9yC,SAAS8yC,uBAAuB;;YAG3BC,SAASixD,KAAK1sG,KAAKy7C,UAAUixD,KAAK1sG,KAAK8/H,aAAapzB,KAAK1sG,KAAK+/H;UAEhEtkF,WAAWj7C;iBACLoC,IAAI,GAAGgb,IAAI69B,OAAO54C,QAAQD,MAAMgb,KAAKhb;gBACvCkI,QAAQ2wC,OAAO74C;UACrB8F,SAASwzC,SAASpxC,MAAMmhC,OAAOnhC,MAAME,OAAOF,MAAMqxC;;;YAI9C1vC,iBAAiBigG,KAAK1sG,KAAKyM;UAE7BA,mBAAmBjM;cAChB6jB,aAAajc;YAEfqE,eAAe4X,WAAW7jB;UAC7B6jB,OAAOR,UAAUpX,eAAe4X;;QAGjC3b,SAAS+D,qBAAqBmwC,OAAOv4B,QAAQ5X,eAAerD;;UAGzDsjG,KAAK5+F,MAAMpF,SAASoF,OAAO4+F,KAAK5+F;UAChC4+F,KAAKrlE,UAAU3+B,SAAS2+B,WAAWqlE,KAAKrlE;aACrC3+B;;;EAKT,2BAA2B4pH;IAC1BtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRmpB,OAAO,KAAKA,SAAS,KAAKo0D,YAAYf,eAAepzG,OAAO,KAAK+/C;MACvE,KAAK6lD,eAAe,KAAKA,gBAAgB7lD;YACnCqlD,aAAa4C,WAAW,KAAKvC;MACnCL,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAOmB,iBAAiB,KAAKV;MAC7BT,OAAOgB,mBAAmB,KAAKT;MAC/BP,OAAOU,KAAK9lG,KAAK,UAAUy0F;YACtB5T,OAAO;;UAGVA,OAAOhrG,KAAKC,MAAM2+G;iBACVh9G;cACJ6sH,YAAY3vH,WAAW2vH,QAAQ7sH;UACnCb,QAAQa,MAAM,sCAAsCuoB,MAAM,KAAKvoB,MAAMC;;;cAIhEkoB,WAAWihF,KAAKjhF;YAElBA,aAAajrB,aAAairB,SAAS7pB,SAASpB,aAAairB,SAAS7pB,KAAKi1C,kBAAkB;UAC5Fp0C,QAAQa,MAAM,qCAAqCuoB;;;QAIpD42B,MAAM9gD,MAAM+qG,MAAMujB;SAChBC,YAAYC;;IAGhBxuH,MAAM+qG,MAAMujB;YACL7oF,aAAa,KAAK64F,gBAAgBvzB,KAAKtlE;YACvCyC,SAAS,KAAKq2F,YAAYxzB,KAAK7iE;YAC/BF,aAAa,KAAKw2F,gBAAgBzzB,KAAK/iE,YAAYE;YACnDje,SAAS,KAAKw0G,YAAY1zB,KAAK9gF,QAAQ;YACxCqkG,WAAWzvH,WAAWyvH,OAAOn4F;;YAE5BtM,WAAW,KAAK60G,cAAc3zB,KAAKlhF,UAAUI;YAC7Cge,YAAY,KAAK02F,eAAe5zB,KAAK9iE,WAAWpe;YAChDsM,SAAS,KAAKyoG,YAAY7zB,KAAK50E,QAAQ6R,YAAYC,WAAWxC;YAC9D0C,YAAY,KAAK02F,eAAe9zB,KAAK5iE,WAAWhS;MACtD,KAAK2oG,cAAc3oG,QAAQgS;;UAEvBmmF,WAAWzvH;YACVkgI,YAAY;mBAELhjH,QAAQkO;cACdA,OAAOlO,iBAAiB0O;YAC3Bs0G,YAAY;;;;YAKVA,cAAc,OAAOzQ,OAAOn4F;;aAG1BA;;IAGRooG,YAAYxzB;YACL7iE;UAEF6iE,SAASlsG;iBACHoC,IAAI,GAAGma,IAAI2vF,KAAK7pG,QAAQD,IAAIma,GAAGna;gBACjC8nC,YAAYi2F,QAAQl0B,SAASC,KAAK9pG;UACxCinC,OAAOa,MAAMhtB,QAAQgtB;;;aAIhBb;;IAGR22F,eAAe9zB,MAAM50E;YACdgS;YACAmsC;;MAENn+C,OAAOsR,SAAS,UAAUN;YACrBA,MAAMkjE,QAAQ/1B,MAAMntC,MAAMprB,QAAQorB;;;UAGnC4jE,SAASlsG;iBACHoC,IAAI,GAAGma,IAAI2vF,KAAK7pG,QAAQD,IAAIma,GAAGna;gBACjCkoC,eAAeyhE,WAAWE,SAASC,KAAK9pG,IAAIqzE;UAClDnsC,UAAUgB,SAASptB,QAAQotB;;;aAItBhB;;IAGRq2F,gBAAgBzzB,MAAM7iE;YACfF;UACFi3F;UAEAl0B,SAASlsG;cACNqgI,2BAA2BC;iBAExBl+H,IAAI,GAAGma,IAAI2vF,KAAK7pG,QAAQD,IAAIma,GAAGna;cACnC8F;gBACE1I,OAAO0sG,KAAK9pG;kBAEV5C,KAAK4B;iBACP;iBACA;cACJ8G,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKmhB,OAAOnhB,KAAKohB,QAAQphB,KAAKsiD,eAAetiD,KAAKuiD;;iBAGnF;iBACA;cACJ75C,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKmhB,OAAOnhB,KAAKohB,QAAQphB,KAAKkuB,OAAOluB,KAAKsiD,eAAetiD,KAAKuiD,gBAAgBviD,KAAKwiD;;iBAGpH;iBACA;cACJ95C,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKoJ,QAAQpJ,KAAKgwG,UAAUhwG,KAAKiwG,YAAYjwG,KAAKkwG;;iBAGnF;iBACA;cACJxnG,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKqwG,WAAWrwG,KAAKswG,cAActwG,KAAKohB,QAAQphB,KAAKuwG,gBAAgBvwG,KAAKuiD,gBAAgBviD,KAAKwwG,WAAWxwG,KAAKiwG,YAAYjwG,KAAKkwG;;iBAGjK;iBACA;cACJxnG,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKoJ,QAAQpJ,KAAKohB,QAAQphB,KAAKuwG,gBAAgBvwG,KAAKuiD,gBAAgBviD,KAAKwwG,WAAWxwG,KAAKiwG,YAAYjwG,KAAKkwG;;iBAG3I;iBACA;cACJxnG,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKoJ,QAAQpJ,KAAKsiD,eAAetiD,KAAKuiD,gBAAgBviD,KAAK2+G,UAAU3+G,KAAK4+G,WAAW5+G,KAAKiwG,YAAYjwG,KAAKkwG;;iBAG5I;iBACA;iBACA;iBACA;iBACA;iBACA;iBACA;iBACA;cACJxnG,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKoJ,QAAQpJ,KAAK0oG;;iBAGnD;iBACA;cACJhgG,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKu/G,aAAav/G,KAAKw/G,aAAax/G,KAAKy/G,eAAez/G,KAAK0/G,aAAa1/G,KAAKiwG,YAAYjwG,KAAKkwG;;iBAGjI;iBACA;cACJxnG,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKoJ,QAAQpJ,KAAK0gH,MAAM1gH,KAAKuwG,gBAAgBvwG,KAAK2gH,iBAAiB3gH,KAAK4gH;;iBAGzG;iBACA;cACJl4G,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKoJ,QAAQpJ,KAAK0gH,MAAM1gH,KAAK2gH,iBAAiB3gH,KAAKuwG,gBAAgBvwG,KAAK0yB,GAAG1yB,KAAKif;;iBAGjH;iBACA;;;cAGJvW,eAAe05G,WAAWpiH,KAAK4B,UAAUo4H,OAAOh6H,KAAK4rE,KAAKhqE,QAAQ6qG,SAASzsG,KAAK4rE,OAAO5rE,KAAK2gH,iBAAiB3gH,KAAKoJ,QAAQpJ,KAAKuwG,gBAAgBvwG,KAAKuhH;;iBAGhJ;iBACA;cACJ74G,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAKu3B,QAAQv3B,KAAKgwG,UAAUhwG,KAAK2+G,UAAU3+G,KAAK4+G;;iBAGjF;iBACA;cACJl2G,eAAe05G,WAAWpiH,KAAK4B,MAAM5B,KAAK0iD,UAAU1iD,KAAKg9C,SAASh9C,KAAKoJ,QAAQpJ,KAAK+gI;;iBAGhF;iBACA;cACJH;uBAES7lG,IAAI,GAAG8hB,KAAK78C,KAAK6pC,OAAOhnC,QAAQk4B,IAAI8hB,IAAI9hB;sBAC1C2P,QAAQb,OAAO7pC,KAAK6pC,OAAO9O;gBACjC6lG,eAAetgI,KAAKoqC;;cAGrBhiC,eAAe05G,WAAWpiH,KAAK4B,MAAMg/H,gBAAgB5gI,KAAKi5G;;iBAGtD;iBACA;cACJ2nB;uBAES7lG,IAAI,GAAG8hB,KAAK78C,KAAK6pC,OAAOhnC,QAAQk4B,IAAI8hB,IAAI9hB;sBAC1C2P,QAAQb,OAAO7pC,KAAK6pC,OAAO9O;gBACjC6lG,eAAetgI,KAAKoqC;;oBAGf8uE,cAAcx5G,KAAK6N,QAAQ2rG;kBAE7BA,gBAAgBh5G;gBACnBR,KAAK6N,QAAQ2rG,kBAAkBwgB,OAAOxgB,YAAY53G,QAAQ6qG,SAAS+M;;cAGpE9wG,eAAe05G,WAAWpiH,KAAK4B,MAAMg/H,gBAAgB5gI,KAAK6N;;iBAGtD;iBACA;cACJnF,WAAWm4H,qBAAqBl/H,MAAM3B;;iBAGlC;cACJyC,QAAQa,MAAM;;;cAIdb,QAAQ0B,KAAK,oDAAoDnE,KAAK4B,OAAO;;;UAI/E8G,SAASgV,OAAO1d,KAAK0d;cACjB1d,KAAK8N,SAAStN,WAAWkI,SAASoF,OAAO9N,KAAK8N;cAC9CpF,SAASu2C,qBAAqB,QAAQj/C,KAAKqnC,aAAa7mC,WAAWkI,SAAS2+B,WAAWrnC,KAAKqnC;UAChGsC,WAAW3pC,KAAK0d,QAAQhV;;;aAInBihC;;IAGR22F,eAAe5zB,MAAMlhF;YACdtkB;;YAEA0iC;UAEF8iE,SAASlsG;cACNywH,aAAa+P;QACnB/P,OAAO0N,YAAYnzG;iBAEV5oB,IAAI,GAAGma,IAAI2vF,KAAK7pG,QAAQD,IAAIma,GAAGna;gBACjC5C,OAAO0sG,KAAK9pG;cAEd5C,KAAK4B,SAAS;;kBAEXib;qBAEGke,IAAI,GAAGA,IAAI/6B,KAAK4pC,UAAU/mC,QAAQk4B;oBACpCjyB,WAAW9I,KAAK4pC,UAAU7O;kBAE5B7zB,MAAM4B,SAAS4U,UAAUld;gBAC5B0G,MAAM4B,SAAS4U,QAAQuzG,OAAOtvH,MAAMmH;;cAGrC+T,MAAMvc,KAAK4G,MAAM4B,SAAS4U;;YAG3BksB,UAAU5pC,KAAK0d,QAAQb;;gBAEnB3V,MAAMlH,KAAK0d,UAAUld;cACxB0G,MAAMlH,KAAK0d,QAAQuzG,OAAOtvH,MAAM3B;;YAGjC4pC,UAAU5pC,KAAK0d,QAAQxW,MAAMlH,KAAK0d;;;;aAK9BksB;;IAGRq2F,gBAAgBvzB;YACTtlE;UAEFslE,SAASlsG;iBACHoC,IAAI,GAAGA,IAAI8pG,KAAK7pG,QAAQD;gBAC1B5C,OAAO0sG,KAAK9pG;gBACZyjH,OAAOyN,cAAcnyH,MAAM3B;UACjConC,WAAWi/E,KAAK3oG,QAAQ2oG;;;aAInBj/E;;IAGRg5F,YAAY1zB,MAAMujB;YACXxtE,QAAQ;YACR72B;UACFqlG;MAEJ,mBAAmBplG;QAClB42B,MAAM6uE,QAAQZ,UAAU7kG;eACjBolG,OAAOU,KAAK9lG,KAAK;UACvB42B,MAAM6uE,QAAQX,QAAQ9kG;WACpBrrB,WAAW;UACbiiD,MAAM6uE,QAAQV,UAAU/kG;UACxB42B,MAAM6uE,QAAQX,QAAQ9kG;;;MAIxB,0BAA0B7C;mBACdA,UAAU;gBACd6C,MAAM7C;gBACN4iD,QAAO,6BAA4BtqE,KAAKuqB,OAAOA,MAAM42B,MAAMgvE,eAAe5lG;iBACzEo1G,UAAUr1D;;cAEb5iD,MAAMhpB;;cAERA,MAAMw/H,cAAcx2G,MAAMpnB,MAAMonB,MAAMhpB;cACtCmhB,OAAO6H,MAAM7H;cACbC,QAAQ4H,MAAM5H;;;mBAGR;;;;UAKNsrF,SAASlsG,aAAaksG,KAAK7pG,SAAS;cACjCyuH,cAAcD,eAAepB;QACnCgB,aAAauD,YAAYlD;QACzBL,OAAOe,eAAe,KAAKT;iBAElB3uH,IAAI,GAAGksB,KAAK49E,KAAK7pG,QAAQD,IAAIksB,IAAIlsB;gBACnComB,QAAQ0jF,KAAK9pG;gBACbipB,MAAM7C,MAAM6C;cAEd3mB,MAAMC,QAAQ0mB;;YAEjBD,OAAO5C,MAAMtL;qBAEJqd,IAAI,GAAG8hB,KAAKhxB,IAAIhpB,QAAQk4B,IAAI8hB,IAAI9hB;oBAClCmmG,aAAar1G,IAAIkP;oBACjBomG,oBAAoBC,iBAAiBF;kBAEvCC,sBAAsB;oBACrBA,6BAA6B/0G;kBAChCR,OAAO5C,MAAMtL,MAAMpd,KAAK6gI;;;kBAGxBv1G,OAAO5C,MAAMtL,MAAMpd,SAAS2rG,YAAYk1B,kBAAkBnhI,MAAMmhI,kBAAkBhgH,OAAOggH,kBAAkB//G;;;;;;kBAMxG+/G,oBAAoBC,iBAAiBp4G,MAAM6C;gBAE7Cs1G,sBAAsB;cACzBv1G,OAAO5C,MAAMtL,QAAQyjH;;;;;aAMlBv1G;;IAGRy0G,cAAc3zB,MAAM9gF;MACnB,uBAAuBne,OAAO7L;mBAClB6L,UAAU,iBAAiBA;QACtChL,QAAQ0B,KAAK,wEAAwEsJ;eAC9E7L,KAAK6L;;YAGP+d;UAEFkhF,SAASlsG;iBACHoC,IAAI,GAAGma,IAAI2vF,KAAK7pG,QAAQD,IAAIma,GAAGna;gBACjC5C,OAAO0sG,KAAK9pG;cAEd5C,KAAKgpB,UAAUxoB;YAClBiC,QAAQ0B,KAAK,gDAAgDnE,KAAK0d;;cAG/DkO,OAAO5rB,KAAKgpB,WAAWxoB;YAC1BiC,QAAQ0B,KAAK,uCAAuCnE,KAAKgpB;;cAGtDsF;gBACEtF,QAAQ4C,OAAO5rB,KAAKgpB;cAEtB9jB,MAAMC,QAAQ6jB;YACjBsF,cAAcy5B,YAAY/+B;gBACtBA,MAAMnmB,WAAW,GAAGyrB,QAAQpC,cAAc;;gBAE1ClD,SAASA,MAAMhpB;cAClBsuB,cAAc29E,YAAYjjF,MAAMhpB,MAAMgpB,MAAM7H,OAAO6H,MAAM5H;;cAEzDkN,cAAczE,QAAQb;;gBAGnBA,OAAOsF,QAAQpC,cAAc;;UAGlCoC,QAAQ5Q,OAAO1d,KAAK0d;cAChB1d,KAAK8N,SAAStN,WAAW8tB,QAAQxgB,OAAO9N,KAAK8N;cAC7C9N,KAAK+pB,YAAYvpB,WAAW8tB,QAAQvE,UAAUs3G,cAAcrhI,KAAK+pB,SAASu3G;cAC1EthI,KAAK8jB,WAAWtjB,WAAW8tB,QAAQxK,OAAOD,UAAU7jB,KAAK8jB;cACzD9jB,KAAK2qB,WAAWnqB,WAAW8tB,QAAQ3D,OAAO9G,UAAU7jB,KAAK2qB;cACzD3qB,KAAKqkB,WAAW7jB,WAAW8tB,QAAQjK,OAAOR,UAAU7jB,KAAKqkB;cACzDrkB,KAAKwL,aAAahL,WAAW8tB,QAAQ9iB,WAAWxL,KAAKwL;cAErDxL,KAAK2rB,SAASnrB;YACjB8tB,QAAQrE,QAAQo3G,cAAcrhI,KAAK2rB,KAAK,IAAI41G;YAC5CjzG,QAAQpE,QAAQm3G,cAAcrhI,KAAK2rB,KAAK,IAAI41G;;cAGzCvhI,KAAKqqB,WAAW7pB,WAAW8tB,QAAQjE,SAASrqB,KAAKqqB;cACjDrqB,KAAK4B,SAASpB,WAAW8tB,QAAQ1sB,OAAO5B,KAAK4B;cAC7C5B,KAAKuqB,aAAa/pB,WAAW8tB,QAAQ/D,WAAWvqB,KAAKuqB;cACrDvqB,KAAKoqB,cAAc5pB,WAAW8tB,QAAQlE,YAAYi3G,cAAcrhI,KAAKoqB,WAAWo3G;cAChFxhI,KAAKmqB,cAAc3pB,WAAW8tB,QAAQnE,YAAYk3G,cAAcrhI,KAAKmqB,WAAWq3G;cAChFxhI,KAAKsqB,eAAe9pB,WAAW8tB,QAAQhE,aAAatqB,KAAKsqB;cACzDtqB,KAAK+qB,UAAUvqB,WAAW8tB,QAAQvD,QAAQ/qB,KAAK+qB;cAC/C/qB,KAAK8qB,qBAAqBtqB,WAAW8tB,QAAQxD,mBAAmB9qB,KAAK8qB;cACrE9qB,KAAKgrB,oBAAoBxqB,WAAW8tB,QAAQtD,kBAAkBhrB,KAAKgrB;UACvEQ,SAASxrB,KAAK0d,QAAQ4Q;;;aAIjB9C;;IAGR+0G,YAAYvgI,MAAM2pC,YAAYC,WAAWxC;UACpCtP;MAEJ,qBAAqBhqB;YAChB67B,WAAW77B,UAAUtN;UACxBiC,QAAQ0B,KAAK,0CAA0C2J;;eAGjD67B,WAAW77B;;MAGnB,qBAAqBA;YAChBA,SAAStN,kBAAkBA;YAE3B0E,MAAMC,QAAQ2I;gBACX+O;mBAEGja,IAAI,GAAGma,IAAIjP,KAAKjL,QAAQD,IAAIma,GAAGna;kBACjC8a,OAAO5P,KAAKlL;gBAEdgnC,UAAUlsB,UAAUld;cACvBiC,QAAQ0B,KAAK,0CAA0CuZ;;YAGxDb,MAAMvc,KAAKspC,UAAUlsB;;iBAGfb;;YAGJ+sB,UAAU97B,UAAUtN;UACvBiC,QAAQ0B,KAAK,0CAA0C2J;;eAGjD87B,UAAU97B;;UAGdpF,UAAUI;cAEN9I,KAAK4B;aACP;UACJk2B,aAAazpB;cAETrO,KAAK04D,eAAel4D;gBACnBswB,OAAOo3B,UAAUloD,KAAK04D;cACzB5gC,OAAO4gC,iBAAiBngB,MAAMv4C,KAAK04D;;;cAIjC14D,KAAKgP,QAAQxO;gBACZR,KAAKgP,IAAIpN,SAAS;cACrBk2B,OAAO9oB,UAAUC,IAAIjP,KAAKgP,IAAIhG,OAAOhJ,KAAKgP,IAAI80B,MAAM9jC,KAAKgP,IAAI+0B;uBACnD/jC,KAAKgP,IAAIpN,SAAS;cAC5Bk2B,OAAO9oB,UAAU65F,QAAQ7oG,KAAKgP,IAAIhG,OAAOhJ,KAAKgP,IAAI8qF;;;;aAMhD;UACJhiE,aAAagvB,kBAAkB9mD,KAAKqlD,KAAKrlD,KAAKslD,QAAQtlD,KAAK8jC,MAAM9jC,KAAK+jC;cAClE/jC,KAAKwlD,UAAUhlD,WAAWs3B,OAAO0tB,QAAQxlD,KAAKwlD;cAC9CxlD,KAAKulD,SAAS/kD,WAAWs3B,OAAOytB,OAAOvlD,KAAKulD;cAC5CvlD,KAAK0lD,cAAcllD,WAAWs3B,OAAO4tB,YAAY1lD,KAAK0lD;cACtD1lD,KAAK2lD,eAAenlD,WAAWs3B,OAAO6tB,aAAa3lD,KAAK2lD;cACxD3lD,KAAKylD,SAASjlD,WAAWs3B,OAAO2tB,OAAO1lC,OAAOuhC,WAAWthD,KAAKylD;;aAG9D;UACJ3tB,aAAa6lG,mBAAmB39H,KAAK0jC,MAAM1jC,KAAK2jC,OAAO3jC,KAAK4jC,KAAK5jC,KAAK6jC,QAAQ7jC,KAAK8jC,MAAM9jC,KAAK+jC;cAC1F/jC,KAAKulD,SAAS/kD,WAAWs3B,OAAOytB,OAAOvlD,KAAKulD;cAC5CvlD,KAAKylD,SAASjlD,WAAWs3B,OAAO2tB,OAAO1lC,OAAOuhC,WAAWthD,KAAKylD;;aAG9D;UACJ3tB,aAAanpB,aAAa3O,KAAKgJ,OAAOhJ,KAAK4O;;aAGvC;UACJkpB,aAAahpB,iBAAiB9O,KAAKgJ,OAAOhJ,KAAK4O;;aAG3C;UACJkpB,aAAa0lG,WAAWx9H,KAAKgJ,OAAOhJ,KAAK4O,WAAW5O,KAAK0M,UAAU1M,KAAKk3D;;aAGpE;UACJp/B,aAAagmG,cAAc99H,KAAKgJ,OAAOhJ,KAAK4O,WAAW5O,KAAKmhB,OAAOnhB,KAAKohB;;aAGpE;UACJ0W,aAAaolG,UAAUl9H,KAAKgJ,OAAOhJ,KAAK4O,WAAW5O,KAAK0M,UAAU1M,KAAKijB,OAAOjjB,KAAK66E,UAAU76E,KAAKk3D;;aAG9F;UACJp/B,aAAaukG,gBAAgBr8H,KAAKgJ,OAAOhJ,KAAK83D,aAAa93D,KAAK4O;;aAG5D;UACJkpB,aAAa0mG,aAAa/xB,SAASzsG;;aAG/B;UACJ0I,WAAW+4H,YAAYzhI,KAAK0I;UAC5BI,WAAW44H,YAAY1hI,KAAK8I;UAC5BgvB,aAAag0E,YAAYpjG,UAAUI;cAC/B9I,KAAK4qC,aAAapqC,WAAWs3B,OAAO8S,WAAW5qC,KAAK4qC;cACpD5qC,KAAK6qC,eAAerqC,WAAWs3B,OAAO+S,WAAWhnB,UAAU7jB,KAAK6qC;cAChE7qC,KAAK8qC,aAAatqC,WAAWs3B,OAAOgT,WAAW9qC,KAAK8qC;;aAGpD;UACJpiC,WAAW+4H,YAAYzhI,KAAK0I;UAC5BI,WAAW44H,YAAY1hI,KAAK8I;UAC5BgvB,aAAa5uB,KAAKR,UAAUI;;aAGxB;UACJJ,WAAW+4H,YAAYzhI,KAAK0I;UAC5BI,WAAW44H,YAAY1hI,KAAK8I;gBACtBkC,QAAQhL,KAAKgL;gBACbi/B,iBAAiBjqC,KAAKiqC;gBACtBC,gBAAgBlqC,KAAKkqC;UAC3BpS,aAAaw1E,cAAc5kG,UAAUI,UAAUkC;UAC/C8sB,OAAOmS,qBAAqBgQ,oBAAoBW,aAAa3Q,eAAeptB,QAAQ;cAChFqtB,kBAAkB1pC,WAAWs3B,OAAOoS,oBAAoB+P,oBAAoBW,aAAa1Q,cAAcrtB,QAAQqtB,cAAc2O;;aAG7H;UACJ/gB,aAAa6pG;;aAGT;UACJ7pG,aAAak2E,KAAKyzB,YAAYzhI,KAAK0I,WAAWg5H,YAAY1hI,KAAK8I;;aAG3D;UACJgvB,aAAa62E,SAAS8yB,YAAYzhI,KAAK0I,WAAWg5H,YAAY1hI,KAAK8I;;aAG/D;UACJgvB,aAAa42E,aAAa+yB,YAAYzhI,KAAK0I,WAAWg5H,YAAY1hI,KAAK8I;;aAGnE;aACA;UACJgvB,aAAak3E,OAAOyyB,YAAYzhI,KAAK0I,WAAWg5H,YAAY1hI,KAAK8I;;aAG7D;UACJgvB,aAAawyE,OAAOo3B,YAAY1hI,KAAK8I;;aAGjC;UACJgvB,aAAa/sB;;aAGT;UACJ+sB,aAAai0E;;;UAIbj0E,aAAaqO;;MAGfrO,OAAOpa,OAAO1d,KAAK0d;UACf1d,KAAK8N,SAAStN,WAAWs3B,OAAOhqB,OAAO9N,KAAK8N;UAE5C9N,KAAK2oB,WAAWnoB;QACnBs3B,OAAOnP,OAAO9E,UAAU7jB,KAAK2oB;YACzB3oB,KAAK4qB,qBAAqBpqB,WAAWs3B,OAAOlN,mBAAmB5qB,KAAK4qB;YACpEkN,OAAOlN,kBAAkBkN,OAAOnP,OAAOya,UAAUtL,OAAOvuB,UAAUuuB,OAAO1G,YAAY0G,OAAOtP;;YAE5FxoB,KAAKuJ,aAAa/I,WAAWs3B,OAAOvuB,SAASsa,UAAU7jB,KAAKuJ;YAC5DvJ,KAAKwL,aAAahL,WAAWs3B,OAAOtsB,SAASqY,UAAU7jB,KAAKwL;YAC5DxL,KAAKoxB,eAAe5wB,WAAWs3B,OAAO1G,WAAWvN,UAAU7jB,KAAKoxB;YAChEpxB,KAAKwoB,UAAUhoB,WAAWs3B,OAAOtP,MAAM3E,UAAU7jB,KAAKwoB;;UAGvDxoB,KAAKgnC,eAAexmC,WAAWs3B,OAAOkP,aAAahnC,KAAKgnC;UACxDhnC,KAAKinC,kBAAkBzmC,WAAWs3B,OAAOmP,gBAAgBjnC,KAAKinC;UAE9DjnC,KAAKk5D;YACJl5D,KAAKk5D,OAAOuhB,SAASj6E,WAAWs3B,OAAOohC,OAAOuhB,OAAOz6E,KAAKk5D,OAAOuhB;YACjEz6E,KAAKk5D,OAAOwhB,eAAel6E,WAAWs3B,OAAOohC,OAAOwhB,aAAa16E,KAAKk5D,OAAOwhB;YAC7E16E,KAAKk5D,OAAO9vD,WAAW5I,WAAWs3B,OAAOohC,OAAO9vD,SAASpJ,KAAKk5D,OAAO9vD;YACrEpJ,KAAKk5D,OAAOyhB,YAAYn6E,WAAWs3B,OAAOohC,OAAOyhB,QAAQ92D,UAAU7jB,KAAKk5D,OAAOyhB;YAC/E36E,KAAKk5D,OAAOrkC,WAAWr0B,WAAWs3B,OAAOohC,OAAOrkC,SAAS,KAAK0rG,YAAYvgI,KAAKk5D,OAAOrkC;;UAGvF70B,KAAK+mC,YAAYvmC,WAAWs3B,OAAOiP,UAAU/mC,KAAK+mC;UAClD/mC,KAAKknC,kBAAkB1mC,WAAWs3B,OAAOoP,gBAAgBlnC,KAAKknC;UAC9DlnC,KAAKmnC,gBAAgB3mC,WAAWs3B,OAAOqP,cAAcnnC,KAAKmnC;UAC1DnnC,KAAKqnC,aAAa7mC,WAAWs3B,OAAOuP,WAAWrnC,KAAKqnC;UACpDrnC,KAAKqlC,WAAW7kC,WAAWs3B,OAAOuN,OAAOP,OAAO9kC,KAAKqlC;UAErDrlC,KAAK64B,aAAar4B;cACfq4B,WAAW74B,KAAK64B;iBAEbj2B,IAAI,GAAGA,IAAIi2B,SAASh2B,QAAQD;UACpCk1B,OAAO7tB,IAAI,KAAKs2H,YAAY1nG,SAASj2B,IAAI+mC,YAAYC,WAAWxC;;;UAI9DpnC,KAAKonC,eAAe5mC;cACjBohI,mBAAmB5hI,KAAKonC;iBAErBxkC,IAAI,GAAGA,IAAIg/H,iBAAiB/+H,QAAQD;gBACtC8a,OAAOkkH,iBAAiBh/H;UAC9Bk1B,OAAOsP,WAAW9mC,KAAK8mC,WAAW1pB;;;UAIhC1d,KAAK4B,SAAS;YACb5B,KAAK09E,eAAel9E,WAAWs3B,OAAO4lD,aAAa19E,KAAK09E;cACtDktB,SAAS5qG,KAAK4qG;iBAEX7tF,IAAI,GAAGA,IAAI6tF,OAAO/nG,QAAQka;gBAC5BkqF,QAAQ2D,OAAO7tF;gBACf+rB,QAAQhR,OAAO8Q,oBAAoB,QAAQq+D,MAAMnvE;cAEnDgR,UAAUtoC;YACbs3B,OAAO+yE,SAAS/hE,OAAOm+D,MAAMv6F;;;;aAKzBorB;;IAGR2oG,cAAc3oG,QAAQgS;UACjB/pB,OAAO+/B,KAAKhW,WAAWjnC,WAAW;MACtCi1B,OAAOsR,SAAS,UAAUN;YACrBA,MAAM6B,kBAAkB,QAAQ7B,MAAMgC,aAAatqC;gBAChDsqC,WAAWhB,UAAUhB,MAAMgC;cAE7BA,aAAatqC;YAChBiC,QAAQ0B,KAAK,oDAAoD2kC,MAAMgC;;YAEvEhC,MAAMwiE,KAAKxgE,UAAUhC,MAAM+B;;;;;;IAQ/Bg3F,eAAep0H;MACdhL,QAAQ0B,KAAK;aACN,KAAKguH,gBAAgB1kH;;;QAKxB6zH;IACL7tH,WAAWA;IACXC,uBAAuBA;IACvBC,uBAAuBA;IACvBC,kCAAkCA;IAClCC,kCAAkCA;IAClCC,yBAAyBA;IACzBC,yBAAyBA;;QAEpBwtH;IACLvtH,gBAAgBA;IAChBC,qBAAqBA;IACrBC,wBAAwBA;;QAEnBstH;IACLrtH,eAAeA;IACfC,4BAA4BA;IAC5BE,2BAA2BA;IAC3BE,cAAcA;IACdC,2BAA2BA;IAC3BE,0BAA0BA;;EAG3B,gCAAgC29G;IAC/BtqH,YAAYspH;MACX,MAAMA;iBAEKwQ,sBAAsB;QAChCr/H,QAAQ0B,KAAK;;iBAGH49H,UAAU;QACpBt/H,QAAQ0B,KAAK;;MAGd,KAAK0J;QACJid,kBAAkB;;;IAIpBk3G,WAAWn0H;MACV,KAAKA,UAAUA;aACR;;IAGR8jH,KAAK9lG,KAAKokG,QAAQC,YAAYC;UACzBtkG,QAAQrrB,WAAWqrB,MAAM;UACzB,KAAK+/C,SAASprE,WAAWqrB,MAAM,KAAK+/C,OAAO//C;MAC/CA,MAAM,KAAKylG,QAAQT,WAAWhlG;YACxB42B,QAAQ;YACRx7C,SAAS6oH,MAAM1jE,IAAIvgC;UAErB5kB,WAAWzG;QACdiiD,MAAM6uE,QAAQZ,UAAU7kG;QACxBzlB,WAAW;cACN6pH,QAAQA,OAAOhpH;UACnBw7C,MAAM6uE,QAAQX,QAAQ9kG;WACpB;eACI5kB;;YAGFg7H;MACNA,aAAaC,cAAc,KAAK3Q,gBAAgB,cAAc,gBAAgB;MAC9E0Q,aAAaE,UAAU,KAAKzQ;MAC5BqQ,MAAMl2G,KAAKo2G,cAAcG,KAAK,UAAUC;eAChCA,IAAIC;SACTF,KAAK,UAAUE;eACVR,kBAAkBQ,MAAMviH,OAAOuhC,OAAOmB,MAAM50C;UAClD00H,sBAAsB;;SAErBH,KAAK,UAAUI;QACjB1S,MAAM7lH,IAAI4hB,KAAK22G;YACXvS,QAAQA,OAAOuS;QACnB//E,MAAM6uE,QAAQX,QAAQ9kG;SACpB42G,MAAM,UAAUx+H;YACdksH,SAASA,QAAQlsH;QACrBw+C,MAAM6uE,QAAQV,UAAU/kG;QACxB42B,MAAM6uE,QAAQX,QAAQ9kG;;MAEvB42B,MAAM6uE,QAAQZ,UAAU7kG;;;EAK1B62G,kBAAkBn+G,UAAUo+G,sBAAsB;EAElD;IACC36H;MACC,KAAKpG,OAAO;MACZ,KAAKoH,YAAYuvC;MACjB,KAAKqqF;MACL,KAAKC,cAAc;;IAGpB7H,OAAOxxH,GAAGG;MACT,KAAKk5H,kBAAkB5G;MACvB,KAAK2G,SAAStiI,KAAK,KAAKuiI;MACxB,KAAKA,YAAY7H,OAAOxxH,GAAGG;aACpB;;IAGRsxH,OAAOzxH,GAAGG;MACT,KAAKk5H,YAAY5H,OAAOzxH,GAAGG;aACpB;;IAGRuxH,iBAAiBC,MAAMC,MAAM5E,IAAIC;MAChC,KAAKoM,YAAY3H,iBAAiBC,MAAMC,MAAM5E,IAAIC;aAC3C;;IAGR4E,cAAcC,OAAOC,OAAOC,OAAOC,OAAOjF,IAAIC;MAC7C,KAAKoM,YAAYxH,cAAcC,OAAOC,OAAOC,OAAOC,OAAOjF,IAAIC;aACxD;;IAGRiF,WAAWpjB;MACV,KAAKuqB,YAAYnH,WAAWpjB;aACrB;;IAGRwqB,SAASC,OAAOC;MACf,yBAAyBC;cAClBp5F;iBAEGjnC,IAAI,GAAGma,IAAIkmH,WAAWpgI,QAAQD,IAAIma,GAAGna;gBACvCsgI,UAAUD,WAAWrgI;gBACrBugI,eAAexC;UACrBwC,SAASjJ,SAASgJ,QAAQhJ;UAC1BrwF,OAAOvpC,KAAK6iI;;eAGNt5F;;MAGR,8BAA8BgxE,MAAMuoB;cAC7BC,UAAUD,UAAUvgI;;;;;YAKtBk1G,SAAS;iBAEJrlF,IAAI2wG,UAAU,GAAGpkH,IAAI,GAAGA,IAAIokH,SAAS3wG,IAAIzT;cAC7CqkH,YAAYF,UAAU1wG;cACtB6wG,aAAaH,UAAUnkH;cACvBukH,SAASD,WAAW/5H,IAAI85H,UAAU95H;cAClCi6H,SAASF,WAAW55H,IAAI25H,UAAU35H;cAElChC,KAAK4W,IAAIklH,UAAU3yG,OAAOC;;gBAEzB0yG,SAAS;cACZH,YAAYF,UAAUnkH;cACtBukH,UAAUA;cACVD,aAAaH,UAAU1wG;cACvB+wG,UAAUA;;gBAGP5oB,KAAKlxG,IAAI25H,UAAU35H,KAAKkxG,KAAKlxG,IAAI45H,WAAW55H;gBAE5CkxG,KAAKlxG,MAAM25H,UAAU35H;kBACpBkxG,KAAKrxG,MAAM85H,UAAU95H,UAAU;;oBAG7Bk6H,WAAWD,UAAU5oB,KAAKrxG,IAAI85H,UAAU95H,KAAKg6H,UAAU3oB,KAAKlxG,IAAI25H,UAAU35H;kBAC5E+5H,aAAa,UAAU;;kBAEvBA,WAAW;cACf3rB,UAAUA;;;;gBAIP8C,KAAKlxG,MAAM25H,UAAU35H;;;gBAGrB45H,WAAW/5H,KAAKqxG,KAAKrxG,KAAKqxG,KAAKrxG,KAAK85H,UAAU95H,KAAK85H,UAAU95H,KAAKqxG,KAAKrxG,KAAKqxG,KAAKrxG,KAAK+5H,WAAW/5H,UAAU;;;eAK1GuuG;;YAGFM,cAAcE,WAAWF;YACzBuqB,WAAW,KAAKA;UAClBA,SAAS//H,WAAW;UACpBmgI,YAAY,aAAaW,gBAAgBf;UACzCgB,OAAOV,SAASC;YACdt5F;UAEF+4F,SAAS//H,WAAW;QACvBqgI,UAAUN,SAAS;QACnBO,eAAexC;QACfwC,SAASjJ,SAASgJ,QAAQhJ;QAC1BrwF,OAAOvpC,KAAK6iI;eACLt5F;;UAGJg6F,cAAcxrB,YAAYuqB,SAAS,GAAG5N;MAC1C6O,aAAad,SAASc,aAAaA;;YAE7BC;YACAC;UACFC;UACAC,UAAU;UACVC;MACJH,UAAUE,WAAWzjI;MACrBwjI,cAAcC;eAELrhI,IAAI,GAAGma,IAAI6lH,SAAS//H,QAAQD,IAAIma,GAAGna;QAC3CsgI,UAAUN,SAAShgI;QACnBshI,YAAYhB,QAAQlO;QACpB4O,QAAQvrB,YAAY6rB;QACpBN,QAAQb,SAASa,QAAQA;YAErBA;eACEC,cAAcE,UAAUE,UAAUA;UACvCF,UAAUE;YACTrlH,OAAO+hH;YACPjuG,GAAGwxG;;UAEJH,UAAUE,SAASrlH,EAAEs7G,SAASgJ,QAAQhJ;cAClC2J,YAAYI;UAChBD,cAAcC;;UAEdD,cAAcC,SAAS3jI;YACtB8mB,GAAG87G;YACHxwG,GAAGwxG,UAAU;;;;;WAMXH,UAAU,WAAWJ,gBAAgBf;UAEtCmB,UAAUlhI,SAAS;YAClBshI,YAAY;cACVC;iBAEGC,OAAO,GAAGC,OAAOP,UAAUlhI,QAAQwhI,OAAOC,MAAMD;UACxDP,iBAAiBO;;iBAGTA,OAAO,GAAGC,OAAOP,UAAUlhI,QAAQwhI,OAAOC,MAAMD;gBAClDE,MAAMP,cAAcK;mBAEjBG,OAAO,GAAGA,OAAOD,IAAI1hI,QAAQ2hI;kBAC/BC,KAAKF,IAAIC;gBACXE,kBAAkB;qBAEbC,QAAQ,GAAGA,QAAQZ,UAAUlhI,QAAQ8hI;kBACzCC,qBAAqBH,GAAG/xG,GAAGqxG,UAAUY,OAAOjyG;oBAC3C2xG,SAASM,OAAOP,SAAS9jI;kBAC5BukI,OAAOR;kBACPS,KAAKH;kBACLvuB,MAAMouB;;oBAGHE;kBACHA,kBAAkB;kBAClBZ,iBAAiBa,OAAOrkI,KAAKmkI;;kBAE7BN,YAAY;;;;gBAKXO;cACHZ,iBAAiBO,MAAM/jI,KAAKmkI;;;;;YAM3BL,SAASvhI,SAAS;;eAEhBshI,WAAWH,gBAAgBF;;;UAI9BiB;eAEKniI,IAAI,GAAGksB,KAAKi1G,UAAUlhI,QAAQD,IAAIksB,IAAIlsB;QAC9CugI,WAAWY,UAAUnhI,GAAGgc;QACxBirB,OAAOvpC,KAAK6iI;QACZ4B,WAAWf,cAAcphI;iBAEhBm4B,IAAI,GAAG8hB,KAAKkoF,SAASliI,QAAQk4B,IAAI8hB,IAAI9hB;UAC7CooG,SAAS1qB,MAAMn4G,KAAKykI,SAAShqG,GAAG3T;;;;aAK3ByiB;;;EAKT;IACC7hC,YAAYhI;MACX,KAAK4B,OAAO;MACZ,KAAK5B,OAAOA;;IAGbygH,eAAeH,MAAMvzG,OAAO;YACrB88B;YACAm7F,QAAQC,YAAY3kB,MAAMvzG,MAAM,KAAK/M;eAElC0yB,IAAI,GAAGqkD,KAAKiuD,MAAMniI,QAAQ6vB,IAAIqkD,IAAIrkD;QAC1CxtB,MAAMqf,UAAUjkB,KAAKiH,MAAMsiC,QAAQm7F,MAAMtyG,GAAGowG;;aAGtCj5F;;;EAKT,qBAAqBy2E,MAAMvzG,MAAM/M;UAC1BklI,QAAQhgI,MAAM6/G,KAAKzE;UACnB93F,QAAQzb,OAAO/M,KAAKq9E;UACpB8nD,eAAenlI,KAAKy4B,YAAY2sG,OAAOplI,KAAKy4B,YAAY4sG,OAAOrlI,KAAKslI,sBAAsB98G;UAC1Fw8G;QACFt+E,UAAU,GACZC,UAAU;aAEH/jD,IAAI,GAAGA,IAAIsiI,MAAMriI,QAAQD;YAC3B2iI,OAAOL,MAAMtiI;UAEf2iI,SAAS;QACZ7+E,UAAU;QACVC,WAAWw+E;;cAELK,MAAMC,WAAWF,MAAM/8G,OAAOk+B,SAASC,SAAS3mD;QACtD0mD,WAAW8+E,IAAI9+E;QACfs+E,MAAM1kI,KAAKklI,IAAI55D;;;WAIVo5D;;EAGR,oBAAoBO,MAAM/8G,OAAOk+B,SAASC,SAAS3mD;UAC5C0lI,QAAQ1lI,KAAK2lI,OAAOJ,SAASvlI,KAAK2lI,OAAO;SAE1CD;MACJjjI,QAAQa,MAAM,4BAA4BiiI,OAAO,sCAAsCvlI,KAAK4lI,aAAa;;;UAIpGh6D,WAAWi6D;QACbr8H,GAAGG,GAAGm8H,KAAKC,KAAKC,MAAMC,MAAMC,MAAMC;QAElCT,MAAM1jB;YACHokB,UAAUV,MAAMW,mBAAmBX,MAAMW,iBAAiBX,MAAM1jB,EAAEl8G,MAAM;eAErElD,IAAI,GAAGma,IAAIqpH,QAAQvjI,QAAQD,IAAIma;cACjCupH,SAASF,QAAQxjI;gBAEf0jI;eACF;;YAEJ98H,IAAI48H,QAAQxjI,OAAO4lB,QAAQk+B;YAC3B/8C,IAAIy8H,QAAQxjI,OAAO4lB,QAAQm+B;YAC3BilB,KAAKovD,OAAOxxH,GAAGG;;eAGX;;YAEJH,IAAI48H,QAAQxjI,OAAO4lB,QAAQk+B;YAC3B/8C,IAAIy8H,QAAQxjI,OAAO4lB,QAAQm+B;YAC3BilB,KAAKqvD,OAAOzxH,GAAGG;;eAGX;;YAEJm8H,MAAMM,QAAQxjI,OAAO4lB,QAAQk+B;YAC7Bq/E,MAAMK,QAAQxjI,OAAO4lB,QAAQm+B;YAC7Bq/E,OAAOI,QAAQxjI,OAAO4lB,QAAQk+B;YAC9Bu/E,OAAOG,QAAQxjI,OAAO4lB,QAAQm+B;YAC9BilB,KAAKsvD,iBAAiB8K,MAAMC,MAAMH,KAAKC;;eAGnC;;YAEJD,MAAMM,QAAQxjI,OAAO4lB,QAAQk+B;YAC7Bq/E,MAAMK,QAAQxjI,OAAO4lB,QAAQm+B;YAC7Bq/E,OAAOI,QAAQxjI,OAAO4lB,QAAQk+B;YAC9Bu/E,OAAOG,QAAQxjI,OAAO4lB,QAAQm+B;YAC9Bu/E,OAAOE,QAAQxjI,OAAO4lB,QAAQk+B;YAC9By/E,OAAOC,QAAQxjI,OAAO4lB,QAAQm+B;YAC9BilB,KAAKyvD,cAAc2K,MAAMC,MAAMC,MAAMC,MAAML,KAAKC;;;;;;MAOnDr/E,SAASg/E,MAAMa,KAAK/9G;MACpBojD,MAAMA;;;EAIR46D,KAAKjiH,UAAUi8F,SAAS;EAExB,yBAAyB8R;IACxBtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRwuE,aAAa4C,WAAW,KAAKvC;MACnCL,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAOmB,iBAAiB,KAAKV;MAC7BT,OAAOgB,mBAAmBxvE,MAAM+uE;MAChCP,OAAOU,KAAK9lG,KAAK,UAAUy0F;YACtB5T;;UAGHA,OAAOhrG,KAAKC,MAAM2+G;iBACVr8G;UACRxB,QAAQ0B,KAAK;UACbuoG,OAAOhrG,KAAKC,MAAM2+G,KAAKmmB,UAAU,IAAInmB,KAAKz9G,SAAS;;cAG9C09G,OAAO99D,MAAM9gD,MAAM+qG;YACrBujB,QAAQA,OAAO1P;SACjB2P,YAAYC;;IAGhBxuH,MAAM+qG;iBACM85B,KAAK95B;;;MAKd1Q;QAEE0qC;IACLp9G,YAAY;UACP0yE,aAAax7F;QAChBw7F,gBAAgBj5F,OAAO2jI,gBAAgB3jI,OAAO4jI;;aAGxC3qC;;IAERnxC,YAAY,UAAUp9C;MACrBuuF,WAAWvuF;;;EAIb,0BAA0B6kH;IACzBtqH,YAAYspH;MACX,MAAMA;;IAGPK,KAAK9lG,KAAKokG,QAAQC,YAAYC;YACvB1tE,QAAQ;YACRwuE,aAAa4C,WAAW,KAAKvC;MACnCL,OAAO0C,gBAAgB;MACvB1C,OAAOiB,QAAQ,KAAKtmD;MACpBqlD,OAAOmB,iBAAiB,KAAKV;MAC7BT,OAAOgB,mBAAmB,KAAKT;MAC/BP,OAAOU,KAAK9lG,KAAK,UAAUkvB;;;;gBAInB6rF,aAAa7rF,OAAOj+B,MAAM;gBAC1BuM,UAAUq9G,aAAap9G;UAC7BD,QAAQw9G,gBAAgBD,YAAY,UAAUE;YAC7C7W,OAAO6W;;iBAEA7iI;cACJksH;YACHA,QAAQlsH;;YAERxB,QAAQa,MAAMW;;UAGfw+C,MAAM6uE,QAAQV,UAAU/kG;;SAEvBqkG,YAAYC;;;EAKjB,mCAAmCqO;IAClCx2H,YAAY6vD,UAAUC,aAAalpD,YAAY;MAC9C,MAAMpO,WAAWoO;YACXspC,aAAaK,QAAQxpC,IAAI8oD;YACzB1f,aAAaI,QAAQxpC,IAAI+oD;YACzBivE,UAAU3+H,QAAQ8vC,OAAOlwB,GAAGkwB,OAAO/wB,GAAG+wB,OAAO/4B;YAC7C6nH,aAAa5+H,QAAQ+vC,OAAOnwB,GAAGmwB,OAAOhxB,GAAGgxB,OAAOh5B;;YAEhDq4G,KAAK7vH,KAAKob,KAAKpb,KAAKyV;YACpBsU,KAAK8lG,KAAK7vH,KAAKob,KAAK;MAC1B,KAAKs3D,GAAGC,aAAa,GAAG34D,KAAKolH,KAAK98H,IAAI+8H,QAAQh9H,eAAewtH;MAC7D,KAAKn9C,GAAGC,aAAa,GAAG34D,KAAKolH,KAAK/kH,IAAIglH,QAAQh9H,eAAe0nB;;;EAK/Du1G,qBAAqB1iH,UAAU2iH,yBAAyB;EAExD,gCAAgC1I;IAC/Bx2H,YAAYgB,OAAO4F,YAAY;MAC9B,MAAMpO,WAAWoO;YACXspC,aAAaK,QAAQxpC,IAAI/F;;MAE/B,KAAKqxE,GAAGC,aAAa,GAAGvrE,IAAImpC,OAAOlwB,GAAGkwB,OAAO/wB,GAAG+wB,OAAO/4B,GAAGnV,eAAe,IAAIrC,KAAKob,KAAKpb,KAAKyV;;;EAK9F+pH,kBAAkB5iH,UAAU6iH,sBAAsB;QAE5CC,6BAA6B9nG;QAE7B+nG,4BAA4B/nG;EAElC;IACCv3B;MACC,KAAKpG,OAAO;MACZ,KAAK0jD,SAAS;MACd,KAAKiiF,SAAS;MACd,KAAKpxC,cAAcrvC;MACnB,KAAKqvC,QAAQ9wD,OAAOL,OAAO;MAC3B,KAAKmxD,QAAQvrE,mBAAmB;MAChC,KAAKwrE,cAActvC;MACnB,KAAKsvC,QAAQ/wD,OAAOL,OAAO;MAC3B,KAAKoxD,QAAQxrE,mBAAmB;MAChC,KAAK48G;QACJhiF,OAAO;QACPH,KAAK;QACLC,QAAQ;QACRxhB,MAAM;QACNC,KAAK;QACLwhB,MAAM;QACNgiF,QAAQ;;;IAIVh2G,OAAOsD;YACA3tB,QAAQ,KAAKsgI;YACbt7G,cAAchlB,MAAMs+C,UAAU3wB,OAAO2wB,SAASt+C,MAAMm+C,QAAQxwB,OAAOwwB,OAAOn+C,MAAMo+C,WAAWzwB,OAAOywB,SAAS,KAAKA,UAAUp+C,MAAM48B,SAASjP,OAAOiP,QAAQ58B,MAAM68B,QAAQlP,OAAOkP,OAAO78B,MAAMq+C,SAAS1wB,OAAO0wB,QAAQr+C,MAAMqgI,WAAW,KAAKA;UAE1Or7G;QACHhlB,MAAMs+C,QAAQ3wB,OAAO2wB;QACrBt+C,MAAMm+C,MAAMxwB,OAAOwwB;QACnBn+C,MAAMo+C,SAASzwB,OAAOywB,SAAS,KAAKA;QACpCp+C,MAAM48B,OAAOjP,OAAOiP;QACpB58B,MAAM68B,MAAMlP,OAAOkP;QACnB78B,MAAMq+C,OAAO1wB,OAAO0wB;QACpBr+C,MAAMqgI,SAAS,KAAKA;;;cAGdxyG,mBAAmBF,OAAOE,iBAAiB3qB;cAC3Cq9H,aAAavgI,MAAMqgI,SAAS;cAC5BG,qBAAqBD,aAAavgI,MAAM48B,OAAO58B,MAAMs+C;cACrDmiF,OAAOzgI,MAAM48B,OAAOn8B,KAAKw+C,IAAIhpC,UAAUjW,MAAMm+C,MAAM,OAAOn+C,MAAMq+C;YAClEqiF,MAAMC;;QAEVP,SAASjlH,SAAS,OAAOolH;QACzBJ,UAAUhlH,SAAS,MAAMolH;;QAEzBG,QAAQD,OAAOzgI,MAAMo+C,SAASoiF;QAC9BG,OAAOF,OAAOzgI,MAAMo+C,SAASoiF;QAC7B3yG,iBAAiB1S,SAAS,KAAK,IAAInb,MAAM48B,QAAQ+jG,OAAOD;QACxD7yG,iBAAiB1S,SAAS,MAAMwlH,OAAOD,SAASC,OAAOD;QACvD,KAAKzxC,QAAQphE,iBAAiBpT,KAAKoT;;QAEnC6yG,QAAQD,OAAOzgI,MAAMo+C,SAASoiF;QAC9BG,OAAOF,OAAOzgI,MAAMo+C,SAASoiF;QAC7B3yG,iBAAiB1S,SAAS,KAAK,IAAInb,MAAM48B,QAAQ+jG,OAAOD;QACxD7yG,iBAAiB1S,SAAS,MAAMwlH,OAAOD,SAASC,OAAOD;QACvD,KAAKxxC,QAAQrhE,iBAAiBpT,KAAKoT;;MAGpC,KAAKohE,QAAQjhE,YAAYvT,KAAKkT,OAAOK,aAAahT,SAASolH;MAC3D,KAAKlxC,QAAQlhE,YAAYvT,KAAKkT,OAAOK,aAAahT,SAASmlH;;;EAK7D;IACCr/H,YAAY8/H,YAAY;MACvB,KAAKA,YAAYA;MACjB,KAAK3b,YAAY;MACjB,KAAK4b,UAAU;MACf,KAAKC,cAAc;MACnB,KAAKC,UAAU;;IAGhBh8F;MACC,KAAKkgF,YAAYnmH;MACjB,KAAK+hI,UAAU,KAAK5b;MACpB,KAAK6b,cAAc;MACnB,KAAKC,UAAU;;IAGhBt9E;MACC,KAAKu9E;MACL,KAAKD,UAAU;MACf,KAAKH,YAAY;;IAGlBI;MACC,KAAKC;aACE,KAAKH;;IAGbG;UACKzN,OAAO;UAEP,KAAKoN,cAAc,KAAKG;QAC3B,KAAKh8F;eACE;;UAGJ,KAAKg8F;cACFG,UAAUpiI;QAChB00H,QAAQ0N,UAAU,KAAKL,WAAW;QAClC,KAAKA,UAAUK;QACf,KAAKJ,eAAetN;;aAGdA;;;EAKT;mBACgB2N,gBAAgB,cAActiI,OAAOsiI,aAAariI;;QAG5DsiI,+BAA+BlgI;QAE/BmgI,iCAAiC30G;QAEjC40G,4BAA4BpgI;QAE5BqgI,kCAAkCrgI;EAExC,4BAA4B+9B;IAC3Bn+B;MACC;MACA,KAAKpG,OAAO;MACZ,KAAKynB,UAAUq9G,aAAap9G;MAC5B,KAAKo/G,OAAO,KAAKr/G,QAAQs/G;MACzB,KAAKD,KAAKE,QAAQ,KAAKv/G,QAAQw/G;MAC/B,KAAK9mI,SAAS;MACd,KAAK+mI,YAAY;;MAEjB,KAAKC,aAAaC;;IAGnBC;aACQ,KAAKP;;IAGbQ;UACK,KAAKnnI,WAAW;QACnB,KAAK2mI,KAAKt0C,WAAW,KAAKryF;QAC1B,KAAKA,OAAOqyF,WAAW,KAAK/qE,QAAQw/G;QACpC,KAAKH,KAAKE,QAAQ,KAAKv/G,QAAQw/G;QAC/B,KAAK9mI,SAAS;;aAGR;;IAGRonI;aACQ,KAAKpnI;;IAGbqnI,UAAU37H;UACL,KAAK1L,WAAW;QACnB,KAAK2mI,KAAKt0C,WAAW,KAAKryF;QAC1B,KAAKA,OAAOqyF,WAAW,KAAK/qE,QAAQw/G;;QAEpC,KAAKH,KAAKt0C,WAAW,KAAK/qE,QAAQw/G;;MAGnC,KAAK9mI,SAAS0L;MACd,KAAKi7H,KAAKE,QAAQ,KAAK7mI;MACvB,KAAKA,OAAO6mI,QAAQ,KAAKv/G,QAAQw/G;aAC1B;;IAGRQ;aACQ,KAAKX,KAAKA,KAAKj7H;;IAGvB67H,gBAAgB77H;MACf,KAAKi7H,KAAKA,KAAKa,gBAAgB97H,OAAO,KAAK4b,QAAQmgH,aAAa;aACzD;;IAGRjgG,kBAAkBC;MACjB,MAAMD,kBAAkBC;YAClBptB,WAAW,KAAKiN,QAAQjN;YACxB4kB,KAAK,KAAKA;MAChB,KAAK8nG,YAAY,KAAKC,OAAOZ;MAC7B,KAAKjzG,YAAYkO,UAAUklG,aAAaC,eAAeC;MAEvDC,eAAe15H,IAAI,GAAG,IAAI,GAAGilB,gBAAgBu0G;UAEzCnsH,SAASqtH;;cAENrd,UAAU,KAAK/iG,QAAQmgH,cAAc,KAAKV;QAChD1sH,SAASqtH,UAAUC,wBAAwBpB,YAAY9+H,GAAG4iH;QAC1DhwG,SAASutH,UAAUD,wBAAwBpB,YAAY3+H,GAAGyiH;QAC1DhwG,SAASwtH,UAAUF,wBAAwBpB,YAAY1+H,GAAGwiH;QAC1DhwG,SAASytH,SAASH,wBAAwBjB,eAAej/H,GAAG4iH;QAC5DhwG,SAAS0tH,SAASJ,wBAAwBjB,eAAe9+H,GAAGyiH;QAC5DhwG,SAAS2tH,SAASL,wBAAwBjB,eAAe7+H,GAAGwiH;QAC5DhwG,SAAS4tH,IAAIN,wBAAwB1oG,GAAGx3B,GAAG4iH;QAC3ChwG,SAAS6tH,IAAIP,wBAAwB1oG,GAAGr3B,GAAGyiH;QAC3ChwG,SAAS8tH,IAAIR,wBAAwB1oG,GAAGp3B,GAAGwiH;;QAE3ChwG,SAAS2lB,YAAYumG,YAAY9+H,GAAG8+H,YAAY3+H,GAAG2+H,YAAY1+H;QAC/DwS,SAAS+tH,eAAe1B,eAAej/H,GAAGi/H,eAAe9+H,GAAG8+H,eAAe7+H,GAAGo3B,GAAGx3B,GAAGw3B,GAAGr3B,GAAGq3B,GAAGp3B;;;;EAMhG,oBAAoBu8B;IACnBn+B,YAAYoU;MACX;MACA,KAAKxa,OAAO;MACZ,KAAKwa,WAAWA;MAChB,KAAKiN,UAAUjN,SAASiN;MACxB,KAAKq/G,OAAO,KAAKr/G,QAAQs/G;MACzB,KAAKD,KAAKE,QAAQxsH,SAAS6sH;MAC3B,KAAKmB,WAAW;MAChB,KAAKrvF,SAAS;MACd,KAAKsvF,SAAS;MACd,KAAKC,OAAO;MACZ,KAAKC,YAAY;MACjB,KAAKC,UAAU;MACf,KAAK1mH,SAAS;MACd,KAAK8pG,WAAWptH;MAChB,KAAKiqI,eAAe;MACpB,KAAKC,YAAY;MACjB,KAAKC,qBAAqB;MAC1B,KAAKv/G,SAAS;MACd,KAAKw/G,aAAa;MAClB,KAAKC,aAAa;MAClB,KAAKC,YAAY;MACjB,KAAKC,aAAa;MAClB,KAAKC;;IAGNC;aACQ,KAAKvC;;IAGbwC,cAAcC;MACb,KAAKR,qBAAqB;MAC1B,KAAKC,aAAa;MAClB,KAAKx/G,SAAS+/G;MACd,KAAKvC;aACE;;IAGRwC,sBAAsBC;MACrB,KAAKV,qBAAqB;MAC1B,KAAKC,aAAa;MAClB,KAAKx/G,SAAS,KAAK/B,QAAQiiH,yBAAyBD;MACpD,KAAKzC;aACE;;IAGR2C,qBAAqBC;MACpB,KAAKb,qBAAqB;MAC1B,KAAKC,aAAa;MAClB,KAAKx/G,SAAS,KAAK/B,QAAQoiH,wBAAwBD;MACnD,KAAK5C;aACE;;IAGR8C,UAAU5E;MACT,KAAK/rF,SAAS+rF;MACd,KAAK8D,aAAa;UACd,KAAKR,UAAU,KAAKuB;aACjB;;IAGRA,KAAKC,QAAQ;UACR,KAAKlB,cAAc;QACtBjoI,QAAQ0B,KAAK;;;UAIV,KAAKwmI,uBAAuB;QAC/BloI,QAAQ0B,KAAK;;;MAId,KAAK0mI,aAAa,KAAKxhH,QAAQmgH,cAAcoC;YACvCxgH,SAAS,KAAK/B,QAAQwiH;MAC5BzgH,OAAO2vB,SAAS,KAAKA;MACrB3vB,OAAOk/G,OAAO,KAAKA;MACnBl/G,OAAOm/G,YAAY,KAAKA;MACxBn/G,OAAOo/G,UAAU,KAAKA;MACtBp/G,OAAO0gH,UAAU,KAAKC,QAAQzgC,KAAK;MACnClgF,OAAO6gB,MAAM,KAAK4+F,YAAY,KAAKC,YAAY,KAAKhnH,QAAQ,KAAK8pG;MACjE,KAAK8c,YAAY;MACjB,KAAKt/G,SAASA;MACd,KAAK4gH,UAAU,KAAK3B;MACpB,KAAK4B,gBAAgB,KAAKxB;aACnB,KAAK7B;;IAGbsD;UACK,KAAKvB,uBAAuB;QAC/BloI,QAAQ0B,KAAK;;;UAIV,KAAKumI,cAAc;;QAEtB,KAAKI,aAAanjI,KAAKF,IAAI,KAAK4hB,QAAQmgH,cAAc,KAAKqB,YAAY,KAAK,KAAKJ;YAE7E,KAAKH,SAAS;;UAEjB,KAAKQ,YAAY,KAAKA,aAAa,KAAKld,YAAY,KAAK7yE,OAAO6yE;;QAGjE,KAAKxiG,OAAOu/B;QACZ,KAAKv/B,OAAO0gH,UAAU;QACtB,KAAKpB,YAAY;;aAGX;;IAGR//E;UACK,KAAKggF,uBAAuB;QAC/BloI,QAAQ0B,KAAK;;;MAId,KAAK2mI,YAAY;MACjB,KAAK1/G,OAAOu/B;MACZ,KAAKv/B,OAAO0gH,UAAU;MACtB,KAAKpB,YAAY;aACV;;IAGR9B;UACK,KAAKoC,QAAQnoI,SAAS;QACzB,KAAKuoB,OAAOw9G,QAAQ,KAAKoC,QAAQ;iBAExBpoI,IAAI,GAAGma,IAAI,KAAKiuH,QAAQnoI,QAAQD,IAAIma,GAAGna;UAC/C,KAAKooI,QAAQpoI,IAAI,GAAGgmI,QAAQ,KAAKoC,QAAQpoI;;QAG1C,KAAKooI,QAAQ,KAAKA,QAAQnoI,SAAS,GAAG+lI,QAAQ,KAAKqC;;QAEnD,KAAK7/G,OAAOw9G,QAAQ,KAAKqC;;MAG1B,KAAKF,aAAa;aACX;;IAGR32C;UACK,KAAK42C,QAAQnoI,SAAS;QACzB,KAAKuoB,OAAOgpE,WAAW,KAAK42C,QAAQ;iBAE3BpoI,IAAI,GAAGma,IAAI,KAAKiuH,QAAQnoI,QAAQD,IAAIma,GAAGna;UAC/C,KAAKooI,QAAQpoI,IAAI,GAAGwxF,WAAW,KAAK42C,QAAQpoI;;QAG7C,KAAKooI,QAAQ,KAAKA,QAAQnoI,SAAS,GAAGuxF,WAAW,KAAK62C;;QAEtD,KAAK7/G,OAAOgpE,WAAW,KAAK62C;;MAG7B,KAAKF,aAAa;aACX;;IAGRoB;aACQ,KAAKnB;;IAGboB,WAAW3+H;WACLA,OAAOA;UAER,KAAKs9H,eAAe;QACvB,KAAK32C;QACL,KAAK42C,UAAUv9H,MAAMqP;QACrB,KAAK8rH;;QAEL,KAAKoC,UAAUv9H,MAAMqP;;aAGf;;IAGRkvH,UAAUv+H;MACT,KAAK48H,SAAS58H;UACV,KAAK2d,OAAOi/G,WAAW7pI;;UAEvB,KAAKkqI,cAAc;QACtB,KAAKt/G,OAAOi/G,OAAOd,gBAAgB,KAAKc,QAAQ,KAAKhhH,QAAQmgH,aAAa;;aAGpE;;IAGR6C;aACQ,KAAKhC;;IAGblB;aACQ,KAAKgD,aAAa;;IAG1B/C,UAAUrnI;aACF,KAAKqqI,WAAWrqI,UAAUA;;IAGlCkqI,gBAAgBx+H;UACX,KAAKk9H,uBAAuB;QAC/BloI,QAAQ0B,KAAK;;;MAId,KAAKsmI,eAAeh9H;UAEhB,KAAKi9H,cAAc;QACtB,KAAKt/G,OAAOq/G,aAAalB,gBAAgB,KAAKkB,cAAc,KAAKphH,QAAQmgH,aAAa;;aAGhF;;IAGR8C;aACQ,KAAK7B;;IAGbsB;MACC,KAAKrB,YAAY;;IAGlB6B;UACK,KAAK5B,uBAAuB;QAC/BloI,QAAQ0B,KAAK;eACN;;aAGD,KAAKmmI;;IAGbkC,QAAQ/+H;UACH,KAAKk9H,uBAAuB;QAC/BloI,QAAQ0B,KAAK;;;MAId,KAAKmmI,OAAO78H;UAER,KAAKi9H,cAAc;QACtB,KAAKt/G,OAAOk/G,OAAO,KAAKA;;aAGlB;;IAGRmC,aAAah/H;MACZ,KAAK88H,YAAY98H;aACV;;IAGRi/H,WAAWj/H;MACV,KAAK+8H,UAAU/8H;aACR;;IAGRk/H;aACQ,KAAKjE,KAAKA,KAAKj7H;;IAGvBm/H,UAAUn/H;MACT,KAAKi7H,KAAKA,KAAKa,gBAAgB97H,OAAO,KAAK4b,QAAQmgH,aAAa;aACzD;;;QAKHqD,6BAA6BzkI;QAE7B0kI,+BAA+Bl5G;QAE/Bm5G,0BAA0B3kI;QAE1B4kI,gCAAgC5kI;EAEtC,8BAA8B6kI;IAC7BjlI,YAAYoU;MACX,MAAMA;MACN,KAAK8wH,SAAS,KAAK7jH,QAAQ8jH;MAC3B,KAAKD,OAAOE,eAAe;MAC3B,KAAKF,OAAOtE,QAAQ,KAAKF;;IAG1BuC;aACQ,KAAKiC;;IAGbG;aACQ,KAAKH,OAAOI;;IAGpBC,eAAe9/H;MACd,KAAKy/H,OAAOI,cAAc7/H;aACnB;;IAGR+/H;aACQ,KAAKN,OAAOO;;IAGpBC,iBAAiBjgI;MAChB,KAAKy/H,OAAOO,gBAAgBhgI;aACrB;;IAGRkgI;aACQ,KAAKT,OAAOU;;IAGpBC,iBAAiBpgI;MAChB,KAAKy/H,OAAOU,gBAAgBngI;aACrB;;IAGRqgI;aACQ,KAAKZ,OAAOa;;IAGpBC,eAAevgI;MACd,KAAKy/H,OAAOa,cAActgI;aACnB;;IAGRwgI,mBAAmBC,gBAAgBC,gBAAgBC;MAClD,KAAKlB,OAAOgB,iBAAiBA;MAC7B,KAAKhB,OAAOiB,iBAAiBA;MAC7B,KAAKjB,OAAOkB,gBAAgBA;aACrB;;IAGR7kG,kBAAkBC;MACjB,MAAMD,kBAAkBC;UACpB,KAAKmhG,uBAAuB,QAAQ,KAAKD,cAAc;MAC3D,KAAKx1G,YAAYkO,UAAUypG,WAAWC,aAAaC;MAEnDC,aAAaj+H,IAAI,GAAG,GAAG,GAAGilB,gBAAgB84G;YAEpCI,SAAS,KAAKA;UAEhBA,OAAOzD;;cAEJrd,UAAU,KAAK/iG,QAAQmgH,cAAc,KAAKptH,SAAS0sH;QACzDoE,OAAOzD,UAAUC,wBAAwBmD,UAAUrjI,GAAG4iH;QACtD8gB,OAAOvD,UAAUD,wBAAwBmD,UAAUljI,GAAGyiH;QACtD8gB,OAAOtD,UAAUF,wBAAwBmD,UAAUjjI,GAAGwiH;QACtD8gB,OAAOmB,aAAa3E,wBAAwBsD,aAAaxjI,GAAG4iH;QAC5D8gB,OAAOoB,aAAa5E,wBAAwBsD,aAAarjI,GAAGyiH;QAC5D8gB,OAAOqB,aAAa7E,wBAAwBsD,aAAapjI,GAAGwiH;;QAE5D8gB,OAAOnrG,YAAY8qG,UAAUrjI,GAAGqjI,UAAUljI,GAAGkjI,UAAUjjI;QACvDsjI,OAAO/C,eAAe6C,aAAaxjI,GAAGwjI,aAAarjI,GAAGqjI,aAAapjI;;;;EAMtE;IACC5B,YAAYwmI,OAAOC,UAAU;MAC5B,KAAKC,WAAWF,MAAMnlH,QAAQslH;MAC9B,KAAKD,SAASD,UAAUA;MACxB,KAAKzuI,WAAWo6C,WAAW,KAAKs0F,SAASE;MACzCJ,MAAMvD,YAAYrC,QAAQ,KAAK8F;;IAGhCG;MACC,KAAKH,SAASI,qBAAqB,KAAK9uI;aACjC,KAAKA;;IAGb+uI;UACKthI,QAAQ;YACNzN,OAAO,KAAK6uI;eAETjsI,IAAI,GAAGA,IAAI5C,KAAK6C,QAAQD;QAChC6K,SAASzN,KAAK4C;;aAGR6K,QAAQzN,KAAK6C;;;EAKtB;IACCmF,YAAYgnI,SAASpf,UAAUpJ;MAC9B,KAAKwoB,UAAUA;MACf,KAAKxoB,YAAYA;UACbyoB,aAAaC,qBAAqBC;;;;;;;;;;;;;;;;cAgB9Bvf;aACF;UACJqf,cAAc,KAAKG;UACnBF,sBAAsB,KAAKG;UAC3BF,cAAc,KAAKG;UACnB,KAAKv0F,aAAaF,aAAa2rE,YAAY;UAC3C,KAAK+oB,aAAa;;aAGd;aACA;UACJN,cAAc,KAAKO;;;UAGnBN,sBAAsB,KAAKM;UAC3BL,cAAc,KAAKM;UACnB,KAAK10F,aAAa71C,MAAMshH,YAAY;;;UAIpCyoB,cAAc,KAAKS;UACnBR,sBAAsB,KAAKS;UAC3BR,cAAc,KAAKS;UACnB,KAAK70F,aAAaF,aAAa2rE,YAAY;;MAG7C,KAAKqpB,mBAAmBZ;MACxB,KAAKa,2BAA2BZ;MAChC,KAAKa,eAAeZ;MACpB,KAAKa,aAAa;MAClB,KAAKC,YAAY;MACjB,KAAKC,mBAAmB;MACxB,KAAKC,2BAA2B;MAChC,KAAKC,WAAW;MAChB,KAAKC,iBAAiB;;;IAIvBC,WAAWC,WAAW5kC;;;YAGf5wD,SAAS,KAAKA,QACjBwiB,SAAS,KAAKipD,WACd1iG,SAASysH,YAAYhzE,SAASA;UAC7BizE,gBAAgB,KAAKN;UAErBM,kBAAkB;;iBAEZ5tI,IAAI,GAAGA,MAAM26D,UAAU36D;UAC/Bm4C,OAAOj3B,SAASlhB,KAAKm4C,OAAOn4C;;QAG7B4tI,gBAAgB7kC;;;QAGhB6kC,iBAAiB7kC;cACX8kC,MAAM9kC,SAAS6kC;QAErB,KAAKX,iBAAiB90F,QAAQj3B,QAAQ,GAAG2sH,KAAKlzE;;MAG/C,KAAK2yE,mBAAmBM;;;IAIzBE,mBAAmB/kC;YACZ5wD,SAAS,KAAKA,QACjBwiB,SAAS,KAAKipD,WACd1iG,SAASy5C,SAAS,KAAK0yE;UAEtB,KAAKE,6BAA6B;;QAErC,KAAKJ;;;MAIN,KAAKD,yBAAyB/0F,QAAQj3B,QAAQ,GAAG6nF,QAAQpuC;MAEzD,KAAK4yE,4BAA4BxkC;;;IAIlCpkG,MAAMgpI;YACChzE,SAAS,KAAKipD,WACjBzrE,SAAS,KAAKA,QACdj3B,SAASysH,YAAYhzE,SAASA,QAC9BouC,SAAS,KAAKukC,kBACdS,iBAAiB,KAAKR,0BACtBnB,UAAU,KAAKA;MAClB,KAAKkB,mBAAmB;MACxB,KAAKC,2BAA2B;UAE5BxkC,SAAS;;cAENilC,sBAAsBrzE,SAAS,KAAKyyE;QAE1C,KAAKH,iBAAiB90F,QAAQj3B,QAAQ8sH,qBAAqB,IAAIjlC,QAAQpuC;;UAGpEozE,iBAAiB;;QAEpB,KAAKb,yBAAyB/0F,QAAQj3B,QAAQ,KAAKmsH,YAAY1yE,QAAQ,GAAGA;;eAGlE36D,IAAI26D,QAAQt5D,IAAIs5D,SAASA,QAAQ36D,MAAMqB,KAAKrB;YAChDm4C,OAAOn4C,OAAOm4C,OAAOn4C,IAAI26D;;UAE5ByxE,QAAQxpE,SAASzqB,QAAQj3B;;;;;;IAO5B+sH;YACO7B,UAAU,KAAKA;YACfj0F,SAAS,KAAKA,QACjBwiB,SAAS,KAAKipD,WACdoqB,sBAAsBrzE,SAAS,KAAKyyE;MACvChB,QAAQ8B,SAAS/1F,QAAQ61F;;eAEhBhuI,IAAI26D,QAAQt5D,IAAI2sI,qBAAqBhuI,MAAMqB,KAAKrB;QACxDm4C,OAAOn4C,KAAKm4C,OAAO61F,sBAAsBhuI,IAAI26D;;;MAI9C,KAAKwyE;MAEL,KAAKG,mBAAmB;MACxB,KAAKC,2BAA2B;;;IAIjCY;YACOH,sBAAsB,KAAKpqB,YAAY;MAC7C,KAAKwoB,QAAQxpE,SAAS,KAAKzqB,QAAQ61F;;IAGpChB;YACO9nB,aAAa,KAAKmoB,YAAY,KAAKzpB;YACnCuB,WAAWD,aAAa,KAAKtB;eAE1B5jH,IAAIklH,YAAYllH,IAAImlH,UAAUnlH;QACtC,KAAKm4C,OAAOn4C,KAAK;;;IAInB0sI;MACC,KAAKM;MAEL,KAAK70F,OAAO,KAAKk1F,YAAY,KAAKzpB,YAAY,KAAK;;IAGpDipB;YACO3nB,aAAa,KAAKkoB,aAAa,KAAKxpB;YACpCwqB,cAAc,KAAKf,YAAY,KAAKzpB;eAEjC5jH,IAAI,GAAGA,IAAI,KAAK4jH,WAAW5jH;QACnC,KAAKm4C,OAAOi2F,cAAcpuI,KAAK,KAAKm4C,OAAO+sE,aAAallH;;;;IAK1D4sI,QAAQz0F,QAAQhrB,WAAW61F,WAAW1nG,GAAGq/C;UACpCr/C,KAAK;iBACCtb,IAAI,GAAGA,MAAM26D,UAAU36D;UAC/Bm4C,OAAOhrB,YAAYntB,KAAKm4C,OAAO6qE,YAAYhjH;;;;IAK9CwsI,OAAOr0F,QAAQhrB,WAAW61F,WAAW1nG;MACpC0V,WAAW/D,UAAUkrB,QAAQhrB,WAAWgrB,QAAQhrB,WAAWgrB,QAAQ6qE,WAAW1nG;;IAG/EmxH,eAAet0F,QAAQhrB,WAAW61F,WAAW1nG,GAAGq/C;YACzC0zE,aAAa,KAAK1B,aAAahyE;;MAErC3pC,WAAW1C,wBAAwB6pB,QAAQk2F,YAAYl2F,QAAQhrB,WAAWgrB,QAAQ6qE;;MAElFhyF,WAAW/D,UAAUkrB,QAAQhrB,WAAWgrB,QAAQhrB,WAAWgrB,QAAQk2F,YAAY/yH;;IAGhFwxH,MAAM30F,QAAQhrB,WAAW61F,WAAW1nG,GAAGq/C;YAChC3+C,IAAI,IAAIV;eAELtb,IAAI,GAAGA,MAAM26D,UAAU36D;cACzBm4B,IAAIhL,YAAYntB;QACtBm4C,OAAOhgB,KAAKggB,OAAOhgB,KAAKnc,IAAIm8B,OAAO6qE,YAAYhjH,KAAKsb;;;IAItDyxH,cAAc50F,QAAQhrB,WAAW61F,WAAW1nG,GAAGq/C;eACrC36D,IAAI,GAAGA,MAAM26D,UAAU36D;cACzBm4B,IAAIhL,YAAYntB;QACtBm4C,OAAOhgB,KAAKggB,OAAOhgB,KAAKggB,OAAO6qE,YAAYhjH,KAAKsb;;;;;QAO7CgzH,qBAAqB;QAErBC,kBAAkB1qI,OAAO,MAAMyqI,qBAAqB,KAAK;;;;QAKzDE,YAAY,OAAOF,qBAAqB;QAExCG,iBAAiB,OAAOH,mBAAmBtiE,QAAQ,OAAO,MAAM;;;QAIhE0iE,gBAAe,mBAAkBlmH,OAAOwjD,QAAQ,MAAMwiE;;QAGtDG,WAAU,YAAWnmH,OAAOwjD,QAAQ,QAAQyiE;;;QAI5CG,aAAY,6BAA4BpmH,OAAOwjD,QAAQ,MAAMwiE;;;QAI7DK,eAAc,wBAAuBrmH,OAAOwjD,QAAQ,MAAMwiE;QAE1DM,eAAejrI,OAAO,KAAK,MAAM6qI,eAAeC,UAAUC,YAAYC,cAAc;QAEpFE,yBAAyB,YAAY,aAAa;EAExD;IACC3pI,YAAY4pI,aAAahmE,MAAMimE;YACxBC,aAAaD,sBAAsBE,gBAAgBC,eAAepmE;MACxE,KAAKqmE,eAAeL;MACpB,KAAKM,YAAYN,YAAYO,WAAWvmE,MAAMkmE;;IAG/ChB,SAASj0H,OAAOiH;MACf,KAAKwnF;;YAEC8mC,kBAAkB,KAAKH,aAAaI,iBACvCrD,UAAU,KAAKkD,UAAUE;;UAExBpD,YAAYxuI,WAAWwuI,QAAQ8B,SAASj0H,OAAOiH;;IAGpD0hD,SAAS3oD,OAAOiH;YACTwuH,WAAW,KAAKJ;eAEbtvI,IAAI,KAAKqvI,aAAaI,iBAAiBz0H,IAAI00H,SAASzvI,QAAQD,MAAMgb,KAAKhb;QAC/E0vI,SAAS1vI,GAAG4iE,SAAS3oD,OAAOiH;;;IAI9BwnF;YACOgnC,WAAW,KAAKJ;eAEbtvI,IAAI,KAAKqvI,aAAaI,iBAAiBz0H,IAAI00H,SAASzvI,QAAQD,MAAMgb,KAAKhb;QAC/E0vI,SAAS1vI,GAAG0oG;;;IAIdinC;YACOD,WAAW,KAAKJ;eAEbtvI,IAAI,KAAKqvI,aAAaI,iBAAiBz0H,IAAI00H,SAASzvI,QAAQD,MAAMgb,KAAKhb;QAC/E0vI,SAAS1vI,GAAG2vI;;;;;;;;;EAWf;IACCvqI,YAAYwqI,UAAU5mE,MAAMkmE;MAC3B,KAAKlmE,OAAOA;MACZ,KAAKkmE,aAAaA,cAAcC,gBAAgBC,eAAepmE;MAC/D,KAAK6mE,OAAOV,gBAAgBW,SAASF,UAAU,KAAKV,WAAWa,aAAaH;MAC5E,KAAKA,WAAWA;;MAEhB,KAAK1B,WAAW,KAAK8B;MACrB,KAAKptE,WAAW,KAAKqtE;;WAGfC,OAAOxwI,MAAMspE,MAAMkmE;YACnBxvI,QAAQA,KAAKywI;mBACPhB,gBAAgBzvI,MAAMspE,MAAMkmE;;mBAE5BC,gBAAgBiB,UAAU1wI,MAAMspE,MAAMkmE;;;;;;;;;;WAY5CmB,iBAAiBnlI;aAChBA,KAAK8gE,QAAQ,OAAO,KAAKA,QAAQuiE,aAAa;;WAG/Ca,eAAe/iB;YACfikB,UAAUxB,SAASn7F,KAAK04E;WAEzBikB;kBACMllI,MAAM,8CAA8CihH;;YAGzDkkB;;QAELR,UAAUO,QAAQ;QAClBE,YAAYF,QAAQ;QACpBG,aAAaH,QAAQ;QACrB/jB,cAAc+jB,QAAQ;;QAEtBI,eAAeJ,QAAQ;;YAElBK,UAAUJ,QAAQR,YAAYQ,QAAQR,SAASzT,YAAY;UAE7DqU,YAAY/yI,aAAa+yI,aAAa;cACnCH,aAAaD,QAAQR,SAASlM,UAAU8M,UAAU;;;;;YAKpD5B,sBAAsB7wI,QAAQsyI,iBAAiB;UAClDD,QAAQR,WAAWQ,QAAQR,SAASlM,UAAU,GAAG8M;UACjDJ,QAAQC,aAAaA;;;UAInBD,QAAQhkB,iBAAiB,QAAQgkB,QAAQhkB,aAAatsH,WAAW;kBAC1DmL,MAAM,iEAAiEihH;;aAG3EkkB;;WAGDT,SAASpwI,MAAMqwI;WAChBA,YAAYA,aAAa,MAAMA,aAAa,OAAOA,cAAc,KAAKA,aAAarwI,KAAKwL,QAAQ6kI,aAAarwI,KAAKob;eAC/Gpb;;;UAIJA,KAAKwoC;cACFwhE,OAAOhqG,KAAKwoC,SAAS0hE,cAAcmmC;YAErCrmC,SAAS9rG;iBACL8rG;;;;UAKLhqG,KAAKu2B;cACF26G,oBAAoB,UAAU36G;mBAC1Bj2B,IAAI,GAAGA,IAAIi2B,SAASh2B,QAAQD;kBAC9B6wI,YAAY56G,SAASj2B;gBAEvB6wI,UAAU3lI,SAAS6kI,YAAYc,UAAU/1H,SAASi1H;qBAC9Cc;;kBAGFv0D,SAASs0D,kBAAkBC,UAAU56G;gBACvCqmD,eAAeA;;iBAGb;;cAGFw0D,cAAcF,kBAAkBlxI,KAAKu2B;YAEvC66G;iBACIA;;;aAIF;;;IAIRC;IAEAC;;IAGAC,iBAAiB94F,QAAQj3B;MACxBi3B,OAAOj3B,UAAU,KAAK2uH,KAAK,KAAKtjB;;IAGjC2kB,gBAAgB/4F,QAAQj3B;YACjBsH,SAAS,KAAK2oH;eAEXnxI,IAAI,GAAGgb,IAAIwN,OAAOvoB,QAAQD,MAAMgb,KAAKhb;QAC7Cm4C,OAAOj3B,YAAYsH,OAAOxoB;;;IAI5BoxI,uBAAuBj5F,QAAQj3B;MAC9Bi3B,OAAOj3B,UAAU,KAAKiwH,iBAAiB,KAAKT;;IAG7CW,kBAAkBl5F,QAAQj3B;MACzB,KAAKiwH,iBAAiBhwH,QAAQg3B,QAAQj3B;;;IAIvCowH,iBAAiBn5F,QAAQj3B;MACxB,KAAKqwH,aAAa,KAAKhlB,gBAAgBp0E,OAAOj3B;;IAG/CswH,gCAAgCr5F,QAAQj3B;MACvC,KAAKqwH,aAAa,KAAKhlB,gBAAgBp0E,OAAOj3B;MAC9C,KAAKqwH,aAAajoH,cAAc;;IAGjCmoH,2CAA2Ct5F,QAAQj3B;MAClD,KAAKqwH,aAAa,KAAKhlB,gBAAgBp0E,OAAOj3B;MAC9C,KAAKqwH,aAAattG,yBAAyB;;;IAI5CytG,gBAAgBv5F,QAAQj3B;YACjBywH,OAAO,KAAKR;eAETnxI,IAAI,GAAGgb,IAAI22H,KAAK1xI,QAAQD,MAAMgb,KAAKhb;QAC3C2xI,KAAK3xI,KAAKm4C,OAAOj3B;;;IAInB0wH,+BAA+Bz5F,QAAQj3B;YAChCywH,OAAO,KAAKR;eAETnxI,IAAI,GAAGgb,IAAI22H,KAAK1xI,QAAQD,MAAMgb,KAAKhb;QAC3C2xI,KAAK3xI,KAAKm4C,OAAOj3B;;MAGlB,KAAKqwH,aAAajoH,cAAc;;IAGjCuoH,0CAA0C15F,QAAQj3B;YAC3CywH,OAAO,KAAKR;eAETnxI,IAAI,GAAGgb,IAAI22H,KAAK1xI,QAAQD,MAAMgb,KAAKhb;QAC3C2xI,KAAK3xI,KAAKm4C,OAAOj3B;;MAGlB,KAAKqwH,aAAattG,yBAAyB;;;IAI5C6tG,uBAAuB35F,QAAQj3B;MAC9B,KAAKiwH,iBAAiB,KAAKT,iBAAiBv4F,OAAOj3B;;IAGpD6wH,sCAAsC55F,QAAQj3B;MAC7C,KAAKiwH,iBAAiB,KAAKT,iBAAiBv4F,OAAOj3B;MACnD,KAAKqwH,aAAajoH,cAAc;;IAGjC0oH,iDAAiD75F,QAAQj3B;MACxD,KAAKiwH,iBAAiB,KAAKT,iBAAiBv4F,OAAOj3B;MACnD,KAAKqwH,aAAattG,yBAAyB;;;IAI5CguG,oBAAoB95F,QAAQj3B;MAC3B,KAAKiwH,iBAAiBlwH,UAAUk3B,QAAQj3B;;IAGzCgxH,mCAAmC/5F,QAAQj3B;MAC1C,KAAKiwH,iBAAiBlwH,UAAUk3B,QAAQj3B;MACxC,KAAKqwH,aAAajoH,cAAc;;IAGjC6oH,8CAA8Ch6F,QAAQj3B;MACrD,KAAKiwH,iBAAiBlwH,UAAUk3B,QAAQj3B;MACxC,KAAKqwH,aAAattG,yBAAyB;;IAG5C+rG,kBAAkBoC,aAAalxH;MAC9B,KAAKwnF;MACL,KAAKwlC,SAASkE,aAAalxH;;IAG5B+uH,kBAAkBoC,aAAanxH;MAC9B,KAAKwnF;MACL,KAAK9lC,SAASyvE,aAAanxH;;;IAI5BwnF;UACK6oC,eAAe,KAAK1B;YAClBX,aAAa,KAAKA;YAClBsB,aAAatB,WAAWsB;YACxBjkB,eAAe2iB,WAAW3iB;UAC5BmkB,gBAAgBxB,WAAWwB;WAE1Ba;QACJA,eAAepC,gBAAgBW,SAAS,KAAKF,UAAUV,WAAWa,aAAa,KAAKH;QACpF,KAAKC,OAAO0B;;;MAIb,KAAKrD,WAAW,KAAK6C;MACrB,KAAKnuE,WAAW,KAAKouE;;WAEhBO;QACJ1xI,QAAQa,MAAM,6DAA6D,KAAKsoE,OAAO;;;UAIpFwnE;YACCC,cAAcvB,WAAWuB;;gBAErBD;eACF;iBACCe,aAAarrI;cACjBrG,QAAQa,MAAM,qFAAqF;;;iBAI/F6wI,aAAarrI,SAAS8gC;cAC1BnnC,QAAQa,MAAM,+GAA+G;;;YAI9H6wI,eAAeA,aAAarrI,SAAS8gC;;eAGjC;iBACCuqG,aAAarpG;cACjBroC,QAAQa,MAAM,kFAAkF;;;;;YAMjG6wI,eAAeA,aAAarpG,SAASmrC;;qBAE5BrzE,IAAI,GAAGA,IAAIuxI,aAAatxI,QAAQD;kBACpCuxI,aAAavxI,GAAGkL,SAASulI;gBAC5BA,cAAczwI;;;;;;gBAQZuxI,aAAaf,gBAAgB5yI;cAChCiC,QAAQa,MAAM,wEAAwE;;;YAIvF6wI,eAAeA,aAAaf;;YAG1BC,gBAAgB7yI;cACf2zI,aAAad,iBAAiB7yI;YACjCiC,QAAQa,MAAM,yFAAyF,MAAM6wI;;;UAI9GA,eAAeA,aAAad;;;;YAKxB6B,eAAef,aAAahlB;UAE9B+lB,iBAAiB10I;cACdmyI,WAAWb,WAAWa;QAC5BlwI,QAAQa,MAAM,iEAAiEqvI,WAAW,MAAMxjB,eAAe,0BAA0BglB;;;;UAKtIgB,aAAa,KAAKC,WAAWC;MACjC,KAAKlB,eAAeA;UAEhBA,aAAajoH,gBAAgB1rB;;QAEhC20I,aAAa,KAAKC,WAAWE;iBACnBnB,aAAattG,2BAA2BrmC;;QAElD20I,aAAa,KAAKC,WAAWG;;;UAI1BC,cAAc,KAAKC,YAAYC;UAE/BpC,kBAAkB9yI;;YAEjB2uH,iBAAiB;;;eAGfglB,aAAazrI;YACjBjG,QAAQa,MAAM,uGAAuG;;;cAIlH6wI,aAAazrI,SAASu2C;iBACpBk1F,aAAazrI,SAAS6yC;cAC1B94C,QAAQa,MAAM,uHAAuH;;;gBAIlI6wI,aAAa9yF,sBAAsBiyF,mBAAmB9yI;cACzD8yI,gBAAgBa,aAAa9yF,sBAAsBiyF;;;YAGpD7wI,QAAQa,MAAM,qHAAqH;;;;QAKrIkyI,cAAc,KAAKC,YAAYE;QAC/B,KAAK5B,mBAAmBmB;QACxB,KAAK5B,gBAAgBA;iBACX4B,aAAarxH,cAAcrjB,aAAa00I,aAAanxH,YAAYvjB;;QAE3Eg1I,cAAc,KAAKC,YAAYG;QAC/B,KAAK7B,mBAAmBmB;iBACdhwI,MAAMC,QAAQ+vI;QACxBM,cAAc,KAAKC,YAAYI;QAC/B,KAAK9B,mBAAmBmB;;QAExB,KAAK/lB,eAAeA;;;MAIrB,KAAK2hB,WAAW,KAAKgF,oBAAoBN;MACzC,KAAKhwE,WAAW,KAAKuwE,iCAAiCP,aAAaL;;IAGpE5C;MACC,KAAKE,OAAO;;;MAGZ,KAAK3B,WAAW,KAAK8B;MACrB,KAAKptE,WAAW,KAAKqtE;;;EAKvBd,gBAAgBiB,YAAYA;EAC5BjB,gBAAgBxtH,UAAUkxH;IACzBC,QAAQ;IACRG,aAAa;IACbF,cAAc;IACdC,gBAAgB;;EAEjB7D,gBAAgBxtH,UAAU6wH;IACzBC,MAAM;IACNC,aAAa;IACbC,wBAAwB;;EAEzBxD,gBAAgBxtH,UAAUuxH,uBAAuB/D,gBAAgBxtH,UAAUsvH,kBAAkB9B,gBAAgBxtH,UAAUuvH,iBAAiB/B,gBAAgBxtH,UAAUyvH,wBAAwBjC,gBAAgBxtH,UAAU0vH;EACpNlC,gBAAgBxtH,UAAUwxH;EAC1BhE,gBAAgBxtH,UAAU2vH,kBAAkBnC,gBAAgBxtH,UAAU6vH,iCAAiCrC,gBAAgBxtH,UAAU8vH;EACjItC,gBAAgBxtH,UAAU+vH,iBAAiBvC,gBAAgBxtH,UAAUiwH,gCAAgCzC,gBAAgBxtH,UAAUkwH;EAC/H1C,gBAAgBxtH,UAAUmwH,wBAAwB3C,gBAAgBxtH,UAAUowH,uCAAuC5C,gBAAgBxtH,UAAUqwH;EAC7I7C,gBAAgBxtH,UAAUswH,qBAAqB9C,gBAAgBxtH,UAAUuwH,oCAAoC/C,gBAAgBxtH,UAAUwwH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BvI;IACC/sI;MACC,KAAK0V,OAAOwC;;MAEZ,KAAKo8D,WAAWp3E,MAAMqf,UAAUzH,MAAMhd,KAAK2kB;MAC3C,KAAK4tH,kBAAkB;;;YAGjBr1F;MACN,KAAKg5F,iBAAiBh5F;;eAEbp6C,IAAI,GAAGgb,IAAI6G,UAAU5hB,QAAQD,MAAMgb,KAAKhb;QAChDo6C,QAAQv4B,UAAU7hB,GAAG8a,QAAQ9a;;MAG9B,KAAKqzI;;MAEL,KAAKC;;MAEL,KAAKhE;;MAEL,KAAKiE;;YAEC1zF,QAAQ;MACd,KAAK2zF;QACJ58E;cACK68E;mBACI5zF,MAAM65B,SAASz5E;;cAGnByzI;mBACI,KAAKD,QAAQ5zF,MAAM4vF;;;YAKxBkE;iBACI9zF,MAAMyvF,UAAUrvI;;;;IAM1BoH;YACOuvD,UAAU,KAAK8iB,UAClBk6D,gBAAgB,KAAKR,gBACrBhR,QAAQ,KAAKiR,QACbQ,cAAc,KAAKP,cACnB5D,WAAW,KAAKJ,WAChBwE,YAAYpE,SAASzvI;UACpB8zI,cAAcn2I,WAChBo2I,WAAWp9E,QAAQ32D,QACnBg0I,iBAAiB,KAAKxE;eAEfzvI,IAAI,GAAGgb,IAAI6G,UAAU5hB,QAAQD,MAAMgb,KAAKhb;cAC1Ck1B,SAASrT,UAAU7hB,IACtB8a,OAAOoa,OAAOpa;YACbhB,QAAQ85H,cAAc94H;YAEtBhB,UAAUlc;;UAEbkc,QAAQk6H;UACRJ,cAAc94H,QAAQhB;UACtB88C,QAAQl5D,KAAKw3B;;mBAEJiD,IAAI,GAAGld,IAAI64H,WAAW37G,MAAMld,KAAKkd;YACzCu3G,SAASv3G,GAAGz6B,SAASyxI,gBAAgBj6G,QAAQktG,MAAMjqG,IAAI07G,YAAY17G;;mBAE1Dre,QAAQm6H;UAClBF,cAAcn9E,QAAQ98C;;gBAEhBo6H,qBAAqBD,gBACxBE,mBAAmBv9E,QAAQs9E;UAC9BN,cAAcO,iBAAiBr5H,QAAQhB;UACvC88C,QAAQ98C,SAASq6H;UACjBP,cAAc94H,QAAQo5H;UACtBt9E,QAAQs9E,oBAAoBh/G;;mBAEnBiD,IAAI,GAAGld,IAAI64H,WAAW37G,MAAMld,KAAKkd;kBACnCi8G,kBAAkB1E,SAASv3G,IAC9Bk8G,aAAaD,gBAAgBF;gBAC5B9H,UAAUgI,gBAAgBt6H;YAC9Bs6H,gBAAgBt6H,SAASu6H;gBAErBjI,YAAYxuI;;;;cAIfwuI,cAAc+C,gBAAgBj6G,QAAQktG,MAAMjqG,IAAI07G,YAAY17G;;YAG7Di8G,gBAAgBF,oBAAoB9H;;mBAE3Bx1E,QAAQ98C,WAAWi6H;UAC7Bl0I,QAAQa,MAAM,sEAAsE;;;;MAMtF,KAAK+uI,kBAAkBwE;;IAGxBxyI;YACOm1D,UAAU,KAAK8iB,UAClBk6D,gBAAgB,KAAKR,gBACrB1D,WAAW,KAAKJ,WAChBwE,YAAYpE,SAASzvI;UACpBg0I,iBAAiB,KAAKxE;eAEjBzvI,IAAI,GAAGgb,IAAI6G,UAAU5hB,QAAQD,MAAMgb,KAAKhb;cAC1Ck1B,SAASrT,UAAU7hB,IACtB8a,OAAOoa,OAAOpa,MACdhB,QAAQ85H,cAAc94H;YAErBhB,UAAUlc,aAAakc,SAASm6H;;gBAE7BK,kBAAkBL,kBACrBM,oBAAoB39E,QAAQ09E;UAC/BV,cAAcW,kBAAkBz5H,QAAQhB;UACxC88C,QAAQ98C,SAASy6H;UACjBX,cAAc94H,QAAQw5H;UACtB19E,QAAQ09E,mBAAmBp/G;;mBAElBiD,IAAI,GAAGld,IAAI64H,WAAW37G,MAAMld,KAAKkd;kBACnCi8G,kBAAkB1E,SAASv3G,IAC9Bq8G,cAAcJ,gBAAgBE,kBAC9BlI,UAAUgI,gBAAgBt6H;YAC7Bs6H,gBAAgBt6H,SAAS06H;YACzBJ,gBAAgBE,mBAAmBlI;;;;;MAMtC,KAAKqD,kBAAkBwE;;;IAIxBQ;YACO79E,UAAU,KAAK8iB,UAClBk6D,gBAAgB,KAAKR,gBACrB1D,WAAW,KAAKJ,WAChBwE,YAAYpE,SAASzvI;UACpBg0I,iBAAiB,KAAKxE,iBACxBuE,WAAWp9E,QAAQ32D;eAEZD,IAAI,GAAGgb,IAAI6G,UAAU5hB,QAAQD,MAAMgb,KAAKhb;cAC1Ck1B,SAASrT,UAAU7hB,IACtB8a,OAAOoa,OAAOpa,MACdhB,QAAQ85H,cAAc94H;YAErBhB,UAAUlc;iBACNg2I,cAAc94H;cAEjBhB,QAAQm6H;;kBAELC,qBAAqBD,gBACxBE,mBAAmBv9E,QAAQs9E,mBAC3BhrE,cAAc8qE,UACdU,aAAa99E,QAAQsS;;YAExB0qE,cAAcO,iBAAiBr5H,QAAQhB;YACvC88C,QAAQ98C,SAASq6H;;YAEjBP,cAAcc,WAAW55H,QAAQo5H;YACjCt9E,QAAQs9E,oBAAoBQ;YAC5B99E,QAAQ0d;;qBAECn8C,IAAI,GAAGld,IAAI64H,WAAW37G,MAAMld,KAAKkd;oBACnCi8G,kBAAkB1E,SAASv3G,IAC9Bk8G,aAAaD,gBAAgBF,mBAC7BxiC,OAAO0iC,gBAAgBlrE;cAC1BkrE,gBAAgBt6H,SAASu6H;cACzBD,gBAAgBF,oBAAoBxiC;cACpC0iC,gBAAgB9/D;;;;kBAIXpL,cAAc8qE,UACjBU,aAAa99E,QAAQsS;gBAEpBA,YAAY;cACf0qE,cAAcc,WAAW55H,QAAQhB;;YAGlC88C,QAAQ98C,SAAS46H;YACjB99E,QAAQ0d;;qBAECn8C,IAAI,GAAGld,IAAI64H,WAAW37G,MAAMld,KAAKkd;oBACnCi8G,kBAAkB1E,SAASv3G;cACjCi8G,gBAAgBt6H,SAASs6H,gBAAgBlrE;cACzCkrE,gBAAgB9/D;;;;;;MASpB,KAAKm7D,kBAAkBwE;;;IAIxB1E,WAAWvmE,MAAMkmE;;;YAGVyF,gBAAgB,KAAKpB;UACvBz5H,QAAQ66H,cAAc3rE;YACpB0mE,WAAW,KAAKJ;UAClBx1H,UAAUlc,kBAAkB8xI,SAAS51H;YACnCsoH,QAAQ,KAAKiR,QAChBQ,cAAc,KAAKP,cACnB18E,UAAU,KAAK8iB,UACfs6D,WAAWp9E,QAAQ32D,QACnBg0I,iBAAiB,KAAKxE,iBACtB2E,sBAAsB9xI,MAAM0xI;MAC/Bl6H,QAAQ41H,SAASzvI;MACjB00I,cAAc3rE,QAAQlvD;MACtBsoH,MAAM1kI,KAAKsrE;MACX6qE,YAAYn2I,KAAKwxI;MACjBQ,SAAShyI,KAAK02I;eAELp0I,IAAIi0I,gBAAgBj5H,IAAI47C,QAAQ32D,QAAQD,MAAMgb,KAAKhb;cACrDk1B,SAAS0hC,QAAQ52D;QACvBo0I,gBAAgBp0I,SAASmvI,gBAAgBj6G,QAAQ8zC,MAAMkmE;;aAGjDkF;;IAGRQ,aAAa5rE;;;YAGN2rE,gBAAgB,KAAKpB,wBACxBz5H,QAAQ66H,cAAc3rE;UAErBlvD,UAAUlc;cACPwkI,QAAQ,KAAKiR,QAChBQ,cAAc,KAAKP,cACnB5D,WAAW,KAAKJ,WAChBuF,oBAAoBnF,SAASzvI,SAAS,GACtC60I,eAAepF,SAASmF,oBACxBE,mBAAmB/rE,KAAK6rE;QAC3BF,cAAcI,oBAAoBj7H;QAClC41H,SAAS51H,SAASg7H;QAClBpF,SAASp7D;QACTu/D,YAAY/5H,SAAS+5H,YAAYgB;QACjChB,YAAYv/D;QACZ8tD,MAAMtoH,SAASsoH,MAAMyS;QACrBzS,MAAM9tD;;;;EAMT0gE,qBAAqBrzH,UAAUwuH,yBAAyB;EAExD;IACC/qI,YAAY6vI,OAAOxxB,MAAMyxB,YAAY,MAAMvvB,YAAYlC,KAAKkC;MAC3D,KAAKwvB,SAASF;MACd,KAAKG,QAAQ3xB;MACb,KAAK4xB,aAAaH;MAClB,KAAKvvB,YAAYA;YACXjC,SAASD,KAAKC,QACjB4xB,UAAU5xB,OAAOzjH,QACjBs1I,mBAAmBjzI,MAAMgzI;YACtBE;QACLpuB,aAAa3wG;QACb4wG,WAAW5wG;;eAGHzW,IAAI,GAAGA,MAAMs1I,WAAWt1I;cAC1BolH,cAAc1B,OAAO1jH,GAAG6kH,kBAAkB;QAChD0wB,aAAav1I,KAAKolH;QAClBA,YAAYY,WAAWwvB;;MAGxB,KAAKC,uBAAuBD;MAC5B,KAAKE,gBAAgBH;;;MAGrB,KAAKI,wBAAwBrzI,MAAMgzI;MACnC,KAAKM,cAAc;;MAEnB,KAAKC,oBAAoB;;MAEzB,KAAKC,wBAAwB;MAC7B,KAAKC,qBAAqB;MAC1B,KAAKrO,OAAOtxH;MACZ,KAAK4/H,cAAc;;;MAGnB,KAAKC,aAAa;;;MAGlB,KAAK/uI,OAAO;MACZ,KAAKoiH,YAAY;MACjB,KAAK4sB,sBAAsB;MAC3B,KAAKntC,SAAS;MACd,KAAKotC,mBAAmB;MACxB,KAAKC,cAAcniH;;MAEnB,KAAKoiH,SAAS;;MAEd,KAAKxyF,UAAU;;MAEf,KAAKyyF,oBAAoB;;MAEzB,KAAKC,mBAAmB;;MAExB,KAAKC,iBAAiB;;;IAIvBzN;MACC,KAAKoM,OAAOsB,gBAAgB;aAErB;;IAGR1uF;MACC,KAAKotF,OAAOuB,kBAAkB;aAEvB,KAAK56E;;IAGbA;MACC,KAAKu6E,SAAS;MACd,KAAKxyF,UAAU;MACf,KAAK38C,OAAO;;MAEZ,KAAK8uI,cAAc;;MAEnB,KAAKC,aAAa;;aAEX,KAAKU,aAAaC;;IAG1BC;aACQ,KAAKhzF,YAAY,KAAKwyF,UAAU,KAAK/sB,cAAc,KAAK,KAAK2sB,eAAe,QAAQ,KAAKd,OAAO2B,gBAAgB;;;IAIxHC;aACQ,KAAK5B,OAAO2B,gBAAgB;;IAGpCE,QAAQ9vI;MACP,KAAK+uI,aAAa/uI;aACX;;IAGR0iI,QAAQrtE,MAAM65E;MACb,KAAK1O,OAAOnrE;MACZ,KAAK65E,cAAcA;aACZ;;;;;;IAORa,mBAAmBluC;MAClB,KAAKA,SAASA;;MAEd,KAAKotC,mBAAmB,KAAKtyF,UAAUklD,SAAS;aACzC,KAAK4tC;;;IAIbO;aACQ,KAAKf;;IAGbgB,OAAOnsB;aACC,KAAKosB,gBAAgBpsB,UAAU,GAAG;;IAG1CqsB,QAAQrsB;aACA,KAAKosB,gBAAgBpsB,UAAU,GAAG;;IAG1CssB,cAAcC,eAAevsB,UAAUwsB;MACtCD,cAAcF,QAAQrsB;MACtB,KAAKmsB,OAAOnsB;UAERwsB;cACGC,iBAAiB,KAAKrC,MAAMpqB,UAC/B0sB,kBAAkBH,cAAcnC,MAAMpqB,UACtC2sB,gBAAgBD,kBAAkBD,gBAClCG,gBAAgBH,iBAAiBC;QACpCH,cAAcC,KAAK,KAAKG,eAAe3sB;QACvC,KAAKwsB,KAAKI,eAAe,KAAK5sB;;aAGxB;;IAGR6sB,YAAYC,cAAc9sB,UAAUwsB;aAC5BM,aAAaR,cAAc,MAAMtsB,UAAUwsB;;IAGnDb;YACOoB,oBAAoB,KAAKhC;UAE3BgC,sBAAsB;QACzB,KAAKhC,qBAAqB;QAE1B,KAAKZ,OAAO6C,4BAA4BD;;aAGlC;;;;;;IAORE,sBAAsB3uB;MACrB,KAAKA,YAAYA;MACjB,KAAK4sB,sBAAsB,KAAKG,SAAS,IAAI/sB;aACtC,KAAKstB;;;IAIbsB;aACQ,KAAKhC;;IAGbiC,YAAYntB;MACX,KAAK1B,YAAY,KAAK8rB,MAAMpqB,WAAWA;aAChC,KAAK4rB;;IAGbwB,SAAS1U;MACR,KAAKx8H,OAAOw8H,OAAOx8H;MACnB,KAAKoiH,YAAYoa,OAAOpa;aACjB,KAAKstB;;IAGbyB,KAAKrtB;aACG,KAAKwsB,KAAK,KAAKtB,qBAAqB,GAAGlrB;;IAG/CwsB,KAAKc,gBAAgBC,cAAcvtB;YAC5BiqB,QAAQ,KAAKE,QAChB/xI,MAAM6xI,MAAM/tI,MACZoiH,YAAY,KAAKA;UAChBlE,cAAc,KAAK0wB;UAEnB1wB,gBAAgB;QACnBA,cAAc6vB,MAAMuD;QACpB,KAAK1C,wBAAwB1wB;;YAGxBxC,QAAQwC,YAAYQ,oBACvBt9E,SAAS88E,YAAYS;MACxBjD,MAAM,KAAKx/G;MACXw/G,MAAM,KAAKx/G,MAAM4nH;MACjB1iF,OAAO,KAAKgwG,iBAAiBhvB;MAC7BhhF,OAAO,KAAKiwG,eAAejvB;aACpB;;IAGRstB;YACO6B,uBAAuB,KAAK3C;UAE9B2C,yBAAyB;QAC5B,KAAK3C,wBAAwB;QAE7B,KAAKX,OAAO6C,4BAA4BS;;aAGlC;;;IAIRC;aACQ,KAAKvD;;IAGbwD;aACQ,KAAKvD;;IAGbwD;aACQ,KAAKvD,cAAc,KAAKF,OAAO0D;;;IAIvCC,QAAQ5xI,MAAM6xI,WAAWC,eAAerL;;WAElC,KAAK9pF;;QAET,KAAKo1F,cAAc/xI;;;YAKdqiH,YAAY,KAAK0sB;UAEnB1sB,cAAc;;cAEX2vB,eAAehyI,OAAOqiH,aAAayvB;YAErCE,cAAc,KAAKF,kBAAkB;;;;QAKzC,KAAK/C,aAAa;;QAElB8C,YAAYC,gBAAgBE;;;MAI7BH,aAAa,KAAKI,iBAAiBjyI;YAE7BkyI,WAAW,KAAKC,YAAYN;;;YAI5BhwC,SAAS,KAAKkwC,cAAc/xI;UAE9B6hG,SAAS;cACNwsC,eAAe,KAAKG;cACpB4D,iBAAiB,KAAK3D;gBAEpB,KAAKhwB;eACP9uG;qBACKshB,IAAI,GAAGld,IAAIs6H,aAAat1I,QAAQk4B,MAAMld,KAAKkd;cACnDo9G,aAAap9G,GAAGktF,SAAS+zB;cACzBE,eAAenhH,GAAG21G,mBAAmB/kC;;;eAKlCnyF;;qBAEKuhB,IAAI,GAAGld,IAAIs6H,aAAat1I,QAAQk4B,MAAMld,KAAKkd;cACnDo9G,aAAap9G,GAAGktF,SAAS+zB;cACzBE,eAAenhH,GAAGu1G,WAAWC,WAAW5kC;;;;;IAO7CkwC,cAAc/xI;UACT6hG,SAAS;UAET,KAAKllD;QACRklD,SAAS,KAAKA;cACRqc,cAAc,KAAK2wB;YAErB3wB,gBAAgB;gBACbm0B,mBAAmBn0B,YAAYC,SAASn+G,MAAM;UACpD6hG,UAAUwwC;cAENryI,OAAOk+G,YAAYQ,mBAAmB;YACzC,KAAK+wB;gBAED4C,qBAAqB;;cAExB,KAAK11F,UAAU;;;;;MAMnB,KAAKsyF,mBAAmBptC;aACjBA;;IAGRowC,iBAAiBjyI;UACZoiH,YAAY;WAEX,KAAK+sB;QACT/sB,YAAY,KAAKA;cACXlE,cAAc,KAAK0wB;YAErB1wB,gBAAgB;gBACbm0B,mBAAmBn0B,YAAYC,SAASn+G,MAAM;UACpDoiH,aAAaiwB;cAETryI,OAAOk+G,YAAYQ,mBAAmB;YACzC,KAAKgxB;gBAEDttB,cAAc;;cAEjB,KAAK+sB,SAAS;;;cAGd,KAAK/sB,YAAYA;;;;;MAMrB,KAAK4sB,sBAAsB5sB;aACpBA;;IAGR+vB,YAAYN;YACL/tB,WAAW,KAAKoqB,MAAMpqB;YACtB0c,OAAO,KAAKA;UACdxgI,OAAO,KAAKA,OAAO6xI;UACnBS,YAAY,KAAKxD;YACfyD,WAAW/R,SAASrxH;UAEtB0iI,cAAc;YACbS,eAAe,UAAUtyI;eACtBuyI,aAAaD,YAAY,OAAO,IAAIxuB,WAAW9jH,OAAOA;;UAG1DwgI,SAASvxH;YACRqjI,eAAe;;UAElB,KAAKxD,aAAa;UAElB,KAAK0D,YAAY,MAAM,MAAM;;QAG9BC;cACKzyI,QAAQ8jH;YACX9jH,OAAO8jH;qBACG9jH,OAAO;YACjBA,OAAO;;YAEP,KAAKA,OAAOA;kBACNyyI;;cAGH,KAAKrD,mBAAmB,KAAKD,SAAS,WAAU,KAAKxyF,UAAU;UACnE,KAAK38C,OAAOA;UAEZ,KAAKiuI,OAAOn7H;YACXhb,MAAM;YACN0kI,QAAQ;YACRjqG,WAAWs/G,YAAY,KAAK,IAAI;;;;;YAK9BS,eAAe;;cAEdT,aAAa;YAChBS,YAAY;YAEZ,KAAKE,YAAY,MAAM,KAAKtD,gBAAgB,GAAGqD;;;;;YAK/C,KAAKC,YAAY,KAAKtD,gBAAgB,GAAG,MAAMqD;;;YAI7CvyI,QAAQ8jH,YAAY9jH,OAAO;;gBAExB0yI,YAAY70I,KAAKC,MAAMkC,OAAO8jH;;UAEpC9jH,QAAQ8jH,WAAW4uB;UACnBJ,aAAaz0I,KAAK4W,IAAIi+H;gBAChBC,UAAU,KAAKzD,cAAcoD;cAE/BK,WAAW;;gBAEV,KAAKvD,mBAAmB,KAAKD,SAAS,WAAU,KAAKxyF,UAAU;YACnE38C,OAAO6xI,YAAY,IAAI/tB,WAAW;YAClC,KAAK9jH,OAAOA;YAEZ,KAAKiuI,OAAOn7H;cACXhb,MAAM;cACN0kI,QAAQ;cACRjqG,WAAWs/G,YAAY,IAAI,KAAK;;;;gBAI7Bc,YAAY;;oBAETC,UAAUf,YAAY;cAE5B,KAAKW,YAAYI,UAAUA,SAASL;;cAEpC,KAAKC,YAAY,OAAO,OAAOD;;YAGhC,KAAKzD,aAAawD;YAClB,KAAKtyI,OAAOA;YAEZ,KAAKiuI,OAAOn7H;cACXhb,MAAM;cACN0kI,QAAQ;cACRkW,WAAWA;;;;UAIb,KAAK1yI,OAAOA;;YAGTuyI,aAAaD,YAAY,OAAO;;iBAE5BxuB,WAAW9jH;;;aAIbA;;IAGRwyI,YAAYI,SAASC,OAAON;YACrBzzB,WAAW,KAAKyvB;UAElBgE;QACHzzB,SAASoB,cAAc1wG;QACvBsvG,SAASqB,YAAY3wG;;;YAGjBojI;UACH9zB,SAASoB,cAAc,KAAKmvB,mBAAmB7/H,kBAAkBD;;UAEjEuvG,SAASoB,cAAczwG;;YAGpBojI;UACH/zB,SAASqB,YAAY,KAAKmvB,iBAAiB9/H,kBAAkBD;;UAE7DuvG,SAASqB,YAAY1wG;;;;IAKxBygI,gBAAgBpsB,UAAUgvB,WAAWC;YAC9BhF,QAAQ,KAAKE,QAChB/xI,MAAM6xI,MAAM/tI;UACXk+G,cAAc,KAAK2wB;UAEnB3wB,gBAAgB;QACnBA,cAAc6vB,MAAMuD;QACpB,KAAKzC,qBAAqB3wB;;YAGrBxC,QAAQwC,YAAYQ,oBACvBt9E,SAAS88E,YAAYS;MACxBjD,MAAM,KAAKx/G;MACXklC,OAAO,KAAK0xG;MACZp3B,MAAM,KAAKx/G,MAAM4nH;MACjB1iF,OAAO,KAAK2xG;aACL;;;EAKT,6BAA6BjzH;IAC5B5hB,YAAY1F;MACX;MACA,KAAKm5I,QAAQn5I;MAEb,KAAKw6I;MAEL,KAAKC,aAAa;MAClB,KAAKjzI,OAAO;MACZ,KAAKoiH,YAAY;;IAGlB8wB,YAAY1W,QAAQ2W;YACb36I,OAAOgkI,OAAO2R,cAAc,KAAKwD,OACpCn1B,SAASggB,OAAO0R,MAAM1xB,QACtB4xB,UAAU5xB,OAAOzjH,QACjByvI,WAAWhM,OAAOiS,mBAClBJ,eAAe7R,OAAOgS,eACtB4E,WAAW56I,KAAKob,MAChBy/H,iBAAiB,KAAKC;UACrBC,iBAAiBF,eAAeD;UAEhCG,mBAAmB78I;QACtB68I;QACAF,eAAeD,YAAYG;;eAGnBz6I,IAAI,GAAGA,MAAMs1I,WAAWt1I;cAC1B2jH,QAAQD,OAAO1jH,IAClBqsH,YAAY1I,MAAMz4G;YACjBkhI,UAAUqO,eAAepuB;YAEzB+f,YAAYxuI;UACf8xI,SAAS1vI,KAAKosI;;UAEdA,UAAUsD,SAAS1vI;cAEfosI,YAAYxuI;;gBAEXwuI,QAAQwJ,gBAAgB;gBACzBxJ,QAAQqB;cAEV,KAAKiN,oBAAoBtO,SAASkO,UAAUjuB;;;;gBAMxCrjD,OAAOqxE,mBAAmBA,gBAAgB1E,kBAAkB31I,GAAGosI,QAAQ8C;UAC7E9C,cAAcuO,cAAcxL,gBAAgBe,OAAOxwI,MAAM2sH,WAAWrjD,OAAO26C,MAAMa,eAAeb,MAAME;YACpGuoB,QAAQqB;UAEV,KAAKiN,oBAAoBtO,SAASkO,UAAUjuB;UAE5CqjB,SAAS1vI,KAAKosI;;QAGfmJ,aAAav1I,GAAGslH,eAAe8mB,QAAQj0F;;;IAIzCs+F,gBAAgB/S;WACV,KAAKoT,gBAAgBpT;YACrBA,OAAOkS,gBAAgB;;;gBAGpB0E,YAAY5W,OAAO2R,cAAc,KAAKwD,OAAO/9H,MAChD8/H,WAAWlX,OAAO0R,MAAMt6H,MACxB+/H,iBAAiB,KAAKC,eAAeF;UAExC,KAAKR,YAAY1W,QAAQmX,kBAAkBA,eAAeE,aAAa;UAEvE,KAAKC,mBAAmBtX,QAAQkX,UAAUN;;cAGrC5K,WAAWhM,OAAOiS;;iBAEf31I,IAAI,GAAGgb,IAAI00H,SAASzvI,QAAQD,MAAMgb,KAAKhb;gBACzCosI,UAAUsD,SAAS1vI;cAErBosI,QAAQoB,eAAe;YAC1B,KAAKyN,aAAa7O;YAElBA,QAAQ6B;;;QAIV,KAAKiN,YAAYxX;;;IAInBgT,kBAAkBhT;UACb,KAAKoT,gBAAgBpT;cAClBgM,WAAWhM,OAAOiS;;iBAEf31I,IAAI,GAAGgb,IAAI00H,SAASzvI,QAAQD,MAAMgb,KAAKhb;gBACzCosI,UAAUsD,SAAS1vI;gBAEnBosI,QAAQoB,aAAa;YAC1BpB,QAAQ+B;YAER,KAAKgN,iBAAiB/O;;;QAIxB,KAAKgP,gBAAgB1X;;;;IAKvBwW;MACC,KAAKmB;;MAEL,KAAKC,kBAAkB;MACvB,KAAKR;;;;;;MAML,KAAKxL;;MAEL,KAAKiM,mBAAmB;MACxB,KAAKf;;MAEL,KAAKgB;;MAEL,KAAKC,8BAA8B;YAC7B57F,QAAQ;MACd,KAAK2zF;QACJkI;cACKjI;mBACI5zF,MAAMw7F,SAASp7I;;cAGnByzI;mBACI7zF,MAAMy7F;;;QAIf5L;cACK+D;mBACI5zF,MAAMyvF,UAAUrvI;;cAGpByzI;mBACI7zF,MAAM07F;;;QAIfI;cACKlI;mBACI5zF,MAAM27F,qBAAqBv7I;;cAG/ByzI;mBACI7zF,MAAM47F;;;;;;IAQjB3E,gBAAgBpT;YACT5pH,QAAQ4pH,OAAOkS;aACd97H,UAAU,QAAQA,QAAQ,KAAKwhI;;IAGvCN,mBAAmBtX,QAAQkX,UAAUN;YAC9BoB,UAAU,KAAKL,UAClBO,gBAAgB,KAAKd;UACpBD,iBAAiBe,cAAchB;UAE/BC,mBAAmBj9I;QACtBi9I;UACCE,eAAerX;UACfmY;;QAEDnY,OAAOmS,oBAAoB;QAC3B+F,cAAchB,YAAYC;;cAEpBE,eAAeF,eAAeE;QACpCrX,OAAOmS,oBAAoBkF,aAAa96I;QACxC86I,aAAar9I,KAAKgmI;;MAGnBA,OAAOkS,cAAc8F,QAAQz7I;MAC7By7I,QAAQh+I,KAAKgmI;MACbmX,eAAegB,aAAavB,YAAY5W;;IAGzCoY,sBAAsBpY;YACfgY,UAAU,KAAKL,UAClBU,qBAAqBL,QAAQA,QAAQz7I,SAAS,IAC9C+7I,aAAatY,OAAOkS;MACvBmG,mBAAmBnG,cAAcoG;MACjCN,QAAQM,cAAcD;MACtBL,QAAQpnE;MACRovD,OAAOkS,cAAc;YACfgF,WAAWlX,OAAO0R,MAAMt6H,MAC3B8gI,gBAAgB,KAAKd,gBACrBD,iBAAiBe,cAAchB,WAC/BqB,sBAAsBpB,eAAeE,cACrCmB,kBAAkBD,oBAAoBA,oBAAoBh8I,SAAS,IACnEk8I,mBAAmBzY,OAAOmS;MAC7BqG,gBAAgBrG,oBAAoBsG;MACpCF,oBAAoBE,oBAAoBD;MACxCD,oBAAoB3nE;MACpBovD,OAAOmS,oBAAoB;YACrBgG,eAAehB,eAAegB,cACjCvB,YAAY5W,OAAO2R,cAAc,KAAKwD,OAAO/9H;aACzC+gI,aAAavB;UAEhB2B,oBAAoBh8I,WAAW;eAC3B27I,cAAchB;;MAGtB,KAAKwB,iCAAiC1Y;;IAGvC0Y,iCAAiC1Y;YAC1BgM,WAAWhM,OAAOiS;eAEf31I,IAAI,GAAGgb,IAAI00H,SAASzvI,QAAQD,MAAMgb,KAAKhb;cACzCosI,UAAUsD,SAAS1vI;cAEnBosI,QAAQqB,mBAAmB;UAChC,KAAK4O,uBAAuBjQ;;;;IAK/B8O,YAAYxX;;;;;;YAMLgY,UAAU,KAAKL,UAClBiB,YAAY5Y,OAAOkS,aACnB2G,kBAAkB,KAAKjB,mBACvBkB,sBAAsBd,QAAQa;MACjC7Y,OAAOkS,cAAc2G;MACrBb,QAAQa,mBAAmB7Y;MAC3B8Y,oBAAoB5G,cAAc0G;MAClCZ,QAAQY,aAAaE;;IAGtBpB,gBAAgB1X;;;;;;YAMTgY,UAAU,KAAKL,UAClBiB,YAAY5Y,OAAOkS,aACnB6G,uBAAuB,KAAKnB,iBAC5BoB,mBAAmBhB,QAAQe;MAC9B/Y,OAAOkS,cAAc6G;MACrBf,QAAQe,sBAAsB/Y;MAC9BgZ,iBAAiB9G,cAAc0G;MAC/BZ,QAAQY,aAAaI;;;IAItBhC,oBAAoBtO,SAASkO,UAAUjuB;YAChCkuB,iBAAiB,KAAKC,wBACzB9K,WAAW,KAAKJ;UACfqN,gBAAgBpC,eAAeD;UAE/BqC,kBAAkB/+I;QACrB++I;QACApC,eAAeD,YAAYqC;;MAG5BA,cAActwB,aAAa+f;MAC3BA,QAAQwJ,cAAclG,SAASzvI;MAC/ByvI,SAAShyI,KAAK0uI;;IAGfiQ,uBAAuBjQ;YAChBsD,WAAW,KAAKJ,WACnBsN,cAAcxQ,QAAQA,SACtBkO,WAAWsC,YAAYhN,SAAS90H,MAChCuxG,YAAYuwB,YAAY5zE,MACxBuxE,iBAAiB,KAAKC,wBACtBmC,gBAAgBpC,eAAeD,WAC/BuC,sBAAsBnN,SAASA,SAASzvI,SAAS,IACjD+7I,aAAa5P,QAAQwJ;MACxBiH,oBAAoBjH,cAAcoG;MAClCtM,SAASsM,cAAca;MACvBnN,SAASp7D;aACFqoE,cAActwB;UAEjBlvG,OAAO+/B,KAAKy/F,eAAe18I,WAAW;eAClCs6I,eAAeD;;;IAIxBW,aAAa7O;YACNsD,WAAW,KAAKJ,WACnBgN,YAAYlQ,QAAQwJ,aACpB2G,kBAAkB,KAAKhB,oBACvBuB,uBAAuBpN,SAAS6M;MACnCnQ,QAAQwJ,cAAc2G;MACtB7M,SAAS6M,mBAAmBnQ;MAC5B0Q,qBAAqBlH,cAAc0G;MACnC5M,SAAS4M,aAAaQ;;IAGvB3B,iBAAiB/O;YACVsD,WAAW,KAAKJ,WACnBgN,YAAYlQ,QAAQwJ,aACpB6G,uBAAuB,KAAKlB,kBAC5BwB,oBAAoBrN,SAAS+M;MAChCrQ,QAAQwJ,cAAc6G;MACtB/M,SAAS+M,sBAAsBrQ;MAC/B2Q,kBAAkBnH,cAAc0G;MAChC5M,SAAS4M,aAAaS;;;IAIvBvE;YACOjD,eAAe,KAAKiG,sBACvBe,kBAAkB,KAAKd;UACtBr2B,cAAcmwB,aAAagH;UAE3Bn3B,gBAAgBxnH;QACnBwnH,kBAAkB6D,sBAAsBjxE,aAAa,QAAQA,aAAa,IAAI,GAAG,KAAKglG;QACtF53B,YAAY63B,eAAeV;QAC3BhH,aAAagH,mBAAmBn3B;;aAG1BA;;IAGR4yB,4BAA4B5yB;YACrBmwB,eAAe,KAAKiG,sBACvBc,YAAYl3B,YAAY63B,cACxBR,uBAAuB,KAAKhB,6BAC5ByB,wBAAwB3H,aAAakH;MACxCr3B,YAAY63B,eAAeR;MAC3BlH,aAAakH,sBAAsBr3B;MACnC83B,sBAAsBD,eAAeX;MACrC/G,aAAa+G,aAAaY;;;;;IAM3BC,WAAW15B,MAAM25B,cAAcz3B;YACxBjmH,OAAO09I,gBAAgB,KAAKvE,OAC/ByB,WAAW56I,KAAKob;UACfuiI,oBAAoB55B,SAAS,WAAWyN,cAAczF,WAAW/rH,MAAM+jH,QAAQA;YAC7Em3B,WAAWyC,eAAe,OAAOA,WAAWviI,OAAO2oG;YACnDo3B,iBAAiB,KAAKC,eAAeF;UACvCP,kBAAkB;UAElB10B,cAAc/nH;YACby/I,eAAe;UAClB13B,YAAY03B,WAAW13B;;UAEvBA,YAAY/uG;;;UAIVikI,mBAAmBj9I;cAChB0/I,iBAAiBzC,eAAegB,aAAavB;YAE/CgD,mBAAmB1/I,aAAa0/I,eAAe33B,cAAcA;iBACzD23B;;;;QAKRjD,kBAAkBQ,eAAeE,aAAa;;YAE1CsC,eAAe,MAAMA,aAAahD,gBAAgBjF;;;UAInDiI,eAAe,aAAa;;YAE1BE,gBAAgBC,gBAAgB,MAAMH,YAAYD,cAAcz3B;MAEtE,KAAKy0B,YAAYmD,WAAWlD;;MAG5B,KAAKW,mBAAmBuC,WAAW3C,UAAUN;aAEtCiD;;;IAIRD,eAAe75B,MAAM25B;YACd19I,OAAO09I,gBAAgB,KAAKvE,OAC/ByB,WAAW56I,KAAKob,MAChBuiI,oBAAoB55B,SAAS,WAAWyN,cAAczF,WAAW/rH,MAAM+jH,QAAQA,MAC/Em3B,WAAWyC,aAAaA,WAAWviI,OAAO2oG,MAC1Co3B,iBAAiB,KAAKC,eAAeF;UAEpCC,mBAAmBj9I;eACfi9I,eAAegB,aAAavB,aAAa;;aAG1C;;;IAIRmD;YACO/B,UAAU,KAAKL,UAClBqC,WAAW,KAAKpC;eAEVt7I,IAAI09I,WAAW,GAAG19I,KAAK,KAAKA;QACpC07I,QAAQ17I,GAAG+nD;;aAGL;;;IAIRp5B,OAAOoqH;MACNA,aAAa,KAAKzvB;YACZoyB,UAAU,KAAKL,UAClBqC,WAAW,KAAKpC,iBAChBp0I,OAAO,KAAKA,QAAQ6xI,WACpBC,gBAAgBj0I,KAAKi3B,KAAK+8G,YAC1BpL,YAAY,KAAKwM,cAAc;;eAEzBn6I,IAAI,GAAGA,MAAM09I,YAAY19I;cAC3B0jI,SAASgY,QAAQ17I;QAEvB0jI,OAAOoV,QAAQ5xI,MAAM6xI,WAAWC,eAAerL;;;YAI1C+B,WAAW,KAAKJ,WACnBwE,YAAY,KAAKyH;eAEXv7I,IAAI,GAAGA,MAAM8zI,aAAa9zI;QAClC0vI,SAAS1vI,GAAG2E,MAAMgpI;;aAGZ;;;IAIRgQ,QAAQC;MACP,KAAK12I,OAAO;;eAEHlH,IAAI,GAAGA,IAAI,KAAKq7I,SAASp7I,QAAQD;QACzC,KAAKq7I,SAASr7I,GAAGkH,OAAO;;aAGlB,KAAKynB,OAAOivH;;;IAIpBhF;aACQ,KAAKC;;;IAIbgF,YAAYp6B;YACLi4B,UAAU,KAAKL,UAClBT,WAAWn3B,KAAK3oG,MAChB8gI,gBAAgB,KAAKd,gBACrBD,iBAAiBe,cAAchB;UAE9BC,mBAAmBj9I;;;;cAIhBkgJ,kBAAkBjD,eAAeE;iBAE9B/6I,IAAI,GAAGgb,IAAI8iI,gBAAgB79I,QAAQD,MAAMgb,KAAKhb;gBAChD0jI,SAASoa,gBAAgB99I;UAE/B,KAAK02I,kBAAkBhT;gBAEjBsY,aAAatY,OAAOkS,aACvBmG,qBAAqBL,QAAQA,QAAQz7I,SAAS;UACjDyjI,OAAOkS,cAAc;UACrBlS,OAAOmS,oBAAoB;UAC3BkG,mBAAmBnG,cAAcoG;UACjCN,QAAQM,cAAcD;UACtBL,QAAQpnE;UAER,KAAK8nE,iCAAiC1Y;;eAGhCkY,cAAchB;;;;IAKvBmD,YAAYr+I;YACL46I,WAAW56I,KAAKob,MACnB8gI,gBAAgB,KAAKd;iBAEbF,YAAYgB;cAChBC,eAAeD,cAAchB,UAAUiB,cAC1CnY,SAASmY,aAAavB;YAErB5W,WAAW9lI;UACd,KAAK84I,kBAAkBhT;UAEvB,KAAKoY,sBAAsBpY;;;YAIvB6W,iBAAiB,KAAKC,wBACzBmC,gBAAgBpC,eAAeD;UAE9BqC,kBAAkB/+I;mBACVyuH,aAAaswB;gBACjBvQ,UAAUuQ,cAActwB;UAC9B+f,QAAQ+B;UAER,KAAKkO,uBAAuBjQ;;;;;IAM/B4R,cAAcv6B,MAAM25B;YACb1Z,SAAS,KAAK4Z,eAAe75B,MAAM25B;UAErC1Z,WAAW;QACd,KAAKgT,kBAAkBhT;QAEvB,KAAKoY,sBAAsBpY;;;;EAM9Bua,eAAet8H,UAAUq7H,uCAAuChlG,aAAa;EAE7E;IACC5yC,YAAYyF;iBACAA,UAAU;QACpBhL,QAAQ0B,KAAK;QACbsJ,QAAQgX,UAAU;;MAGnB,KAAKhX,QAAQA;;IAGdrD;iBACY02I,QAAQ,KAAKrzI,MAAMrD,UAAU5J,YAAY,KAAKiN,QAAQ,KAAKA,MAAMrD;;;EAK9E,yCAAyC6+F;IACxCjhG,YAAY6U,OAAO0gD,QAAQH,mBAAmB;MAC7C,MAAMvgD,OAAO0gD;MACb,KAAKH,mBAAmBA,oBAAoB;;IAG7Cz7C,KAAKyJ;MACJ,MAAMzJ,KAAKyJ;MACX,KAAKgyC,mBAAmBhyC,OAAOgyC;aACxB;;IAGRhzD,MAAMpK;YACCgpG,KAAK,MAAM5+F,MAAMpK;MACvBgpG,GAAG5rC,mBAAmB,KAAKA;aACpB4rC;;IAGR39E,OAAOrrB;YACA0sG,OAAO,MAAMrhF,OAAOrrB;MAC1B0sG,KAAK1uC,+BAA+B;MACpC0uC,KAAKtvC,mBAAmB,KAAKA;aACtBsvC;;;EAKTq0C,2BAA2Bx8H,UAAUy5C,+BAA+B;EAEpE;IACCh2D,YAAY+yC,QAAQn5C,MAAMi3C,UAAU0T,aAAavhD;MAChD,KAAK+vC,SAASA;MACd,KAAKn5C,OAAOA;MACZ,KAAKi3C,WAAWA;MAChB,KAAK0T,cAAcA;MACnB,KAAKvhD,QAAQA;MACb,KAAKigB,UAAU;;QAGZiB,YAAYze;UACXA,UAAU,MAAM,KAAKwd;;IAG1BygH,UAAU3wF;MACT,KAAKA,SAASA;aACP;;IAGRimG,QAAQp/I,MAAM2qD;MACb,KAAK3qD,OAAOA;MACZ,KAAK2qD,cAAcA;aACZ;;IAGR00F,YAAYpoG;MACX,KAAKA,WAAWA;aACT;;IAGRqoG,SAASl2I;MACR,KAAKA,QAAQA;aACN;;;EAKTm2I,kBAAkB58H,UAAUk4B,sBAAsB;EAElD;IACCz0C,YAAYrB,QAAQ01B,WAAWyH,OAAO,GAAGC,MAAMlN;MAC9C,KAAKyF,UAAU6jB,IAAIx5C,QAAQ01B;;MAE3B,KAAKyH,OAAOA;MACZ,KAAKC,MAAMA;MACX,KAAKlP,SAAS;MACd,KAAKwQ,aAAayB;MAClB,KAAKv8B;QACJrB;QACA8kG;UACCtY,WAAW;;QAEZisC;QACA3yB;UACCtZ,WAAW;;QAEZ4U;;;IAIFv7F,IAAIpI,QAAQ01B;;MAEX,KAAKC,IAAIvtB,IAAIpI,QAAQ01B;;IAGtB+kH,cAAcC,QAAQxsH;UACjBA,UAAUA,OAAOkyB;QACpB,KAAKzqB,IAAI31B,OAAO6vB,sBAAsB3B,OAAOK;QAC7C,KAAKoH,IAAID,UAAUttB,IAAIsyI,OAAO73I,GAAG63I,OAAO13I,GAAG,KAAKqrB,UAAUH,QAAQ7S,IAAI,KAAKsa,IAAI31B,QAAQqF;QACvF,KAAK6oB,SAASA;iBACJA,UAAUA,OAAOixE;QAC3B,KAAKxpE,IAAI31B,OAAOoI,IAAIsyI,OAAO73I,GAAG63I,OAAO13I,IAAIkrB,OAAOiP,OAAOjP,OAAOkP,QAAQlP,OAAOiP,OAAOjP,OAAOkP,MAAM/O,UAAUH;;QAE3G,KAAKyH,IAAID,UAAUttB,IAAI,GAAG,IAAI,GAAGomB,mBAAmBN,OAAOK;QAC3D,KAAKL,SAASA;;QAEdpyB,QAAQa,MAAM,+CAA+CuxB,OAAOjzB;;;IAItE0/I,gBAAgBxpH,QAAQsT,YAAY,OAAOsW;MAC1C4/F,gBAAgBxpH,QAAQ,MAAM4pB,YAAYtW;MAC1CsW,WAAWujB,KAAKs8E;aACT7/F;;IAGR8/F,iBAAiBhoF,SAASpuB,YAAY,OAAOsW;eACnC9+C,IAAI,GAAGma,IAAIy8C,QAAQ32D,QAAQD,IAAIma,GAAGna;QAC1C0+I,gBAAgB9nF,QAAQ52D,IAAI,MAAM8+C,YAAYtW;;MAG/CsW,WAAWujB,KAAKs8E;aACT7/F;;;EAKT,iBAAiBxiC,GAAGC;WACZD,EAAExS,WAAWyS,EAAEzS;;EAGvB,yBAAyBorB,QAAQ2pB,WAAWC,YAAYtW;QACnDtT,OAAOuN,OAAO/jC,KAAKmgD,UAAUpc;MAChCvN,OAAOqR,QAAQsY,WAAWC;;QAGvBtW,cAAc;YACXvS,WAAWf,OAAOe;eAEfj2B,IAAI,GAAGma,IAAI8b,SAASh2B,QAAQD,IAAIma,GAAGna;QAC3C0+I,gBAAgBzoH,SAASj2B,IAAI6+C,WAAWC,YAAY;;;;;;;;;;EAYvD;IACC15C,YAAYoB,SAAS,GAAGE,MAAM,GAAGD,QAAQ;MACxC,KAAKD,SAASA;MACd,KAAKE,MAAMA;;MAEX,KAAKD,QAAQA;;aAEN;;IAGR0F,IAAI3F,QAAQE,KAAKD;MAChB,KAAKD,SAASA;MACd,KAAKE,MAAMA;MACX,KAAKD,QAAQA;aACN;;IAGRsY,KAAK8/H;MACJ,KAAKr4I,SAASq4I,MAAMr4I;MACpB,KAAKE,MAAMm4I,MAAMn4I;MACjB,KAAKD,QAAQo4I,MAAMp4I;aACZ;;;IAIRq4I;YACOviC,MAAM;MACZ,KAAK71G,MAAM3B,KAAKF,IAAI03G,KAAKx3G,KAAKD,IAAIC,KAAKyV,KAAK+hG,KAAK,KAAK71G;aAC/C;;IAGRk7B,eAAep9B;aACP,KAAKu6I,uBAAuBv6I,EAAEoC,GAAGpC,EAAEuC,GAAGvC,EAAEwC;;IAGhD+3I,uBAAuBn4I,GAAGG,GAAGC;MAC5B,KAAKR,SAASzB,KAAKob,KAAKvZ,IAAIA,IAAIG,IAAIA,IAAIC,IAAIA;UAExC,KAAKR,WAAW;QACnB,KAAKC,QAAQ;QACb,KAAKC,MAAM;;QAEX,KAAKD,QAAQ1B,KAAKub,MAAM1Z,GAAGI;QAC3B,KAAKN,MAAM3B,KAAKglB,KAAKxM,MAAMxW,IAAI,KAAKP,SAAS,GAAG;;aAG1C;;IAGRgB;iBACY,KAAKpC,cAAc2Z,KAAK;;;;;;EAQrC;IACC3Z,YAAYoB,SAAS,GAAGC,QAAQ,GAAGM,IAAI;MACtC,KAAKP,SAASA;;MAEd,KAAKC,QAAQA;;MAEb,KAAKM,IAAIA;;aAEF;;IAGRoF,IAAI3F,QAAQC,OAAOM;MAClB,KAAKP,SAASA;MACd,KAAKC,QAAQA;MACb,KAAKM,IAAIA;aACF;;IAGRgY,KAAK8/H;MACJ,KAAKr4I,SAASq4I,MAAMr4I;MACpB,KAAKC,QAAQo4I,MAAMp4I;MACnB,KAAKM,IAAI83I,MAAM93I;aACR;;IAGR66B,eAAep9B;aACP,KAAKu6I,uBAAuBv6I,EAAEoC,GAAGpC,EAAEuC,GAAGvC,EAAEwC;;IAGhD+3I,uBAAuBn4I,GAAGG,GAAGC;MAC5B,KAAKR,SAASzB,KAAKob,KAAKvZ,IAAIA,IAAII,IAAIA;MACpC,KAAKP,QAAQ1B,KAAKub,MAAM1Z,GAAGI;MAC3B,KAAKD,IAAIA;aACF;;IAGRS;iBACY,KAAKpC,cAAc2Z,KAAK;;;QAK/BigI,6BAA6Bt9H;EAEnC;IACCtc,YAAYN,UAAU4c,SAASuS,WAAWA,WAAWpvB,UAAU6c,SAASuS,WAAWA;MAClF,KAAKnvB,MAAMA;MACX,KAAKD,MAAMA;;IAGZsH,IAAIrH,KAAKD;MACR,KAAKC,IAAIia,KAAKja;MACd,KAAKD,IAAIka,KAAKla;aACP;;IAGR6vB,cAAcC;MACb,KAAKC;eAEI50B,IAAI,GAAGksB,KAAKyI,OAAO10B,QAAQD,IAAIksB,IAAIlsB;QAC3C,KAAK60B,cAAcF,OAAO30B;;aAGpB;;IAGR80B,qBAAqBrT,QAAQtX;YACtB4qB,WAAWiqH,UAAUjgI,KAAK5U,MAAM/C,eAAe;MAErD,KAAKtC,IAAIia,KAAK0C,QAAQrC,IAAI2V;MAC1B,KAAKlwB,IAAIka,KAAK0C,QAAQpa,IAAI0tB;aACnB;;IAGRvtB;iBACY,KAAKpC,cAAc2Z,KAAK;;IAGpCA,KAAKqW;MACJ,KAAKtwB,IAAIia,KAAKqW,IAAItwB;MAClB,KAAKD,IAAIka,KAAKqW,IAAIvwB;aACX;;IAGR+vB;MACC,KAAK9vB,IAAI8B,IAAI,KAAK9B,IAAIiC,KAAKktB;MAC3B,KAAKpvB,IAAI+B,IAAI,KAAK/B,IAAIkC,KAAKktB;aACpB;;IAGRoB;;aAEQ,KAAKxwB,IAAI+B,IAAI,KAAK9B,IAAI8B,KAAK,KAAK/B,IAAIkC,IAAI,KAAKjC,IAAIiC;;IAGzDuuB,UAAU9rB;UACLA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAakY;;aAGP,KAAK2T,YAAY7rB,OAAO2C,IAAI,GAAG,KAAK3C,OAAOyV,WAAW,KAAKna,KAAK,KAAKD,KAAKuC,eAAe;;IAGjGmuB,QAAQ/rB;UACHA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAakY;;aAGP,KAAK2T,YAAY7rB,OAAO2C,IAAI,GAAG,KAAK3C,OAAOH,WAAW,KAAKxE,KAAK,KAAKC;;IAG7E+vB,cAAcW;MACb,KAAK1wB,IAAIA,IAAI0wB;MACb,KAAK3wB,IAAIA,IAAI2wB;aACN;;IAGRC,eAAeC;MACd,KAAK5wB,IAAIsa,IAAIsW;MACb,KAAK7wB,IAAIwC,IAAIquB;aACN;;IAGRC,eAAejX;MACd,KAAK5Z,IAAIoa,WAAWR;MACpB,KAAK7Z,IAAIqa,UAAUR;aACZ;;IAGRwX,cAAcV;aACNA,MAAM5uB,IAAI,KAAK9B,IAAI8B,KAAK4uB,MAAM5uB,IAAI,KAAK/B,IAAI+B,KAAK4uB,MAAMzuB,IAAI,KAAKjC,IAAIiC,KAAKyuB,MAAMzuB,IAAI,KAAKlC,IAAIkC,IAAI,QAAQ;;IAG/GovB,YAAYf;aACJ,KAAKtwB,IAAI8B,KAAKwuB,IAAItwB,IAAI8B,KAAKwuB,IAAIvwB,IAAI+B,KAAK,KAAK/B,IAAI+B,KAAK,KAAK9B,IAAIiC,KAAKquB,IAAItwB,IAAIiC,KAAKquB,IAAIvwB,IAAIkC,KAAK,KAAKlC,IAAIkC;;IAG/GqvB,aAAaZ,OAAOhsB;;;UAGfA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAakY;;aAGPlY,OAAO2C,KAAKqpB,MAAM5uB,IAAI,KAAK9B,IAAI8B,MAAM,KAAK/B,IAAI+B,IAAI,KAAK9B,IAAI8B,KAAK4uB,MAAMzuB,IAAI,KAAKjC,IAAIiC,MAAM,KAAKlC,IAAIkC,IAAI,KAAKjC,IAAIiC;;IAGvHsvB,cAAcjB;;aAENA,IAAIvwB,IAAI+B,IAAI,KAAK9B,IAAI8B,KAAKwuB,IAAItwB,IAAI8B,IAAI,KAAK/B,IAAI+B,KAAKwuB,IAAIvwB,IAAIkC,IAAI,KAAKjC,IAAIiC,KAAKquB,IAAItwB,IAAIiC,IAAI,KAAKlC,IAAIkC,IAAI,QAAQ;;IAGvHyvB,WAAWhB,OAAOhsB;UACbA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAakY;;aAGPlY,OAAOuV,KAAKyW,OAAOjY,MAAM,KAAKzY,KAAK,KAAKD;;IAGhD4yB,gBAAgBjC;YACTkC,eAAesnH,UAAUjgI,KAAKyW,OAAOjY,MAAM,KAAKzY,KAAK,KAAKD;aAEzD6yB,aAAatY,IAAIoW,OAAOv1B;;IAGhC23B,UAAUxC;MACT,KAAKtwB,IAAID,IAAIuwB,IAAItwB;MACjB,KAAKD,IAAIC,IAAIswB,IAAIvwB;aACV;;IAGRmxB,MAAMZ;MACL,KAAKtwB,IAAIA,IAAIswB,IAAItwB;MACjB,KAAKD,IAAIA,IAAIuwB,IAAIvwB;aACV;;IAGRihB,UAAU5E;MACT,KAAKpc,IAAIuC,IAAI6Z;MACb,KAAKrc,IAAIwC,IAAI6Z;aACN;;IAGRF,OAAOoU;aACCA,IAAItwB,IAAIkc,OAAO,KAAKlc,QAAQswB,IAAIvwB,IAAImc,OAAO,KAAKnc;;;EAKzDo6I,KAAKt9H,UAAUu9H,SAAS;QAElBC,2BAA2B35I;QAE3B45I,6BAA6B55I;EAEnC;IACCJ,YAAYikC,YAAY7jC,WAAWikC,UAAUjkC;MAC5C,KAAK6jC,QAAQA;MACb,KAAKI,MAAMA;;IAGZt9B,IAAIk9B,OAAOI;MACV,KAAKJ,MAAMtqB,KAAKsqB;MAChB,KAAKI,IAAI1qB,KAAK0qB;aACP;;IAGR1qB,KAAKoqB;MACJ,KAAKE,MAAMtqB,KAAKoqB,KAAKE;MACrB,KAAKI,IAAI1qB,KAAKoqB,KAAKM;aACZ;;IAGRnU,UAAU9rB;UACLA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAahE;;aAGPgE,OAAOyV,WAAW,KAAKoqB,OAAO,KAAKI,KAAKriC,eAAe;;IAG/DgiC,MAAM5/B;UACDA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAahE;;aAGPgE,OAAOH,WAAW,KAAKogC,KAAK,KAAKJ;;IAGzCg2G;aACQ,KAAKh2G,MAAM9oB,kBAAkB,KAAKkpB;;IAG1C3/B;aACQ,KAAKu/B,MAAMngC,WAAW,KAAKugC;;IAGnC9P,GAAGre,GAAG9R;UACDA,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAahE;;aAGP,KAAK4jC,MAAM5/B,QAAQpC,eAAekU,GAAGjU,IAAI,KAAKgiC;;IAGtDi2G,6BAA6B9pH,OAAO+pH;MACnCJ,QAAQ91I,WAAWmsB,OAAO,KAAK6T;MAE/B+1G,UAAU/1I,WAAW,KAAKogC,KAAK,KAAKJ;YAE9Bm2G,YAAYJ,UAAUp/H,IAAIo/H;YAE1BK,kBAAkBL,UAAUp/H,IAAIm/H;UAElC7jI,IAAImkI,kBAAkBD;UAEtBD;QACHjkI,IAAIiC,MAAMjC,GAAG,GAAG;;aAGVA;;IAGRue,oBAAoBrE,OAAO+pH,aAAa/1I;YACjC8R,IAAI,KAAKgkI,6BAA6B9pH,OAAO+pH;UAE/C/1I,WAAW5L;QACdiC,QAAQ0B,KAAK;QACbiI,aAAahE;;aAGP,KAAK4jC,MAAM5/B,QAAQpC,eAAekU,GAAGjU,IAAI,KAAKgiC;;IAGtDxf,aAAa9D;MACZ,KAAKsjB,MAAMxf,aAAa9D;MACxB,KAAK0jB,IAAI5f,aAAa9D;aACf;;IAGR/E,OAAOmoB;aACCA,KAAKE,MAAMroB,OAAO,KAAKqoB,UAAUF,KAAKM,IAAIzoB,OAAO,KAAKyoB;;IAG9DjiC;iBACY,KAAKpC,cAAc2Z,KAAK;;;EAKrC,oCAAoCwkB;IACnCn+B,YAAYc;MACX;MACA,KAAKA,WAAWA;MAEhB,KAAK++C,SAAS;;MAId,KAAKg7C,eAAe;MACpB,KAAKC,aAAa;MAClB,KAAKE,YAAY;MACjB,KAAKD,SAAS;MACd,KAAKE,gBAAgB;MACrB,KAAKE,cAAc;MACnB,KAAKE,aAAa;MAClB,KAAKD,UAAU;MACf,KAAKp4F,QAAQ;;;EAKfs3I,sBAAsB/9H,UAAUqgF,0BAA0B;QAEpD29C,6BAA6Bn6I;EAEnC,8BAA8B+9B;IAC7Bn+B,YAAY6G,OAAO7F;MAClB;MACA,KAAK6F,QAAQA;MACb,KAAKA,MAAM06B;MACX,KAAK5gB,SAAS9Z,MAAMqmB;MACpB,KAAKtK,mBAAmB;MACxB,KAAK5hB,QAAQA;YACPN,eAAeg3C;YACfzC,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG;eAEnGr6C,IAAI,GAAGm4B,IAAI,GAAGhe,IAAI,IAAIna,IAAIma,IAAGna,KAAKm4B;cACpCE,KAAKr4B,IAAIma,IAAIpV,KAAKyV,KAAK;cACvB8d,KAAKH,IAAIhe,IAAIpV,KAAKyV,KAAK;QAC7B6/B,UAAU38C,KAAKqH,KAAK+B,IAAIuxB,KAAKtzB,KAAK8B,IAAIwxB,KAAK,GAAGtzB,KAAK+B,IAAIwxB,KAAKvzB,KAAK8B,IAAIyxB,KAAK;;MAG3ExyB,SAAS9C,aAAa,gBAAgB22C,uBAAuBU,WAAW;YAClEn0C,eAAe6sE;QACpB3mE,KAAK;QACLwiC,YAAY;;MAEb,KAAKgxG,WAAW9zC,aAAahmG,UAAUI;MACvC,KAAKmB,IAAI,KAAKu4I;MACd,KAAKjxH;;IAGNhxB;MACC,KAAKiiJ,KAAK95I,SAASnI;MACnB,KAAKiiJ,KAAK15I,SAASvI;;IAGpBgxB;MACC,KAAK1iB,MAAM06B;YACLk5G,aAAa,KAAK5zI,MAAMnC,WAAW,KAAKmC,MAAMnC,WAAW;YACzDg2I,YAAYD,aAAa96I,KAAKw+C,IAAI,KAAKt3C,MAAMoU;MACnD,KAAKu/H,KAAKh6H,MAAMzZ,IAAI2zI,WAAWA,WAAWD;MAE1CF,UAAU/rH,sBAAsB,KAAK3nB,MAAMzC,OAAO8oB;MAElD,KAAKstH,KAAKn4I,OAAOk4I;UAEb,KAAKv5I,UAAUxI;QAClB,KAAKgiJ,KAAK15I,SAASE,MAAM+F,IAAI,KAAK/F;;QAElC,KAAKw5I,KAAK15I,SAASE,MAAM2Y,KAAK,KAAK9S,MAAM7F;;;;QAMtC25I,6BAA6Bv6I;QAE7Bw6I,+BAA+BrjH;QAE/BsjH,mCAAmCtjH;EAEzC,6BAA6BmvE;IAC5B1mG,YAAY8vB;YACLm+C,QAAQ6sE,YAAYhrH;YACpBpvB,eAAeg3C;YACfgD;YACAlJ;YACAtB,aAAaK,MAAM,GAAG,GAAG;YACzBJ,aAAaI,MAAM,GAAG,GAAG;eAEtB31C,IAAI,GAAGA,IAAIqzE,MAAMpzE,QAAQD;cAC3B0pG,OAAOr2B,MAAMrzE;YAEf0pG,KAAKrrG,UAAUqrG,KAAKrrG,OAAO+qG;UAC9BtpD,SAASpiD,KAAK,GAAG,GAAG;UACpBoiD,SAASpiD,KAAK,GAAG,GAAG;UACpBk5C,OAAOl5C,KAAK43C,OAAOlwB,GAAGkwB,OAAO/wB,GAAG+wB,OAAO/4B;UACvCq6B,OAAOl5C,KAAK63C,OAAOnwB,GAAGmwB,OAAOhxB,GAAGgxB,OAAOh5B;;;MAIzCzW,SAAS9C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACvEh6C,SAAS9C,aAAa,aAAa22C,uBAAuB/C,QAAQ;YAC5D1wC,eAAe6sE;QACpBpmC,cAAc;QACdU,WAAW;QACXC,YAAY;QACZsB,YAAY;QACZ/B,aAAa;;MAEd,MAAM/mC,UAAUI;MAChB,KAAKlH,OAAO;MACZ,KAAKmhJ,mBAAmB;MACxB,KAAKzgJ,OAAOw1B;MACZ,KAAKm+C,QAAQA;MACb,KAAKttD,SAASmP,OAAO5C;MACrB,KAAKtK,mBAAmB;;IAGzB2e,kBAAkBC;YACXysC,QAAQ,KAAKA;YACbvtE,WAAW,KAAKA;YAChBa,WAAWb,SAAS7C,aAAa;MAEvCg9I,gBAAgBlhI,KAAK,KAAKrf,KAAK4yB,aAAa7N;eAEnCzkB,IAAI,GAAGm4B,IAAI,GAAGn4B,IAAIqzE,MAAMpzE,QAAQD;cAClC0pG,OAAOr2B,MAAMrzE;YAEf0pG,KAAKrrG,UAAUqrG,KAAKrrG,OAAO+qG;UAC9B42C,YAAYh9H,iBAAiBi9H,iBAAiBv2C,KAAKp3E;UAEnDytH,UAAUnsH,sBAAsBosH;UAEhCr5I,SAASuwC,OAAO/e,GAAG4nH,UAAUn5I,GAAGm5I,UAAUh5I,GAAGg5I,UAAU/4I;UAEvDg5I,YAAYh9H,iBAAiBi9H,iBAAiBv2C,KAAKrrG,OAAOi0B;UAE1DytH,UAAUnsH,sBAAsBosH;UAEhCr5I,SAASuwC,OAAO/e,IAAI,GAAG4nH,UAAUn5I,GAAGm5I,UAAUh5I,GAAGg5I,UAAU/4I;UAC3DmxB,KAAK;;;MAIPryB,SAAS7C,aAAa,YAAYqmB,cAAc;MAChD,MAAMqd,kBAAkBC;;;EAK1B,qBAAqB1R;UACdkrH;QAEFlrH,UAAUA,OAAOk0E;MACpBg3C,SAAS1iJ,KAAKw3B;;aAGNl1B,IAAI,GAAGA,IAAIk1B,OAAOe,SAASh2B,QAAQD;MAC3CogJ,SAAS1iJ,KAAKiH,MAAMy7I,UAAUF,YAAYhrH,OAAOe,SAASj2B;;WAGpDogJ;;EAGR,+BAA+B95I;IAC9BlB,YAAY6G,OAAOo0I,YAAYj6I;YACxBN,eAAem7G,eAAeo/B,YAAY,GAAG;YAC7Cn6I,eAAe2vC;QACpBvrC,WAAW;QACX8B,KAAK;QACLwiC,YAAY;;MAEb,MAAM9oC,UAAUI;MAChB,KAAK+F,QAAQA;MACb,KAAKA,MAAM06B;MACX,KAAKvgC,QAAQA;MACb,KAAKpH,OAAO;MACZ,KAAK+mB,SAAS,KAAK9Z,MAAMqmB;MACzB,KAAKtK,mBAAmB;MACxB,KAAK2G;;IAiBNhxB;MACC,KAAKmI,SAASnI;MACd,KAAKuI,SAASvI;;IAGfgxB;UACK,KAAKvoB,UAAUxI;QAClB,KAAKsI,SAASE,MAAM+F,IAAI,KAAK/F;;QAE7B,KAAKF,SAASE,MAAM2Y,KAAK,KAAK9S,MAAM7F;;;;QAgBjCk6I,6BAA6B96I;QAE7B+6I,2BAA2B5qG;QAE3B6qG,2BAA2B7qG;EAEjC,oCAAoCpS;IACnCn+B,YAAY6G,OAAO9B,MAAM/D;MACxB;MACA,KAAK6F,QAAQA;MACb,KAAKA,MAAM06B;MACX,KAAK5gB,SAAS9Z,MAAMqmB;MACpB,KAAKtK,mBAAmB;MACxB,KAAK5hB,QAAQA;YACPN,eAAey6G,mBAAmBp2G;MACxCrE,SAASo/B,QAAQngC,KAAKyV,KAAK;MAC3B,KAAKtU,eAAe2vC;QACnBvrC,WAAW;QACX8B,KAAK;QACLwiC,YAAY;;UAET,KAAKxoC,UAAUxI,WAAW,KAAKsI,SAASymC,eAAe;YACrDhmC,WAAWb,SAAS7C,aAAa;YACjC2zC,aAAaoB,aAAarxC,SAASyB,QAAQ;MACjDtC,SAAS9C,aAAa,aAAaq0C,gBAAgBT,QAAQ;MAC3D,KAAKvvC,QAAQf,KAAKR,UAAU,KAAKI;MACjC,KAAKyoB;;IAGNhxB;MACC,KAAKs4B,SAAS,GAAGnwB,SAASnI;MAC1B,KAAKs4B,SAAS,GAAG/vB,SAASvI;;IAG3BgxB;YACOtoB,OAAO,KAAK4vB,SAAS;UAEvB,KAAK7vB,UAAUxI;QAClB,KAAKsI,SAASE,MAAM+F,IAAI,KAAK/F;;cAEvBwwC,SAASvwC,KAAKP,SAAS7C,aAAa;QAE1Cs9I,QAAQxhI,KAAK,KAAK9S,MAAM7F;QAExBo6I,QAAQzhI,KAAK,KAAK9S,MAAMipD;iBAEfl1D,IAAI,GAAGma,IAAIy8B,OAAOxuC,OAAOpI,IAAIma,GAAGna;gBAClCoG,QAAQpG,IAAIma,IAAI,IAAIomI,UAAUC;UACpC5pG,OAAOM,OAAOl3C,GAAGoG,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;;QAG1Cq6B,OAAOttB,cAAc;;MAGtBjjB,KAAKoB,OAAO64I,UAAU1sH,sBAAsB,KAAK3nB,MAAMqmB,aAAavS;;;EAKtE,yBAAyB+rF;IACxB1mG,YAAY+E,OAAO,IAAIkoH,YAAY,IAAI/8E,SAAS,UAAUC,SAAS;MAClED,aAAaK,MAAML;MACnBC,aAAaI,MAAMJ;YACb9zB,SAAS4wG,YAAY;YACrBziG,OAAOzlB,OAAOkoH;YACdt9F,WAAW5qB,OAAO;YAClB21C,eACHlJ;eAEM52C,IAAI,GAAGm4B,IAAI,GAAGh2B,KAAK4yB,UAAU/0B,KAAKqyH,YAAWryH,KAAKmC,KAAKytB;QAC/DkwB,SAASpiD,MAAMq3B,UAAU,GAAG5yB,GAAG4yB,UAAU,GAAG5yB;QAC5C29C,SAASpiD,KAAKyE,GAAG,IAAI4yB,UAAU5yB,GAAG,GAAG4yB;cAC/B3uB,QAAQpG,MAAMyhB,SAAS6zB,SAASC;QACtCnvC,MAAM+a,QAAQy1B,QAAQze;QACtBA,KAAK;QACL/xB,MAAM+a,QAAQy1B,QAAQze;QACtBA,KAAK;QACL/xB,MAAM+a,QAAQy1B,QAAQze;QACtBA,KAAK;QACL/xB,MAAM+a,QAAQy1B,QAAQze;QACtBA,KAAK;;YAGAryB,eAAeg3C;MACrBh3C,SAAS9C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACvEh6C,SAAS9C,aAAa,aAAa22C,uBAAuB/C,QAAQ;YAC5D1wC,eAAe6sE;QACpBpmC,cAAc;QACdiC,YAAY;;MAEb,MAAM9oC,UAAUI;MAChB,KAAKlH,OAAO;;;EAKd,8BAA8B8sG;IAC7B1mG,YAAYoB,SAAS,IAAIi6I,UAAU,IAAIC,UAAU,GAAGruB,YAAY,IAAI/8E,SAAS,UAAUC,SAAS;MAC/FD,aAAaK,MAAML;MACnBC,aAAaI,MAAMJ;YACbuK;YACAlJ;;eAEG52C,IAAI,GAAGA,KAAKygJ,SAASzgJ;cACvBwE,IAAIxE,IAAIygJ,WAAW17I,KAAKyV,KAAK;cAC7B5T,IAAI7B,KAAK8B,IAAIrC,KAAKgC;cAClBQ,IAAIjC,KAAK+B,IAAItC,KAAKgC;QACxBs5C,SAASpiD,KAAK,GAAG,GAAG;QACpBoiD,SAASpiD,KAAKkJ,GAAG,GAAGI;cACdZ,QAAQpG,IAAI,IAAIs1C,SAASC;QAC/BqB,OAAOl5C,KAAK0I,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;QACpCq6B,OAAOl5C,KAAK0I,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;;;eAI5Bvc,IAAI,GAAGA,KAAK0gJ,SAAS1gJ;cACvBoG,QAAQpG,IAAI,IAAIs1C,SAASC;cACzBnwB,IAAI5e,SAASA,SAASk6I,UAAU1gJ;iBAE7Bm4B,IAAI,GAAGA,IAAIk6F,WAAWl6F;;cAE1B3zB,IAAI2zB,IAAIk6F,aAAattH,KAAKyV,KAAK;cAC/B5T,IAAI7B,KAAK8B,IAAIrC,KAAK4gB;cAClBpe,IAAIjC,KAAK+B,IAAItC,KAAK4gB;UACtB06B,SAASpiD,KAAKkJ,GAAG,GAAGI;UACpB4vC,OAAOl5C,KAAK0I,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;;UAEpC/X,KAAK2zB,IAAI,KAAKk6F,aAAattH,KAAKyV,KAAK;UACrC5T,IAAI7B,KAAK8B,IAAIrC,KAAK4gB;UAClBpe,IAAIjC,KAAK+B,IAAItC,KAAK4gB;UAClB06B,SAASpiD,KAAKkJ,GAAG,GAAGI;UACpB4vC,OAAOl5C,KAAK0I,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;;;YAIhCzW,eAAeg3C;MACrBh3C,SAAS9C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACvEh6C,SAAS9C,aAAa,aAAa22C,uBAAuB/C,QAAQ;YAC5D1wC,eAAe6sE;QACpBpmC,cAAc;QACdiC,YAAY;;MAEb,MAAM9oC,UAAUI;MAChB,KAAKlH,OAAO;;;QAKR2hJ,uBAAuBn7I;QAEvBo7I,uBAAuBp7I;QAEvBq7I,uBAAuBr7I;EAE7B,qCAAqC+9B;IACpCn+B,YAAY6G,OAAO9B,MAAM/D;MACxB;MACA,KAAK6F,QAAQA;MACb,KAAKA,MAAM06B;MACX,KAAK5gB,SAAS9Z,MAAMqmB;MACpB,KAAKtK,mBAAmB;MACxB,KAAK5hB,QAAQA;UACT+D,SAASvM,WAAWuM,OAAO;UAC3BrE,eAAeg3C;MACnBh3C,SAAS9C,aAAa,gBAAgB22C,yBAAyBxvC,MAAMA,MAAM,GAAGA,MAAMA,MAAM,GAAGA,OAAOA,MAAM,IAAIA,OAAOA,MAAM,IAAIA,MAAMA,MAAM,IAAI;YACzIjE,eAAe6sE;QACpB3mE,KAAK;QACLwiC,YAAY;;MAEb,KAAKkyG,iBAAiB11C,KAAKtlG,UAAUI;MACrC,KAAKmB,IAAI,KAAKy5I;MACdh7I,eAAeg3C;MACfh3C,SAAS9C,aAAa,gBAAgB22C,wBAAwB,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI;MACjF,KAAKonG,iBAAiB31C,KAAKtlG,UAAUI;MACrC,KAAKmB,IAAI,KAAK05I;MACd,KAAKpyH;;IAGNhxB;MACC,KAAKmjJ,WAAWh7I,SAASnI;MACzB,KAAKmjJ,WAAW56I,SAASvI;MACzB,KAAKojJ,WAAWj7I,SAASnI;MACzB,KAAKojJ,WAAW76I,SAASvI;;IAG1BgxB;MACCgyH,IAAI/sH,sBAAsB,KAAK3nB,MAAMqmB;MAErCsuH,IAAIhtH,sBAAsB,KAAK3nB,MAAMzC,OAAO8oB;MAE5CuuH,IAAIx3I,WAAWu3I,KAAKD;MAEpB,KAAKG,WAAWr5I,OAAOm5I;UAEnB,KAAKx6I,UAAUxI;QAClB,KAAKkjJ,WAAW56I,SAASE,MAAM+F,IAAI,KAAK/F;QACxC,KAAK26I,WAAW76I,SAASE,MAAM+F,IAAI,KAAK/F;;QAExC,KAAK06I,WAAW56I,SAASE,MAAM2Y,KAAK,KAAK9S,MAAM7F;QAC/C,KAAK26I,WAAW76I,SAASE,MAAM2Y,KAAK,KAAK9S,MAAM7F;;MAGhD,KAAK26I,WAAWt5I,OAAOm5I;MACvB,KAAKG,WAAWn7H,MAAM5e,IAAI65I,IAAI5gJ;;;QAK1B+gJ,2BAA2Bx7I;QAE3By7I,2BAA2Bz+F;;;;;;;EASjC,2BAA2BspD;IAC1B1mG,YAAY6sB;YACLnsB,eAAeg3C;YACf52C,eAAe6sE;QACpB3sE,OAAO;QACPumC,cAAc;QACdiC,YAAY;;YAEPkR;YACAlJ;YACAsqG;;YAEAC,mBAAmBxrG,MAAM;YACzByrG,gBAAgBzrG,MAAM;YACtB0rG,cAAc1rG,MAAM;YACpB2rG,kBAAkB3rG,MAAM;YACxB4rG,iBAAiB5rG,MAAM;;MAE7B6rG,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;;MAEpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;;MAEpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;MACpBK,QAAQ,MAAM,MAAML;;MAEpBK,QAAQ,KAAK,MAAMJ;MACnBI,QAAQ,KAAK,MAAMJ;MACnBI,QAAQ,KAAK,MAAMJ;MACnBI,QAAQ,KAAK,MAAMJ;;MAEnBI,QAAQ,MAAM,MAAMH;MACpBG,QAAQ,MAAM,MAAMH;MACpBG,QAAQ,MAAM,MAAMH;;MAEpBG,QAAQ,KAAK,KAAKF;MAClBE,QAAQ,KAAK,KAAKD;;MAElBC,QAAQ,OAAO,OAAOD;MACtBC,QAAQ,OAAO,OAAOD;MACtBC,QAAQ,OAAO,OAAOD;MACtBC,QAAQ,OAAO,OAAOD;MAEtB,iBAAiBjlI,GAAGC,GAAGnW;QACtBq7I,SAASnlI,GAAGlW;QACZq7I,SAASllI,GAAGnW;;MAGb,kBAAkBzG,IAAIyG;QACrB05C,SAASpiD,KAAK,GAAG,GAAG;QACpBk5C,OAAOl5C,KAAK0I,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;YAEhC2kI,SAASvhJ,QAAQ/B;UACpBsjJ,SAASvhJ;;QAGVuhJ,SAASvhJ,IAAIjC,KAAKoiD,SAAS7/C,SAAS,IAAI;;MAGzC6F,SAAS9C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACvEh6C,SAAS9C,aAAa,aAAa22C,uBAAuB/C,QAAQ;MAClE,MAAM9wC,UAAUI;MAChB,KAAKlH,OAAO;MACZ,KAAKizB,SAASA;UACV,KAAKA,OAAO+wB,wBAAwB,KAAK/wB,OAAO+wB;MACpD,KAAKj9B,SAASkM,OAAOK;MACrB,KAAKtK,mBAAmB;MACxB,KAAKk5H,WAAWA;MAChB,KAAKvyH;;IAGNA;YACO7oB,WAAW,KAAKA;YAChBo7I,WAAW,KAAKA;YAChBliI,IAAI,GACPwF,IAAI;;;MAGPy8H,QAAQ5uH,wBAAwBtT,KAAK,KAAKkT,OAAOI;;MAGjDqvH,SAAS,KAAKR,UAAUp7I,UAAUm7I,SAAS,GAAG,IAAI;MAClDS,SAAS,KAAKR,UAAUp7I,UAAUm7I,SAAS,GAAG,GAAG;;MAEjDS,SAAS,MAAMR,UAAUp7I,UAAUm7I,UAAUjiI,IAAIwF,IAAI;MACrDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,SAASjiI,IAAIwF,IAAI;MACpDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,UAAUjiI,GAAGwF,IAAI;MACpDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,SAASjiI,GAAGwF,IAAI;;MAEnDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,UAAUjiI,IAAIwF,GAAG;MACpDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,SAASjiI,IAAIwF,GAAG;MACnDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,UAAUjiI,GAAGwF,GAAG;MACnDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,SAASjiI,GAAGwF,GAAG;;MAElDk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,SAASjiI,IAAI,KAAKwF,IAAI,MAAM;MAC/Dk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,UAAUjiI,IAAI,KAAKwF,IAAI,MAAM;MAChEk9H,SAAS,MAAMR,UAAUp7I,UAAUm7I,SAAS,GAAGz8H,IAAI,IAAI;;MAEvDk9H,SAAS,OAAOR,UAAUp7I,UAAUm7I,UAAUjiI,GAAG,GAAG;MACpD0iI,SAAS,OAAOR,UAAUp7I,UAAUm7I,SAASjiI,GAAG,GAAG;MACnD0iI,SAAS,OAAOR,UAAUp7I,UAAUm7I,SAAS,IAAIz8H,GAAG;MACpDk9H,SAAS,OAAOR,UAAUp7I,UAAUm7I,SAAS,GAAGz8H,GAAG;MACnDk9H,SAAS,OAAOR,UAAUp7I,UAAUm7I,UAAUjiI,GAAG,IAAI;MACrD0iI,SAAS,OAAOR,UAAUp7I,UAAUm7I,SAASjiI,GAAG,IAAI;MACpD0iI,SAAS,OAAOR,UAAUp7I,UAAUm7I,SAAS,IAAIz8H,IAAI;MACrDk9H,SAAS,OAAOR,UAAUp7I,UAAUm7I,SAAS,GAAGz8H,IAAI;MACpD1e,SAAS7C,aAAa,YAAYqmB,cAAc;;IAGjD3rB;MACC,KAAKmI,SAASnI;MACd,KAAKuI,SAASvI;;;EAKhB,kBAAkB63B,OAAO0rH,UAAUp7I,UAAUmsB,QAAQrrB,GAAGG,GAAGC;IAC1Dg6I,QAAQ70I,IAAIvF,GAAGG,GAAGC,GAAGorB,UAAUH;UAEzB0C,SAASusH,SAAS1rH;QAEpBb,WAAW/2B;YACR+I,WAAWb,SAAS7C,aAAa;eAE9BjD,IAAI,GAAGma,IAAIwa,OAAO10B,QAAQD,IAAIma,GAAGna;QACzC2G,SAASuwC,OAAOviB,OAAO30B,IAAIghJ,QAAQp6I,GAAGo6I,QAAQj6I,GAAGi6I,QAAQh6I;;;;QAKtD26I,wBAAwB7pH;EAE9B,wBAAwBg0E;IACvB1mG,YAAY8vB,QAAQ9uB,QAAQ;YACrBg0C,cAAczC,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;YAChG0C,gBAAgBrC,aAAa,IAAI;YACjClyC,eAAeg3C;MACrBh3C,SAASkzC,aAAa3B,gBAAgB+C,SAAS;MAC/Ct0C,SAAS9C,aAAa,gBAAgBq0C,gBAAgBgD,WAAW;MACjE,MAAMv0C,cAAcitE;QACnB3sE,OAAOA;QACPwoC,YAAY;;MAEb,KAAK1Z,SAASA;MACd,KAAKl2B,OAAO;MACZ,KAAKgpB,mBAAmB;MACxB,KAAK2G;;IAGNA,OAAOuG;UACFA,WAAWt3B;QACdiC,QAAQ0B,KAAK;;UAGV,KAAK2zB,WAAWt3B;QACnB+jJ,KAAK1sH,cAAc,KAAKC;;UAGrBysH,KAAKtsH;YACHvwB,MAAM68I,KAAK78I;YACXD,MAAM88I,KAAK98I;;;;;;;;;;;;;;;YAgBX8B,WAAW,KAAKb,SAAS4yC,WAAW/xC;YACpCsT,QAAQtT,SAASsT;MACvBA,MAAM,KAAKpV,IAAI+B;MACfqT,MAAM,KAAKpV,IAAIkC;MACfkT,MAAM,KAAKpV,IAAImC;MACfiT,MAAM,KAAKnV,IAAI8B;MACfqT,MAAM,KAAKpV,IAAIkC;MACfkT,MAAM,KAAKpV,IAAImC;MACfiT,MAAM,KAAKnV,IAAI8B;MACfqT,MAAM,KAAKnV,IAAIiC;MACfkT,MAAM,KAAKpV,IAAImC;MACfiT,MAAM,KAAKpV,IAAI+B;MACfqT,MAAM,MAAMnV,IAAIiC;MAChBkT,MAAM,MAAMpV,IAAImC;MAChBiT,MAAM,MAAMpV,IAAI+B;MAChBqT,MAAM,MAAMpV,IAAIkC;MAChBkT,MAAM,MAAMnV,IAAIkC;MAChBiT,MAAM,MAAMnV,IAAI8B;MAChBqT,MAAM,MAAMpV,IAAIkC;MAChBkT,MAAM,MAAMnV,IAAIkC;MAChBiT,MAAM,MAAMnV,IAAI8B;MAChBqT,MAAM,MAAMnV,IAAIiC;MAChBkT,MAAM,MAAMnV,IAAIkC;MAChBiT,MAAM,MAAMpV,IAAI+B;MAChBqT,MAAM,MAAMnV,IAAIiC;MAChBkT,MAAM,MAAMnV,IAAIkC;MAChBL,SAAS2iB,cAAc;MACvB,KAAKxjB,SAAS8D;;IAGfqrB,cAAcC;MACb,KAAKA,SAASA;MACd,KAAKvG;aACE;;IAGR5P,KAAKyJ;MACJsjF,aAAanqF,UAAU5C,KAAK7hB,KAAK,MAAMsrB;MACvC,KAAK0M,SAAS1M,OAAO0M;aACd;;;EAKT,yBAAyB42E;IACxB1mG,YAAYgwB,KAAKhvB,QAAQ;YAClBg0C,cAAczC,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;YAChG0C,aAAa,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI;YAC9Fv0C,eAAeg3C;MACrBh3C,SAASkzC,aAAa3B,gBAAgB+C,SAAS;MAC/Ct0C,SAAS9C,aAAa,gBAAgB22C,uBAAuBU,WAAW;MACxE,MAAMv0C,cAAcitE;QACnB3sE,OAAOA;QACPwoC,YAAY;;MAEb,KAAKxZ,MAAMA;MACX,KAAKp2B,OAAO;MACZ,KAAK8G,SAAS8D;;IAGf+8B,kBAAkBC;YACXxR,MAAM,KAAKA;UACbA,IAAIC;MACRD,IAAIE,UAAU,KAAK3uB;MACnByuB,IAAIG,QAAQ,KAAK3P;MACjB,KAAKA,MAAMxe,eAAe;MAC1B,MAAMu/B,kBAAkBC;;;EAK1B,0BAA0BwkE;IACzBhmG,YAAYsxB,OAAOvsB,OAAO,GAAGkpC,MAAM;YAC5BjtC,QAAQitC;YACRgH,aAAa,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;YAC5Gv0C,eAAeg3C;MACrBh3C,SAAS9C,aAAa,gBAAgB22C,uBAAuBU,WAAW;MACxEv0C,SAAS8D;MACT,MAAM9D,cAAcitE;QACnB3sE,OAAOA;QACPwoC,YAAY;;MAEb,KAAK5vC,OAAO;MACZ,KAAK03B,QAAQA;MACb,KAAKvsB,OAAOA;YACNy3I,cAAc,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG;YACvE/kG,gBAAgBC;MACtBD,UAAU75C,aAAa,gBAAgB22C,uBAAuBioG,YAAY;MAC1E/kG,UAAUjzC;MACV,KAAKvC,QAAQf,KAAKu2C,eAAehH;QAChCzvC,OAAOA;QACPwmC,SAAS;QACTC,aAAa;QACbS,YAAY;QACZsB,YAAY;;;IAIdjI,kBAAkBC;UACbhhB,SAAS,KAAK8Q,MAAMC;UACpB5xB,KAAK4W,IAAIiK,SAAS,MAAMA,QAAQ;;MAEpC,KAAKA,MAAMzZ,IAAI,MAAM,KAAKhC,MAAM,MAAM,KAAKA,MAAMyb;MACjD,KAAKqQ,SAAS,GAAG/vB,SAASwmC,OAAO9mB,QAAQ,IAAI1X,WAAWD;;MAExD,KAAKxG,OAAO,KAAKivB,MAAMrD;MACvB,MAAMsT,kBAAkBC;;;QAKpBi7G,yBAAyBr8I;MAE3Bs8I,eAAeC;EAEnB,0BAA0Bx+G;;IAEzBn+B,YAAY4oB,UAAUxoB,QAAQ,GAAG,GAAG,IAAIzB,aAAayB,QAAQ,GAAG,GAAG,IAAIvF,SAAS,GAAGmG,QAAQ,UAAU47I,aAAa/hJ,SAAS,KAAKgiJ,YAAYD,aAAa;MACxJ;MACA,KAAKhjJ,OAAO;UAER8iJ,kBAAkBlkJ;QACrBkkJ,oBAAoBhlG;QAEpBglG,cAAc9+I,aAAa,gBAAgB22C,wBAAwB,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI;QAEtFooG,oBAAoBh8I,iBAAiB,GAAG,KAAK,GAAG,GAAG;QAEnDg8I,cAAcj8H,UAAU,IAAI,KAAK;;MAGlC,KAAKnf,SAASoY,KAAKhb;MACnB,KAAKolC,WAAWiiE,KAAK02C,mBAAmB/uE;QACvC3sE,OAAOA;QACPwoC,YAAY;;MAEb,KAAKzF,KAAKnhB,mBAAmB;MAC7B,KAAK3gB,IAAI,KAAK8hC;MACd,KAAKy2G,WAAWt5I,KAAKy7I,mBAAmBlsG;QACvCzvC,OAAOA;QACPwoC,YAAY;;MAEb,KAAKgxG,KAAK53H,mBAAmB;MAC7B,KAAK3gB,IAAI,KAAKu4I;MACd,KAAKsC,aAAal0H;MAClB,KAAKrN,UAAU1gB,QAAQ+hJ,YAAYC;;IAGpCC,aAAal0H;;UAERA,IAAIjnB,IAAI;QACX,KAAKynB,WAAWriB,IAAI,GAAG,GAAG,GAAG;iBACnB6hB,IAAIjnB,KAAK;QACnB,KAAKynB,WAAWriB,IAAI,GAAG,GAAG,GAAG;;QAE7B01I,MAAM11I,IAAI6hB,IAAIhnB,GAAG,IAAIgnB,IAAIpnB,GAAGwC;cAEtB8S,UAAUnX,KAAKglB,KAAKiE,IAAIjnB;QAC9B,KAAKynB,WAAWU,iBAAiB2yH,OAAO3lI;;;IAI1CyE,UAAU1gB,QAAQ+hJ,aAAa/hJ,SAAS,KAAKgiJ,YAAYD,aAAa;MACrE,KAAK74G,KAAKvjB,MAAMzZ,IAAI,GAAGpH,KAAKF,IAAI,QAAQ5E,SAAS+hJ,aAAa;;MAE9D,KAAK74G,KAAK5gB;MACV,KAAKq3H,KAAKh6H,MAAMzZ,IAAI81I,WAAWD,YAAYC;MAC3C,KAAKrC,KAAKj5I,SAASI,IAAI9G;MACvB,KAAK2/I,KAAKr3H;;IAGX45H,SAAS/7I;MACR,KAAK+iC,KAAKjjC,SAASE,MAAM+F,IAAI/F;MAC7B,KAAKw5I,KAAK15I,SAASE,MAAM+F,IAAI/F;;IAG9B2Y,KAAKyJ;MACJ,MAAMzJ,KAAKyJ,QAAQ;MACnB,KAAK2gB,KAAKpqB,KAAKyJ,OAAO2gB;MACtB,KAAKy2G,KAAK7gI,KAAKyJ,OAAOo3H;aACf;;;EAKT,yBAAyB9zC;IACxB1mG,YAAY+E,OAAO;YACZ21C,YAAY,GAAG,GAAG,GAAG31C,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGA,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAGA;YACrEysC,UAAU,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK;YACnE9wC,eAAeg3C;MACrBh3C,SAAS9C,aAAa,gBAAgB22C,uBAAuBmG,UAAU;MACvEh6C,SAAS9C,aAAa,aAAa22C,uBAAuB/C,QAAQ;YAC5D1wC,eAAe6sE;QACpBpmC,cAAc;QACdiC,YAAY;;MAEb,MAAM9oC,UAAUI;MAChB,KAAKlH,OAAO;;IAGbrB;MACC,KAAKmI,SAASnI;MACd,KAAKuI,SAASvI;;;QAKVykJ,iBAAiBpqG,aAAa;QAE9BqqG,iBAAiBzqG,WAAWwqG,WAAWjqG;EAE7C;;WAEQmqG,YAAYC;;;;;MAMlBH,WAAW,KAAKG;YACV37I,IAAIy7I,WAAW;UACjB/iD,OAAO14F,KAAK,KAAK;;UAGjBqU,IAAIrU,KAAK,KAAK;;YAGZvF,IAAIuF,KAAK,KAAK;;;;UAMhBvF,IAAI,YAAYi+F;;UAGhBj+F,IAAI;QACPi+F,QAAQ;;;QAIRA,SAASj+F,KAAK,MAAM,IAAI,MAAMuF,IAAI;eAC3B04F;;;UAKJj+F,IAAI;QACP4Z,KAAK;;;QAILqkF,SAASrkF,KAAK,MAAM5Z,MAAM4Z,KAAK,MAAM5Z,IAAI;eAClCi+F;;MAGRA,QAAQj+F,IAAI,OAAO,KAAK4Z,KAAK;;;MAI7BqkF,QAAQrkF,IAAI;aACLqkF;;;QAKHkjD,UAAU;QACVC,UAAU;QACVC,WAAW39I,KAAKgF,IAAI,GAAG04I;;;;;QAKvBE,mBAAmB,OAAO,OAAO,MAAM,OAAO,OAAO;QACrDC,aAAaH,UAAUD,UAAU,IAAIG,gBAAgB1iJ;;;QAGrD4+D,cAAc;QACdgkF;KACJ5rI,iBAAiB;KACjBC,eAAe;KACfE,eAAe;KACfE,gBAAgB;KAChBC,iBAAiB;KACjBC,eAAe;KACfL,gBAAgB;;QAEZ2rI,yBAAyBjtG;IAC9BnJ,MAAMx+B;IACNo/B,YAAY;IACZD,WAAW;;QAEN01G,oBAAoBz8I,SAAS8D,eAAe04I;QAE5CE,+BAA+BjoB;SAGpCkoB,YACAC,WACAC,wBACgBC;QAEXC,+BAA+B1tG;MAEjC2tG,aAAa;;QAEXC,OAAO,IAAIx+I,KAAKob,KAAK,MAAM;QAC3BqjI,UAAU,IAAID;;;QAGdE,oCAAoCj+I,QAAQ,GAAG,GAAG,qBAAqBA,SAAS,GAAG,GAAG,qBAAqBA,QAAQ,GAAG,IAAI,qBAAqBA,SAAS,GAAG,IAAI,qBAAqBA,QAAQ,GAAG+9I,KAAKC,2BAA2Bh+I,QAAQ,GAAG+9I,MAAMC,2BAA2Bh+I,QAAQg+I,SAAS,GAAGD,uBAAuB/9I,SAASg+I,SAAS,GAAGD,uBAAuB/9I,QAAQ+9I,KAAKC,SAAS,qBAAqBh+I,SAAS+9I,KAAKC,SAAS;;;;;;;;;;;;;;;EAgB1a,6BAA6Bp9I;UACtBs9I,eAAe3+I,KAAKF,IAAIuB,MAAMgf,GAAGhf,MAAMme,GAAGne,MAAMmW;UAChDonI,OAAO5+I,KAAKD,IAAIC,KAAKF,IAAIE,KAAKoX,KAAKpX,KAAKkiF,KAAKy8D,iBAAiB,QAAQ;IAC5Et9I,MAAMgB,eAAerC,KAAKgF,IAAI,MAAM45I;UAC9B/iI,SAAS+iI,OAAO,SAAS;WACxB/iI;;EAGR;IACCxb,YAAYwG;MACX,KAAK6tE,YAAY7tE;MACjB,KAAKg4I,wBAAwB;MAC7B,KAAKC,gBAAgBC,eAAejlF;MACpC,KAAKklF,kBAAkB;MACvB,KAAKC,iBAAiB;MAEtB,KAAKC,iBAAiB,KAAKJ;;;;;;;;;IAW5BK,UAAUl5I,OAAOm5I,QAAQ,GAAGjjH,OAAO,KAAKC,MAAM;MAC7CmiH,aAAa,KAAK7pE,UAAU10B;YAEtBq/F,qBAAqB,KAAKC;MAEhC,KAAKC,eAAet5I,OAAOk2B,MAAMC,KAAKijH;UAElCD,QAAQ;QACX,KAAKI,MAAMH,oBAAoB,GAAG,GAAGD;;MAGtC,KAAKK,YAAYJ;MAEjB,KAAKK,SAASL;aAEPA;;;;;;;IASRM,oBAAoBC;aACZ,KAAKC,aAAaD;;;;;;;IAS1BE,YAAYrkF;aACJ,KAAKokF,aAAapkF;;;;;;IAQ1BskF;UACK,KAAKd,mBAAmB;QAC3B,KAAKA,iBAAiBe;QAEtB,KAAKd,iBAAiB,KAAKD;;;;;;;IAS7BgB;UACK,KAAKjB,oBAAoB;QAC5B,KAAKA,kBAAkBkB;QAEvB,KAAKhB,iBAAiB,KAAKF;;;;;;;;IAU7BpmJ;MACC,KAAKkmJ,cAAclmJ;UAEf,KAAKqmJ,mBAAmB,MAAM,KAAKA,eAAermJ;UAClD,KAAKomJ,oBAAoB,MAAM,KAAKA,gBAAgBpmJ;eAE/CqC,IAAI,GAAGA,IAAIijJ,WAAWhjJ,QAAQD;QACtCijJ,WAAWjjJ,GAAGrC;;;;IAKhB8mJ,SAASS;MACR,KAAKtB,sBAAsBjmJ;MAE3B,KAAK87E,UAAUz0B,gBAAgBs+F;MAE/B4B,aAAa15H,cAAc;MAE3B25H,aAAaD,cAAc,GAAG,GAAGA,aAAa3mI,OAAO2mI,aAAa1mI;;IAGnEomI,aAAal5H;MACZ43H,aAAa,KAAK7pE,UAAU10B;YAEtBq/F,qBAAqB,KAAKC,iBAAiB34H;MAEjD,KAAK05H,iBAAiB15H,SAAS04H;MAE/B,KAAKI,YAAYJ;MAEjB,KAAKK,SAASL;aAEPA;;IAGRC,iBAAiB34H;;YAEV/jB;QACL4f,WAAWhW;QACXiW,WAAWjW;QACX0W,iBAAiB;QACjBjpB,MAAMiT;QACNwV,QAAQvU;QACRyU,UAAU09H,OAAO35H,WAAWA,QAAQ/D,WAAWvQ;QAC/CuU,aAAa;;YAGRy4H,qBAAqBkB,oBAAoB39I;MAE/Cy8I,mBAAmBz4H,cAAcD,UAAU,QAAQ;MACnD,KAAKk4H,wBAAwB0B,oBAAoB39I;aAC1Cy8I;;IAGRH,iBAAiB/9I;YACVq/I,cAAcj/I,KAAK28I,WAAW,IAAI/8I;MAExC,KAAKuzE,UAAU6nB,QAAQikD,SAASvC;;IAGjCsB,eAAet5I,OAAOk2B,MAAMC,KAAKijH;YAC1B3hG,MAAM;YACNC,SAAS;YACT8iG,iBAAiBthG,kBAAkBzB,KAAKC,QAAQxhB,MAAMC;YACtDskH,UAAU,IAAI,GAAG,GAAG,GAAG,GAAG;YAC1BC,eAAe,GAAG,GAAG,IAAI,IAAI,IAAI;YACjC95I,WAAW,KAAK6tE;YAChBksE,oBAAoB/5I,SAAS+rD;YAC7B0Y,iBAAiBzkE,SAASykE;YAC1BtY,cAAcnsD,SAASmsD;MAC7BnsD,SAASssD,cAAcmrF;MACvBz3I,SAASmsD,cAAcxnD;MACvB3E,SAASykE,iBAAiBp5D;MAC1BrL,SAAS+rD,YAAY;UACjBiuF,gBAAgB;YACd9vF,aAAa9qD,MAAM8qD;UAErBA;YACCA,WAAW1mB;UACd0zG,mBAAmB18I,MAAM2Y,KAAK+2C,YAAYlhB;UAC1C5pC,MAAM8qD,aAAa;gBACbl1C,QAAQilI,oBAAoB/C,mBAAmB18I;UACrD08I,mBAAmBl2G,UAAUhsB;UAC7BglI,gBAAgB;;;QAGjB9C,mBAAmB18I,MAAM2Y,KAAKskI,aAAazuG;cACrCh0B,QAAQilI,oBAAoB/C,mBAAmB18I;QACrD08I,mBAAmBl2G,UAAUhsB;QAC7BglI,gBAAgB;;eAGR5lJ,IAAI,GAAGA,IAAI,GAAGA;cAChB8lJ,MAAM9lJ,IAAI;YAEZ8lJ,OAAO;UACVN,WAAWpnH,GAAGjyB,IAAI,GAAGs5I,OAAOzlJ,IAAI;UAChCwlJ,WAAW/9I,OAAOi+I,YAAY1lJ,IAAI,GAAG;mBAC3B8lJ,OAAO;UACjBN,WAAWpnH,GAAGjyB,IAAI,GAAG,GAAGs5I,OAAOzlJ;UAC/BwlJ,WAAW/9I,OAAO,GAAGi+I,YAAY1lJ,IAAI;;UAErCwlJ,WAAWpnH,GAAGjyB,IAAI,GAAGs5I,OAAOzlJ,IAAI;UAChCwlJ,WAAW/9I,OAAO,GAAG,GAAGi+I,YAAY1lJ;;QAGrCmlJ,aAAaf,oBAAoB0B,MAAMpD,UAAU1iJ,IAAI,IAAI0iJ,WAAW,GAAGA,UAAUA;QAEjF92I,SAASo5C,gBAAgBo/F;YAErBwB;UACHh6I,SAASq5C,OAAO89F,eAAeyC;;QAGhC55I,SAASq5C,OAAOj6C,OAAOw6I;;MAGxB55I,SAASmsD,cAAcA;MACvBnsD,SAASykE,iBAAiBA;MAC1BzkE,SAAS+rD,YAAYguF;;IAGtBP,iBAAiB15H,SAAS04H;YACnBx4I,WAAW,KAAK6tE;UAElB/tD,QAAQ05B;YACP,KAAK4+F,kBAAkB;UAC1B,KAAKA,iBAAiBe;;;YAGnB,KAAKhB,mBAAmB;UAC3B,KAAKA,kBAAkBkB;;;YAInB/+I,WAAWwlB,QAAQ05B,gBAAgB,KAAK4+F,iBAAiB,KAAKD;YAC9D19I,WAAWC,KAAK28I,WAAW,IAAI/8I;YAC/B86C,WAAW96C,SAAS86C;MAC1BA,SAAS,UAAUn2C,QAAQ6gB;WAEtBA,QAAQ05B;QACZpE,SAAS,aAAan2C,MAAMsB,IAAI,MAAMuf,QAAQtF,MAAM7H,OAAO,MAAMmN,QAAQtF,MAAM5H;;MAGhFwiC,SAAS,iBAAiBn2C,QAAQg4I,UAAUn3H,QAAQ/D;MACpDq5B,SAAS,kBAAkBn2C,QAAQg4I,UAAUuB,mBAAmB14H,QAAQ/D;MAExEw9H,aAAaf,oBAAoB,GAAG,GAAG,IAAI1B,UAAU,IAAIA;MAEzD92I,SAASo5C,gBAAgBo/F;MACzBx4I,SAASq5C,OAAO5+C,MAAM28I;;IAGvBwB,YAAYJ;YACLx4I,WAAW,KAAK6tE;YAChB9hB,YAAY/rD,SAAS+rD;MAC3B/rD,SAAS+rD,YAAY;eAEZ33D,IAAI,GAAGA,IAAI4iJ,YAAY5iJ;cACzBmkJ,QAAQp/I,KAAKob,KAAKgjI,QAAQnjJ,KAAKmjJ,QAAQnjJ,KAAKmjJ,QAAQnjJ,IAAI,KAAKmjJ,QAAQnjJ,IAAI;cACzE+lJ,WAAWtC,iBAAiBzjJ,IAAI,KAAKyjJ,gBAAgBxjJ;QAE3D,KAAKskJ,MAAMH,oBAAoBpkJ,IAAI,GAAGA,GAAGmkJ,OAAO4B;;MAGjDn6I,SAAS+rD,YAAYA;;;;;;;;;IAWtB4sF,MAAMH,oBAAoB4B,OAAOC,QAAQ9B,OAAO4B;YACzCG,uBAAuB,KAAKtC;MAElC,KAAKuC,UAAU/B,oBAAoB8B,sBAAsBF,OAAOC,QAAQ9B,OAAO,eAAe4B;MAE9F,KAAKI,UAAUD,sBAAsB9B,oBAAoB6B,QAAQA,QAAQ9B,OAAO,gBAAgB4B;;IAGjGI,UAAUC,UAAUC,WAAWL,OAAOC,QAAQK,cAAc7sH,WAAWssH;YAChEn6I,WAAW,KAAK6tE;YAChB8sE,eAAe,KAAK1C;UAEtBpqH,cAAc,iBAAiBA,cAAc;QAChD55B,QAAQa,MAAM;;;YAIT8lJ,sBAAsB;YACtBC,eAAengJ,KAAK28I,WAAWgD,SAASM;YACxCG,eAAeH,aAAavlG;YAC5B2lG,SAASzD,UAAU8C,SAAS;YAC5BY,kBAAkBxrG,SAASkrG,gBAAgBvhJ,KAAKyV,MAAM,IAAImsI,UAAU,IAAI5hJ,KAAKyV,MAAM,IAAIqkD,cAAc;YACrGgoF,cAAcP,eAAeM;YAC7Bv6H,UAAU+uB,SAASkrG,gBAAgB,IAAIvhJ,KAAKC,MAAMwhJ,sBAAsBK,eAAehoF;UAEzFxyC,UAAUwyC;QACbh/D,QAAQ0B,MAAM,gBAAgB+kJ,aAAa,gDAAgDj6H,QAAQ,sCAAsCwyC,YAAY;;YAGhJioF;UACFvxC,MAAM;eAEDv1G,IAAI,GAAGA,IAAI6+D,eAAe7+D;cAC5B4G,IAAI5G,IAAI6mJ;cACR99C,SAAShkG,KAAK2W,KAAK9U,IAAIA,IAAI;QACjCkgJ,QAAQppJ,KAAKqrG;YAET/oG,KAAK;UACRu1G,OAAOxM;mBACG/oG,IAAIqsB;UACdkpF,OAAO,IAAIxM;;;eAIJ/oG,IAAI,GAAGA,IAAI8mJ,QAAQ7mJ,QAAQD;QACnC8mJ,QAAQ9mJ,KAAK8mJ,QAAQ9mJ,KAAKu1G;;MAG3BmxC,aAAa,UAAU77I,QAAQu7I,SAAS16H;MACxCg7H,aAAa,WAAW77I,QAAQwhB;MAChCq6H,aAAa,WAAW77I,QAAQi8I;MAChCJ,aAAa,eAAe77I,QAAQ4uB,cAAc;UAE9CssH;QACHW,aAAa,YAAY77I,QAAQk7I;;MAGlCW,aAAa,UAAU77I,QAAQ+7I;MAC/BF,aAAa,UAAU77I,QAAQ43I,UAAUuD;MACzCU,aAAa,iBAAiB77I,QAAQg4I,UAAUuD,SAAS16H,QAAQ/D;MACjE++H,aAAa,kBAAkB77I,QAAQg4I,UAAUuD,SAAS16H,QAAQ/D;YAC5Do/H,aAAa7D,UAAU+C;YACvBr/I,IAAI,IAAI7B,KAAKF,IAAI,GAAG69I,WAAW,IAAIqE;YACnChgJ,KAAKk/I,WAAW,IAAI,IAAI,IAAIvD,YAAY,IAAIqE,cAAcd,SAASxD,UAAUD,UAAUyD,SAASxD,UAAUD,UAAU;MAE1H2C,aAAakB,WAAWz/I,GAAGG,GAAG,IAAIggJ,YAAY,IAAIA;MAElDn7I,SAASo5C,gBAAgBqhG;MACzBz6I,SAASq5C,OAAOwhG,UAAUzD;;;EAK5B,gBAAgBt3H;QACXA,YAAY9tB,aAAa8tB,QAAQ1sB,SAASiT,yBAAyB;WAChEyZ,QAAQ/D,aAAa1Q,kBAAkByU,QAAQ/D,aAAazQ,gBAAgBwU,QAAQ/D,aAAaxQ;;EAGzG;UACO8rI;UACAC;UACAC;QACF6D,MAAMvE;aAEDziJ,IAAI,GAAGA,IAAI4iJ,YAAY5iJ;YACzBinJ,UAAUliJ,KAAKgF,IAAI,GAAGi9I;MAE5B9D,UAAUxlJ,KAAKupJ;UAEX9C,QAAQ,MAAM8C;UAEdjnJ,IAAIyiJ,UAAUD;QACjB2B,QAAQxB,gBAAgB3iJ,IAAIyiJ,UAAUD,UAAU;iBACtCxiJ,KAAK;QACfmkJ,QAAQ;;MAGThB,QAAQzlJ,KAAKymJ;YAEP+C,YAAY,OAAOD,UAAU;YAC7BniJ,OAAOoiJ,YAAY;YACnBriJ,MAAM,IAAIqiJ,YAAY;YACtB57G,OAAOxmC,KAAKA,KAAKD,KAAKC,KAAKD,KAAKA,KAAKC,KAAKA,KAAKD,KAAKA,KAAKC,KAAKD;YAC9DsiJ,YAAY;YACZrnG,WAAW;YACXsnG,eAAe;YACfC,SAAS;YACTC,gBAAgB;YAChB3gJ,eAAeqxC,aAAaovG,eAAetnG,WAAWqnG;YACtD99H,SAAS2uB,aAAaqvG,SAASvnG,WAAWqnG;YAC1ChoG,gBAAgBnH,aAAasvG,gBAAgBxnG,WAAWqnG;eAErD/nG,OAAO,GAAGA,OAAO+nG,WAAW/nG;cAC9Bx4C,IAAIw4C,OAAO,IAAI,IAAI,IAAI;cACvBr4C,IAAIq4C,OAAO,IAAI,KAAK;cACpBmoG,eAAe3gJ,GAAGG,GAAG,GAAGH,IAAI,IAAI,GAAGG,GAAG,GAAGH,IAAI,IAAI,GAAGG,IAAI,GAAG,GAAGH,GAAGG,GAAG,GAAGH,IAAI,IAAI,GAAGG,IAAI,GAAG,GAAGH,GAAGG,IAAI,GAAG;QAC5GJ,SAASwF,IAAIo7I,aAAaH,eAAetnG,WAAWV;QACpD/1B,GAAGld,IAAIm/B,KAAK+7G,SAASvnG,WAAWV;cAC1BooG,QAAQpoG,MAAMA,MAAMA,MAAMA,MAAMA,MAAMA;QAC5CD,UAAUhzC,IAAIq7I,MAAMF,gBAAgBxnG,WAAWV;;YAG1C8G,aAAapJ;MACnBoJ,OAAOljD,aAAa,gBAAgBq0C,gBAAgB1wC,UAAUygJ;MAC9DlhG,OAAOljD,aAAa,UAAUq0C,gBAAgBhuB,IAAIg+H;MAClDnhG,OAAOljD,aAAa,iBAAiBq0C,gBAAgB8H,WAAWmoG;MAEhErE,WAAWvlJ,KAAKwoD;UAEZ8gG,MAAMxE;QACTwE;;;;MAKD/D;MACAC;MACAC;;;EAIF,6BAA6Bx7I;UACtBy8I,yBAAyBp4H,kBAAkB,IAAI02H,UAAU,IAAIA,UAAU/6I;IAC7Ey8I,mBAAmB14H,QAAQvE,UAAUjW;IACrCkzI,mBAAmB14H,QAAQxgB,OAAO;IAClCk5I,mBAAmB54H,cAAc;WAC1B44H;;EAGR,sBAAsB56I,QAAQ5C,GAAGG,GAAGwX,OAAOC;IAC1ChV,OAAOiiB,SAAStf,IAAIvF,GAAGG,GAAGwX,OAAOC;IACjChV,OAAO+hB,QAAQpf,IAAIvF,GAAGG,GAAGwX,OAAOC;;EAGjC,wBAAwBogD;UACjBkoF,cAAc9uG,aAAa4mB;UAC3BmnF,eAAevgJ,QAAQ,GAAG,GAAG;UAC7BiiJ,qBAAqB3lC;MAC1B52G,MAAM;MACNq2C;QACC,KAAKqd;;MAEN5d;QACC;UACCn2C,OAAO;;QAER;UACCA,OAAO;;QAER;UACCA,OAAOi8I;;QAER;UACCj8I,OAAO;;QAER;UACCA,OAAO;;QAER;UACCA,OAAO;;QAER;UACCA,OAAOk7I;;QAER;UACCl7I,OAAOg4I,UAAU5rI;;QAElB;UACCpM,OAAOg4I,UAAU5rI;;;MAGnBuqC,cAAckmG;MACdjmG;OAEC;;;;;;;;;;;;;;;KAeCkmG,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAkDlBl7G,UAAUn+B;MACV++B,WAAW;MACXC,YAAY;;WAENm6G;;EAGR;UACOP,gBAAgBxlI,QAAQ,GAAG;UAC3B+lI,qBAAqB3lC;MAC1B52G,MAAM;MACN81C;QACC;UACCn2C,OAAO;;QAER;UACCA,OAAOq8I;;QAER;UACCr8I,OAAOg4I,UAAU5rI;;QAElB;UACCpM,OAAOg4I,UAAU5rI;;;MAGnBuqC,cAAckmG;MACdjmG;OAEC;;;;;;;;;;KAUCkmG,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6BlBl7G,UAAUn+B;MACV++B,WAAW;MACXC,YAAY;;WAENm6G;;EAGR;UACOA,qBAAqB3lC;MAC1B52G,MAAM;MACN81C;QACC;UACCn2C,OAAO;;QAER;UACCA,OAAOg4I,UAAU5rI;;QAElB;UACCpM,OAAOg4I,UAAU5rI;;;MAGnBuqC,cAAckmG;MACdjmG;OAEC;;;;;;;;;KASCkmG,gBAAgB;;;;;;;;;;MAUlBl7G,UAAUn+B;MACV++B,WAAW;MACXC,YAAY;;WAENm6G;;EAGR;;;OAGG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6DH;;;OAGG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAoFGG,YAAY;QACZC,aAAa;QACbC,WAAW;QACXC,aAAa;QACbC,eAAe;EACrB,0BAA0BhhH;IACzBnnC,QAAQ0B,KAAK;WACNylC;;EAER,uBAAuBA;IACtBnnC,QAAQ0B,KAAK;IACbylC,UAAUihH,kBAAkB;IAC5BjhH,UAAUA,YAAYA;IAEtBA,UAAUx/B,QAAQ;aACVw/B,UAAU9sB;;WAGX8sB;;EAER,oBAAoBlhC,UAAUI;IAC7BrG,QAAQ0B,KAAK;eACF6qG,OAAOtmG,UAAUI;;EAE7B,kBAAkBA;IACjBrG,QAAQ0B,KAAK;eACFmmG,OAAOxhG;;EAEnB,wBAAwBJ,UAAUI;IACjCrG,QAAQ0B,KAAK;eACF6qG,OAAOtmG,UAAUI;;EAE7B,4BAA4B2hC;IAC3BhoC,QAAQ0B,KAAK;eACF0xE,eAAeprC;;EAE3B,+BAA+BA;IAC9BhoC,QAAQ0B,KAAK;eACF0xE,eAAeprC;;EAE3B,gCAAgCA;IAC/BhoC,QAAQ0B,KAAK;eACF0xE,eAAeprC;;EAE3B,gBAAgBjhC,GAAGG,GAAGC;IACrBnH,QAAQ0B,KAAK;eACFiE,QAAQoB,GAAGG,GAAGC;;;EAG1B,gCAAgCiT,OAAOg8B;IACtCp2C,QAAQ0B,KAAK;eACF81C,gBAAgBp9B,OAAOg8B,UAAUK,SAASx9B;;EAEtD,uBAAuBmB,OAAOg8B;IAC7Bp2C,QAAQ0B,KAAK;eACF2mJ,oBAAoBjuI,OAAOg8B;;EAEvC,wBAAwBh8B,OAAOg8B;IAC9Bp2C,QAAQ0B,KAAK;eACF4mJ,qBAAqBluI,OAAOg8B;;EAExC,+BAA+Bh8B,OAAOg8B;IACrCp2C,QAAQ0B,KAAK;eACF6mJ,4BAA4BnuI,OAAOg8B;;EAE/C,wBAAwBh8B,OAAOg8B;IAC9Bp2C,QAAQ0B,KAAK;eACF8mJ,qBAAqBpuI,OAAOg8B;;EAExC,yBAAyBh8B,OAAOg8B;IAC/Bp2C,QAAQ0B,KAAK;eACF43C,sBAAsBl/B,OAAOg8B;;EAEzC,wBAAwBh8B,OAAOg8B;IAC9Bp2C,QAAQ0B,KAAK;eACF+mJ,qBAAqBruI,OAAOg8B;;EAExC,yBAAyBh8B,OAAOg8B;IAC/Bp2C,QAAQ0B,KAAK;eACF23C,sBAAsBj/B,OAAOg8B;;EAEzC,0BAA0Bh8B,OAAOg8B;IAChCp2C,QAAQ0B,KAAK;eACFo4C,uBAAuB1/B,OAAOg8B;;EAE1C,0BAA0Bh8B,OAAOg8B;IAChCp2C,QAAQ0B,KAAK;eACFgnJ,uBAAuBtuI,OAAOg8B;;;EAG1C09E,MAAMuc,SAAS,UAAUsY,WAAWv2B;IACnCpyH,QAAQ6B,IAAI;IACZ8mJ,UAAU7mI,YAAYxE,OAAO+yH,OAAOvc,MAAMhyG;IAC1C6mI,UAAU7mI,UAAUvc,cAAcojJ;IAClCA,UAAU7mI,UAAUswG,WAAWA;WACxBu2B;;;EAIRnvB,KAAK13G,UAAU8mI,aAAa,UAAU9zH;IACrC90B,QAAQ0B,KAAK;WACN,KAAKmzB,cAAcC;;;EAI3B,oBAAoBxqB;IACnBtK,QAAQ0B,KAAK;eACFmnJ,WAAWv+I;;EAEvB,2BAA2B+qB,QAAQ9uB;IAClCvG,QAAQ0B,KAAK;eACFonJ,UAAUzzH,QAAQ9uB;;EAE9B,qBAAqB8uB,QAAQme;IAC5BxzC,QAAQ0B,KAAK;eACFuqG,iBAAiBmU,cAAc/qF,OAAOpvB,eAAeitE;MAC/D3sE,OAAOitC,QAAQz1C,YAAYy1C,MAAM;;;EAInCu1G,WAAWjnI,UAAUknI,YAAY;IAChChpJ,QAAQa,MAAM;;EAGfooJ,eAAennI,UAAUgN,SAAS;IACjC9uB,QAAQa,MAAM;;EAGf,yBAAyBw0B,QAAQme;IAChCxzC,QAAQ0B,KAAK;eACFuqG,iBAAiB+V,kBAAkB3sF,OAAOpvB,eAAeitE;MACnE3sE,OAAOitC,QAAQz1C,YAAYy1C,MAAM;;;;EAInCq8E,OAAO/tG,UAAU06G,iBAAiB,UAAUpzG;IAC3CppB,QAAQ0B,KAAK;WACN67H,YAAYf,eAAepzG;;EAGnCymG,OAAOq5B;IACN1hJ,KAAK;;MAGJxH,QAAQa,MAAM;;IAEf8oD,KAAK;;MAGJ3pD,QAAQa,MAAM;;;EAGhB,mBAAmBguH;IAClB7uH,QAAQ0B,KAAK;eACF0vH,WAAWvC;;EAEvB,6BAA6BA;IAC5B7uH,QAAQ0B,KAAK;eACFynJ,kBAAkBt6B;;;EAG9BuwB,KAAKt9H,UAAUF,SAAS,UAAUywG;IACjCryH,QAAQ0B,KAAK;WACN,KAAK+zB,UAAU48F;;EAGvB+sB,KAAKt9H,UAAUsnI,QAAQ;IACtBppJ,QAAQ0B,KAAK;WACN,KAAK8zB;;EAGb4pH,KAAKt9H,UAAUunI,oBAAoB,UAAU9zH;IAC5Cv1B,QAAQ0B,KAAK;WACN,KAAK80B,cAAcjB;;EAG3B6pH,KAAKt9H,UAAUxX,OAAO,UAAU+nH;IAC/BryH,QAAQ0B,KAAK;WACN,KAAKg0B,QAAQ28F;;;EAIrBp6F,KAAKnW,UAAUF,SAAS,UAAUywG;IACjCryH,QAAQ0B,KAAK;WACN,KAAK+zB,UAAU48F;;EAGvBp6F,KAAKnW,UAAUsnI,QAAQ;IACtBppJ,QAAQ0B,KAAK;WACN,KAAK8zB;;EAGbyC,KAAKnW,UAAUunI,oBAAoB,UAAU9zH;IAC5Cv1B,QAAQ0B,KAAK;WACN,KAAK80B,cAAcjB;;EAG3B0C,KAAKnW,UAAUwnI,uBAAuB,UAAU5yH;IAC/C12B,QAAQ0B,KAAK;WACN,KAAK+0B,iBAAiBC;;EAG9BuB,KAAKnW,UAAUxX,OAAO,UAAU+nH;IAC/BryH,QAAQ0B,KAAK;WACN,KAAKg0B,QAAQ28F;;;EAIrBl4E,OAAOr4B,UAAUsnI,QAAQ;IACxBppJ,QAAQ0B,KAAK;WACN,KAAK8zB;;;EAIbwkD,QAAQl4D,UAAUynI,gBAAgB,UAAUnuI;IAC3Cpb,QAAQ0B,KAAK;WACN,KAAK6kD,wBAAwBnrC;;;EAIrCouI,MAAM1nI,UAAUF,SAAS,UAAUywG;IAClCryH,QAAQ0B,KAAK;WACN,KAAK+zB,UAAU48F;;;EAIvBlsG,QAAQrE,UAAU2nI,uBAAuB,UAAUrvI,OAAOiH;IACzDrhB,QAAQ0B,KAAK;WACN,KAAK4f,QAAQlH,OAAOiH;;EAG5B8E,QAAQrE,UAAU4nI,kBAAkB,UAAU7zH;IAC7C71B,QAAQ0B,KAAK;WACNm0B,OAAOlW,aAAa;;EAG5BwG,QAAQrE,UAAU6nI,uBAAuB;;IAGxC3pJ,QAAQa,MAAM;;EAGfslB,QAAQrE,UAAU8nI,yBAAyB,UAAUpoI;IACpDxhB,QAAQ0B,KAAK;WACN8f,UAAU7B,aAAa;;EAG/BwG,QAAQrE,UAAU+nI,sBAAsB;;IAGvC7pJ,QAAQa,MAAM;;EAGfslB,QAAQrE,UAAUgoI,aAAa,UAAU5jI;IACxClmB,QAAQ0B,KAAK;WACN,KAAKwd,KAAKgH,QAAQtB;;;EAI1BkY,QAAQhb,UAAUioI,kBAAkB,UAAU3uI;IAC7Cpb,QAAQ0B,KAAK;WACN,KAAKq7B,aAAa3hB;;EAG1B0hB,QAAQhb,UAAU2nI,uBAAuB,UAAUrvI,OAAOiH;IACzDrhB,QAAQ0B,KAAK;WACN,KAAK4f,QAAQlH,OAAOiH;;EAG5Byb,QAAQhb,UAAUkoI,cAAc;IAC/BhqJ,QAAQ0B,KAAK;eACFiE,UAAUsuB,oBAAoB,MAAM;;EAGhD6I,QAAQhb,UAAUojB,4BAA4B,UAAU1oB;IACvDxc,QAAQ0B,KAAK;WACN,KAAKw8B,2BAA2B1hB;;EAGxCsgB,QAAQhb,UAAUmoI,kBAAkB;IACnCjqJ,QAAQ0B,KAAK;;EAGdo7B,QAAQhb,UAAU4nI,kBAAkB,UAAU7zH;IAC7C71B,QAAQ0B,KAAK;WACNm0B,OAAO7L,aAAa;;EAG5B8S,QAAQhb,UAAUooI,kBAAkB,UAAUr0H;IAC7C71B,QAAQ0B,KAAK;WACNm0B,OAAO7L,aAAa;;EAG5B8S,QAAQhb,UAAU6nI,uBAAuB;;IAGxC3pJ,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAUqoI,aAAa,UAAUxlJ;IACxC3E,QAAQ0B,KAAK;IACbiD,EAAE+tB,mBAAmB;;EAGtBoK,QAAQhb,UAAUsoI,cAAc,UAAUv0H;IACzC71B,QAAQ0B,KAAK;WACNm0B,OAAO7L,aAAa;;EAG5B8S,QAAQhb,UAAUmE,YAAY;IAC7BjmB,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAU3b,UAAU;IAC3BnG,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAUujB,UAAU;IAC3BrlC,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAUwjB,UAAU;IAC3BtlC,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAUuoI,eAAe;IAChCrqJ,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAU8nI,yBAAyB,UAAUpoI;IACpDxhB,QAAQ0B,KAAK;WACN8f,UAAUwI,aAAa;;EAG/B8S,QAAQhb,UAAU+nI,sBAAsB;;IAGvC7pJ,QAAQa,MAAM;;EAGfi8B,QAAQhb,UAAUwoI,cAAc,UAAUrpH,MAAMC,OAAOE,QAAQD,KAAKE,MAAMC;IACzEthC,QAAQ0B,KAAK;WACN,KAAKs/B,gBAAgBC,MAAMC,OAAOC,KAAKC,QAAQC,MAAMC;;EAG7DxE,QAAQhb,UAAUgoI,aAAa,UAAU5jI;IACxClmB,QAAQ0B,KAAK;WACN,KAAKwd,KAAKgH,QAAQtB;;;EAI1BolB,MAAMloB,UAAUyoI,qBAAqB,UAAUjhH;IAC9CtpC,QAAQ0B,KAAK;WACN,KAAK+nC,eAAeH;;;EAI5BnY,WAAWrP,UAAU4nI,kBAAkB,UAAU7zH;IAChD71B,QAAQ0B,KAAK;WACNm0B,OAAOtE,gBAAgB;;EAG/BJ,WAAWrP,UAAU8nF,UAAU;IAC9B5pG,QAAQ0B,KAAK;WACN,KAAKkjB;;;EAIb84B,IAAI57B,UAAUunI,oBAAoB,UAAU9zH;IAC3Cv1B,QAAQ0B,KAAK;WACN,KAAK80B,cAAcjB;;EAG3BmoB,IAAI57B,UAAU0oI,sBAAsB,UAAU3zH;IAC7C72B,QAAQ0B,KAAK;WACN,KAAKk1B,gBAAgBC;;EAG7B6mB,IAAI57B,UAAUwnI,uBAAuB,UAAU5yH;IAC9C12B,QAAQ0B,KAAK;WACN,KAAK+0B,iBAAiBC;;;EAI9ByV,SAASrqB,UAAUqwF,OAAO;IACzBnyG,QAAQ0B,KAAK;WACN,KAAKuqC;;EAGbE,SAASrqB,UAAU2oI,qBAAqB,UAAU90H,OAAOhsB;IACxD3J,QAAQ0B,KAAK;WACN,KAAKopC,aAAanV,OAAOhsB;;EAGjCwiC,SAASrqB,UAAU4oI,WAAW,UAAU/gJ;IACvC3J,QAAQ0B,KAAK;WACN,KAAKwqC,YAAYviC;;EAGzBwiC,SAASw+G,kBAAkB,UAAUhhJ;IACpC3J,QAAQ0B,KAAK;WACN,KAAKkpC,UAAUjhC;;EAGvBwiC,SAASrqB,UAAU+U,QAAQ,UAAUltB;IACpC3J,QAAQ0B,KAAK;WACN,KAAK0qC,SAASziC;;EAGtBwiC,SAASs+G,qBAAqB,UAAU90H,OAAOlZ,GAAGC,GAAGC,GAAGhT;IACvD3J,QAAQ0B,KAAK;WACNyqC,SAASrB,aAAanV,OAAOlZ,GAAGC,GAAGC,GAAGhT;;EAG9CwiC,SAAS3Y,SAAS,UAAU/W,GAAGC,GAAGC,GAAGhT;IACpC3J,QAAQ0B,KAAK;WACNyqC,SAASvB,UAAUnuB,GAAGC,GAAGC,GAAGhT;;;EAIpCu0H,MAAMp8G,UAAU8oI,mBAAmB,UAAUp4B;IAC5CxyH,QAAQ0B,KAAK;WACN,KAAKk2G,cAAc4a;;EAG3B0L,MAAMp8G,UAAU+oI,UAAU,UAAUz/I;IACnCpL,QAAQ0B,KAAK;eACFk8G,gBAAgB,MAAMxyG;;EAGlC8yH,MAAMp8G,UAAUgpI,eAAe,UAAU1/I;IACxCpL,QAAQ0B,KAAK;eACFw/G,cAAc,MAAM91G;;;EAIhCyW,QAAQC,UAAUipI,gBAAgB,UAAUvpI,WAAWvH,OAAOoH;IAC7DrhB,QAAQ0B,KAAK;WACN,KAAK6f,oBAAoBC,WAAWvH,OAAOoH;;EAGnDQ,QAAQC,UAAUkpI,sBAAsB,UAAUrmJ;IACjD3E,QAAQ0B,KAAK;WACN,KAAKmf,oBAAoBlc;;EAGjCkd,QAAQC,UAAUmpI,kBAAkB;IACnCjrJ,QAAQ0B,KAAK;WACN,KAAK6e;;;EAIb5a,QAAQmc,UAAUopI,6BAA6B;IAC9ClrJ,QAAQa,MAAM;;EAGf8E,QAAQmc,UAAUqpI,yBAAyB;IAC1CnrJ,QAAQa,MAAM;;EAGf8E,QAAQmc,UAAUspI,wBAAwB,UAAUhwI;IACnDpb,QAAQ0B,KAAK;WACN,KAAKqyB,sBAAsB3Y;;EAGnCzV,QAAQmc,UAAUupI,qBAAqB,UAAUjwI;IAChDpb,QAAQ0B,KAAK;WACN,KAAKsyB,mBAAmB5Y;;EAGhCzV,QAAQmc,UAAUwpI,sBAAsB,UAAUrxI,OAAOiM;IACxDlmB,QAAQ0B,KAAK;WACN,KAAKuyB,oBAAoB/N,QAAQjM;;EAGzCtU,QAAQmc,UAAUypI,kBAAkB,UAAUnwI;IAC7Cpb,QAAQ0B,KAAK;WACN,KAAKsoB,aAAa5O;;EAG1BzV,QAAQmc,UAAUipI,gBAAgB,UAAUvpI,WAAWvH,OAAOoH;IAC7DrhB,QAAQ0B,KAAK;WACN,KAAK6f,oBAAoBC,WAAWvH,OAAOoH;;EAGnD1b,QAAQmc,UAAUkpI,sBAAsB,UAAUrmJ;IACjD3E,QAAQ0B,KAAK;WACN,KAAKmf,oBAAoBlc;;EAGjCgB,QAAQmc,UAAUmpI,kBAAkB;IACnCjrJ,QAAQ0B,KAAK;WACN,KAAK6e;;;EAIbgL,QAAQzJ,UAAUipI,gBAAgB,UAAUvpI,WAAWvH,OAAOoH;IAC7DrhB,QAAQ0B,KAAK;WACN,KAAK6f,oBAAoBC,WAAWvH,OAAOoH;;EAGnDkK,QAAQzJ,UAAUmpI,kBAAkB;IACnCjrJ,QAAQ0B,KAAK;WACN,KAAK6e;;;EAIbmjB,SAAS5hB,UAAU0pI,iBAAiB,UAAUngJ;IAC7CrL,QAAQ0B,KAAK;WACN,KAAK0kC,gBAAgB/6B;;EAG7Bq4B,SAAS5hB,UAAU2pI,cAAc;IAChCzrJ,QAAQ0B,KAAK;;EAGdgiC,SAAS5hB,UAAUmE,YAAY,UAAUhc,UAAUqlB;IAClDtvB,QAAQ0B,KAAK;WACN,KAAK6jC,gBAAgBjW,MAAMrlB;;EAGnCy5B,SAAS5hB,UAAU4pI,mBAAmB;IACrC1rJ,QAAQa,MAAM;;EAGf6iC,SAAS5hB,UAAU6pI,cAAc,UAAUzlI;IAC1ClmB,QAAQ0B,KAAK;WACN,KAAKsoB,aAAa9D;;EAG1B5I,OAAOwmB,iBAAiBJ,SAAS5hB;IAChC8pI;MACCjiG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKqH,SAAS6T;;MAEtBtQ,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKqH,SAAS6T,QAAQ5R;;;IAGxB6gJ;MACCliG,KAAK;QACJ3pD,QAAQ0B,KAAK;;MAEd4K,KAAK;QACJtM,QAAQ0B,KAAK;;;;EAKhB+E,KAAKqb,UAAUgqI,cAAc;IAC5B9rJ,QAAQa,MAAM;;EAGfyc,OAAOwmB,iBAAiBr9B,KAAKqb;IAC5BiqI;MACCpiG,KAAK;QACJ3pD,QAAQa,MAAM;eACPoW;;MAER3K,KAAK;QACJtM,QAAQa,MAAM;;;;EAKjBwoG,YAAYvnF,UAAUkqI,YAAY;IACjChsJ,QAAQa,MAAM;;;EAIfwjD,kBAAkBviC,UAAUmqI,UAAU,UAAU5oG,aAAaJ;IAC5DjjD,QAAQ0B,KAAK,oDAAoD;QAC7DuhD,cAAcllD,WAAW,KAAKklD,YAAYA;IAC9C,KAAKG,eAAeC;;;EAIrB/lC,OAAOwmB,iBAAiB61F,MAAM73G;IAC7BoqI;MACC5/I,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGfyqJ;MACC7/I,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAOwwB,MAAM53C;;;IAG3BohJ;MACC9/I,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAO6O,OAAOj2B;;;IAG5BqhJ;MACC//I,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAO8O,QAAQl2B;;;IAG7BshJ;MACChgJ,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAO+O,MAAMn2B;;;IAG3BuhJ;MACCjgJ,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAOgP,SAASp2B;;;IAG9B+pD;MACCzoD,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAOiP,OAAOr2B;;;IAG5BgqD;MACC1oD,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOrkC,OAAOkP,MAAMt2B;;;IAG3BwhJ;MACClgJ,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGfsyD;MACC1nD,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOuhB,OAAOhtE;;;IAGrByhJ;MACCngJ,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGfgrJ;MACCpgJ,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOyhB,QAAQx5D,QAAQ1T;;;IAG9B2hJ;MACCrgJ,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK+0D,OAAOyhB,QAAQv5D,SAAS3T;;;;;EAKhCsS,OAAOwmB,iBAAiB0T,gBAAgB11B;IACvC1hB;MACCupD,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAK0Y,MAAMha;;;IAGpBwsJ;MACCjjG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAK40C,UAAUr9B;;MAEvB3M,KAAK;;QAGJtM,QAAQ0B,KAAK;QACb,KAAK+0C,SAASx9B;;;;EAKjBu+B,gBAAgB11B,UAAU+qI,aAAa,UAAU7hJ;IAChDhL,QAAQ0B,KAAK;IACb,KAAK+0C,SAASzrC,UAAU,OAAOiO,mBAAmBD;WAC3C;;GAGRw+B,gBAAgB11B,UAAUgrI,mBAAmB;;IAG5C9sJ,QAAQa,MAAM;KACZ22C,gBAAgB11B,UAAUirI,WAAW;;IAGvC/sJ,QAAQa,MAAM;;;EAGfo8C,eAAen7B,UAAUkrI,WAAW,UAAU/yI;IAC7Cja,QAAQ0B,KAAK;IACb,KAAKy3C,SAASl/B;;EAGfgjC,eAAen7B,UAAUmrI,eAAe,UAAU5hJ,MAAMmW;IACvDxhB,QAAQ0B,KAAK;UAEP8f,aAAaA,UAAUi2B,wBAAwBj2B,aAAaA,UAAUkoC;MAC3E1pD,QAAQ0B,KAAK;aACN,KAAKyB,aAAakI,UAAUmsC,gBAAgBx1B,UAAU,IAAIA,UAAU;;QAGxE3W,SAAS;MACZrL,QAAQ0B,KAAK;MACb,KAAKy3C,SAAS33B;aACP;;WAGD,KAAKre,aAAakI,MAAMmW;;EAGhCy7B,eAAen7B,UAAUorI,cAAc,UAAU1jH,OAAOjhC,OAAO60G;QAC1DA,gBAAgBr/G;MACnBiC,QAAQ0B,KAAK;;IAGd1B,QAAQ0B,KAAK;IACb,KAAK+3C,SAASjQ,OAAOjhC;;EAGtB00C,eAAen7B,UAAUqrI,iBAAiB;IACzCntJ,QAAQ0B,KAAK;IACb,KAAKi4C;;EAGNsD,eAAen7B,UAAUsrI,iBAAiB;IACzCptJ,QAAQ0B,KAAK;;EAGdu7C,eAAen7B,UAAUurI,kBAAkB,UAAUhiJ;IACpDrL,QAAQ0B,KAAK;WACN,KAAK63C,gBAAgBluC;;EAG7B4xC,eAAen7B,UAAU6pI,cAAc,UAAUzlI;IAChDlmB,QAAQ0B,KAAK;WACN,KAAKsoB,aAAa9D;;EAG1B5I,OAAOwmB,iBAAiBmZ,eAAen7B;IACtCu7G;MACC1zE,KAAK;QACJ3pD,QAAQa,MAAM;eACP,KAAKm4C;;;IAGdskF;MACC3zE,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKs3C;;;;EAKfwtD,kBAAkB1kF,UAAU+qI,aAAa,UAAU7hJ;IAClDhL,QAAQ0B,KAAK;IACb,KAAK+0C,SAASzrC,UAAU,OAAOiO,mBAAmBD;WAC3C;;EAGRwtF,kBAAkB1kF,UAAUirI,WAAW;;IAGtC/sJ,QAAQa,MAAM;;;EAIf+8G,gBAAgB97F,UAAUwrI,YAAY;IACrCttJ,QAAQa,MAAM;;EAGf+8G,gBAAgB97F,UAAUyrI,eAAe;IACxCvtJ,QAAQa,MAAM;;EAGf+8G,gBAAgB97F,UAAUw0F,WAAW;IACpCt2G,QAAQa,MAAM;;;EAIf+K,MAAMkW,UAAUhkB,UAAU;IACzBkC,QAAQa,MAAM;;;EAIfw9I,QAAQv8H,UAAU2G,WAAW;IAC5BzoB,QAAQ0B,KAAK;WACN;;;EAIR4b,OAAOwmB,iBAAiBkP,SAASlxB;IAChC0rI;MACC7jG,KAAK;QACJ3pD,QAAQ0B,KAAK;;MAEd4K,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGf+rJ;MACC9jG,KAAK;QACJ3pD,QAAQ0B,KAAK;;MAEd4K,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGfgsJ;MACC/jG,KAAK;QACJ3pD,QAAQ0B,KAAK;mBACFo0C;;;IAGbmmF;MACCtyE,KAAK;QACJ3pD,QAAQa,MAAM,WAAW,KAAK1B,OAAO;;MAEtCmN,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK,WAAW,KAAKvC,OAAO;QACpC,KAAKkwC,cAAcrkC,UAAUuD;;;IAG/BixE;MACC71B,KAAK;QACJ3pD,QAAQ0B,KAAK,WAAW,KAAKvC,OAAO;eAC7B,KAAK0uC;;MAEbvhC,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK,WAAW,KAAKvC,OAAO;QACpC,KAAK0uC,kBAAkB7iC;;;;EAI1BsS,OAAOwmB,iBAAiB2e,eAAe3gC;IACtCkgC;MACC2H,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKqgD,WAAWC;;MAExB11C,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKqgD,WAAWC,cAAch3C;;;;;EAKjCk7F,cAAcpkF,UAAU6rI,cAAc,UAAUppG,cAAch+C,OAAOklB,OAAOs6B;IAC3E/lD,QAAQ0B,KAAK;IACb,KAAKyjD,gBAAgBZ;IACrB,KAAKtkD,MAAMsG,OAAOklB,OAAOs6B;;EAG1BmgD,cAAcpkF,UAAU8rI,UAAU,UAAU18H;IAC3ClxB,QAAQ0B,KAAK;IACb,KAAKsK,iBAAiBklB;;EAGvBg1E,cAAcpkF,UAAU+rI,yBAAyB;IAChD7tJ,QAAQ0B,KAAK;WACN,KAAKwjD;;EAGbghD,cAAcpkF,UAAUm9C,mBAAmB;IAC1Cj/D,QAAQ0B,KAAK;WACN,KAAK4mD,aAAa2W;;EAG1BinC,cAAcpkF,UAAUgsI,eAAe;IACtC9tJ,QAAQ0B,KAAK;WACN,KAAK4mD,aAAa/Z;;EAG1B23D,cAAcpkF,UAAUisI,eAAe;IACtC/tJ,QAAQ0B,KAAK;WACN,KAAKo1D,MAAMmF;;EAGnBiqC,cAAcpkF,UAAUksI,wBAAwB;IAC/ChuJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUmsI,4BAA4B;IACnDjuJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUosI,8BAA8B;IACrDluJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUqsI,gCAAgC;IACvDnuJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUssI,iCAAiC;IACxDpuJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUusI,sBAAsB;IAC7CruJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUmtD,yBAAyB;IAChDjvE,QAAQ0B,KAAK;WACN,KAAK4mD,aAAasW;;EAG1BsnC,cAAcpkF,UAAUwsI,0BAA0B;IACjDtuJ,QAAQ0B,KAAK;WACN,KAAKqgD,WAAW4H,IAAI;;EAG5Bu8C,cAAcpkF,UAAUysI,oBAAoB,UAAUlvD;IACrDr/F,QAAQ0B,KAAK;IACb,KAAK+5E,eAAe4jB;;EAGrB6G,cAAcpkF,UAAU0sI,eAAe;IACtCxuJ,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU2sI,eAAe;IACtCzuJ,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU4sI,gBAAgB;IACvC1uJ,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU6sI,kBAAkB;IACzC3uJ,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU8sI,iBAAiB;IACxC5uJ,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU+sI,mBAAmB;IAC1C7uJ,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAUmK,aAAa;IACpCjsB,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU0rE,eAAe;IACtCxtF,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAU6sE,iBAAiB;IACxC3uF,QAAQ0B,KAAK;;EAGdwkG,cAAcpkF,UAAUgtI,uBAAuB;IAC9C9uJ,QAAQ0B,KAAK;WACN,KAAK25E;;EAGb/9D,OAAOwmB,iBAAiBoiE,cAAcpkF;IACrCguD;MACCnmB,KAAK;eACG,KAAK0qB,UAAUrwB;;MAEvB13C,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK2yE,UAAUrwB,UAAUh5C;;;IAG3ByiE;MACC9jB,KAAK;eACG,KAAK0qB,UAAUl1E;;MAEvBmN,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK2yE,UAAUl1E,OAAO6L;;;IAGxB+jJ;MACCplG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN3D;;MAERuO,KAAK;;QAGJtM,QAAQ0B,KAAK;;;IAGfklB;MACC+iC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmlB;;;IAGdmoI;MACCrlG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKsjD;;;IAGdiqG;MACCtlG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN;;MAER4K,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGfwtJ;MACCvlG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN;;MAER4K,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAK8uE,iBAAiBxlE,UAAU,OAAOqM,eAAeD;;;IAGxD+3I;MACCxlG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN;;MAER4K,KAAK;QACJtM,QAAQ0B,KAAK;;;;EAIhB4b,OAAOwmB,iBAAiBo6D,eAAep8E;IACtCkjE;MACCr7B,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN3D;;MAERuO,KAAK;;QAGJtM,QAAQ0B,KAAK;;;IAGf0tJ;MACCzlG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN3D;;MAERuO,KAAK;QACJtM,QAAQ0B,KAAK;;;IAGf2tJ;MACC1lG,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN3D;;MAERuO,KAAK;QACJtM,QAAQ0B,KAAK;;;;EAIhB,+BAA+Bgd,OAAOC,QAAQvT;IAC7CpL,QAAQ0B,KAAK;eACFskD,sBAAsBtnC,OAAOtT;;;EAGzCkS,OAAOwmB,iBAAiB3X,kBAAkBrK;IACzC0F;MACCmiC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQrE;;MAErBlb,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQrE,QAAQxc;;;IAGvByc;MACCkiC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQpE;;MAErBnb,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQpE,QAAQzc;;;IAGvB0c;MACCiiC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQnE;;MAErBpb,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQnE,YAAY1c;;;IAG3B2c;MACCgiC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQlE;;MAErBrb,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQlE,YAAY3c;;;IAG3B6c;MACC8hC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQhE;;MAErBvb,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQhE,aAAa7c;;;IAG5BqW;MACCsoC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQxK;;MAErB/U,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQxK,SAASrW;;;IAGxBkd;MACCyhC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQ3D;;MAErB5b,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQ3D,SAASld;;;IAGxB4c;MACC+hC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQjE;;MAErBtb,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQjE,SAAS5c;;;IAGxB7L;MACCwqD,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQ1sB;;MAErBmN,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQ1sB,OAAO6L;;;IAGtBod;MACCuhC,KAAK;QACJ3pD,QAAQ0B,KAAK;eACN,KAAKmqB,QAAQzD;;MAErB9b,KAAK,UAAUtB;QACdhL,QAAQ0B,KAAK;QACb,KAAKmqB,QAAQzD,kBAAkBpd;;;;;EAKlCw/H,MAAM1oH,UAAUotG,OAAO,UAAU3B;IAChCvtH,QAAQ0B,KAAK;UACPs+C,QAAQ;UACRsvG,kBAAkBC;IACxBD,YAAYpgC,KAAK3B,MAAM,UAAUj1E;MAChC0H,MAAMipF,UAAU3wF;;WAEV;;EAGRk3G,cAAc1tI,UAAU2tI,UAAU;IACjCzvJ,QAAQ0B,KAAK;WACN,KAAK0qI;;;EAIbtmF,WAAWhkC,UAAU4tI,gBAAgB,UAAU3jJ,UAAUZ;IACxDnL,QAAQ0B,KAAK;WACN,KAAKotB,OAAO/iB,UAAUZ;;EAG9B26C,WAAWhkC,UAAU7hB,QAAQ,UAAU8L,UAAUxF,OAAOklB,OAAOs6B;IAC9D/lD,QAAQ0B,KAAK;WACN,KAAK6iD,aAAatkD,MAAM8L,UAAUxF,OAAOklB,OAAOs6B;;EAGxDl8B,WAAWilG,cAAc/wH;EAEzB8rB,WAAW4nG,cAAc,UAAUroG,KAAK9B,SAASkmG,QAAQE;IACxD1tH,QAAQ0B,KAAK;UACP8sH,aAAamhC;IACnBnhC,OAAOe,eAAe,KAAKT;UACrBjjG,UAAU2iG,OAAOU,KAAK9lG,KAAKokG,QAAQzvH,WAAW2vH;QAChDpmG,SAASuE,QAAQvE,UAAUA;WACxBuE;;EAGRhC,WAAW+lI,kBAAkB,UAAU99B,MAAMxqG,SAASkmG,QAAQE;IAC7D1tH,QAAQ0B,KAAK;UACP8sH,aAAaqhC;IACnBrhC,OAAOe,eAAe,KAAKT;UACrBjjG,UAAU2iG,OAAOU,KAAK4C,MAAMtE,QAAQzvH,WAAW2vH;QACjDpmG,SAASuE,QAAQvE,UAAUA;WACxBuE;;EAGRhC,WAAWimI,wBAAwB;IAClC9vJ,QAAQa,MAAM;;EAGfgpB,WAAWkmI,4BAA4B;IACtC/vJ,QAAQa,MAAM;;;EAIf;IACCb,QAAQa,MAAM;;;EAGf;IACCb,QAAQa,MAAM;;;QAGTmvJ;IACLC,2BAA2B;;MAG1BjwJ,QAAQa,MAAM;;IAEfqvJ,QAAQ;;MAGPlwJ,QAAQa,MAAM;;IAEfolC,QAAQ;;MAGPjmC,QAAQa,MAAM;;;;EAIhB;IACCb,QAAQa,MAAM;;aAGJklG,uBAAuB;;IAEjCA,mBAAmB5rF,kBAAkB6rF,YAAY;MAChDC;QACCkqD,UAAUljJ;;;;aAOF3M,WAAW;QACjBA,OAAO8vJ;MACVpwJ,QAAQ0B,KAAK;;MAEbpB,OAAO8vJ,YAAYnjJ;;;EAIrBL,QAAQkE,wBAAwBA;EAChClE,QAAQmC,cAAcA;EACtBnC,QAAQ6D,eAAeA;EACvB7D,QAAQoK,6BAA6BA;EACrCpK,QAAQ+B,mBAAmBA;EAC3B/B,QAAQoG,cAAcA;EACtBpG,QAAQoD,cAAcA;EACtBpD,QAAQmM,oBAAoBA;EAC5BnM,QAAQV,eAAeA;EACvBU,QAAQ83H,oBAAoBA;EAC5B93H,QAAQykH,gBAAgBA;EACxBzkH,QAAQyjJ,kBAAkBA;EAC1BzjJ,QAAQwxI,iBAAiBA;EACzBxxI,QAAQuoI,uBAAuBA;EAC/BvoI,QAAQw1G,iBAAiBA;EACzBx1G,QAAQioH,WAAWA;EACnBjoH,QAAQ8jF,cAAcA;EACtB9jF,QAAQ0jJ,cAAcA;EACtB1jJ,QAAQ49H,QAAQA;EAChB59H,QAAQ4iJ,gBAAgBA;EACxB5iJ,QAAQq3H,eAAeA;EACvBr3H,QAAQ2jJ,gBAAgBA;EACxB3jJ,QAAQ2iJ,cAAcA;EACtB3iJ,QAAQi8I,aAAaA;EACrBj8I,QAAQ4jJ,aAAaA;EACrB5jJ,QAAQyB,WAAWA;EACnBzB,QAAQgL,oBAAoBA;EAC5BhL,QAAQoB,iBAAiBA;EACzBpB,QAAQ6jJ,sBAAsBA;EAC9B7jJ,QAAQ08F,OAAOA;EACf18F,QAAQg+G,uBAAuBA;EAC/Bh+G,QAAQ8jJ,oBAAoBA;EAC5B9jJ,QAAQwyI,OAAOA;EACfxyI,QAAQqrB,OAAOA;EACfrrB,QAAQ+jJ,aAAaA;EACrB/jJ,QAAQgzG,oBAAoBr1G;EAC5BqC,QAAQrC,cAAcA;EACtBqC,QAAQk8I,YAAYA;EACpBl8I,QAAQ4qC,kBAAkBA;EAC1B5qC,QAAQqwC,iBAAiBA;EACzBrwC,QAAQyxH,uBAAuBA;EAC/BzxH,QAAQyF,WAAWA;EACnBzF,QAAQygH,QAAQA;EAChBzgH,QAAQ+1C,SAASA;EACjB/1C,QAAQgkJ,eAAeA;EACvBhkJ,QAAQikJ,iBAAiBA;EACzBjkJ,QAAQwgG,gBAAgBA;EACxBxgG,QAAQipH,mBAAmBA;EAC3BjpH,QAAQiE,oBAAoBA;EAC5BjE,QAAQkzG,uBAAuBD;EAC/BjzG,QAAQizG,iBAAiBA;EACzBjzG,QAAQ4E,sBAAsBA;EAC9B5E,QAAQ25H,QAAQA;EAChB35H,QAAQkpC,QAAQA;EAChBlpC,QAAQi+G,qBAAqBA;EAC7Bj+G,QAAQugG,oBAAoBA;EAC5BvgG,QAAQkkJ,0BAA0BA;EAClClkJ,QAAQozG,qBAAqBD;EAC7BnzG,QAAQmzG,eAAeA;EACvBnzG,QAAQk5C,aAAaA;EACrBl5C,QAAQqE,wBAAwBA;EAChCrE,QAAQsE,wBAAwBA;EAChCtE,QAAQ04C,cAAcA;EACtB14C,QAAQijJ,oBAAoBA;EAC5BjjJ,QAAQyE,0BAA0BA;EAClCzE,QAAQ0E,0BAA0BA;EAClC1E,QAAQ4pH,mBAAmBA;EAC3B5pH,QAAQ8pH,oBAAoBA;EAC5B9pH,QAAQ08G,mBAAmBA;EAC3B18G,QAAQiB,eAAeA;EACvBjB,QAAQkB,gBAAgBA;EACxBlB,QAAQmB,oBAAoBA;EAC5BnB,QAAQgB,eAAeA;EACvBhB,QAAQknH,QAAQA;EAChBlnH,QAAQyrH,YAAYA;EACpBzrH,QAAQkC,iBAAiBA;EACzBlC,QAAQmE,oBAAoBA;EAC5BnE,QAAQqzG,yBAAyB/5G;EACjC0G,QAAQ1G,mBAAmBA;EAC3B0G,QAAQmkJ,cAAcA;EACtBnkJ,QAAQ48F,cAAcA;EACtB58F,QAAQy2D,qBAAqBA;EAC7Bz2D,QAAQ22D,gBAAgBA;EACxB32D,QAAQu8I,oBAAoBA;EAC5Bv8I,QAAQokJ,YAAYA;EACpBpkJ,QAAQwL,qBAAqBA;EAC7BxL,QAAQ0L,yBAAyBA;EACjC1L,QAAQ+hH,wBAAwBA;EAChC/hH,QAAQ0G,cAAcA;EACtB1G,QAAQ2G,qBAAqBA;EAC7B3G,QAAQ0gG,eAAeA;EACvB1gG,QAAQP,mBAAmBA;EAC3BO,QAAQqkJ,yBAAyBA;EACjCrkJ,QAAQs8G,sBAAsBA;EAC9Bt8G,QAAQuzG,6BAA6BD;EACrCtzG,QAAQszG,uBAAuBA;EAC/BtzG,QAAQ0B,aAAaA;EACrB1B,QAAQ8C,iBAAiBA;EACzB9C,QAAQgD,iBAAiBA;EACzBhD,QAAQskJ,yBAAyBA;EACjCtkJ,QAAQ2M,mBAAmBA;EAC3B3M,QAAQqM,mBAAmBA;EAC3BrM,QAAQwM,mBAAmBA;EAC3BxM,QAAQwzG,gBAAgBA;EACxBxzG,QAAQukJ,cAAcA;EACtBvkJ,QAAQ8nH,eAAeA;EACvB9nH,QAAQuD,aAAaA;EACrBvD,QAAQ8L,mBAAmBA;EAC3B9L,QAAQuE,mCAAmCA;EAC3CvE,QAAQwE,mCAAmCA;EAC3CxE,QAAQ+0B,QAAQA;EAChB/0B,QAAQua,kBAAkBA;EAC1Bva,QAAQyzG,wBAAwBzC;EAChChxG,QAAQgxG,kBAAkBA;EAC1BhxG,QAAQs7I,aAAaA;EACrBt7I,QAAQwkH,aAAaA;EACrBxkH,QAAQ2B,cAAcA;EACtB3B,QAAQqrC,yBAAyBA;EACjCrrC,QAAQwkJ,mBAAmBA;EAC3BxkJ,QAAQktC,yBAAyBA;EACjCltC,QAAQykJ,mBAAmBA;EAC3BzkJ,QAAQ87I,yBAAyBA;EACjC97I,QAAQ8F,YAAYA;EACpB9F,QAAQJ,MAAMA;EACdI,QAAQw5F,UAAUA;EAClBx5F,QAAQm3H,OAAOA;EACfn3H,QAAQ0kJ,aAAaA;EACrB1kJ,QAAQwB,YAAYA;EACpBxB,QAAQotE,UAAUA;EAClBptE,QAAQ8xI,oBAAoBA;EAC5B9xI,QAAQ6M,QAAQA;EAChB7M,QAAQ8M,QAAQA;EAChB9M,QAAQ0K,gBAAgBA;EACxB1K,QAAQyD,eAAeA;EACvBzD,QAAQwD,oBAAoBA;EAC5BxD,QAAQkM,0BAA0BA;EAClClM,QAAQgM,qBAAqBA;EAC7BhM,QAAQm8I,aAAaA;EACrBn8I,QAAQtE,QAAQA;EAChBsE,QAAQ+F,gBAAgBA;EACxB/F,QAAQgtH,kBAAkBA;EAC1BhtH,QAAQ2kJ,wBAAwBA;EAChC3kJ,QAAQ43H,uBAAuBA;EAC/B53H,QAAQ2zG,4BAA4BD;EACpC1zG,QAAQ0zG,sBAAsBA;EAC9B1zG,QAAQqzH,oBAAoBA;EAC5BrzH,QAAQmlH,cAAcA;EACtBnlH,QAAQid,aAAaA;EACrBjd,QAAQizI,wBAAwBA;EAChCjzI,QAAQuL,qBAAqBA;EAC7BvL,QAAQyL,yBAAyBA;EACjCzL,QAAQ+vH,2BAA2BA;EACnC/vH,QAAQ8vH,0BAA0BA;EAClC9vH,QAAQ0xI,6BAA6BA;EACrC1xI,QAAQi+F,gBAAgBA;EACxBj+F,QAAQ4kJ,iBAAiBA;EACzB5kJ,QAAQ47I,uBAAuBA;EAC/B57I,QAAQ6kJ,iBAAiBA;EACzB7kJ,QAAQ67I,uBAAuBA;EAC/B77I,QAAQ8kJ,gBAAgBA;EACxB9kJ,QAAQy7I,sBAAsBA;EAC9Bz7I,QAAQ4F,UAAUA;EAClB5F,QAAQ45F,oBAAoBA;EAC5B55F,QAAQi6F,6BAA6BA;EACrCj6F,QAAQs6G,cAAcA;EACtBt6G,QAAQ6J,sBAAsBA;EAC9B7J,QAAQ8J,oBAAoBA;EAC5B9J,QAAQ+J,oBAAoBA;EAC5B/J,QAAQ2L,kBAAkBA;EAC1B3L,QAAQ+kJ,aAAaA;EACrB/kJ,QAAQqL,gBAAgBA;EACxBrL,QAAQ+9G,gBAAgBA;EACxB/9G,QAAQsyH,MAAMA;EACdtyH,QAAQ6zG,sBAAsBD;EAC9B5zG,QAAQ4zG,gBAAgBA;EACxB5zG,QAAQy3B,SAASA;EACjBz3B,QAAQglJ,YAAYA;EACpBhlJ,QAAQqD,YAAYA;EACpBrD,QAAQsD,iBAAiBA;EACzBtD,QAAQ+L,uBAAuBA;EAC/B/L,QAAQ6L,kBAAkBA;EAC1B7L,QAAQ+sH,QAAQA;EAChB/sH,QAAQmvH,aAAaA;EACrBnvH,QAAQ2+F,OAAOA;EACf3+F,QAAQ48I,QAAQA;EAChB58I,QAAQsmE,oBAAoBA;EAC5BtmE,QAAQgqH,YAAYA;EACpBhqH,QAAQ4qH,aAAaA;EACrB5qH,QAAQumE,qBAAqBA;EAC7BvmE,QAAQs/F,WAAWA;EACnBt/F,QAAQo7I,aAAaA;EACrBp7I,QAAQq/F,eAAeA;EACvBr/F,QAAQm7I,YAAYA;EACpBn7I,QAAQwK,iBAAiBA;EACzBxK,QAAQmF,eAAeA;EACvBnF,QAAQw8G,oBAAoBA;EAC5Bx8G,QAAQuF,2BAA2BA;EACnCvF,QAAQqF,4BAA4BA;EACpCrF,QAAQsF,2BAA2BA;EACnCtF,QAAQoF,4BAA4BA;EACpCpF,QAAQ+D,oBAAoBA;EAC5B/D,QAAQijH,SAASA;EACjBjjH,QAAQ2wH,cAAcA;EACtB3wH,QAAQgiH,iBAAiBA;EACzBhiH,QAAQ4K,iBAAiBA;EACzB5K,QAAQ0J,WAAWA;EACnB1J,QAAQ4J,eAAeA;EACvB5J,QAAQ2J,aAAaA;EACrB3J,QAAQwG,uBAAuBA;EAC/BxG,QAAQuG,kBAAkBA;EAC1BvG,QAAQM,QAAQA;EAChBN,QAAQomC,WAAWA;EACnBpmC,QAAQ2xH,iBAAiBA;EACzB3xH,QAAQ1H,OAAOmY;EACfzQ,QAAQyQ,YAAYA;EACpBzQ,QAAQuZ,UAAUA;EAClBvZ,QAAQkwB,UAAUA;EAClBlwB,QAAQuC,cAAcA;EACtBvC,QAAQnG,OAAOA;EACfmG,QAAQopC,oBAAoBA;EAC5BppC,QAAQ+lE,oBAAoBA;EAC5B/lE,QAAQgmE,uBAAuBA;EAC/BhmE,QAAQilJ,mBAAmBA;EAC3BjlJ,QAAQimE,sBAAsBA;EAC9BjmE,QAAQqmE,qBAAqBA;EAC7BrmE,QAAQpC,qBAAqBA;EAC7BoC,QAAQtG,oBAAoBA;EAC5BsG,QAAQomE,uBAAuBA;EAC/BpmE,QAAQmmE,uBAAuBA;EAC/BnmE,QAAQkmE,mBAAmBA;EAC3BlmE,QAAQsC,cAAcA;EACtBtC,QAAQ6E,yBAAyBA;EACjC7E,QAAQ4D,eAAeA;EACvB5D,QAAQklJ,gBAAgBA;EACxBllJ,QAAQiC,mBAAmBA;EAC3BjC,QAAQ2D,oBAAoBA;EAC5B3D,QAAQ8E,gBAAgBA;EACxB9E,QAAQkF,4BAA4BA;EACpClF,QAAQgF,6BAA6BA;EACrChF,QAAQiF,4BAA4BA;EACpCjF,QAAQ+E,6BAA6BA;EACrC/E,QAAQmD,aAAaA;EACrBnD,QAAQ4L,mBAAmBA;EAC3B5L,QAAQ6B,aAAaA;EACrB7B,QAAQq7I,WAAWA;EACnBr7I,QAAQ8D,gBAAgBA;EACxB9D,QAAQmK,2BAA2BA;EACnCnK,QAAQ8B,iBAAiBA;EACzB9B,QAAQ0D,gBAAgBA;EACxB1D,QAAQiM,sBAAsBA;EAC9BjM,QAAQk+G,sBAAsBA;EAC9Bl+G,QAAQ82B,WAAWA;EACnB92B,QAAQmlJ,eAAeA;EACvBnlJ,QAAQmL,uBAAuBA;EAC/BnL,QAAQ+zG,2BAA2BD;EACnC9zG,QAAQ8zG,qBAAqBA;EAC7B9zG,QAAQyC,YAAYA;EACpBzC,QAAQ+C,yBAAyBA;EACjC/C,QAAQiD,yBAAyBA;EACjCjD,QAAQ6C,yBAAyBA;EACjC7C,QAAQ2C,yBAAyBA;EACjC3C,QAAQsuH,qBAAqBA;EAC7BtuH,QAAQqB,eAAeA;EACvBrB,QAAQsB,mBAAmBA;EAC3BtB,QAAQolJ,iBAAiBA;EACzBplJ,QAAQi0G,2BAA2BD;EACnCh0G,QAAQg0G,qBAAqBA;EAC7Bh0G,QAAQqlJ,WAAWA;EACnBrlJ,QAAQslJ,wBAAwBA;EAChCtlJ,QAAQulJ,iBAAiBA;EACzBvlJ,QAAQwlJ,yBAAyBA;EACjCxlJ,QAAQ4sH,OAAOA;EACf5sH,QAAQy3C,oBAAoBA;EAC5Bz3C,QAAQo9B,QAAQA;EAChBp9B,QAAQk0G,sBAAsB1oD;EAC9BxrD,QAAQwrD,gBAAgBA;EACxBxrD,QAAQylJ,cAAcA;EACtBzlJ,QAAQ0lJ,aAAaA;EACrB1lJ,QAAQ2lJ,qBAAqBA;EAC7B3lJ,QAAQmuH,aAAaA;EACrBnuH,QAAQ4lJ,mBAAmBA;EAC3B5lJ,QAAQ2/F,SAASA;EACjB3/F,QAAQwmE,iBAAiBA;EACzBxmE,QAAQ6lJ,kBAAkBA;EAC1B7lJ,QAAQm0G,2BAA2BnR;EACnChjG,QAAQgjG,qBAAqBA;EAC7BhjG,QAAQ8lJ,kBAAkBA;EAC1B9lJ,QAAQ0iI,kBAAkBA;EAC1B1iI,QAAQkuI,gBAAgBA;EACxBluI,QAAQoqH,uBAAuBA;EAC/BpqH,QAAQsqH,wBAAwBA;EAChCtqH,QAAQukB,aAAaA;EACrBvkB,QAAQo+G,0BAA0BA;EAClCp+G,QAAQm+G,8BAA8BA;EACtCn+G,QAAQK,WAAWA;EACnBL,QAAQiL,mBAAmBA;EAC3BjL,QAAQsG,aAAaA;EACrBtG,QAAQiH,oBAAoBA;EAC5BjH,QAAQwI,yBAAyBA;EACjCxI,QAAQqI,wBAAwBA;EAChCrI,QAAQsI,wBAAwBA;EAChCtI,QAAQuI,wBAAwBA;EAChCvI,QAAQyI,yBAAyBA;EACjCzI,QAAQ0I,yBAAyBA;EACjC1I,QAAQ6H,uBAAuBA;EAC/B7H,QAAQ8H,uBAAuBA;EAC/B9H,QAAQ+H,uBAAuBA;EAC/B/H,QAAQgI,uBAAuBA;EAC/BhI,QAAQiI,uBAAuBA;EAC/BjI,QAAQkI,uBAAuBA;EAC/BlI,QAAQmI,uBAAuBA;EAC/BnI,QAAQoI,uBAAuBA;EAC/BpI,QAAQ2I,mBAAmBA;EAC3B3I,QAAQ4H,uBAAuBA;EAC/B5H,QAAQyH,2BAA2BA;EACnCzH,QAAQwH,2BAA2BA;EACnCxH,QAAQmH,wBAAwBA;EAChCnH,QAAQoH,wBAAwBA;EAChCpH,QAAQqH,wBAAwBA;EAChCrH,QAAQ+K,eAAeA;EACvB/K,QAAQ2K,eAAeA;EACvB3K,QAAQyG,aAAaA;EACrBzG,QAAQqG,YAAYA;EACpBrG,QAAQgH,mBAAmBA;EAC3BhH,QAAQ8K,iBAAiBA;EACzB9K,QAAQ6K,gBAAgBA;EACxB7K,QAAQ0H,kBAAkBA;EAC1B1H,QAAQ2H,kBAAkBA;EAC1B3H,QAAQuH,0BAA0BA;EAClCvH,QAAQsH,0BAA0BA;EAClCtH,QAAQkH,uBAAuBA;EAC/BlH,QAAQ8G,WAAWA;EACnB9G,QAAQ+G,kBAAkBA;EAC1B/G,QAAQq1G,oBAAoBA;EAC5Br1G,QAAQ8wC,MAAMA;EACd9wC,QAAQ+lJ,YAAYA;EACpB/lJ,QAAQyuH,gBAAgBA;EACxBzuH,QAAQ4G,YAAYA;EACpB5G,QAAQ6G,mBAAmBA;EAC3B7G,QAAQgE,sBAAsBA;EAC9BhE,QAAQ2E,iBAAiBA;EACzB3E,QAAQsL,mBAAmBA;EAC3BtL,QAAQqC,0BAA0BA;EAClCrC,QAAQq0G,qBAAqBD;EAC7Bp0G,QAAQo0G,eAAeA;EACvBp0G,QAAQuJ,iCAAiCA;EACzCvJ,QAAQoJ,gCAAgCA;EACxCpJ,QAAQqJ,gCAAgCA;EACxCrJ,QAAQsJ,gCAAgCA;EACxCtJ,QAAQwJ,iCAAiCA;EACzCxJ,QAAQyJ,iCAAiCA;EACzCzJ,QAAQ4I,+BAA+BA;EACvC5I,QAAQ6I,+BAA+BA;EACvC7I,QAAQ8I,+BAA+BA;EACvC9I,QAAQ+I,+BAA+BA;EACvC/I,QAAQgJ,+BAA+BA;EACvChJ,QAAQiJ,+BAA+BA;EACvCjJ,QAAQkJ,+BAA+BA;EACvClJ,QAAQmJ,+BAA+BA;EACvCnJ,QAAQhB,QAAQA;EAChBgB,QAAQojJ,aAAaA;EACrBpjJ,QAAQylD,cAAcA;EACtBzlD,QAAQ6oD,YAAYA;EACpB7oD,QAAQ61C,iBAAiBA;EACzB71C,QAAQymE,iBAAiBA;EACzBzmE,QAAQsxH,QAAQA;EAChBtxH,QAAQu0G,sBAAsBD;EAC9Bt0G,QAAQs0G,gBAAgBA;EACxBt0G,QAAQw2H,YAAYA;EACpBx2H,QAAQkpG,aAAaA;EACrBlpG,QAAQ0F,YAAYA;EACpB1F,QAAQk9F,WAAWA;EACnBl9F,QAAQq8I,iBAAiBA;EACzBr8I,QAAQy8F,cAAcA;EACtBz8F,QAAQ4B,gBAAgBA;EACxB5B,QAAQutC,SAASA;EACjBvtC,QAAQy0G,uBAAuBD;EAC/Bx0G,QAAQw0G,iBAAiBA;EACzBx0G,QAAQgmJ,YAAYA;EACpBhmJ,QAAQivH,sBAAsBA;EAC9BjvH,QAAQyqH,cAAcA;EACtBzqH,QAAQ6tH,YAAYA;EACpB7tH,QAAQimJ,kBAAkBA;EAC1BjmJ,QAAQi7F,SAASA;EACjBj7F,QAAQ0mE,iBAAiBA;EACzB1mE,QAAQ4C,iBAAiBA;EACzB5C,QAAQkD,yBAAyBA;EACjClD,QAAQ0C,iBAAiBA;EACzB1C,QAAQ0M,kBAAkBA;EAC1B1M,QAAQoM,kBAAkBA;EAC1BpM,QAAQuM,kBAAkBA;EAC1BvM,QAAQkmJ,eAAeA;EACvBlmJ,QAAQ4M,kBAAkBA;EAC1B5M,QAAQsM,kBAAkBA;EAC1BtM,QAAQyM,kBAAkBA;EAC1BzM,QAAQq+G,sBAAsBA;EAC9Br+G,QAAQoC,mBAAmBA;EAC3BpC,QAAQgC,sBAAsBA;EAC9BhC,QAAQa,QAAQA;EAChBb,QAAQkL,wBAAwBA;EAChClL,QAAQ20G,4BAA4BD;EACpC10G,QAAQ00G,sBAAsBA;EAC9B10G,QAAQ60G,qBAAqBD;EAC7B50G,QAAQ40G,eAAeA;EACvB50G,QAAQwa,UAAUA;EAClBxa,QAAQ+iJ,gBAAgBA;EACxB/iJ,QAAQ+0G,sBAAsBD;EAC9B90G,QAAQ80G,gBAAgBA;EACxB90G,QAAQi1G,0BAA0BD;EAClCh1G,QAAQg1G,oBAAoBA;EAC5Bh1G,QAAQu/B,WAAWA;EACnBv/B,QAAQuK,sBAAsBA;EAC9BvK,QAAQsK,wBAAwBA;EAChCtK,QAAQqK,oBAAoBA;EAC5BrK,QAAQm1G,qBAAqBD;EAC7Bl1G,QAAQk1G,eAAeA;EACvBl1G,QAAQoE,YAAYA;EACpBpE,QAAQmmJ,kBAAkBA;EAC1BnmJ,QAAQ0sC,wBAAwBA;EAChC1sC,QAAQomJ,kBAAkBA;EAC1BpmJ,QAAQysC,wBAAwBA;EAChCzsC,QAAQqmJ,iBAAiBA;EACzBrmJ,QAAQ07I,uBAAuBA;EAC/B17I,QAAQsmJ,wBAAwBA;EAChCtmJ,QAAQ27I,8BAA8BA;EACtC37I,QAAQyxI,UAAUA;EAClBzxI,QAAQ0lD,cAAcA;EACtB1lD,QAAQ00C,gBAAgBA;EACxB10C,QAAQwF,mBAAmBA;EAC3BxF,QAAQmG,qBAAqBA;EAC7BnG,QAAQ6F,kBAAkBA;EAC1B7F,QAAQgG,wBAAwBA;EAChChG,QAAQiG,wBAAwBA;EAChCjG,QAAQkG,uBAAuBA;EAC/BlG,QAAQ2F,oBAAoBA;EAC5B3F,QAAQuB,eAAeA;EACvBvB,QAAQiV,UAAUA;EAClBjV,QAAQjH,UAAUA;EAClBiH,QAAQ2e,UAAUA;EAClB3e,QAAQs+G,sBAAsBA;EAC9Bt+G,QAAQumJ,SAASA;EACjBvmJ,QAAQu7I,eAAeA;EACvBv7I,QAAQsgG,eAAeA;EACvBtgG,QAAQu5F,iBAAiBA;EACzBv5F,QAAQo5C,wBAAwBA;EAChCp5C,QAAQ0f,6BAA6BA;EACrC1f,QAAQ6f,+BAA+BA;EACvC7f,QAAQuf,oBAAoBA;EAC5Bvf,QAAQwmJ,wBAAwBA;EAChCxmJ,QAAQs5F,gBAAgBA;EACxBt5F,QAAQqwF,aAAaA;EACrBrwF,QAAQo1G,oBAAoBA;EAC5Bp1G,QAAQymJ,kBAAkBA;EAC1BzmJ,QAAQkK,mBAAmBA;EAC3BlK,QAAQ0mJ,YAAYA;EACpB1mJ,QAAQgK,sBAAsBA;EAC9BhK,QAAQwC,aAAaA;EACrBxC,QAAQiK,kBAAkBA;EAC1BjK,QAAQoL,gBAAgBA;EACxBpL,QAAQyK,eAAeA;EAEvBiG,OAAOyK,eAAenb,SAAS;IAAgB5B,OAAO;;;;;;;qBC35mChC;kCACR;;MACTuoJ;AAES;EACbhuJ,YAAY4F;IACV,KAAKA,QAAQA;;IAGb,KAAKqoJ;;IAGL,KAAKC;;IAGL,KAAKC;;IAGLpzJ,OAAOwK,iBAAiB,UAAU,MAAM,KAAK6oJ;;;;;EAM/CH;IACE,KAAKznJ,sBAAqBm6F;MAAgBjR,WAAW;;IACrD,KAAKlpF,SAASmgB,QAAQ5rB,OAAOszJ,YAAYtzJ,OAAOuzJ;IAChD,KAAK5qF,YAAY7nE,SAASO,eAAe;IACzC,KAAKsnE,UAAU3nE,YAAY,KAAKyK,SAASwuF;;;EAI3Ck5D;IACE,KAAK7wG,MAAM;IACX,KAAKvhB,OAAO;IACZ,KAAKC,MAAM;IAEX,KAAKlP,oBAAmBiyB,kBAAkB,KAAKzB,KAAKtiD,OAAOszJ,aAAatzJ,OAAOuzJ,aAAa,KAAKxyH,MAAM,KAAKC;;;EAI9GoyH;IACE,KAAKI,eAAeP,cAAc,KAAKnhI,QAAQ,KAAKrmB,SAASwuF;IAE7D,KAAKu5D,SAASC,aAAa;IAC3B,KAAKD,SAASE,gBAAgB;IAC9B,KAAKF,SAASG,gBAAgB;IAC9B,KAAK7hI,OAAOtrB,SAASK,IAAI;IAEzB,KAAK2sJ,SAAShlI;;;;;EAMhB6kI;IACE,KAAKvhI,OAAOywB,SAAS,KAAKomB,UAAUirF,cAAc,KAAKjrF,UAAUkrF;IACjE,KAAK/hI,OAAO+wB;IAEZ,KAAKp3C,SAASmgB,QAAQ,KAAK+8C,UAAUirF,aAAa,KAAKjrF,UAAUkrF;IACjE,KAAKpoJ,SAAS6yF,cAAct+F,OAAO8zJ;;;;;EAMrChtJ;IACE,KAAK0sJ,SAAShlI;IACd,KAAK/iB,SAASq5C,OAAO,KAAKj6C,OAAO,KAAKinB;;;;;;ACpE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["./node_modules/@parcel/runtime-browser-hmr/lib/HMRRuntime.js","./src/app.js","./src/setup/index.js","./src/setup/Scene.js","../node_modules/three/build/three.js","./src/setup/CameraController.js","../node_modules/three-orbit-controls/index.js","./node_modules/@parcel/transformer-js/lib/esmodule-helpers.js","./node_modules/uuid/index.js","./node_modules/uuid/v1.js","./node_modules/uuid/lib/rng-browser.js","./node_modules/uuid/lib/bytesToUuid.js","./node_modules/uuid/v4.js"],"sourcesContent":[null,null,null,null,"/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));\n}(this, (function (exports) { 'use strict';\n\n\tconst REVISION = '129';\n\tconst MOUSE = {\n\t\tLEFT: 0,\n\t\tMIDDLE: 1,\n\t\tRIGHT: 2,\n\t\tROTATE: 0,\n\t\tDOLLY: 1,\n\t\tPAN: 2\n\t};\n\tconst TOUCH = {\n\t\tROTATE: 0,\n\t\tPAN: 1,\n\t\tDOLLY_PAN: 2,\n\t\tDOLLY_ROTATE: 3\n\t};\n\tconst CullFaceNone = 0;\n\tconst CullFaceBack = 1;\n\tconst CullFaceFront = 2;\n\tconst CullFaceFrontBack = 3;\n\tconst BasicShadowMap = 0;\n\tconst PCFShadowMap = 1;\n\tconst PCFSoftShadowMap = 2;\n\tconst VSMShadowMap = 3;\n\tconst FrontSide = 0;\n\tconst BackSide = 1;\n\tconst DoubleSide = 2;\n\tconst FlatShading = 1;\n\tconst SmoothShading = 2;\n\tconst NoBlending = 0;\n\tconst NormalBlending = 1;\n\tconst AdditiveBlending = 2;\n\tconst SubtractiveBlending = 3;\n\tconst MultiplyBlending = 4;\n\tconst CustomBlending = 5;\n\tconst AddEquation = 100;\n\tconst SubtractEquation = 101;\n\tconst ReverseSubtractEquation = 102;\n\tconst MinEquation = 103;\n\tconst MaxEquation = 104;\n\tconst ZeroFactor = 200;\n\tconst OneFactor = 201;\n\tconst SrcColorFactor = 202;\n\tconst OneMinusSrcColorFactor = 203;\n\tconst SrcAlphaFactor = 204;\n\tconst OneMinusSrcAlphaFactor = 205;\n\tconst DstAlphaFactor = 206;\n\tconst OneMinusDstAlphaFactor = 207;\n\tconst DstColorFactor = 208;\n\tconst OneMinusDstColorFactor = 209;\n\tconst SrcAlphaSaturateFactor = 210;\n\tconst NeverDepth = 0;\n\tconst AlwaysDepth = 1;\n\tconst LessDepth = 2;\n\tconst LessEqualDepth = 3;\n\tconst EqualDepth = 4;\n\tconst GreaterEqualDepth = 5;\n\tconst GreaterDepth = 6;\n\tconst NotEqualDepth = 7;\n\tconst MultiplyOperation = 0;\n\tconst MixOperation = 1;\n\tconst AddOperation = 2;\n\tconst NoToneMapping = 0;\n\tconst LinearToneMapping = 1;\n\tconst ReinhardToneMapping = 2;\n\tconst CineonToneMapping = 3;\n\tconst ACESFilmicToneMapping = 4;\n\tconst CustomToneMapping = 5;\n\tconst UVMapping = 300;\n\tconst CubeReflectionMapping = 301;\n\tconst CubeRefractionMapping = 302;\n\tconst EquirectangularReflectionMapping = 303;\n\tconst EquirectangularRefractionMapping = 304;\n\tconst CubeUVReflectionMapping = 306;\n\tconst CubeUVRefractionMapping = 307;\n\tconst RepeatWrapping = 1000;\n\tconst ClampToEdgeWrapping = 1001;\n\tconst MirroredRepeatWrapping = 1002;\n\tconst NearestFilter = 1003;\n\tconst NearestMipmapNearestFilter = 1004;\n\tconst NearestMipMapNearestFilter = 1004;\n\tconst NearestMipmapLinearFilter = 1005;\n\tconst NearestMipMapLinearFilter = 1005;\n\tconst LinearFilter = 1006;\n\tconst LinearMipmapNearestFilter = 1007;\n\tconst LinearMipMapNearestFilter = 1007;\n\tconst LinearMipmapLinearFilter = 1008;\n\tconst LinearMipMapLinearFilter = 1008;\n\tconst UnsignedByteType = 1009;\n\tconst ByteType = 1010;\n\tconst ShortType = 1011;\n\tconst UnsignedShortType = 1012;\n\tconst IntType = 1013;\n\tconst UnsignedIntType = 1014;\n\tconst FloatType = 1015;\n\tconst HalfFloatType = 1016;\n\tconst UnsignedShort4444Type = 1017;\n\tconst UnsignedShort5551Type = 1018;\n\tconst UnsignedShort565Type = 1019;\n\tconst UnsignedInt248Type = 1020;\n\tconst AlphaFormat = 1021;\n\tconst RGBFormat = 1022;\n\tconst RGBAFormat = 1023;\n\tconst LuminanceFormat = 1024;\n\tconst LuminanceAlphaFormat = 1025;\n\tconst RGBEFormat = RGBAFormat;\n\tconst DepthFormat = 1026;\n\tconst DepthStencilFormat = 1027;\n\tconst RedFormat = 1028;\n\tconst RedIntegerFormat = 1029;\n\tconst RGFormat = 1030;\n\tconst RGIntegerFormat = 1031;\n\tconst RGBIntegerFormat = 1032;\n\tconst RGBAIntegerFormat = 1033;\n\tconst RGB_S3TC_DXT1_Format = 33776;\n\tconst RGBA_S3TC_DXT1_Format = 33777;\n\tconst RGBA_S3TC_DXT3_Format = 33778;\n\tconst RGBA_S3TC_DXT5_Format = 33779;\n\tconst RGB_PVRTC_4BPPV1_Format = 35840;\n\tconst RGB_PVRTC_2BPPV1_Format = 35841;\n\tconst RGBA_PVRTC_4BPPV1_Format = 35842;\n\tconst RGBA_PVRTC_2BPPV1_Format = 35843;\n\tconst RGB_ETC1_Format = 36196;\n\tconst RGB_ETC2_Format = 37492;\n\tconst RGBA_ETC2_EAC_Format = 37496;\n\tconst RGBA_ASTC_4x4_Format = 37808;\n\tconst RGBA_ASTC_5x4_Format = 37809;\n\tconst RGBA_ASTC_5x5_Format = 37810;\n\tconst RGBA_ASTC_6x5_Format = 37811;\n\tconst RGBA_ASTC_6x6_Format = 37812;\n\tconst RGBA_ASTC_8x5_Format = 37813;\n\tconst RGBA_ASTC_8x6_Format = 37814;\n\tconst RGBA_ASTC_8x8_Format = 37815;\n\tconst RGBA_ASTC_10x5_Format = 37816;\n\tconst RGBA_ASTC_10x6_Format = 37817;\n\tconst RGBA_ASTC_10x8_Format = 37818;\n\tconst RGBA_ASTC_10x10_Format = 37819;\n\tconst RGBA_ASTC_12x10_Format = 37820;\n\tconst RGBA_ASTC_12x12_Format = 37821;\n\tconst RGBA_BPTC_Format = 36492;\n\tconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\n\tconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\n\tconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\n\tconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\n\tconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\n\tconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\n\tconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\n\tconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\n\tconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\n\tconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\n\tconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\n\tconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\n\tconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\n\tconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\n\tconst LoopOnce = 2200;\n\tconst LoopRepeat = 2201;\n\tconst LoopPingPong = 2202;\n\tconst InterpolateDiscrete = 2300;\n\tconst InterpolateLinear = 2301;\n\tconst InterpolateSmooth = 2302;\n\tconst ZeroCurvatureEnding = 2400;\n\tconst ZeroSlopeEnding = 2401;\n\tconst WrapAroundEnding = 2402;\n\tconst NormalAnimationBlendMode = 2500;\n\tconst AdditiveAnimationBlendMode = 2501;\n\tconst TrianglesDrawMode = 0;\n\tconst TriangleStripDrawMode = 1;\n\tconst TriangleFanDrawMode = 2;\n\tconst LinearEncoding = 3000;\n\tconst sRGBEncoding = 3001;\n\tconst GammaEncoding = 3007;\n\tconst RGBEEncoding = 3002;\n\tconst LogLuvEncoding = 3003;\n\tconst RGBM7Encoding = 3004;\n\tconst RGBM16Encoding = 3005;\n\tconst RGBDEncoding = 3006;\n\tconst BasicDepthPacking = 3200;\n\tconst RGBADepthPacking = 3201;\n\tconst TangentSpaceNormalMap = 0;\n\tconst ObjectSpaceNormalMap = 1;\n\tconst ZeroStencilOp = 0;\n\tconst KeepStencilOp = 7680;\n\tconst ReplaceStencilOp = 7681;\n\tconst IncrementStencilOp = 7682;\n\tconst DecrementStencilOp = 7683;\n\tconst IncrementWrapStencilOp = 34055;\n\tconst DecrementWrapStencilOp = 34056;\n\tconst InvertStencilOp = 5386;\n\tconst NeverStencilFunc = 512;\n\tconst LessStencilFunc = 513;\n\tconst EqualStencilFunc = 514;\n\tconst LessEqualStencilFunc = 515;\n\tconst GreaterStencilFunc = 516;\n\tconst NotEqualStencilFunc = 517;\n\tconst GreaterEqualStencilFunc = 518;\n\tconst AlwaysStencilFunc = 519;\n\tconst StaticDrawUsage = 35044;\n\tconst DynamicDrawUsage = 35048;\n\tconst StreamDrawUsage = 35040;\n\tconst StaticReadUsage = 35045;\n\tconst DynamicReadUsage = 35049;\n\tconst StreamReadUsage = 35041;\n\tconst StaticCopyUsage = 35046;\n\tconst DynamicCopyUsage = 35050;\n\tconst StreamCopyUsage = 35042;\n\tconst GLSL1 = '100';\n\tconst GLSL3 = '300 es';\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\tclass EventDispatcher {\n\t\taddEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) this._listeners = {};\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif (listeners[type] === undefined) {\n\t\t\t\tlisteners[type] = [];\n\t\t\t}\n\n\t\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\t\tlisteners[type].push(listener);\n\t\t\t}\n\t\t}\n\n\t\thasEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) return false;\n\t\t\tconst listeners = this._listeners;\n\t\t\treturn listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n\t\t}\n\n\t\tremoveEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) return;\n\t\t\tconst listeners = this._listeners;\n\t\t\tconst listenerArray = listeners[type];\n\n\t\t\tif (listenerArray !== undefined) {\n\t\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdispatchEvent(event) {\n\t\t\tif (this._listeners === undefined) return;\n\t\t\tconst listeners = this._listeners;\n\t\t\tconst listenerArray = listeners[event.type];\n\n\t\t\tif (listenerArray !== undefined) {\n\t\t\t\tevent.target = this; // Make a copy, in case listeners are removed while iterating.\n\n\t\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\tarray[i].call(this, event);\n\t\t\t\t}\n\n\t\t\t\tevent.target = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst _lut = [];\n\n\tfor (let i = 0; i < 256; i++) {\n\t\t_lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n\t}\n\n\tlet _seed = 1234567;\n\tconst DEG2RAD = Math.PI / 180;\n\tconst RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\tfunction generateUUID() {\n\t\tconst d0 = Math.random() * 0xffffffff | 0;\n\t\tconst d1 = Math.random() * 0xffffffff | 0;\n\t\tconst d2 = Math.random() * 0xffffffff | 0;\n\t\tconst d3 = Math.random() * 0xffffffff | 0;\n\t\tconst uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n\t\treturn uuid.toUpperCase();\n\t}\n\n\tfunction clamp(value, min, max) {\n\t\treturn Math.max(min, Math.min(max, value));\n\t} // compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\n\tfunction euclideanModulo(n, m) {\n\t\treturn (n % m + m) % m;\n\t} // Linear mapping from range <a1, a2> to range <b1, b2>\n\n\n\tfunction mapLinear(x, a1, a2, b1, b2) {\n\t\treturn b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n\t} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\n\tfunction inverseLerp(x, y, value) {\n\t\tif (x !== y) {\n\t\t\treturn (value - x) / (y - x);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} // https://en.wikipedia.org/wiki/Linear_interpolation\n\n\n\tfunction lerp(x, y, t) {\n\t\treturn (1 - t) * x + t * y;\n\t} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n\n\n\tfunction damp(x, y, lambda, dt) {\n\t\treturn lerp(x, y, 1 - Math.exp(-lambda * dt));\n\t} // https://www.desmos.com/calculator/vcsjnyz7x4\n\n\n\tfunction pingpong(x, length = 1) {\n\t\treturn length - Math.abs(euclideanModulo(x, length * 2) - length);\n\t} // http://en.wikipedia.org/wiki/Smoothstep\n\n\n\tfunction smoothstep(x, min, max) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * (3 - 2 * x);\n\t}\n\n\tfunction smootherstep(x, min, max) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t} // Random integer from <low, high> interval\n\n\n\tfunction randInt(low, high) {\n\t\treturn low + Math.floor(Math.random() * (high - low + 1));\n\t} // Random float from <low, high> interval\n\n\n\tfunction randFloat(low, high) {\n\t\treturn low + Math.random() * (high - low);\n\t} // Random float from <-range/2, range/2> interval\n\n\n\tfunction randFloatSpread(range) {\n\t\treturn range * (0.5 - Math.random());\n\t} // Deterministic pseudo-random float in the interval [ 0, 1 ]\n\n\n\tfunction seededRandom(s) {\n\t\tif (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm\n\n\t\t_seed = _seed * 16807 % 2147483647;\n\t\treturn (_seed - 1) / 2147483646;\n\t}\n\n\tfunction degToRad(degrees) {\n\t\treturn degrees * DEG2RAD;\n\t}\n\n\tfunction radToDeg(radians) {\n\t\treturn radians * RAD2DEG;\n\t}\n\n\tfunction isPowerOfTwo(value) {\n\t\treturn (value & value - 1) === 0 && value !== 0;\n\t}\n\n\tfunction ceilPowerOfTwo(value) {\n\t\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n\t}\n\n\tfunction floorPowerOfTwo(value) {\n\t\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n\t}\n\n\tfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n\t\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\t\t// rotations are applied to the axes in the order specified by 'order'\n\t\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t\t// angles are in radians\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\t\tconst c2 = cos(b / 2);\n\t\tconst s2 = sin(b / 2);\n\t\tconst c13 = cos((a + c) / 2);\n\t\tconst s13 = sin((a + c) / 2);\n\t\tconst c1_3 = cos((a - c) / 2);\n\t\tconst s1_3 = sin((a - c) / 2);\n\t\tconst c3_1 = cos((c - a) / 2);\n\t\tconst s3_1 = sin((c - a) / 2);\n\n\t\tswitch (order) {\n\t\t\tcase 'XYX':\n\t\t\t\tq.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZY':\n\t\t\t\tq.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXZ':\n\t\t\t\tq.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZX':\n\t\t\t\tq.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXY':\n\t\t\t\tq.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYZ':\n\t\t\t\tq.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);\n\t\t}\n\t}\n\n\tvar MathUtils = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tDEG2RAD: DEG2RAD,\n\t\tRAD2DEG: RAD2DEG,\n\t\tgenerateUUID: generateUUID,\n\t\tclamp: clamp,\n\t\teuclideanModulo: euclideanModulo,\n\t\tmapLinear: mapLinear,\n\t\tinverseLerp: inverseLerp,\n\t\tlerp: lerp,\n\t\tdamp: damp,\n\t\tpingpong: pingpong,\n\t\tsmoothstep: smoothstep,\n\t\tsmootherstep: smootherstep,\n\t\trandInt: randInt,\n\t\trandFloat: randFloat,\n\t\trandFloatSpread: randFloatSpread,\n\t\tseededRandom: seededRandom,\n\t\tdegToRad: degToRad,\n\t\tradToDeg: radToDeg,\n\t\tisPowerOfTwo: isPowerOfTwo,\n\t\tceilPowerOfTwo: ceilPowerOfTwo,\n\t\tfloorPowerOfTwo: floorPowerOfTwo,\n\t\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler\n\t});\n\n\tclass Vector2 {\n\t\tconstructor(x = 0, y = 0) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tset width(value) {\n\t\t\tthis.x = value;\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tset height(value) {\n\t\t\tthis.y = value;\n\t\t}\n\n\t\tset(x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v) {\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivide(v) {\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6];\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7];\n\t\t\treturn this;\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y;\n\t\t}\n\n\t\tcross(v) {\n\t\t\treturn this.x * v.y - this.y * v.x;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tangle() {\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\t\tconst angle = Math.atan2(-this.y, -this.x) + Math.PI;\n\t\t\treturn angle;\n\t\t}\n\n\t\tdistanceTo(v) {\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t}\n\n\t\tdistanceToSquared(v) {\n\t\t\tconst dx = this.x - v.x,\n\t\t\t\t\t\tdy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\n\t\tmanhattanDistanceTo(v) {\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateAround(center, angle) {\n\t\t\tconst c = Math.cos(angle),\n\t\t\t\t\t\ts = Math.sin(angle);\n\t\t\tconst x = this.x - center.x;\n\t\t\tconst y = this.y - center.y;\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector2.prototype.isVector2 = true;\n\n\tclass Matrix3 {\n\t\tconstructor() {\n\t\t\tthis.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconsole.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t}\n\t\t}\n\n\t\tset(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] = n11;\n\t\t\tte[1] = n21;\n\t\t\tte[2] = n31;\n\t\t\tte[3] = n12;\n\t\t\tte[4] = n22;\n\t\t\tte[5] = n32;\n\t\t\tte[6] = n13;\n\t\t\tte[7] = n23;\n\t\t\tte[8] = n33;\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(m) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\t\t\tte[0] = me[0];\n\t\t\tte[1] = me[1];\n\t\t\tte[2] = me[2];\n\t\t\tte[3] = me[3];\n\t\t\tte[4] = me[4];\n\t\t\tte[5] = me[5];\n\t\t\tte[6] = me[6];\n\t\t\tte[7] = me[7];\n\t\t\tte[8] = me[8];\n\t\t\treturn this;\n\t\t}\n\n\t\textractBasis(xAxis, yAxis, zAxis) {\n\t\t\txAxis.setFromMatrix3Column(this, 0);\n\t\t\tyAxis.setFromMatrix3Column(this, 1);\n\t\t\tzAxis.setFromMatrix3Column(this, 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrix4(m) {\n\t\t\tconst me = m.elements;\n\t\t\tthis.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(m) {\n\t\t\treturn this.multiplyMatrices(this, m);\n\t\t}\n\n\t\tpremultiply(m) {\n\t\t\treturn this.multiplyMatrices(m, this);\n\t\t}\n\n\t\tmultiplyMatrices(a, b) {\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = ae[0],\n\t\t\t\t\t\ta12 = ae[3],\n\t\t\t\t\t\ta13 = ae[6];\n\t\t\tconst a21 = ae[1],\n\t\t\t\t\t\ta22 = ae[4],\n\t\t\t\t\t\ta23 = ae[7];\n\t\t\tconst a31 = ae[2],\n\t\t\t\t\t\ta32 = ae[5],\n\t\t\t\t\t\ta33 = ae[8];\n\t\t\tconst b11 = be[0],\n\t\t\t\t\t\tb12 = be[3],\n\t\t\t\t\t\tb13 = be[6];\n\t\t\tconst b21 = be[1],\n\t\t\t\t\t\tb22 = be[4],\n\t\t\t\t\t\tb23 = be[7];\n\t\t\tconst b31 = be[2],\n\t\t\t\t\t\tb32 = be[5],\n\t\t\t\t\t\tb33 = be[8];\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= s;\n\t\t\tte[3] *= s;\n\t\t\tte[6] *= s;\n\t\t\tte[1] *= s;\n\t\t\tte[4] *= s;\n\t\t\tte[7] *= s;\n\t\t\tte[2] *= s;\n\t\t\tte[5] *= s;\n\t\t\tte[8] *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeterminant() {\n\t\t\tconst te = this.elements;\n\t\t\tconst a = te[0],\n\t\t\t\t\t\tb = te[1],\n\t\t\t\t\t\tc = te[2],\n\t\t\t\t\t\td = te[3],\n\t\t\t\t\t\te = te[4],\n\t\t\t\t\t\tf = te[5],\n\t\t\t\t\t\tg = te[6],\n\t\t\t\t\t\th = te[7],\n\t\t\t\t\t\ti = te[8];\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\t}\n\n\t\tinvert() {\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tn11 = te[0],\n\t\t\t\t\t\tn21 = te[1],\n\t\t\t\t\t\tn31 = te[2],\n\t\t\t\t\t\tn12 = te[3],\n\t\t\t\t\t\tn22 = te[4],\n\t\t\t\t\t\tn32 = te[5],\n\t\t\t\t\t\tn13 = te[6],\n\t\t\t\t\t\tn23 = te[7],\n\t\t\t\t\t\tn33 = te[8],\n\t\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\t\tif (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t\t\tconst detInv = 1 / det;\n\t\t\tte[0] = t11 * detInv;\n\t\t\tte[1] = (n31 * n23 - n33 * n21) * detInv;\n\t\t\tte[2] = (n32 * n21 - n31 * n22) * detInv;\n\t\t\tte[3] = t12 * detInv;\n\t\t\tte[4] = (n33 * n11 - n31 * n13) * detInv;\n\t\t\tte[5] = (n31 * n12 - n32 * n11) * detInv;\n\t\t\tte[6] = t13 * detInv;\n\t\t\tte[7] = (n21 * n13 - n23 * n11) * detInv;\n\t\t\tte[8] = (n22 * n11 - n21 * n12) * detInv;\n\t\t\treturn this;\n\t\t}\n\n\t\ttranspose() {\n\t\t\tlet tmp;\n\t\t\tconst m = this.elements;\n\t\t\ttmp = m[1];\n\t\t\tm[1] = m[3];\n\t\t\tm[3] = tmp;\n\t\t\ttmp = m[2];\n\t\t\tm[2] = m[6];\n\t\t\tm[6] = tmp;\n\t\t\ttmp = m[5];\n\t\t\tm[5] = m[7];\n\t\t\tm[7] = tmp;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetNormalMatrix(matrix4) {\n\t\t\treturn this.setFromMatrix4(matrix4).invert().transpose();\n\t\t}\n\n\t\ttransposeIntoArray(r) {\n\t\t\tconst m = this.elements;\n\t\t\tr[0] = m[0];\n\t\t\tr[1] = m[3];\n\t\t\tr[2] = m[6];\n\t\t\tr[3] = m[1];\n\t\t\tr[4] = m[4];\n\t\t\tr[5] = m[7];\n\t\t\tr[6] = m[2];\n\t\t\tr[7] = m[5];\n\t\t\tr[8] = m[8];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n\t\t\tconst c = Math.cos(rotation);\n\t\t\tconst s = Math.sin(rotation);\n\t\t\tthis.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(sx, sy) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= sx;\n\t\t\tte[3] *= sx;\n\t\t\tte[6] *= sx;\n\t\t\tte[1] *= sy;\n\t\t\tte[4] *= sy;\n\t\t\tte[7] *= sy;\n\t\t\treturn this;\n\t\t}\n\n\t\trotate(theta) {\n\t\t\tconst c = Math.cos(theta);\n\t\t\tconst s = Math.sin(theta);\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = te[0],\n\t\t\t\t\t\ta12 = te[3],\n\t\t\t\t\t\ta13 = te[6];\n\t\t\tconst a21 = te[1],\n\t\t\t\t\t\ta22 = te[4],\n\t\t\t\t\t\ta23 = te[7];\n\t\t\tte[0] = c * a11 + s * a21;\n\t\t\tte[3] = c * a12 + s * a22;\n\t\t\tte[6] = c * a13 + s * a23;\n\t\t\tte[1] = -s * a11 + c * a21;\n\t\t\tte[4] = -s * a12 + c * a22;\n\t\t\tte[7] = -s * a13 + c * a23;\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(tx, ty) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] += tx * te[2];\n\t\t\tte[3] += tx * te[5];\n\t\t\tte[6] += tx * te[8];\n\t\t\tte[1] += ty * te[2];\n\t\t\tte[4] += ty * te[5];\n\t\t\tte[7] += ty * te[8];\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(matrix) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst te = this.elements;\n\t\t\tarray[offset] = te[0];\n\t\t\tarray[offset + 1] = te[1];\n\t\t\tarray[offset + 2] = te[2];\n\t\t\tarray[offset + 3] = te[3];\n\t\t\tarray[offset + 4] = te[4];\n\t\t\tarray[offset + 5] = te[5];\n\t\t\tarray[offset + 6] = te[6];\n\t\t\tarray[offset + 7] = te[7];\n\t\t\tarray[offset + 8] = te[8];\n\t\t\treturn array;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().fromArray(this.elements);\n\t\t}\n\n\t}\n\n\tMatrix3.prototype.isMatrix3 = true;\n\n\tlet _canvas;\n\n\tclass ImageUtils {\n\t\tstatic getDataURL(image) {\n\t\t\tif (/^data:/i.test(image.src)) {\n\t\t\t\treturn image.src;\n\t\t\t}\n\n\t\t\tif (typeof HTMLCanvasElement == 'undefined') {\n\t\t\t\treturn image.src;\n\t\t\t}\n\n\t\t\tlet canvas;\n\n\t\t\tif (image instanceof HTMLCanvasElement) {\n\t\t\t\tcanvas = image;\n\t\t\t} else {\n\t\t\t\tif (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\t\t\t_canvas.width = image.width;\n\t\t\t\t_canvas.height = image.height;\n\n\t\t\t\tconst context = _canvas.getContext('2d');\n\n\t\t\t\tif (image instanceof ImageData) {\n\t\t\t\t\tcontext.putImageData(image, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.drawImage(image, 0, 0, image.width, image.height);\n\t\t\t\t}\n\n\t\t\t\tcanvas = _canvas;\n\t\t\t}\n\n\t\t\tif (canvas.width > 2048 || canvas.height > 2048) {\n\t\t\t\tconsole.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);\n\t\t\t\treturn canvas.toDataURL('image/jpeg', 0.6);\n\t\t\t} else {\n\t\t\t\treturn canvas.toDataURL('image/png');\n\t\t\t}\n\t\t}\n\n\t}\n\n\tlet textureId = 0;\n\n\tclass Texture extends EventDispatcher {\n\t\tconstructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: textureId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.image = image;\n\t\t\tthis.mipmaps = [];\n\t\t\tthis.mapping = mapping;\n\t\t\tthis.wrapS = wrapS;\n\t\t\tthis.wrapT = wrapT;\n\t\t\tthis.magFilter = magFilter;\n\t\t\tthis.minFilter = minFilter;\n\t\t\tthis.anisotropy = anisotropy;\n\t\t\tthis.format = format;\n\t\t\tthis.internalFormat = null;\n\t\t\tthis.type = type;\n\t\t\tthis.offset = new Vector2(0, 0);\n\t\t\tthis.repeat = new Vector2(1, 1);\n\t\t\tthis.center = new Vector2(0, 0);\n\t\t\tthis.rotation = 0;\n\t\t\tthis.matrixAutoUpdate = true;\n\t\t\tthis.matrix = new Matrix3();\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n\t\t\tthis.encoding = encoding;\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\t}\n\n\t\tupdateMatrix() {\n\t\t\tthis.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice(0);\n\t\t\tthis.mapping = source.mapping;\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\t\t\tthis.anisotropy = source.anisotropy;\n\t\t\tthis.format = source.format;\n\t\t\tthis.internalFormat = source.internalFormat;\n\t\t\tthis.type = source.type;\n\t\t\tthis.offset.copy(source.offset);\n\t\t\tthis.repeat.copy(source.repeat);\n\t\t\tthis.center.copy(source.center);\n\t\t\tthis.rotation = source.rotation;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrix.copy(source.matrix);\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst isRootObject = meta === undefined || typeof meta === 'string';\n\n\t\t\tif (!isRootObject && meta.textures[this.uuid] !== undefined) {\n\t\t\t\treturn meta.textures[this.uuid];\n\t\t\t}\n\n\t\t\tconst output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\t\t\t\tmapping: this.mapping,\n\t\t\t\trepeat: [this.repeat.x, this.repeat.y],\n\t\t\t\toffset: [this.offset.x, this.offset.y],\n\t\t\t\tcenter: [this.center.x, this.center.y],\n\t\t\t\trotation: this.rotation,\n\t\t\t\twrap: [this.wrapS, this.wrapT],\n\t\t\t\tformat: this.format,\n\t\t\t\ttype: this.type,\n\t\t\t\tencoding: this.encoding,\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\t\t\t\tflipY: this.flipY,\n\t\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\t\tunpackAlignment: this.unpackAlignment\n\t\t\t};\n\n\t\t\tif (this.image !== undefined) {\n\t\t\t\t// TODO: Move to THREE.Image\n\t\t\t\tconst image = this.image;\n\n\t\t\t\tif (image.uuid === undefined) {\n\t\t\t\t\timage.uuid = generateUUID(); // UGH\n\t\t\t\t}\n\n\t\t\t\tif (!isRootObject && meta.images[image.uuid] === undefined) {\n\t\t\t\t\tlet url;\n\n\t\t\t\t\tif (Array.isArray(image)) {\n\t\t\t\t\t\t// process array of images e.g. CubeTexture\n\t\t\t\t\t\turl = [];\n\n\t\t\t\t\t\tfor (let i = 0, l = image.length; i < l; i++) {\n\t\t\t\t\t\t\t// check cube texture with data textures\n\t\t\t\t\t\t\tif (image[i].isDataTexture) {\n\t\t\t\t\t\t\t\turl.push(serializeImage(image[i].image));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turl.push(serializeImage(image[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// process single image\n\t\t\t\t\t\turl = serializeImage(image);\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.images[image.uuid] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: url\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\t\t\t}\n\n\t\t\tif (!isRootObject) {\n\t\t\t\tmeta.textures[this.uuid] = output;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t\ttransformUv(uv) {\n\t\t\tif (this.mapping !== UVMapping) return uv;\n\t\t\tuv.applyMatrix3(this.matrix);\n\n\t\t\tif (uv.x < 0 || uv.x > 1) {\n\t\t\t\tswitch (this.wrapS) {\n\t\t\t\t\tcase RepeatWrapping:\n\t\t\t\t\t\tuv.x = uv.x - Math.floor(uv.x);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\t\t\t\t\tif (Math.abs(Math.floor(uv.x) % 2) === 1) {\n\t\t\t\t\t\t\tuv.x = Math.ceil(uv.x) - uv.x;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor(uv.x);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (uv.y < 0 || uv.y > 1) {\n\t\t\t\tswitch (this.wrapT) {\n\t\t\t\t\tcase RepeatWrapping:\n\t\t\t\t\t\tuv.y = uv.y - Math.floor(uv.y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\t\t\t\t\tif (Math.abs(Math.floor(uv.y) % 2) === 1) {\n\t\t\t\t\t\t\tuv.y = Math.ceil(uv.y) - uv.y;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor(uv.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.flipY) {\n\t\t\t\tuv.y = 1 - uv.y;\n\t\t\t}\n\n\t\t\treturn uv;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\tTexture.prototype.isTexture = true;\n\n\tfunction serializeImage(image) {\n\t\tif (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n\t\t\t// default images\n\t\t\treturn ImageUtils.getDataURL(image);\n\t\t} else {\n\t\t\tif (image.data) {\n\t\t\t\t// images of DataTexture\n\t\t\t\treturn {\n\t\t\t\t\tdata: Array.prototype.slice.call(image.data),\n\t\t\t\t\twidth: image.width,\n\t\t\t\t\theight: image.height,\n\t\t\t\t\ttype: image.data.constructor.name\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.Texture: Unable to serialize Texture.');\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Vector4 {\n\t\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.z;\n\t\t}\n\n\t\tset width(value) {\n\t\t\tthis.z = value;\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.w;\n\t\t}\n\n\t\tset height(value) {\n\t\t\tthis.w = value;\n\t\t}\n\n\t\tset(x, y, z, w) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(z) {\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetW(w) {\n\t\t\tthis.w = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.z = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.w = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tcase 2:\n\t\t\t\t\treturn this.z;\n\n\t\t\t\tcase 3:\n\t\t\t\t\treturn this.w;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = v.w !== undefined ? v.w : 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v) {\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\t\tthis.w *= v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z,\n\t\t\t\t\t\tw = this.w;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tsetAxisAngleFromQuaternion(q) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\t\t// q is assumed to be normalized\n\t\t\tthis.w = 2 * Math.acos(q.w);\n\t\t\tconst s = Math.sqrt(1 - q.w * q.w);\n\n\t\t\tif (s < 0.0001) {\n\t\t\t\tthis.x = 1;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t} else {\n\t\t\t\tthis.x = q.x / s;\n\t\t\t\tthis.y = q.y / s;\n\t\t\t\tthis.z = q.z / s;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetAxisAngleFromRotationMatrix(m) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tlet angle, x, y, z; // variables for result\n\n\t\t\tconst epsilon = 0.01,\n\t\t\t\t\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\n\t\t\t\t\t\t// margin to distinguish between 0 and 180 degrees\n\t\t\tte = m.elements,\n\t\t\t\t\t\tm11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8],\n\t\t\t\t\t\tm21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9],\n\t\t\t\t\t\tm31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10];\n\n\t\t\tif (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\t\t\t\tif (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\t\t\t\tthis.set(1, 0, 0, 0);\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\t\t\t} // otherwise this singularity is angle = 180\n\n\n\t\t\t\tangle = Math.PI;\n\t\t\t\tconst xx = (m11 + 1) / 2;\n\t\t\t\tconst yy = (m22 + 1) / 2;\n\t\t\t\tconst zz = (m33 + 1) / 2;\n\t\t\t\tconst xy = (m12 + m21) / 4;\n\t\t\t\tconst xz = (m13 + m31) / 4;\n\t\t\t\tconst yz = (m23 + m32) / 4;\n\n\t\t\t\tif (xx > yy && xx > zz) {\n\t\t\t\t\t// m11 is the largest diagonal term\n\t\t\t\t\tif (xx < epsilon) {\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = Math.sqrt(xx);\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\t\t\t\t\t}\n\t\t\t\t} else if (yy > zz) {\n\t\t\t\t\t// m22 is the largest diagonal term\n\t\t\t\t\tif (yy < epsilon) {\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = Math.sqrt(yy);\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\t\t\t\tif (zz < epsilon) {\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz = Math.sqrt(zz);\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.set(x, y, z, angle);\n\t\t\t\treturn this; // return 180 deg rotation\n\t\t\t} // as we have reached here there are no singularities so we can handle normally\n\n\n\t\t\tlet s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n\t\t\tif (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = (m32 - m23) / s;\n\t\t\tthis.y = (m13 - m31) / s;\n\t\t\tthis.z = (m21 - m12) / s;\n\t\t\tthis.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\tthis.w = Math.min(this.w, v.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\tthis.w = Math.max(this.w, v.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\tthis.z = Math.max(minVal, Math.min(maxVal, this.z));\n\t\t\tthis.w = Math.max(minVal, Math.min(maxVal, this.w));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\tthis.z = Math.floor(this.z);\n\t\t\tthis.w = Math.floor(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\tthis.z = Math.ceil(this.z);\n\t\t\tthis.w = Math.ceil(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\tthis.z = Math.round(this.z);\n\t\t\tthis.w = Math.round(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\tthis.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\tthis.z = -this.z;\n\t\t\tthis.w = -this.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\tthis.w += (v.w - this.w) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\tthis.z = v1.z + (v2.z - v1.z) * alpha;\n\t\t\tthis.w = v1.w + (v2.w - v1.w) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\tthis.z = array[offset + 2];\n\t\t\tthis.w = array[offset + 3];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\tarray[offset + 2] = this.z;\n\t\t\tarray[offset + 3] = this.w;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\tthis.z = attribute.getZ(index);\n\t\t\tthis.w = attribute.getW(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\t\t\tthis.w = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector4.prototype.isVector4 = true;\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\n\tclass WebGLRenderTarget extends EventDispatcher {\n\t\tconstructor(width, height, options) {\n\t\t\tsuper();\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = 1;\n\t\t\tthis.scissor = new Vector4(0, 0, width, height);\n\t\t\tthis.scissorTest = false;\n\t\t\tthis.viewport = new Vector4(0, 0, width, height);\n\t\t\toptions = options || {};\n\t\t\tthis.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\t\t\tthis.texture.image = {};\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\t\t\tthis.texture.image.depth = 1;\n\t\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\t}\n\n\t\tsetTexture(texture) {\n\t\t\ttexture.image = {\n\t\t\t\twidth: this.width,\n\t\t\t\theight: this.height,\n\t\t\t\tdepth: this.depth\n\t\t\t};\n\t\t\tthis.texture = texture;\n\t\t}\n\n\t\tsetSize(width, height, depth = 1) {\n\t\t\tif (this.width !== width || this.height !== height || this.depth !== depth) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.depth = depth;\n\t\t\t\tthis.texture.image.width = width;\n\t\t\t\tthis.texture.image.height = height;\n\t\t\t\tthis.texture.image.depth = depth;\n\t\t\t\tthis.dispose();\n\t\t\t}\n\n\t\t\tthis.viewport.set(0, 0, width, height);\n\t\t\tthis.scissor.set(0, 0, width, height);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.viewport.copy(source.viewport);\n\t\t\tthis.texture = source.texture.clone();\n\t\t\tthis.texture.image = { ...this.texture.image\n\t\t\t}; // See #20328.\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\n\tclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n\t\tconstructor(width, height, count) {\n\t\t\tsuper(width, height);\n\t\t\tconst texture = this.texture;\n\t\t\tthis.texture = [];\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tthis.texture[i] = texture.clone();\n\t\t\t}\n\t\t}\n\n\t\tsetSize(width, height, depth = 1) {\n\t\t\tif (this.width !== width || this.height !== height || this.depth !== depth) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.depth = depth;\n\n\t\t\t\tfor (let i = 0, il = this.texture.length; i < il; i++) {\n\t\t\t\t\tthis.texture[i].image.width = width;\n\t\t\t\t\tthis.texture[i].image.height = height;\n\t\t\t\t\tthis.texture[i].image.depth = depth;\n\t\t\t\t}\n\n\t\t\t\tthis.dispose();\n\t\t\t}\n\n\t\t\tthis.viewport.set(0, 0, width, height);\n\t\t\tthis.scissor.set(0, 0, width, height);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.dispose();\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.viewport.set(0, 0, this.width, this.height);\n\t\t\tthis.scissor.set(0, 0, this.width, this.height);\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\t\tthis.texture.length = 0;\n\n\t\t\tfor (let i = 0, il = source.texture.length; i < il; i++) {\n\t\t\t\tthis.texture[i] = source.texture[i].clone();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tWebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;\n\n\tclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n\t\tconstructor(width, height, options) {\n\t\t\tsuper(width, height, options);\n\t\t\tthis.samples = 4;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy.call(this, source);\n\t\t\tthis.samples = source.samples;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\n\tclass Quaternion {\n\t\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\t\t}\n\n\t\tstatic slerp(qa, qb, qm, t) {\n\t\t\tconsole.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');\n\t\t\treturn qm.slerpQuaternions(qa, qb, t);\n\t\t}\n\n\t\tstatic slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\t\tlet x0 = src0[srcOffset0 + 0],\n\t\t\t\t\ty0 = src0[srcOffset0 + 1],\n\t\t\t\t\tz0 = src0[srcOffset0 + 2],\n\t\t\t\t\tw0 = src0[srcOffset0 + 3];\n\t\t\tconst x1 = src1[srcOffset1 + 0],\n\t\t\t\t\t\ty1 = src1[srcOffset1 + 1],\n\t\t\t\t\t\tz1 = src1[srcOffset1 + 2],\n\t\t\t\t\t\tw1 = src1[srcOffset1 + 3];\n\n\t\t\tif (t === 0) {\n\t\t\t\tdst[dstOffset + 0] = x0;\n\t\t\t\tdst[dstOffset + 1] = y0;\n\t\t\t\tdst[dstOffset + 2] = z0;\n\t\t\t\tdst[dstOffset + 3] = w0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t === 1) {\n\t\t\t\tdst[dstOffset + 0] = x1;\n\t\t\t\tdst[dstOffset + 1] = y1;\n\t\t\t\tdst[dstOffset + 2] = z1;\n\t\t\t\tdst[dstOffset + 3] = w1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n\t\t\t\tlet s = 1 - t;\n\t\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\t\t\t\tdir = cos >= 0 ? 1 : -1,\n\t\t\t\t\t\t\tsqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n\t\t\t\tif (sqrSin > Number.EPSILON) {\n\t\t\t\t\tconst sin = Math.sqrt(sqrSin),\n\t\t\t\t\t\t\t\tlen = Math.atan2(sin, cos * dir);\n\t\t\t\t\ts = Math.sin(s * len) / sin;\n\t\t\t\t\tt = Math.sin(t * len) / sin;\n\t\t\t\t}\n\n\t\t\t\tconst tDir = t * dir;\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n\t\t\t\tif (s === 1 - t) {\n\t\t\t\t\tconst f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdst[dstOffset] = x0;\n\t\t\tdst[dstOffset + 1] = y0;\n\t\t\tdst[dstOffset + 2] = z0;\n\t\t\tdst[dstOffset + 3] = w0;\n\t\t}\n\n\t\tstatic multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n\t\t\tconst x0 = src0[srcOffset0];\n\t\t\tconst y0 = src0[srcOffset0 + 1];\n\t\t\tconst z0 = src0[srcOffset0 + 2];\n\t\t\tconst w0 = src0[srcOffset0 + 3];\n\t\t\tconst x1 = src1[srcOffset1];\n\t\t\tconst y1 = src1[srcOffset1 + 1];\n\t\t\tconst z1 = src1[srcOffset1 + 2];\n\t\t\tconst w1 = src1[srcOffset1 + 3];\n\t\t\tdst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\t\tdst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\t\tdst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\t\tdst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\t\t\treturn dst;\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x;\n\t\t}\n\n\t\tset x(value) {\n\t\t\tthis._x = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y;\n\t\t}\n\n\t\tset y(value) {\n\t\t\tthis._y = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget z() {\n\t\t\treturn this._z;\n\t\t}\n\n\t\tset z(value) {\n\t\t\tthis._z = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget w() {\n\t\t\treturn this._w;\n\t\t}\n\n\t\tset w(value) {\n\t\t\tthis._w = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tset(x, y, z, w) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this._x, this._y, this._z, this._w);\n\t\t}\n\n\t\tcopy(quaternion) {\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromEuler(euler, update) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tthrow new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\tconst x = euler._x,\n\t\t\t\t\t\ty = euler._y,\n\t\t\t\t\t\tz = euler._z,\n\t\t\t\t\t\torder = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tconst cos = Math.cos;\n\t\t\tconst sin = Math.sin;\n\t\t\tconst c1 = cos(x / 2);\n\t\t\tconst c2 = cos(y / 2);\n\t\t\tconst c3 = cos(z / 2);\n\t\t\tconst s1 = sin(x / 2);\n\t\t\tconst s2 = sin(y / 2);\n\t\t\tconst s3 = sin(z / 2);\n\n\t\t\tswitch (order) {\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n\t\t\t}\n\n\t\t\tif (update !== false) this._onChangeCallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromAxisAngle(axis, angle) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t\t// assumes axis is normalized\n\t\t\tconst halfAngle = angle / 2,\n\t\t\t\t\t\ts = Math.sin(halfAngle);\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos(halfAngle);\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromRotationMatrix(m) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tconst te = m.elements,\n\t\t\t\t\t\tm11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8],\n\t\t\t\t\t\tm21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9],\n\t\t\t\t\t\tm31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10],\n\t\t\t\t\t\ttrace = m11 + m22 + m33;\n\n\t\t\tif (trace > 0) {\n\t\t\t\tconst s = 0.5 / Math.sqrt(trace + 1.0);\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = (m32 - m23) * s;\n\t\t\t\tthis._y = (m13 - m31) * s;\n\t\t\t\tthis._z = (m21 - m12) * s;\n\t\t\t} else if (m11 > m22 && m11 > m33) {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\t\t\t\tthis._w = (m32 - m23) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = (m12 + m21) / s;\n\t\t\t\tthis._z = (m13 + m31) / s;\n\t\t\t} else if (m22 > m33) {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\t\t\t\tthis._w = (m13 - m31) / s;\n\t\t\t\tthis._x = (m12 + m21) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = (m23 + m32) / s;\n\t\t\t} else {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\t\t\t\tthis._w = (m21 - m12) / s;\n\t\t\t\tthis._x = (m13 + m31) / s;\n\t\t\t\tthis._y = (m23 + m32) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromUnitVectors(vFrom, vTo) {\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\t\tlet r = vFrom.dot(vTo) + 1;\n\n\t\t\tif (r < Number.EPSILON) {\n\t\t\t\t// vFrom and vTo point in opposite directions\n\t\t\t\tr = 0;\n\n\t\t\t\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n\t\t\t\t\tthis._x = -vFrom.y;\n\t\t\t\t\tthis._y = vFrom.x;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = r;\n\t\t\t\t} else {\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = -vFrom.z;\n\t\t\t\t\tthis._z = vFrom.y;\n\t\t\t\t\tthis._w = r;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\t\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\t\tthis._w = r;\n\t\t\t}\n\n\t\t\treturn this.normalize();\n\t\t}\n\n\t\tangleTo(q) {\n\t\t\treturn 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n\t\t}\n\n\t\trotateTowards(q, step) {\n\t\t\tconst angle = this.angleTo(q);\n\t\t\tif (angle === 0) return this;\n\t\t\tconst t = Math.min(1, step / angle);\n\t\t\tthis.slerp(q, t);\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\treturn this.set(0, 0, 0, 1);\n\t\t}\n\n\t\tinvert() {\n\t\t\t// quaternion is assumed to have unit length\n\t\t\treturn this.conjugate();\n\t\t}\n\n\t\tconjugate() {\n\t\t\tthis._x *= -1;\n\t\t\tthis._y *= -1;\n\t\t\tthis._z *= -1;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n\t\t}\n\n\t\tnormalize() {\n\t\t\tlet l = this.length();\n\n\t\t\tif (l === 0) {\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\t\t\t} else {\n\t\t\t\tl = 1 / l;\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(q, p) {\n\t\t\tif (p !== undefined) {\n\t\t\t\tconsole.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n\t\t\t\treturn this.multiplyQuaternions(q, p);\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions(this, q);\n\t\t}\n\n\t\tpremultiply(q) {\n\t\t\treturn this.multiplyQuaternions(q, this);\n\t\t}\n\n\t\tmultiplyQuaternions(a, b) {\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\t\tconst qax = a._x,\n\t\t\t\t\t\tqay = a._y,\n\t\t\t\t\t\tqaz = a._z,\n\t\t\t\t\t\tqaw = a._w;\n\t\t\tconst qbx = b._x,\n\t\t\t\t\t\tqby = b._y,\n\t\t\t\t\t\tqbz = b._z,\n\t\t\t\t\t\tqbw = b._w;\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tslerp(qb, t) {\n\t\t\tif (t === 0) return this;\n\t\t\tif (t === 1) return this.copy(qb);\n\t\t\tconst x = this._x,\n\t\t\t\t\t\ty = this._y,\n\t\t\t\t\t\tz = this._z,\n\t\t\t\t\t\tw = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif (cosHalfTheta < 0) {\n\t\t\t\tthis._w = -qb._w;\n\t\t\t\tthis._x = -qb._x;\n\t\t\t\tthis._y = -qb._y;\n\t\t\t\tthis._z = -qb._z;\n\t\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t\t} else {\n\t\t\t\tthis.copy(qb);\n\t\t\t}\n\n\t\t\tif (cosHalfTheta >= 1.0) {\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\t\tif (sqrSinHalfTheta <= Number.EPSILON) {\n\t\t\t\tconst s = 1 - t;\n\t\t\t\tthis._w = s * w + t * this._w;\n\t\t\t\tthis._x = s * x + t * this._x;\n\t\t\t\tthis._y = s * y + t * this._y;\n\t\t\t\tthis._z = s * z + t * this._z;\n\t\t\t\tthis.normalize();\n\n\t\t\t\tthis._onChangeCallback();\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n\t\t\tconst halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n\t\t\tconst ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n\t\t\t\t\t\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\t\t\tthis._w = w * ratioA + this._w * ratioB;\n\t\t\tthis._x = x * ratioA + this._x * ratioB;\n\t\t\tthis._y = y * ratioA + this._y * ratioB;\n\t\t\tthis._z = z * ratioA + this._z * ratioB;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tslerpQuaternions(qa, qb, t) {\n\t\t\tthis.copy(qa).slerp(qb, t);\n\t\t}\n\n\t\tequals(quaternion) {\n\t\t\treturn quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis._x = array[offset];\n\t\t\tthis._y = array[offset + 1];\n\t\t\tthis._z = array[offset + 2];\n\t\t\tthis._w = array[offset + 3];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this._x;\n\t\t\tarray[offset + 1] = this._y;\n\t\t\tarray[offset + 2] = this._z;\n\t\t\tarray[offset + 3] = this._w;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index) {\n\t\t\tthis._x = attribute.getX(index);\n\t\t\tthis._y = attribute.getY(index);\n\t\t\tthis._z = attribute.getZ(index);\n\t\t\tthis._w = attribute.getW(index);\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChange(callback) {\n\t\t\tthis._onChangeCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t}\n\n\tQuaternion.prototype.isQuaternion = true;\n\n\tclass Vector3 {\n\t\tconstructor(x = 0, y = 0, z = 0) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tset(x, y, z) {\n\t\t\tif (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(z) {\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.z = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tcase 2:\n\t\t\t\t\treturn this.z;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y, this.z);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n\t\t\t\treturn this.multiplyVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyVectors(a, b) {\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyEuler(euler) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tconsole.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\treturn this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n\t\t}\n\n\t\tapplyAxisAngle(axis, angle) {\n\t\t\treturn this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\treturn this.applyMatrix3(m).normalize();\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tconst w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\t\t\tthis.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n\t\t\tthis.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n\t\t\tthis.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst qx = q.x,\n\t\t\t\t\t\tqy = q.y,\n\t\t\t\t\t\tqz = q.z,\n\t\t\t\t\t\tqw = q.w; // calculate quat * vector\n\n\t\t\tconst ix = qw * x + qy * z - qz * y;\n\t\t\tconst iy = qw * y + qz * x - qx * z;\n\t\t\tconst iz = qw * z + qx * y - qy * x;\n\t\t\tconst iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\t\t\treturn this;\n\t\t}\n\n\t\tproject(camera) {\n\t\t\treturn this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n\t\t}\n\n\t\tunproject(camera) {\n\t\t\treturn this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\t\t\treturn this.normalize();\n\t\t}\n\n\t\tdivide(v) {\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\tthis.z = Math.max(minVal, Math.min(maxVal, this.z));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\tthis.z = Math.floor(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\tthis.z = Math.ceil(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\tthis.z = Math.round(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\tthis.z = -this.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\t} // TODO lengthSquared?\n\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\tthis.z = v1.z + (v2.z - v1.z) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tcross(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n\t\t\t\treturn this.crossVectors(v, w);\n\t\t\t}\n\n\t\t\treturn this.crossVectors(this, v);\n\t\t}\n\n\t\tcrossVectors(a, b) {\n\t\t\tconst ax = a.x,\n\t\t\t\t\t\tay = a.y,\n\t\t\t\t\t\taz = a.z;\n\t\t\tconst bx = b.x,\n\t\t\t\t\t\tby = b.y,\n\t\t\t\t\t\tbz = b.z;\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\t\t\treturn this;\n\t\t}\n\n\t\tprojectOnVector(v) {\n\t\t\tconst denominator = v.lengthSq();\n\t\t\tif (denominator === 0) return this.set(0, 0, 0);\n\t\t\tconst scalar = v.dot(this) / denominator;\n\t\t\treturn this.copy(v).multiplyScalar(scalar);\n\t\t}\n\n\t\tprojectOnPlane(planeNormal) {\n\t\t\t_vector$c.copy(this).projectOnVector(planeNormal);\n\n\t\t\treturn this.sub(_vector$c);\n\t\t}\n\n\t\treflect(normal) {\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\t\t\treturn this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n\t\t}\n\n\t\tangleTo(v) {\n\t\t\tconst denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n\t\t\tif (denominator === 0) return Math.PI / 2;\n\t\t\tconst theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n\t\t\treturn Math.acos(clamp(theta, -1, 1));\n\t\t}\n\n\t\tdistanceTo(v) {\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t}\n\n\t\tdistanceToSquared(v) {\n\t\t\tconst dx = this.x - v.x,\n\t\t\t\t\t\tdy = this.y - v.y,\n\t\t\t\t\t\tdz = this.z - v.z;\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\t}\n\n\t\tmanhattanDistanceTo(v) {\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n\t\t}\n\n\t\tsetFromSpherical(s) {\n\t\t\treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n\t\t}\n\n\t\tsetFromSphericalCoords(radius, phi, theta) {\n\t\t\tconst sinPhiRadius = Math.sin(phi) * radius;\n\t\t\tthis.x = sinPhiRadius * Math.sin(theta);\n\t\t\tthis.y = Math.cos(phi) * radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos(theta);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCylindrical(c) {\n\t\t\treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n\t\t}\n\n\t\tsetFromCylindricalCoords(radius, theta, y) {\n\t\t\tthis.x = radius * Math.sin(theta);\n\t\t\tthis.y = y;\n\t\t\tthis.z = radius * Math.cos(theta);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixPosition(m) {\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[12];\n\t\t\tthis.y = e[13];\n\t\t\tthis.z = e[14];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixScale(m) {\n\t\t\tconst sx = this.setFromMatrixColumn(m, 0).length();\n\t\t\tconst sy = this.setFromMatrixColumn(m, 1).length();\n\t\t\tconst sz = this.setFromMatrixColumn(m, 2).length();\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixColumn(m, index) {\n\t\t\treturn this.fromArray(m.elements, index * 4);\n\t\t}\n\n\t\tsetFromMatrix3Column(m, index) {\n\t\t\treturn this.fromArray(m.elements, index * 3);\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\tthis.z = array[offset + 2];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\tarray[offset + 2] = this.z;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\tthis.z = attribute.getZ(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector3.prototype.isVector3 = true;\n\n\tconst _vector$c = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$4 = /*@__PURE__*/new Quaternion();\n\n\tclass Box3 {\n\t\tconstructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\t\t}\n\n\t\tset(min, max) {\n\t\t\tthis.min.copy(min);\n\t\t\tthis.max.copy(max);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromArray(array) {\n\t\t\tlet minX = +Infinity;\n\t\t\tlet minY = +Infinity;\n\t\t\tlet minZ = +Infinity;\n\t\t\tlet maxX = -Infinity;\n\t\t\tlet maxY = -Infinity;\n\t\t\tlet maxZ = -Infinity;\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i += 3) {\n\t\t\t\tconst x = array[i];\n\t\t\t\tconst y = array[i + 1];\n\t\t\t\tconst z = array[i + 2];\n\t\t\t\tif (x < minX) minX = x;\n\t\t\t\tif (y < minY) minY = y;\n\t\t\t\tif (z < minZ) minZ = z;\n\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t}\n\n\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\tthis.max.set(maxX, maxY, maxZ);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromBufferAttribute(attribute) {\n\t\t\tlet minX = +Infinity;\n\t\t\tlet minY = +Infinity;\n\t\t\tlet minZ = +Infinity;\n\t\t\tlet maxX = -Infinity;\n\t\t\tlet maxY = -Infinity;\n\t\t\tlet maxZ = -Infinity;\n\n\t\t\tfor (let i = 0, l = attribute.count; i < l; i++) {\n\t\t\t\tconst x = attribute.getX(i);\n\t\t\t\tconst y = attribute.getY(i);\n\t\t\t\tconst z = attribute.getZ(i);\n\t\t\t\tif (x < minX) minX = x;\n\t\t\t\tif (y < minY) minY = y;\n\t\t\t\tif (z < minZ) minZ = z;\n\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t}\n\n\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\tthis.max.set(maxX, maxY, maxZ);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCenterAndSize(center, size) {\n\t\t\tconst halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n\n\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\tthis.max.copy(center).add(halfSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromObject(object) {\n\t\t\tthis.makeEmpty();\n\t\t\treturn this.expandByObject(object);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(box) {\n\t\t\tthis.min.copy(box.min);\n\t\t\tthis.max.copy(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.min.x = this.min.y = this.min.z = +Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t}\n\n\t\tgetSize(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getSize() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\tthis.min.min(point);\n\t\t\tthis.max.max(point);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByVector(vector) {\n\t\t\tthis.min.sub(vector);\n\t\t\tthis.max.add(vector);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByScalar(scalar) {\n\t\t\tthis.min.addScalar(-scalar);\n\t\t\tthis.max.addScalar(scalar);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByObject(object) {\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\t\t\tobject.updateWorldMatrix(false, false);\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif (geometry !== undefined) {\n\t\t\t\tif (geometry.boundingBox === null) {\n\t\t\t\t\tgeometry.computeBoundingBox();\n\t\t\t\t}\n\n\t\t\t\t_box$3.copy(geometry.boundingBox);\n\n\t\t\t\t_box$3.applyMatrix4(object.matrixWorld);\n\n\t\t\t\tthis.union(_box$3);\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tthis.expandByObject(children[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n\t\t}\n\n\t\tcontainsBox(box) {\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n\t\t}\n\n\t\tgetParameter(point, target) {\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getParameter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.\n\n\t\t\treturn _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\t\tlet min, max;\n\n\t\t\tif (plane.normal.x > 0) {\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\t\t} else {\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\t\t}\n\n\t\t\tif (plane.normal.y > 0) {\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\t\t} else {\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\t\t}\n\n\t\t\tif (plane.normal.z > 0) {\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\t\t} else {\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\t\t}\n\n\t\t\treturn min <= -plane.constant && max >= -plane.constant;\n\t\t}\n\n\t\tintersectsTriangle(triangle) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t} // compute box center and extents\n\n\n\t\t\tthis.getCenter(_center);\n\n\t\t\t_extents.subVectors(this.max, _center); // translate triangle to aabb origin\n\n\n\t\t\t_v0$2.subVectors(triangle.a, _center);\n\n\t\t\t_v1$7.subVectors(triangle.b, _center);\n\n\t\t\t_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle\n\n\n\t\t\t_f0.subVectors(_v1$7, _v0$2);\n\n\t\t\t_f1.subVectors(_v2$3, _v1$7);\n\n\t\t\t_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\n\n\t\t\tlet axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n\n\t\t\tif (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n\t\t\t\treturn false;\n\t\t\t} // test 3 face normals from the aabb\n\n\n\t\t\taxes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\tif (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n\t\t\t\treturn false;\n\t\t\t} // finally testing the face normal of the triangle\n\t\t\t// use already existing triangle edge vectors here\n\n\n\t\t\t_triangleNormal.crossVectors(_f0, _f1);\n\n\t\t\taxes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n\t\t\treturn satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\tconst clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n\n\t\t\treturn clampedPoint.sub(point).length();\n\t\t}\n\n\t\tgetBoundingSphere(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency\n\t\t\t}\n\n\t\t\tthis.getCenter(target.center);\n\t\t\ttarget.radius = this.getSize(_vector$b).length() * 0.5;\n\t\t\treturn target;\n\t\t}\n\n\t\tintersect(box) {\n\t\t\tthis.min.max(box.min);\n\t\t\tthis.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\n\t\t\tif (this.isEmpty()) this.makeEmpty();\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(box) {\n\t\t\tthis.min.min(box.min);\n\t\t\tthis.max.max(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\n\t\t\t_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n\n\t\t\t_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n\n\t\t\t_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n\n\t\t\t_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n\n\t\t\t_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n\n\t\t\t_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n\n\t\t\t_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n\n\t\t\t_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\n\t\t\tthis.setFromPoints(_points);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.min.add(offset);\n\t\t\tthis.max.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(box) {\n\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t}\n\n\t}\n\n\tBox3.prototype.isBox3 = true;\n\tconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\n\n\tconst _vector$b = /*@__PURE__*/new Vector3();\n\n\tconst _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices\n\n\n\tconst _v0$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v1$7 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors\n\n\n\tconst _f0 = /*@__PURE__*/new Vector3();\n\n\tconst _f1 = /*@__PURE__*/new Vector3();\n\n\tconst _f2 = /*@__PURE__*/new Vector3();\n\n\tconst _center = /*@__PURE__*/new Vector3();\n\n\tconst _extents = /*@__PURE__*/new Vector3();\n\n\tconst _triangleNormal = /*@__PURE__*/new Vector3();\n\n\tconst _testAxis = /*@__PURE__*/new Vector3();\n\n\tfunction satForAxes(axes, v0, v1, v2, extents) {\n\t\tfor (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n\t\t\t_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis\n\n\n\t\t\tconst r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis\n\n\t\t\tconst p0 = v0.dot(_testAxis);\n\t\t\tconst p1 = v1.dot(_testAxis);\n\t\t\tconst p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r\n\n\t\t\tif (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconst _box$2 = /*@__PURE__*/new Box3();\n\n\tconst _v1$6 = /*@__PURE__*/new Vector3();\n\n\tconst _toFarthestPoint = /*@__PURE__*/new Vector3();\n\n\tconst _toPoint = /*@__PURE__*/new Vector3();\n\n\tclass Sphere {\n\t\tconstructor(center = new Vector3(), radius = -1) {\n\t\t\tthis.center = center;\n\t\t\tthis.radius = radius;\n\t\t}\n\n\t\tset(center, radius) {\n\t\t\tthis.center.copy(center);\n\t\t\tthis.radius = radius;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points, optionalCenter) {\n\t\t\tconst center = this.center;\n\n\t\t\tif (optionalCenter !== undefined) {\n\t\t\t\tcenter.copy(optionalCenter);\n\t\t\t} else {\n\t\t\t\t_box$2.setFromPoints(points).getCenter(center);\n\t\t\t}\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt(maxRadiusSq);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(sphere) {\n\t\t\tthis.center.copy(sphere.center);\n\t\t\tthis.radius = sphere.radius;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\treturn this.radius < 0;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.center.set(0, 0, 0);\n\t\t\tthis.radius = -1;\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.distanceToSquared(this.center) <= this.radius * this.radius;\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn point.distanceTo(this.center) - this.radius;\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\tconst radiusSum = this.radius + sphere.radius;\n\t\t\treturn sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsSphere(this);\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\treturn Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tconst deltaLengthSq = this.center.distanceToSquared(point);\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Sphere: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.copy(point);\n\n\t\t\tif (deltaLengthSq > this.radius * this.radius) {\n\t\t\t\ttarget.sub(this.center).normalize();\n\t\t\t\ttarget.multiplyScalar(this.radius).add(this.center);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\tgetBoundingBox(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Sphere: .getBoundingBox() target is now required');\n\t\t\t\ttarget = new Box3();\n\t\t\t}\n\n\t\t\tif (this.isEmpty()) {\n\t\t\t\t// Empty sphere produces empty bounding box\n\t\t\t\ttarget.makeEmpty();\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\ttarget.set(this.center, this.center);\n\t\t\ttarget.expandByScalar(this.radius);\n\t\t\treturn target;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tthis.center.applyMatrix4(matrix);\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.center.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\t\t\t_toPoint.subVectors(point, this.center);\n\n\t\t\tconst lengthSq = _toPoint.lengthSq();\n\n\t\t\tif (lengthSq > this.radius * this.radius) {\n\t\t\t\tconst length = Math.sqrt(lengthSq);\n\t\t\t\tconst missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,\n\t\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\n\t\t\t\t// the whole missing distance were just added to radius.\n\n\t\t\t\tthis.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n\t\t\t\tthis.radius += missingRadiusHalf;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(sphere) {\n\t\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\t\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\n\t\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\n\t\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\n\t\t\t_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n\n\t\t\tthis.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n\t\t\tthis.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(sphere) {\n\t\t\treturn sphere.center.equals(this.center) && sphere.radius === this.radius;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tconst _vector$a = /*@__PURE__*/new Vector3();\n\n\tconst _segCenter = /*@__PURE__*/new Vector3();\n\n\tconst _segDir = /*@__PURE__*/new Vector3();\n\n\tconst _diff = /*@__PURE__*/new Vector3();\n\n\tconst _edge1 = /*@__PURE__*/new Vector3();\n\n\tconst _edge2 = /*@__PURE__*/new Vector3();\n\n\tconst _normal$1 = /*@__PURE__*/new Vector3();\n\n\tclass Ray {\n\t\tconstructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n\t\t\tthis.origin = origin;\n\t\t\tthis.direction = direction;\n\t\t}\n\n\t\tset(origin, direction) {\n\t\t\tthis.origin.copy(origin);\n\t\t\tthis.direction.copy(direction);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(ray) {\n\t\t\tthis.origin.copy(ray.origin);\n\t\t\tthis.direction.copy(ray.direction);\n\t\t\treturn this;\n\t\t}\n\n\t\tat(t, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Ray: .at() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\n\t\t}\n\n\t\tlookAt(v) {\n\t\t\tthis.direction.copy(v).sub(this.origin).normalize();\n\t\t\treturn this;\n\t\t}\n\n\t\trecast(t) {\n\t\t\tthis.origin.copy(this.at(t, _vector$a));\n\t\t\treturn this;\n\t\t}\n\n\t\tclosestPointToPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Ray: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.subVectors(point, this.origin);\n\t\t\tconst directionDistance = target.dot(this.direction);\n\n\t\t\tif (directionDistance < 0) {\n\t\t\t\treturn target.copy(this.origin);\n\t\t\t}\n\n\t\t\treturn target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn Math.sqrt(this.distanceSqToPoint(point));\n\t\t}\n\n\t\tdistanceSqToPoint(point) {\n\t\t\tconst directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n\n\t\t\tif (directionDistance < 0) {\n\t\t\t\treturn this.origin.distanceToSquared(point);\n\t\t\t}\n\n\t\t\t_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n\t\t\treturn _vector$a.distanceToSquared(point);\n\t\t}\n\n\t\tdistanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\t\t\t_segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n\n\t\t\t_segDir.copy(v1).sub(v0).normalize();\n\n\t\t\t_diff.copy(this.origin).sub(_segCenter);\n\n\t\t\tconst segExtent = v0.distanceTo(v1) * 0.5;\n\t\t\tconst a01 = -this.direction.dot(_segDir);\n\n\t\t\tconst b0 = _diff.dot(this.direction);\n\n\t\t\tconst b1 = -_diff.dot(_segDir);\n\n\t\t\tconst c = _diff.lengthSq();\n\n\t\t\tconst det = Math.abs(1 - a01 * a01);\n\t\t\tlet s0, s1, sqrDist, extDet;\n\n\t\t\tif (det > 0) {\n\t\t\t\t// The ray and segment are not parallel.\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif (s0 >= 0) {\n\t\t\t\t\tif (s1 >= -extDet) {\n\t\t\t\t\t\tif (s1 <= extDet) {\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// region 1\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 5\n\t\t\t\t\t\ts1 = -segExtent;\n\t\t\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (s1 <= -extDet) {\n\t\t\t\t\t\t// region 4\n\t\t\t\t\t\ts0 = Math.max(0, -(-a01 * segExtent + b0));\n\t\t\t\t\t\ts1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t} else if (s1 <= extDet) {\n\t\t\t\t\t\t// region 3\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 2\n\t\t\t\t\t\ts0 = Math.max(0, -(a01 * segExtent + b0));\n\t\t\t\t\t\ts1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Ray and segment are parallel.\n\t\t\t\ts1 = a01 > 0 ? -segExtent : segExtent;\n\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t}\n\n\t\t\tif (optionalPointOnRay) {\n\t\t\t\toptionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n\t\t\t}\n\n\t\t\tif (optionalPointOnSegment) {\n\t\t\t\toptionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\t\t}\n\n\t\tintersectSphere(sphere, target) {\n\t\t\t_vector$a.subVectors(sphere.center, this.origin);\n\n\t\t\tconst tca = _vector$a.dot(this.direction);\n\n\t\t\tconst d2 = _vector$a.dot(_vector$a) - tca * tca;\n\t\t\tconst radius2 = sphere.radius * sphere.radius;\n\t\t\tif (d2 > radius2) return null;\n\t\t\tconst thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n\t\t\tconst t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n\t\t\tconst t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n\t\t\tif (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\n\t\t\tif (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n\t\t\treturn this.at(t0, target);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\treturn this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n\t\t}\n\n\t\tdistanceToPlane(plane) {\n\t\t\tconst denominator = plane.normal.dot(this.direction);\n\n\t\t\tif (denominator === 0) {\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif (plane.distanceToPoint(this.origin) === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} // Null is preferable to undefined since undefined means.... it is undefined\n\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t : null;\n\t\t}\n\n\t\tintersectPlane(plane, target) {\n\t\t\tconst t = this.distanceToPlane(plane);\n\n\t\t\tif (t === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn this.at(t, target);\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\t// check if the ray lies on the plane first\n\t\t\tconst distToPoint = plane.distanceToPoint(this.origin);\n\n\t\t\tif (distToPoint === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst denominator = plane.normal.dot(this.direction);\n\n\t\t\tif (denominator * distToPoint < 0) {\n\t\t\t\treturn true;\n\t\t\t} // ray origin is behind the plane (and is pointing behind it)\n\n\n\t\t\treturn false;\n\t\t}\n\n\t\tintersectBox(box, target) {\n\t\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\t\tconst invdirx = 1 / this.direction.x,\n\t\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\t\tconst origin = this.origin;\n\n\t\t\tif (invdirx >= 0) {\n\t\t\t\ttmin = (box.min.x - origin.x) * invdirx;\n\t\t\t\ttmax = (box.max.x - origin.x) * invdirx;\n\t\t\t} else {\n\t\t\t\ttmin = (box.max.x - origin.x) * invdirx;\n\t\t\t\ttmax = (box.min.x - origin.x) * invdirx;\n\t\t\t}\n\n\t\t\tif (invdiry >= 0) {\n\t\t\t\ttymin = (box.min.y - origin.y) * invdiry;\n\t\t\t\ttymax = (box.max.y - origin.y) * invdiry;\n\t\t\t} else {\n\t\t\t\ttymin = (box.max.y - origin.y) * invdiry;\n\t\t\t\ttymax = (box.min.y - origin.y) * invdiry;\n\t\t\t}\n\n\t\t\tif (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif (tymin > tmin || tmin !== tmin) tmin = tymin;\n\t\t\tif (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n\t\t\tif (invdirz >= 0) {\n\t\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\n\t\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\n\t\t\t} else {\n\t\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\n\t\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\n\t\t\t}\n\n\t\t\tif (tmin > tzmax || tzmin > tmax) return null;\n\t\t\tif (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n\t\t\tif (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n\t\t\tif (tmax < 0) return null;\n\t\t\treturn this.at(tmin >= 0 ? tmin : tmax, target);\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn this.intersectBox(box, _vector$a) !== null;\n\t\t}\n\n\t\tintersectTriangle(a, b, c, backfaceCulling, target) {\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\t\t_edge1.subVectors(b, a);\n\n\t\t\t_edge2.subVectors(c, a);\n\n\t\t\t_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//\t |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//\t |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//\t |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n\n\t\t\tlet DdN = this.direction.dot(_normal$1);\n\t\t\tlet sign;\n\n\t\t\tif (DdN > 0) {\n\t\t\t\tif (backfaceCulling) return null;\n\t\t\t\tsign = 1;\n\t\t\t} else if (DdN < 0) {\n\t\t\t\tsign = -1;\n\t\t\t\tDdN = -DdN;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t_diff.subVectors(this.origin, a);\n\n\t\t\tconst DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection\n\n\t\t\tif (DdQxE2 < 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection\n\n\t\t\tif (DdE1xQ < 0) {\n\t\t\t\treturn null;\n\t\t\t} // b1+b2 > 1, no intersection\n\n\n\t\t\tif (DdQxE2 + DdE1xQ > DdN) {\n\t\t\t\treturn null;\n\t\t\t} // Line intersects triangle, check if ray does.\n\n\n\t\t\tconst QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection\n\n\n\t\t\tif (QdN < 0) {\n\t\t\t\treturn null;\n\t\t\t} // Ray intersects triangle.\n\n\n\t\t\treturn this.at(QdN / DdN, target);\n\t\t}\n\n\t\tapplyMatrix4(matrix4) {\n\t\t\tthis.origin.applyMatrix4(matrix4);\n\t\t\tthis.direction.transformDirection(matrix4);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(ray) {\n\t\t\treturn ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tclass Matrix4 {\n\t\tconstructor() {\n\t\t\tthis.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconsole.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t}\n\t\t}\n\n\t\tset(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] = n11;\n\t\t\tte[4] = n12;\n\t\t\tte[8] = n13;\n\t\t\tte[12] = n14;\n\t\t\tte[1] = n21;\n\t\t\tte[5] = n22;\n\t\t\tte[9] = n23;\n\t\t\tte[13] = n24;\n\t\t\tte[2] = n31;\n\t\t\tte[6] = n32;\n\t\t\tte[10] = n33;\n\t\t\tte[14] = n34;\n\t\t\tte[3] = n41;\n\t\t\tte[7] = n42;\n\t\t\tte[11] = n43;\n\t\t\tte[15] = n44;\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Matrix4().fromArray(this.elements);\n\t\t}\n\n\t\tcopy(m) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\t\t\tte[0] = me[0];\n\t\t\tte[1] = me[1];\n\t\t\tte[2] = me[2];\n\t\t\tte[3] = me[3];\n\t\t\tte[4] = me[4];\n\t\t\tte[5] = me[5];\n\t\t\tte[6] = me[6];\n\t\t\tte[7] = me[7];\n\t\t\tte[8] = me[8];\n\t\t\tte[9] = me[9];\n\t\t\tte[10] = me[10];\n\t\t\tte[11] = me[11];\n\t\t\tte[12] = me[12];\n\t\t\tte[13] = me[13];\n\t\t\tte[14] = me[14];\n\t\t\tte[15] = me[15];\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyPosition(m) {\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tme = m.elements;\n\t\t\tte[12] = me[12];\n\t\t\tte[13] = me[13];\n\t\t\tte[14] = me[14];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrix3(m) {\n\t\t\tconst me = m.elements;\n\t\t\tthis.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\textractBasis(xAxis, yAxis, zAxis) {\n\t\t\txAxis.setFromMatrixColumn(this, 0);\n\t\t\tyAxis.setFromMatrixColumn(this, 1);\n\t\t\tzAxis.setFromMatrixColumn(this, 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeBasis(xAxis, yAxis, zAxis) {\n\t\t\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\textractRotation(m) {\n\t\t\t// this method does not support reflection matrices\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\n\t\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n\n\t\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n\n\t\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n\n\t\t\tte[0] = me[0] * scaleX;\n\t\t\tte[1] = me[1] * scaleX;\n\t\t\tte[2] = me[2] * scaleX;\n\t\t\tte[3] = 0;\n\t\t\tte[4] = me[4] * scaleY;\n\t\t\tte[5] = me[5] * scaleY;\n\t\t\tte[6] = me[6] * scaleY;\n\t\t\tte[7] = 0;\n\t\t\tte[8] = me[8] * scaleZ;\n\t\t\tte[9] = me[9] * scaleZ;\n\t\t\tte[10] = me[10] * scaleZ;\n\t\t\tte[11] = 0;\n\t\t\tte[12] = 0;\n\t\t\tte[13] = 0;\n\t\t\tte[14] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationFromEuler(euler) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tconsole.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = euler.x,\n\t\t\t\t\t\ty = euler.y,\n\t\t\t\t\t\tz = euler.z;\n\t\t\tconst a = Math.cos(x),\n\t\t\t\t\t\tb = Math.sin(x);\n\t\t\tconst c = Math.cos(y),\n\t\t\t\t\t\td = Math.sin(y);\n\t\t\tconst e = Math.cos(z),\n\t\t\t\t\t\tf = Math.sin(z);\n\n\t\t\tif (euler.order === 'XYZ') {\n\t\t\t\tconst ae = a * e,\n\t\t\t\t\t\t\taf = a * f,\n\t\t\t\t\t\t\tbe = b * e,\n\t\t\t\t\t\t\tbf = b * f;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = -c * f;\n\t\t\t\tte[8] = d;\n\t\t\t\tte[1] = af + be * d;\n\t\t\t\tte[5] = ae - bf * d;\n\t\t\t\tte[9] = -b * c;\n\t\t\t\tte[2] = bf - ae * d;\n\t\t\t\tte[6] = be + af * d;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'YXZ') {\n\t\t\t\tconst ce = c * e,\n\t\t\t\t\t\t\tcf = c * f,\n\t\t\t\t\t\t\tde = d * e,\n\t\t\t\t\t\t\tdf = d * f;\n\t\t\t\tte[0] = ce + df * b;\n\t\t\t\tte[4] = de * b - cf;\n\t\t\t\tte[8] = a * d;\n\t\t\t\tte[1] = a * f;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = -b;\n\t\t\t\tte[2] = cf * b - de;\n\t\t\t\tte[6] = df + ce * b;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'ZXY') {\n\t\t\t\tconst ce = c * e,\n\t\t\t\t\t\t\tcf = c * f,\n\t\t\t\t\t\t\tde = d * e,\n\t\t\t\t\t\t\tdf = d * f;\n\t\t\t\tte[0] = ce - df * b;\n\t\t\t\tte[4] = -a * f;\n\t\t\t\tte[8] = de + cf * b;\n\t\t\t\tte[1] = cf + de * b;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = df - ce * b;\n\t\t\t\tte[2] = -a * d;\n\t\t\t\tte[6] = b;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'ZYX') {\n\t\t\t\tconst ae = a * e,\n\t\t\t\t\t\t\taf = a * f,\n\t\t\t\t\t\t\tbe = b * e,\n\t\t\t\t\t\t\tbf = b * f;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = be * d - af;\n\t\t\t\tte[8] = ae * d + bf;\n\t\t\t\tte[1] = c * f;\n\t\t\t\tte[5] = bf * d + ae;\n\t\t\t\tte[9] = af * d - be;\n\t\t\t\tte[2] = -d;\n\t\t\t\tte[6] = b * c;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'YZX') {\n\t\t\t\tconst ac = a * c,\n\t\t\t\t\t\t\tad = a * d,\n\t\t\t\t\t\t\tbc = b * c,\n\t\t\t\t\t\t\tbd = b * d;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = bd - ac * f;\n\t\t\t\tte[8] = bc * f + ad;\n\t\t\t\tte[1] = f;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = -b * e;\n\t\t\t\tte[2] = -d * e;\n\t\t\t\tte[6] = ad * f + bc;\n\t\t\t\tte[10] = ac - bd * f;\n\t\t\t} else if (euler.order === 'XZY') {\n\t\t\t\tconst ac = a * c,\n\t\t\t\t\t\t\tad = a * d,\n\t\t\t\t\t\t\tbc = b * c,\n\t\t\t\t\t\t\tbd = b * d;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = -f;\n\t\t\t\tte[8] = d * e;\n\t\t\t\tte[1] = ac * f + bd;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = ad * f - bc;\n\t\t\t\tte[2] = bc * f - ad;\n\t\t\t\tte[6] = b * e;\n\t\t\t\tte[10] = bd * f + ac;\n\t\t\t} // bottom row\n\n\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = 0; // last column\n\n\t\t\tte[12] = 0;\n\t\t\tte[13] = 0;\n\t\t\tte[14] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationFromQuaternion(q) {\n\t\t\treturn this.compose(_zero, q, _one);\n\t\t}\n\n\t\tlookAt(eye, target, up) {\n\t\t\tconst te = this.elements;\n\n\t\t\t_z.subVectors(eye, target);\n\n\t\t\tif (_z.lengthSq() === 0) {\n\t\t\t\t// eye and target are in the same position\n\t\t\t\t_z.z = 1;\n\t\t\t}\n\n\t\t\t_z.normalize();\n\n\t\t\t_x.crossVectors(up, _z);\n\n\t\t\tif (_x.lengthSq() === 0) {\n\t\t\t\t// up and z are parallel\n\t\t\t\tif (Math.abs(up.z) === 1) {\n\t\t\t\t\t_z.x += 0.0001;\n\t\t\t\t} else {\n\t\t\t\t\t_z.z += 0.0001;\n\t\t\t\t}\n\n\t\t\t\t_z.normalize();\n\n\t\t\t\t_x.crossVectors(up, _z);\n\t\t\t}\n\n\t\t\t_x.normalize();\n\n\t\t\t_y.crossVectors(_z, _x);\n\n\t\t\tte[0] = _x.x;\n\t\t\tte[4] = _y.x;\n\t\t\tte[8] = _z.x;\n\t\t\tte[1] = _x.y;\n\t\t\tte[5] = _y.y;\n\t\t\tte[9] = _z.y;\n\t\t\tte[2] = _x.z;\n\t\t\tte[6] = _y.z;\n\t\t\tte[10] = _z.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(m, n) {\n\t\t\tif (n !== undefined) {\n\t\t\t\tconsole.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n\t\t\t\treturn this.multiplyMatrices(m, n);\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices(this, m);\n\t\t}\n\n\t\tpremultiply(m) {\n\t\t\treturn this.multiplyMatrices(m, this);\n\t\t}\n\n\t\tmultiplyMatrices(a, b) {\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = ae[0],\n\t\t\t\t\t\ta12 = ae[4],\n\t\t\t\t\t\ta13 = ae[8],\n\t\t\t\t\t\ta14 = ae[12];\n\t\t\tconst a21 = ae[1],\n\t\t\t\t\t\ta22 = ae[5],\n\t\t\t\t\t\ta23 = ae[9],\n\t\t\t\t\t\ta24 = ae[13];\n\t\t\tconst a31 = ae[2],\n\t\t\t\t\t\ta32 = ae[6],\n\t\t\t\t\t\ta33 = ae[10],\n\t\t\t\t\t\ta34 = ae[14];\n\t\t\tconst a41 = ae[3],\n\t\t\t\t\t\ta42 = ae[7],\n\t\t\t\t\t\ta43 = ae[11],\n\t\t\t\t\t\ta44 = ae[15];\n\t\t\tconst b11 = be[0],\n\t\t\t\t\t\tb12 = be[4],\n\t\t\t\t\t\tb13 = be[8],\n\t\t\t\t\t\tb14 = be[12];\n\t\t\tconst b21 = be[1],\n\t\t\t\t\t\tb22 = be[5],\n\t\t\t\t\t\tb23 = be[9],\n\t\t\t\t\t\tb24 = be[13];\n\t\t\tconst b31 = be[2],\n\t\t\t\t\t\tb32 = be[6],\n\t\t\t\t\t\tb33 = be[10],\n\t\t\t\t\t\tb34 = be[14];\n\t\t\tconst b41 = be[3],\n\t\t\t\t\t\tb42 = be[7],\n\t\t\t\t\t\tb43 = be[11],\n\t\t\t\t\t\tb44 = be[15];\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= s;\n\t\t\tte[4] *= s;\n\t\t\tte[8] *= s;\n\t\t\tte[12] *= s;\n\t\t\tte[1] *= s;\n\t\t\tte[5] *= s;\n\t\t\tte[9] *= s;\n\t\t\tte[13] *= s;\n\t\t\tte[2] *= s;\n\t\t\tte[6] *= s;\n\t\t\tte[10] *= s;\n\t\t\tte[14] *= s;\n\t\t\tte[3] *= s;\n\t\t\tte[7] *= s;\n\t\t\tte[11] *= s;\n\t\t\tte[15] *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeterminant() {\n\t\t\tconst te = this.elements;\n\t\t\tconst n11 = te[0],\n\t\t\t\t\t\tn12 = te[4],\n\t\t\t\t\t\tn13 = te[8],\n\t\t\t\t\t\tn14 = te[12];\n\t\t\tconst n21 = te[1],\n\t\t\t\t\t\tn22 = te[5],\n\t\t\t\t\t\tn23 = te[9],\n\t\t\t\t\t\tn24 = te[13];\n\t\t\tconst n31 = te[2],\n\t\t\t\t\t\tn32 = te[6],\n\t\t\t\t\t\tn33 = te[10],\n\t\t\t\t\t\tn34 = te[14];\n\t\t\tconst n41 = te[3],\n\t\t\t\t\t\tn42 = te[7],\n\t\t\t\t\t\tn43 = te[11],\n\t\t\t\t\t\tn44 = te[15]; //TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n\t\t}\n\n\t\ttranspose() {\n\t\t\tconst te = this.elements;\n\t\t\tlet tmp;\n\t\t\ttmp = te[1];\n\t\t\tte[1] = te[4];\n\t\t\tte[4] = tmp;\n\t\t\ttmp = te[2];\n\t\t\tte[2] = te[8];\n\t\t\tte[8] = tmp;\n\t\t\ttmp = te[6];\n\t\t\tte[6] = te[9];\n\t\t\tte[9] = tmp;\n\t\t\ttmp = te[3];\n\t\t\tte[3] = te[12];\n\t\t\tte[12] = tmp;\n\t\t\ttmp = te[7];\n\t\t\tte[7] = te[13];\n\t\t\tte[13] = tmp;\n\t\t\ttmp = te[11];\n\t\t\tte[11] = te[14];\n\t\t\tte[14] = tmp;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetPosition(x, y, z) {\n\t\t\tconst te = this.elements;\n\n\t\t\tif (x.isVector3) {\n\t\t\t\tte[12] = x.x;\n\t\t\t\tte[13] = x.y;\n\t\t\t\tte[14] = x.z;\n\t\t\t} else {\n\t\t\t\tte[12] = x;\n\t\t\t\tte[13] = y;\n\t\t\t\tte[14] = z;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tinvert() {\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tn11 = te[0],\n\t\t\t\t\t\tn21 = te[1],\n\t\t\t\t\t\tn31 = te[2],\n\t\t\t\t\t\tn41 = te[3],\n\t\t\t\t\t\tn12 = te[4],\n\t\t\t\t\t\tn22 = te[5],\n\t\t\t\t\t\tn32 = te[6],\n\t\t\t\t\t\tn42 = te[7],\n\t\t\t\t\t\tn13 = te[8],\n\t\t\t\t\t\tn23 = te[9],\n\t\t\t\t\t\tn33 = te[10],\n\t\t\t\t\t\tn43 = te[11],\n\t\t\t\t\t\tn14 = te[12],\n\t\t\t\t\t\tn24 = te[13],\n\t\t\t\t\t\tn34 = te[14],\n\t\t\t\t\t\tn44 = te[15],\n\t\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\t\tif (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t\t\tconst detInv = 1 / det;\n\t\t\tte[0] = t11 * detInv;\n\t\t\tte[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n\t\t\tte[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n\t\t\tte[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n\t\t\tte[4] = t12 * detInv;\n\t\t\tte[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n\t\t\tte[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n\t\t\tte[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n\t\t\tte[8] = t13 * detInv;\n\t\t\tte[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n\t\t\tte[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n\t\t\tte[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n\t\t\tte[12] = t14 * detInv;\n\t\t\tte[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n\t\t\tte[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n\t\t\tte[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(v) {\n\t\t\tconst te = this.elements;\n\t\t\tconst x = v.x,\n\t\t\t\t\t\ty = v.y,\n\t\t\t\t\t\tz = v.z;\n\t\t\tte[0] *= x;\n\t\t\tte[4] *= y;\n\t\t\tte[8] *= z;\n\t\t\tte[1] *= x;\n\t\t\tte[5] *= y;\n\t\t\tte[9] *= z;\n\t\t\tte[2] *= x;\n\t\t\tte[6] *= y;\n\t\t\tte[10] *= z;\n\t\t\tte[3] *= x;\n\t\t\tte[7] *= y;\n\t\t\tte[11] *= z;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMaxScaleOnAxis() {\n\t\t\tconst te = this.elements;\n\t\t\tconst scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\t\tconst scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\t\tconst scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\t\t\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n\t\t}\n\n\t\tmakeTranslation(x, y, z) {\n\t\t\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationX(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationY(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationZ(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationAxis(axis, angle) {\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\t\tconst c = Math.cos(angle);\n\t\t\tconst s = Math.sin(angle);\n\t\t\tconst t = 1 - c;\n\t\t\tconst x = axis.x,\n\t\t\t\t\t\ty = axis.y,\n\t\t\t\t\t\tz = axis.z;\n\t\t\tconst tx = t * x,\n\t\t\t\t\t\tty = t * y;\n\t\t\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeScale(x, y, z) {\n\t\t\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeShear(xy, xz, yx, yz, zx, zy) {\n\t\t\tthis.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tcompose(position, quaternion, scale) {\n\t\t\tconst te = this.elements;\n\t\t\tconst x = quaternion._x,\n\t\t\t\t\t\ty = quaternion._y,\n\t\t\t\t\t\tz = quaternion._z,\n\t\t\t\t\t\tw = quaternion._w;\n\t\t\tconst x2 = x + x,\n\t\t\t\t\t\ty2 = y + y,\n\t\t\t\t\t\tz2 = z + z;\n\t\t\tconst xx = x * x2,\n\t\t\t\t\t\txy = x * y2,\n\t\t\t\t\t\txz = x * z2;\n\t\t\tconst yy = y * y2,\n\t\t\t\t\t\tyz = y * z2,\n\t\t\t\t\t\tzz = z * z2;\n\t\t\tconst wx = w * x2,\n\t\t\t\t\t\twy = w * y2,\n\t\t\t\t\t\twz = w * z2;\n\t\t\tconst sx = scale.x,\n\t\t\t\t\t\tsy = scale.y,\n\t\t\t\t\t\tsz = scale.z;\n\t\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\t\tte[1] = (xy + wz) * sx;\n\t\t\tte[2] = (xz - wy) * sx;\n\t\t\tte[3] = 0;\n\t\t\tte[4] = (xy - wz) * sy;\n\t\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\t\tte[6] = (yz + wx) * sy;\n\t\t\tte[7] = 0;\n\t\t\tte[8] = (xz + wy) * sz;\n\t\t\tte[9] = (yz - wx) * sz;\n\t\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\t\tte[11] = 0;\n\t\t\tte[12] = position.x;\n\t\t\tte[13] = position.y;\n\t\t\tte[14] = position.z;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tdecompose(position, quaternion, scale) {\n\t\t\tconst te = this.elements;\n\n\t\t\tlet sx = _v1$5.set(te[0], te[1], te[2]).length();\n\n\t\t\tconst sy = _v1$5.set(te[4], te[5], te[6]).length();\n\n\t\t\tconst sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale\n\n\n\t\t\tconst det = this.determinant();\n\t\t\tif (det < 0) sx = -sx;\n\t\t\tposition.x = te[12];\n\t\t\tposition.y = te[13];\n\t\t\tposition.z = te[14]; // scale the rotation part\n\n\t\t\t_m1$2.copy(this);\n\n\t\t\tconst invSX = 1 / sx;\n\t\t\tconst invSY = 1 / sy;\n\t\t\tconst invSZ = 1 / sz;\n\t\t\t_m1$2.elements[0] *= invSX;\n\t\t\t_m1$2.elements[1] *= invSX;\n\t\t\t_m1$2.elements[2] *= invSX;\n\t\t\t_m1$2.elements[4] *= invSY;\n\t\t\t_m1$2.elements[5] *= invSY;\n\t\t\t_m1$2.elements[6] *= invSY;\n\t\t\t_m1$2.elements[8] *= invSZ;\n\t\t\t_m1$2.elements[9] *= invSZ;\n\t\t\t_m1$2.elements[10] *= invSZ;\n\t\t\tquaternion.setFromRotationMatrix(_m1$2);\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakePerspective(left, right, top, bottom, near, far) {\n\t\t\tif (far === undefined) {\n\t\t\t\tconsole.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\n\t\t\t}\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = 2 * near / (right - left);\n\t\t\tconst y = 2 * near / (top - bottom);\n\t\t\tconst a = (right + left) / (right - left);\n\t\t\tconst b = (top + bottom) / (top - bottom);\n\t\t\tconst c = -(far + near) / (far - near);\n\t\t\tconst d = -2 * far * near / (far - near);\n\t\t\tte[0] = x;\n\t\t\tte[4] = 0;\n\t\t\tte[8] = a;\n\t\t\tte[12] = 0;\n\t\t\tte[1] = 0;\n\t\t\tte[5] = y;\n\t\t\tte[9] = b;\n\t\t\tte[13] = 0;\n\t\t\tte[2] = 0;\n\t\t\tte[6] = 0;\n\t\t\tte[10] = c;\n\t\t\tte[14] = d;\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = -1;\n\t\t\tte[15] = 0;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeOrthographic(left, right, top, bottom, near, far) {\n\t\t\tconst te = this.elements;\n\t\t\tconst w = 1.0 / (right - left);\n\t\t\tconst h = 1.0 / (top - bottom);\n\t\t\tconst p = 1.0 / (far - near);\n\t\t\tconst x = (right + left) * w;\n\t\t\tconst y = (top + bottom) * h;\n\t\t\tconst z = (far + near) * p;\n\t\t\tte[0] = 2 * w;\n\t\t\tte[4] = 0;\n\t\t\tte[8] = 0;\n\t\t\tte[12] = -x;\n\t\t\tte[1] = 0;\n\t\t\tte[5] = 2 * h;\n\t\t\tte[9] = 0;\n\t\t\tte[13] = -y;\n\t\t\tte[2] = 0;\n\t\t\tte[6] = 0;\n\t\t\tte[10] = -2 * p;\n\t\t\tte[14] = -z;\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(matrix) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst te = this.elements;\n\t\t\tarray[offset] = te[0];\n\t\t\tarray[offset + 1] = te[1];\n\t\t\tarray[offset + 2] = te[2];\n\t\t\tarray[offset + 3] = te[3];\n\t\t\tarray[offset + 4] = te[4];\n\t\t\tarray[offset + 5] = te[5];\n\t\t\tarray[offset + 6] = te[6];\n\t\t\tarray[offset + 7] = te[7];\n\t\t\tarray[offset + 8] = te[8];\n\t\t\tarray[offset + 9] = te[9];\n\t\t\tarray[offset + 10] = te[10];\n\t\t\tarray[offset + 11] = te[11];\n\t\t\tarray[offset + 12] = te[12];\n\t\t\tarray[offset + 13] = te[13];\n\t\t\tarray[offset + 14] = te[14];\n\t\t\tarray[offset + 15] = te[15];\n\t\t\treturn array;\n\t\t}\n\n\t}\n\n\tMatrix4.prototype.isMatrix4 = true;\n\n\tconst _v1$5 = /*@__PURE__*/new Vector3();\n\n\tconst _m1$2 = /*@__PURE__*/new Matrix4();\n\n\tconst _zero = /*@__PURE__*/new Vector3(0, 0, 0);\n\n\tconst _one = /*@__PURE__*/new Vector3(1, 1, 1);\n\n\tconst _x = /*@__PURE__*/new Vector3();\n\n\tconst _y = /*@__PURE__*/new Vector3();\n\n\tconst _z = /*@__PURE__*/new Vector3();\n\n\tconst _matrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _quaternion$3 = /*@__PURE__*/new Quaternion();\n\n\tclass Euler {\n\t\tconstructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order;\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x;\n\t\t}\n\n\t\tset x(value) {\n\t\t\tthis._x = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y;\n\t\t}\n\n\t\tset y(value) {\n\t\t\tthis._y = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget z() {\n\t\t\treturn this._z;\n\t\t}\n\n\t\tset z(value) {\n\t\t\tthis._z = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget order() {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tset order(value) {\n\t\t\tthis._order = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tset(x, y, z, order) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this._x, this._y, this._z, this._order);\n\t\t}\n\n\t\tcopy(euler) {\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromRotationMatrix(m, order, update) {\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tconst te = m.elements;\n\t\t\tconst m11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8];\n\t\t\tconst m21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9];\n\t\t\tconst m31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10];\n\t\t\torder = order || this._order;\n\n\t\t\tswitch (order) {\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._y = Math.asin(clamp(m13, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m13) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = Math.asin(-clamp(m23, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m23) < 0.9999999) {\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m22);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = Math.asin(clamp(m32, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m32) < 0.9999999) {\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._y = Math.asin(-clamp(m31, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m31) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._z = Math.asin(clamp(m21, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m21) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m22);\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._z = Math.asin(-clamp(m12, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m12) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n\t\t\t}\n\n\t\t\tthis._order = order;\n\t\t\tif (update !== false) this._onChangeCallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromQuaternion(q, order, update) {\n\t\t\t_matrix$1.makeRotationFromQuaternion(q);\n\n\t\t\treturn this.setFromRotationMatrix(_matrix$1, order, update);\n\t\t}\n\n\t\tsetFromVector3(v, order) {\n\t\t\treturn this.set(v.x, v.y, v.z, order || this._order);\n\t\t}\n\n\t\treorder(newOrder) {\n\t\t\t// WARNING: this discards revolution information -bhouston\n\t\t\t_quaternion$3.setFromEuler(this);\n\n\t\t\treturn this.setFromQuaternion(_quaternion$3, newOrder);\n\t\t}\n\n\t\tequals(euler) {\n\t\t\treturn euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n\t\t}\n\n\t\tfromArray(array) {\n\t\t\tthis._x = array[0];\n\t\t\tthis._y = array[1];\n\t\t\tthis._z = array[2];\n\t\t\tif (array[3] !== undefined) this._order = array[3];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this._x;\n\t\t\tarray[offset + 1] = this._y;\n\t\t\tarray[offset + 2] = this._z;\n\t\t\tarray[offset + 3] = this._order;\n\t\t\treturn array;\n\t\t}\n\n\t\ttoVector3(optionalResult) {\n\t\t\tif (optionalResult) {\n\t\t\t\treturn optionalResult.set(this._x, this._y, this._z);\n\t\t\t} else {\n\t\t\t\treturn new Vector3(this._x, this._y, this._z);\n\t\t\t}\n\t\t}\n\n\t\t_onChange(callback) {\n\t\t\tthis._onChangeCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t}\n\n\tEuler.prototype.isEuler = true;\n\tEuler.DefaultOrder = 'XYZ';\n\tEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\n\n\tclass Layers {\n\t\tconstructor() {\n\t\t\tthis.mask = 1 | 0;\n\t\t}\n\n\t\tset(channel) {\n\t\t\tthis.mask = 1 << channel | 0;\n\t\t}\n\n\t\tenable(channel) {\n\t\t\tthis.mask |= 1 << channel | 0;\n\t\t}\n\n\t\tenableAll() {\n\t\t\tthis.mask = 0xffffffff | 0;\n\t\t}\n\n\t\ttoggle(channel) {\n\t\t\tthis.mask ^= 1 << channel | 0;\n\t\t}\n\n\t\tdisable(channel) {\n\t\t\tthis.mask &= ~(1 << channel | 0);\n\t\t}\n\n\t\tdisableAll() {\n\t\t\tthis.mask = 0;\n\t\t}\n\n\t\ttest(layers) {\n\t\t\treturn (this.mask & layers.mask) !== 0;\n\t\t}\n\n\t}\n\n\tlet _object3DId = 0;\n\n\tconst _v1$4 = /*@__PURE__*/new Vector3();\n\n\tconst _q1 = /*@__PURE__*/new Quaternion();\n\n\tconst _m1$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _target = /*@__PURE__*/new Vector3();\n\n\tconst _position$3 = /*@__PURE__*/new Vector3();\n\n\tconst _scale$2 = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$2 = /*@__PURE__*/new Quaternion();\n\n\tconst _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);\n\n\tconst _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);\n\n\tconst _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);\n\n\tconst _addedEvent = {\n\t\ttype: 'added'\n\t};\n\tconst _removedEvent = {\n\t\ttype: 'removed'\n\t};\n\n\tclass Object3D extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: _object3DId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\t\tconst position = new Vector3();\n\t\t\tconst rotation = new Euler();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3(1, 1, 1);\n\n\t\t\tfunction onRotationChange() {\n\t\t\t\tquaternion.setFromEuler(rotation, false);\n\t\t\t}\n\n\t\t\tfunction onQuaternionChange() {\n\t\t\t\trotation.setFromQuaternion(quaternion, undefined, false);\n\t\t\t}\n\n\t\t\trotation._onChange(onRotationChange);\n\n\t\t\tquaternion._onChange(onQuaternionChange);\n\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tposition: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\t\tthis.animations = [];\n\t\t\tthis.userData = {};\n\t\t}\n\n\t\tonBeforeRender() {}\n\n\t\tonAfterRender() {}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\t\t\tthis.matrix.premultiply(matrix);\n\t\t\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\tthis.quaternion.premultiply(q);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRotationFromAxisAngle(axis, angle) {\n\t\t\t// assumes axis is normalized\n\t\t\tthis.quaternion.setFromAxisAngle(axis, angle);\n\t\t}\n\n\t\tsetRotationFromEuler(euler) {\n\t\t\tthis.quaternion.setFromEuler(euler, true);\n\t\t}\n\n\t\tsetRotationFromMatrix(m) {\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tthis.quaternion.setFromRotationMatrix(m);\n\t\t}\n\n\t\tsetRotationFromQuaternion(q) {\n\t\t\t// assumes q is normalized\n\t\t\tthis.quaternion.copy(q);\n\t\t}\n\n\t\trotateOnAxis(axis, angle) {\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\t\t_q1.setFromAxisAngle(axis, angle);\n\n\t\t\tthis.quaternion.multiply(_q1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateOnWorldAxis(axis, angle) {\n\t\t\t// rotate object on axis in world space\n\t\t\t// axis is assumed to be normalized\n\t\t\t// method assumes no rotated parent\n\t\t\t_q1.setFromAxisAngle(axis, angle);\n\n\t\t\tthis.quaternion.premultiply(_q1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateX(angle) {\n\t\t\treturn this.rotateOnAxis(_xAxis, angle);\n\t\t}\n\n\t\trotateY(angle) {\n\t\t\treturn this.rotateOnAxis(_yAxis, angle);\n\t\t}\n\n\t\trotateZ(angle) {\n\t\t\treturn this.rotateOnAxis(_zAxis, angle);\n\t\t}\n\n\t\ttranslateOnAxis(axis, distance) {\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\t\t_v1$4.copy(axis).applyQuaternion(this.quaternion);\n\n\t\t\tthis.position.add(_v1$4.multiplyScalar(distance));\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslateX(distance) {\n\t\t\treturn this.translateOnAxis(_xAxis, distance);\n\t\t}\n\n\t\ttranslateY(distance) {\n\t\t\treturn this.translateOnAxis(_yAxis, distance);\n\t\t}\n\n\t\ttranslateZ(distance) {\n\t\t\treturn this.translateOnAxis(_zAxis, distance);\n\t\t}\n\n\t\tlocalToWorld(vector) {\n\t\t\treturn vector.applyMatrix4(this.matrixWorld);\n\t\t}\n\n\t\tworldToLocal(vector) {\n\t\t\treturn vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n\t\t}\n\n\t\tlookAt(x, y, z) {\n\t\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\t\t\tif (x.isVector3) {\n\t\t\t\t_target.copy(x);\n\t\t\t} else {\n\t\t\t\t_target.set(x, y, z);\n\t\t\t}\n\n\t\t\tconst parent = this.parent;\n\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t_position$3.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\tif (this.isCamera || this.isLight) {\n\t\t\t\t_m1$1.lookAt(_position$3, _target, this.up);\n\t\t\t} else {\n\t\t\t\t_m1$1.lookAt(_target, _position$3, this.up);\n\t\t\t}\n\n\t\t\tthis.quaternion.setFromRotationMatrix(_m1$1);\n\n\t\t\tif (parent) {\n\t\t\t\t_m1$1.extractRotation(parent.matrixWorld);\n\n\t\t\t\t_q1.setFromRotationMatrix(_m1$1);\n\n\t\t\t\tthis.quaternion.premultiply(_q1.invert());\n\t\t\t}\n\t\t}\n\n\t\tadd(object) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\tthis.add(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (object === this) {\n\t\t\t\tconsole.error('THREE.Object3D.add: object can\\'t be added as a child of itself.', object);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (object && object.isObject3D) {\n\t\t\t\tif (object.parent !== null) {\n\t\t\t\t\tobject.parent.remove(object);\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tthis.children.push(object);\n\t\t\t\tobject.dispatchEvent(_addedEvent);\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tremove(object) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\tthis.remove(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst index = this.children.indexOf(object);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tobject.parent = null;\n\t\t\t\tthis.children.splice(index, 1);\n\t\t\t\tobject.dispatchEvent(_removedEvent);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tremoveFromParent() {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (parent !== null) {\n\t\t\t\tparent.remove(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclear() {\n\t\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\t\tconst object = this.children[i];\n\t\t\t\tobject.parent = null;\n\t\t\t\tobject.dispatchEvent(_removedEvent);\n\t\t\t}\n\n\t\t\tthis.children.length = 0;\n\t\t\treturn this;\n\t\t}\n\n\t\tattach(object) {\n\t\t\t// adds object as a child of this, while maintaining the object's world transform\n\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t_m1$1.copy(this.matrixWorld).invert();\n\n\t\t\tif (object.parent !== null) {\n\t\t\t\tobject.parent.updateWorldMatrix(true, false);\n\n\t\t\t\t_m1$1.multiply(object.parent.matrixWorld);\n\t\t\t}\n\n\t\t\tobject.applyMatrix4(_m1$1);\n\t\t\tthis.add(object);\n\t\t\tobject.updateWorldMatrix(false, true);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetObjectById(id) {\n\t\t\treturn this.getObjectByProperty('id', id);\n\t\t}\n\n\t\tgetObjectByName(name) {\n\t\t\treturn this.getObjectByProperty('name', name);\n\t\t}\n\n\t\tgetObjectByProperty(name, value) {\n\t\t\tif (this[name] === value) return this;\n\n\t\t\tfor (let i = 0, l = this.children.length; i < l; i++) {\n\t\t\t\tconst child = this.children[i];\n\t\t\t\tconst object = child.getObjectByProperty(name, value);\n\n\t\t\t\tif (object !== undefined) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tgetWorldPosition(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldPosition() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\treturn target.setFromMatrixPosition(this.matrixWorld);\n\t\t}\n\n\t\tgetWorldQuaternion(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldQuaternion() target is now required');\n\t\t\t\ttarget = new Quaternion();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tthis.matrixWorld.decompose(_position$3, target, _scale$2);\n\t\t\treturn target;\n\t\t}\n\n\t\tgetWorldScale(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldScale() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tthis.matrixWorld.decompose(_position$3, _quaternion$2, target);\n\t\t\treturn target;\n\t\t}\n\n\t\tgetWorldDirection(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldDirection() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tconst e = this.matrixWorld.elements;\n\t\t\treturn target.set(e[8], e[9], e[10]).normalize();\n\t\t}\n\n\t\traycast() {}\n\n\t\ttraverse(callback) {\n\t\t\tcallback(this);\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].traverse(callback);\n\t\t\t}\n\t\t}\n\n\t\ttraverseVisible(callback) {\n\t\t\tif (this.visible === false) return;\n\t\t\tcallback(this);\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].traverseVisible(callback);\n\t\t\t}\n\t\t}\n\n\t\ttraverseAncestors(callback) {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (parent !== null) {\n\t\t\t\tcallback(parent);\n\t\t\t\tparent.traverseAncestors(callback);\n\t\t\t}\n\t\t}\n\n\t\tupdateMatrix() {\n\t\t\tthis.matrix.compose(this.position, this.quaternion, this.scale);\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\tif (this.matrixWorldNeedsUpdate || force) {\n\t\t\t\tif (this.parent === null) {\n\t\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t\t} else {\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\t\t\tforce = true;\n\t\t\t} // update children\n\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].updateMatrixWorld(force);\n\t\t\t}\n\t\t}\n\n\t\tupdateWorldMatrix(updateParents, updateChildren) {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (updateParents === true && parent !== null) {\n\t\t\t\tparent.updateWorldMatrix(true, false);\n\t\t\t}\n\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\tif (this.parent === null) {\n\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t} else {\n\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t} // update children\n\n\n\t\t\tif (updateChildren === true) {\n\t\t\t\tconst children = this.children;\n\n\t\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchildren[i].updateWorldMatrix(false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\t// meta is a string when called from JSON.stringify\n\t\t\tconst isRootObject = meta === undefined || typeof meta === 'string';\n\t\t\tconst output = {}; // meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\n\t\t\tif (isRootObject) {\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {},\n\t\t\t\t\tshapes: {},\n\t\t\t\t\tskeletons: {},\n\t\t\t\t\tanimations: {}\n\t\t\t\t};\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\t\t\t} // standard Object3D serialization\n\n\n\t\t\tconst object = {};\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\t\t\tif (this.name !== '') object.name = this.name;\n\t\t\tif (this.castShadow === true) object.castShadow = true;\n\t\t\tif (this.receiveShadow === true) object.receiveShadow = true;\n\t\t\tif (this.visible === false) object.visible = false;\n\t\t\tif (this.frustumCulled === false) object.frustumCulled = false;\n\t\t\tif (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n\t\t\tif (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\n\t\t\tobject.layers = this.layers.mask;\n\t\t\tobject.matrix = this.matrix.toArray();\n\t\t\tif (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties\n\n\t\t\tif (this.isInstancedMesh) {\n\t\t\t\tobject.type = 'InstancedMesh';\n\t\t\t\tobject.count = this.count;\n\t\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\t\tif (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n\t\t\t} //\n\n\n\t\t\tfunction serialize(library, element) {\n\t\t\t\tif (library[element.uuid] === undefined) {\n\t\t\t\t\tlibrary[element.uuid] = element.toJSON(meta);\n\t\t\t\t}\n\n\t\t\t\treturn element.uuid;\n\t\t\t}\n\n\t\t\tif (this.isMesh || this.isLine || this.isPoints) {\n\t\t\t\tobject.geometry = serialize(meta.geometries, this.geometry);\n\t\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\t\tif (parameters !== undefined && parameters.shapes !== undefined) {\n\t\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\t\tif (Array.isArray(shapes)) {\n\t\t\t\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\t\t\t\tconst shape = shapes[i];\n\t\t\t\t\t\t\tserialize(meta.shapes, shape);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tserialize(meta.shapes, shapes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isSkinnedMesh) {\n\t\t\t\tobject.bindMode = this.bindMode;\n\t\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\t\tif (this.skeleton !== undefined) {\n\t\t\t\t\tserialize(meta.skeletons, this.skeleton);\n\t\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.material !== undefined) {\n\t\t\t\tif (Array.isArray(this.material)) {\n\t\t\t\t\tconst uuids = [];\n\n\t\t\t\t\tfor (let i = 0, l = this.material.length; i < l; i++) {\n\t\t\t\t\t\tuuids.push(serialize(meta.materials, this.material[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.material = uuids;\n\t\t\t\t} else {\n\t\t\t\t\tobject.material = serialize(meta.materials, this.material);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tif (this.children.length > 0) {\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\t\t\tobject.children.push(this.children[i].toJSON(meta).object);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tif (this.animations.length > 0) {\n\t\t\t\tobject.animations = [];\n\n\t\t\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\t\t\tconst animation = this.animations[i];\n\t\t\t\t\tobject.animations.push(serialize(meta.animations, animation));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRootObject) {\n\t\t\t\tconst geometries = extractFromCache(meta.geometries);\n\t\t\t\tconst materials = extractFromCache(meta.materials);\n\t\t\t\tconst textures = extractFromCache(meta.textures);\n\t\t\t\tconst images = extractFromCache(meta.images);\n\t\t\t\tconst shapes = extractFromCache(meta.shapes);\n\t\t\t\tconst skeletons = extractFromCache(meta.skeletons);\n\t\t\t\tconst animations = extractFromCache(meta.animations);\n\t\t\t\tif (geometries.length > 0) output.geometries = geometries;\n\t\t\t\tif (materials.length > 0) output.materials = materials;\n\t\t\t\tif (textures.length > 0) output.textures = textures;\n\t\t\t\tif (images.length > 0) output.images = images;\n\t\t\t\tif (shapes.length > 0) output.shapes = shapes;\n\t\t\t\tif (skeletons.length > 0) output.skeletons = skeletons;\n\t\t\t\tif (animations.length > 0) output.animations = animations;\n\t\t\t}\n\n\t\t\toutput.object = object;\n\t\t\treturn output; // extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\n\t\t\tfunction extractFromCache(cache) {\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (const key in cache) {\n\t\t\t\t\tconst data = cache[key];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push(data);\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\n\t\tclone(recursive) {\n\t\t\treturn new this.constructor().copy(this, recursive);\n\t\t}\n\n\t\tcopy(source, recursive = true) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.up.copy(source.up);\n\t\t\tthis.position.copy(source.position);\n\t\t\tthis.rotation.order = source.rotation.order;\n\t\t\tthis.quaternion.copy(source.quaternion);\n\t\t\tthis.scale.copy(source.scale);\n\t\t\tthis.matrix.copy(source.matrix);\n\t\t\tthis.matrixWorld.copy(source.matrixWorld);\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\n\t\t\tif (recursive === true) {\n\t\t\t\tfor (let i = 0; i < source.children.length; i++) {\n\t\t\t\t\tconst child = source.children[i];\n\t\t\t\t\tthis.add(child.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3(0, 1, 0);\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\tObject3D.prototype.isObject3D = true;\n\n\tconst _vector1 = /*@__PURE__*/new Vector3();\n\n\tconst _vector2$1 = /*@__PURE__*/new Vector3();\n\n\tconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\n\tclass Plane {\n\t\tconstructor(normal = new Vector3(1, 0, 0), constant = 0) {\n\t\t\t// normal is assumed to be normalized\n\t\t\tthis.normal = normal;\n\t\t\tthis.constant = constant;\n\t\t}\n\n\t\tset(normal, constant) {\n\t\t\tthis.normal.copy(normal);\n\t\t\tthis.constant = constant;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponents(x, y, z, w) {\n\t\t\tthis.normal.set(x, y, z);\n\t\t\tthis.constant = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromNormalAndCoplanarPoint(normal, point) {\n\t\t\tthis.normal.copy(normal);\n\t\t\tthis.constant = -point.dot(this.normal);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCoplanarPoints(a, b, c) {\n\t\t\tconst normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n\t\t\tthis.setFromNormalAndCoplanarPoint(normal, a);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(plane) {\n\t\t\tthis.normal.copy(plane.normal);\n\t\t\tthis.constant = plane.constant;\n\t\t\treturn this;\n\t\t}\n\n\t\tnormalize() {\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar(inverseNormalLength);\n\t\t\tthis.constant *= inverseNormalLength;\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.constant *= -1;\n\t\t\tthis.normal.negate();\n\t\t\treturn this;\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn this.normal.dot(point) + this.constant;\n\t\t}\n\n\t\tdistanceToSphere(sphere) {\n\t\t\treturn this.distanceToPoint(sphere.center) - sphere.radius;\n\t\t}\n\n\t\tprojectPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .projectPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n\t\t}\n\n\t\tintersectLine(line, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .intersectLine() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tconst direction = line.delta(_vector1);\n\t\t\tconst denominator = this.normal.dot(direction);\n\n\t\t\tif (denominator === 0) {\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif (this.distanceToPoint(line.start) === 0) {\n\t\t\t\t\treturn target.copy(line.start);\n\t\t\t\t} // Unsure if this is the correct method to handle this case.\n\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n\t\t\tif (t < 0 || t > 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn target.copy(direction).multiplyScalar(t).add(line.start);\n\t\t}\n\n\t\tintersectsLine(line) {\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\t\tconst startSign = this.distanceToPoint(line.start);\n\t\t\tconst endSign = this.distanceToPoint(line.end);\n\t\t\treturn startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsPlane(this);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\treturn sphere.intersectsPlane(this);\n\t\t}\n\n\t\tcoplanarPoint(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .coplanarPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.normal).multiplyScalar(-this.constant);\n\t\t}\n\n\t\tapplyMatrix4(matrix, optionalNormalMatrix) {\n\t\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n\t\t\tconst referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n\t\t\tconst normal = this.normal.applyMatrix3(normalMatrix).normalize();\n\t\t\tthis.constant = -referencePoint.dot(normal);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.constant -= offset.dot(this.normal);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(plane) {\n\t\t\treturn plane.normal.equals(this.normal) && plane.constant === this.constant;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tPlane.prototype.isPlane = true;\n\n\tconst _v0$1 = /*@__PURE__*/new Vector3();\n\n\tconst _v1$3 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v3$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vab = /*@__PURE__*/new Vector3();\n\n\tconst _vac = /*@__PURE__*/new Vector3();\n\n\tconst _vbc = /*@__PURE__*/new Vector3();\n\n\tconst _vap = /*@__PURE__*/new Vector3();\n\n\tconst _vbp = /*@__PURE__*/new Vector3();\n\n\tconst _vcp = /*@__PURE__*/new Vector3();\n\n\tclass Triangle {\n\t\tconstructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tstatic getNormal(a, b, c, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getNormal() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.subVectors(c, b);\n\n\t\t\t_v0$1.subVectors(a, b);\n\n\t\t\ttarget.cross(_v0$1);\n\t\t\tconst targetLengthSq = target.lengthSq();\n\n\t\t\tif (targetLengthSq > 0) {\n\t\t\t\treturn target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n\t\t\t}\n\n\t\t\treturn target.set(0, 0, 0);\n\t\t} // static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\n\t\tstatic getBarycoord(point, a, b, c, target) {\n\t\t\t_v0$1.subVectors(c, a);\n\n\t\t\t_v1$3.subVectors(b, a);\n\n\t\t\t_v2$2.subVectors(point, a);\n\n\t\t\tconst dot00 = _v0$1.dot(_v0$1);\n\n\t\t\tconst dot01 = _v0$1.dot(_v1$3);\n\n\t\t\tconst dot02 = _v0$1.dot(_v2$2);\n\n\t\t\tconst dot11 = _v1$3.dot(_v1$3);\n\n\t\t\tconst dot12 = _v1$3.dot(_v2$2);\n\n\t\t\tconst denom = dot00 * dot11 - dot01 * dot01;\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getBarycoord() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t} // collinear or singular triangle\n\n\n\t\t\tif (denom === 0) {\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn target.set(-2, -1, -1);\n\t\t\t}\n\n\t\t\tconst invDenom = 1 / denom;\n\t\t\tconst u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\t\t\tconst v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n\t\t\treturn target.set(1 - u - v, v, u);\n\t\t}\n\n\t\tstatic containsPoint(point, a, b, c) {\n\t\t\tthis.getBarycoord(point, a, b, c, _v3$1);\n\t\t\treturn _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n\t\t}\n\n\t\tstatic getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n\t\t\tthis.getBarycoord(point, p1, p2, p3, _v3$1);\n\t\t\ttarget.set(0, 0);\n\t\t\ttarget.addScaledVector(uv1, _v3$1.x);\n\t\t\ttarget.addScaledVector(uv2, _v3$1.y);\n\t\t\ttarget.addScaledVector(uv3, _v3$1.z);\n\t\t\treturn target;\n\t\t}\n\n\t\tstatic isFrontFacing(a, b, c, direction) {\n\t\t\t_v0$1.subVectors(c, b);\n\n\t\t\t_v1$3.subVectors(a, b); // strictly front facing\n\n\n\t\t\treturn _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n\t\t}\n\n\t\tset(a, b, c) {\n\t\t\tthis.a.copy(a);\n\t\t\tthis.b.copy(b);\n\t\t\tthis.c.copy(c);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPointsAndIndices(points, i0, i1, i2) {\n\t\t\tthis.a.copy(points[i0]);\n\t\t\tthis.b.copy(points[i1]);\n\t\t\tthis.c.copy(points[i2]);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(triangle) {\n\t\t\tthis.a.copy(triangle.a);\n\t\t\tthis.b.copy(triangle.b);\n\t\t\tthis.c.copy(triangle.c);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetArea() {\n\t\t\t_v0$1.subVectors(this.c, this.b);\n\n\t\t\t_v1$3.subVectors(this.a, this.b);\n\n\t\t\treturn _v0$1.cross(_v1$3).length() * 0.5;\n\t\t}\n\n\t\tgetMidpoint(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getMidpoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n\t\t}\n\n\t\tgetNormal(target) {\n\t\t\treturn Triangle.getNormal(this.a, this.b, this.c, target);\n\t\t}\n\n\t\tgetPlane(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getPlane() target is now required');\n\t\t\t\ttarget = new Plane();\n\t\t\t}\n\n\t\t\treturn target.setFromCoplanarPoints(this.a, this.b, this.c);\n\t\t}\n\n\t\tgetBarycoord(point, target) {\n\t\t\treturn Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n\t\t}\n\n\t\tgetUV(point, uv1, uv2, uv3, target) {\n\t\t\treturn Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn Triangle.containsPoint(point, this.a, this.b, this.c);\n\t\t}\n\n\t\tisFrontFacing(direction) {\n\t\t\treturn Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsTriangle(this);\n\t\t}\n\n\t\tclosestPointToPoint(p, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tconst a = this.a,\n\t\t\t\t\t\tb = this.b,\n\t\t\t\t\t\tc = this.c;\n\t\t\tlet v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t\t_vab.subVectors(b, a);\n\n\t\t\t_vac.subVectors(c, a);\n\n\t\t\t_vap.subVectors(p, a);\n\n\t\t\tconst d1 = _vab.dot(_vap);\n\n\t\t\tconst d2 = _vac.dot(_vap);\n\n\t\t\tif (d1 <= 0 && d2 <= 0) {\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\t\treturn target.copy(a);\n\t\t\t}\n\n\t\t\t_vbp.subVectors(p, b);\n\n\t\t\tconst d3 = _vab.dot(_vbp);\n\n\t\t\tconst d4 = _vac.dot(_vbp);\n\n\t\t\tif (d3 >= 0 && d4 <= d3) {\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\t\treturn target.copy(b);\n\t\t\t}\n\n\t\t\tconst vc = d1 * d4 - d3 * d2;\n\n\t\t\tif (vc <= 0 && d1 >= 0 && d3 <= 0) {\n\t\t\t\tv = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)\n\n\t\t\t\treturn target.copy(a).addScaledVector(_vab, v);\n\t\t\t}\n\n\t\t\t_vcp.subVectors(p, c);\n\n\t\t\tconst d5 = _vab.dot(_vcp);\n\n\t\t\tconst d6 = _vac.dot(_vcp);\n\n\t\t\tif (d6 >= 0 && d5 <= d6) {\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\t\treturn target.copy(c);\n\t\t\t}\n\n\t\t\tconst vb = d5 * d2 - d1 * d6;\n\n\t\t\tif (vb <= 0 && d2 >= 0 && d6 <= 0) {\n\t\t\t\tw = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)\n\n\t\t\t\treturn target.copy(a).addScaledVector(_vac, w);\n\t\t\t}\n\n\t\t\tconst va = d3 * d6 - d5 * d4;\n\n\t\t\tif (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n\t\t\t\t_vbc.subVectors(c, b);\n\n\t\t\t\tw = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)\n\n\t\t\t\treturn target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n\t\t\t} // face region\n\n\n\t\t\tconst denom = 1 / (va + vb + vc); // u = va * denom\n\n\t\t\tv = vb * denom;\n\t\t\tw = vc * denom;\n\t\t\treturn target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n\t\t}\n\n\t\tequals(triangle) {\n\t\t\treturn triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n\t\t}\n\n\t}\n\n\tlet materialId = 0;\n\n\tclass Material extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: materialId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\t\tthis.fog = true;\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.vertexColors = false;\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\t\tthis.stencilWriteMask = 0xff;\n\t\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\t\tthis.stencilRef = 0;\n\t\t\tthis.stencilFuncMask = 0xff;\n\t\t\tthis.stencilFail = KeepStencilOp;\n\t\t\tthis.stencilZFail = KeepStencilOp;\n\t\t\tthis.stencilZPass = KeepStencilOp;\n\t\t\tthis.stencilWrite = false;\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\t\tthis.shadowSide = null;\n\t\t\tthis.colorWrite = true;\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\t\tthis.dithering = false;\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.alphaToCoverage = false;\n\t\t\tthis.premultipliedAlpha = false;\n\t\t\tthis.visible = true;\n\t\t\tthis.toneMapped = true;\n\t\t\tthis.userData = {};\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tonBuild()\n\t\t/* shaderobject, renderer */\n\t\t{}\n\n\t\tonBeforeCompile()\n\t\t/* shaderobject, renderer */\n\t\t{}\n\n\t\tcustomProgramCacheKey() {\n\t\t\treturn this.onBeforeCompile.toString();\n\t\t}\n\n\t\tsetValues(values) {\n\t\t\tif (values === undefined) return;\n\n\t\t\tfor (const key in values) {\n\t\t\t\tconst newValue = values[key];\n\n\t\t\t\tif (newValue === undefined) {\n\t\t\t\t\tconsole.warn('THREE.Material: \\'' + key + '\\' parameter is undefined.');\n\t\t\t\t\tcontinue;\n\t\t\t\t} // for backward compatability if shading is set in the constructor\n\n\n\t\t\t\tif (key === 'shading') {\n\t\t\t\t\tconsole.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t\t\tthis.flatShading = newValue === FlatShading ? true : false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst currentValue = this[key];\n\n\t\t\t\tif (currentValue === undefined) {\n\t\t\t\t\tconsole.warn('THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (currentValue && currentValue.isColor) {\n\t\t\t\t\tcurrentValue.set(newValue);\n\t\t\t\t} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n\t\t\t\t\tcurrentValue.copy(newValue);\n\t\t\t\t} else {\n\t\t\t\t\tthis[key] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst isRoot = meta === undefined || typeof meta === 'string';\n\n\t\t\tif (isRoot) {\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t}; // standard Material serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (this.color && this.color.isColor) data.color = this.color.getHex();\n\t\t\tif (this.roughness !== undefined) data.roughness = this.roughness;\n\t\t\tif (this.metalness !== undefined) data.metalness = this.metalness;\n\t\t\tif (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();\n\t\t\tif (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n\t\t\tif (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n\t\t\tif (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n\t\t\tif (this.shininess !== undefined) data.shininess = this.shininess;\n\t\t\tif (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n\t\t\tif (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\t\tif (this.clearcoatMap && this.clearcoatMap.isTexture) {\n\t\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n\t\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n\t\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n\t\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\t\t\t}\n\n\t\t\tif (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n\t\t\tif (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n\t\t\tif (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n\t\t\tif (this.lightMap && this.lightMap.isTexture) {\n\t\t\t\tdata.lightMap = this.lightMap.toJSON(meta).uuid;\n\t\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\t\t\t}\n\n\t\t\tif (this.aoMap && this.aoMap.isTexture) {\n\t\t\t\tdata.aoMap = this.aoMap.toJSON(meta).uuid;\n\t\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\t\t\t}\n\n\t\t\tif (this.bumpMap && this.bumpMap.isTexture) {\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON(meta).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\t\t}\n\n\t\t\tif (this.normalMap && this.normalMap.isTexture) {\n\t\t\t\tdata.normalMap = this.normalMap.toJSON(meta).uuid;\n\t\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\t\t}\n\n\t\t\tif (this.displacementMap && this.displacementMap.isTexture) {\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON(meta).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\t\t}\n\n\t\t\tif (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n\t\t\tif (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n\t\t\tif (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n\t\t\tif (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n\n\t\t\tif (this.envMap && this.envMap.isTexture) {\n\t\t\t\tdata.envMap = this.envMap.toJSON(meta).uuid;\n\t\t\t\tif (this.combine !== undefined) data.combine = this.combine;\n\t\t\t}\n\n\t\t\tif (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n\t\t\tif (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n\t\t\tif (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n\n\t\t\tif (this.gradientMap && this.gradientMap.isTexture) {\n\t\t\t\tdata.gradientMap = this.gradientMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.transmission !== undefined) data.transmission = this.transmission;\n\t\t\tif (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n\t\t\tif (this.thickness !== undefined) data.thickness = this.thickness;\n\t\t\tif (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n\t\t\tif (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;\n\t\t\tif (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();\n\t\t\tif (this.size !== undefined) data.size = this.size;\n\t\t\tif (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n\t\t\tif (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n\t\t\tif (this.blending !== NormalBlending) data.blending = this.blending;\n\t\t\tif (this.side !== FrontSide) data.side = this.side;\n\t\t\tif (this.vertexColors) data.vertexColors = true;\n\t\t\tif (this.opacity < 1) data.opacity = this.opacity;\n\t\t\tif (this.transparent === true) data.transparent = this.transparent;\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\t\t\tdata.colorWrite = this.colorWrite;\n\t\t\tdata.stencilWrite = this.stencilWrite;\n\t\t\tdata.stencilWriteMask = this.stencilWriteMask;\n\t\t\tdata.stencilFunc = this.stencilFunc;\n\t\t\tdata.stencilRef = this.stencilRef;\n\t\t\tdata.stencilFuncMask = this.stencilFuncMask;\n\t\t\tdata.stencilFail = this.stencilFail;\n\t\t\tdata.stencilZFail = this.stencilZFail;\n\t\t\tdata.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)\n\n\t\t\tif (this.rotation && this.rotation !== 0) data.rotation = this.rotation;\n\t\t\tif (this.polygonOffset === true) data.polygonOffset = true;\n\t\t\tif (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\t\tif (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\t\t\tif (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;\n\t\t\tif (this.dashSize !== undefined) data.dashSize = this.dashSize;\n\t\t\tif (this.gapSize !== undefined) data.gapSize = this.gapSize;\n\t\t\tif (this.scale !== undefined) data.scale = this.scale;\n\t\t\tif (this.dithering === true) data.dithering = true;\n\t\t\tif (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n\t\t\tif (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;\n\t\t\tif (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif (this.wireframe === true) data.wireframe = this.wireframe;\n\t\t\tif (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n\t\t\tif (this.morphTargets === true) data.morphTargets = true;\n\t\t\tif (this.morphNormals === true) data.morphNormals = true;\n\t\t\tif (this.flatShading === true) data.flatShading = this.flatShading;\n\t\t\tif (this.visible === false) data.visible = false;\n\t\t\tif (this.toneMapped === false) data.toneMapped = false;\n\t\t\tif (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache(cache) {\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (const key in cache) {\n\t\t\t\t\tconst data = cache[key];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push(data);\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t}\n\n\t\t\tif (isRoot) {\n\t\t\t\tconst textures = extractFromCache(meta.textures);\n\t\t\t\tconst images = extractFromCache(meta.images);\n\t\t\t\tif (textures.length > 0) data.textures = textures;\n\t\t\t\tif (images.length > 0) data.images = images;\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.vertexColors = source.vertexColors;\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\t\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\t\tthis.stencilFunc = source.stencilFunc;\n\t\t\tthis.stencilRef = source.stencilRef;\n\t\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\t\tthis.stencilFail = source.stencilFail;\n\t\t\tthis.stencilZFail = source.stencilZFail;\n\t\t\tthis.stencilZPass = source.stencilZPass;\n\t\t\tthis.stencilWrite = source.stencilWrite;\n\t\t\tconst srcPlanes = source.clippingPlanes;\n\t\t\tlet dstPlanes = null;\n\n\t\t\tif (srcPlanes !== null) {\n\t\t\t\tconst n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array(n);\n\n\t\t\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\t\t\tdstPlanes[i] = srcPlanes[i].clone();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.shadowSide = source.shadowSide;\n\t\t\tthis.colorWrite = source.colorWrite;\n\t\t\tthis.precision = source.precision;\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\t\tthis.dithering = source.dithering;\n\t\t\tthis.alphaTest = source.alphaTest;\n\t\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.toneMapped = source.toneMapped;\n\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t}\n\n\tMaterial.prototype.isMaterial = true;\n\n\tconst _colorKeywords = {\n\t\t'aliceblue': 0xF0F8FF,\n\t\t'antiquewhite': 0xFAEBD7,\n\t\t'aqua': 0x00FFFF,\n\t\t'aquamarine': 0x7FFFD4,\n\t\t'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC,\n\t\t'bisque': 0xFFE4C4,\n\t\t'black': 0x000000,\n\t\t'blanchedalmond': 0xFFEBCD,\n\t\t'blue': 0x0000FF,\n\t\t'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A,\n\t\t'burlywood': 0xDEB887,\n\t\t'cadetblue': 0x5F9EA0,\n\t\t'chartreuse': 0x7FFF00,\n\t\t'chocolate': 0xD2691E,\n\t\t'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED,\n\t\t'cornsilk': 0xFFF8DC,\n\t\t'crimson': 0xDC143C,\n\t\t'cyan': 0x00FFFF,\n\t\t'darkblue': 0x00008B,\n\t\t'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B,\n\t\t'darkgray': 0xA9A9A9,\n\t\t'darkgreen': 0x006400,\n\t\t'darkgrey': 0xA9A9A9,\n\t\t'darkkhaki': 0xBDB76B,\n\t\t'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F,\n\t\t'darkorange': 0xFF8C00,\n\t\t'darkorchid': 0x9932CC,\n\t\t'darkred': 0x8B0000,\n\t\t'darksalmon': 0xE9967A,\n\t\t'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B,\n\t\t'darkslategray': 0x2F4F4F,\n\t\t'darkslategrey': 0x2F4F4F,\n\t\t'darkturquoise': 0x00CED1,\n\t\t'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493,\n\t\t'deepskyblue': 0x00BFFF,\n\t\t'dimgray': 0x696969,\n\t\t'dimgrey': 0x696969,\n\t\t'dodgerblue': 0x1E90FF,\n\t\t'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0,\n\t\t'forestgreen': 0x228B22,\n\t\t'fuchsia': 0xFF00FF,\n\t\t'gainsboro': 0xDCDCDC,\n\t\t'ghostwhite': 0xF8F8FF,\n\t\t'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520,\n\t\t'gray': 0x808080,\n\t\t'green': 0x008000,\n\t\t'greenyellow': 0xADFF2F,\n\t\t'grey': 0x808080,\n\t\t'honeydew': 0xF0FFF0,\n\t\t'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C,\n\t\t'indigo': 0x4B0082,\n\t\t'ivory': 0xFFFFF0,\n\t\t'khaki': 0xF0E68C,\n\t\t'lavender': 0xE6E6FA,\n\t\t'lavenderblush': 0xFFF0F5,\n\t\t'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD,\n\t\t'lightblue': 0xADD8E6,\n\t\t'lightcoral': 0xF08080,\n\t\t'lightcyan': 0xE0FFFF,\n\t\t'lightgoldenrodyellow': 0xFAFAD2,\n\t\t'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90,\n\t\t'lightgrey': 0xD3D3D3,\n\t\t'lightpink': 0xFFB6C1,\n\t\t'lightsalmon': 0xFFA07A,\n\t\t'lightseagreen': 0x20B2AA,\n\t\t'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899,\n\t\t'lightslategrey': 0x778899,\n\t\t'lightsteelblue': 0xB0C4DE,\n\t\t'lightyellow': 0xFFFFE0,\n\t\t'lime': 0x00FF00,\n\t\t'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6,\n\t\t'magenta': 0xFF00FF,\n\t\t'maroon': 0x800000,\n\t\t'mediumaquamarine': 0x66CDAA,\n\t\t'mediumblue': 0x0000CD,\n\t\t'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB,\n\t\t'mediumseagreen': 0x3CB371,\n\t\t'mediumslateblue': 0x7B68EE,\n\t\t'mediumspringgreen': 0x00FA9A,\n\t\t'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585,\n\t\t'midnightblue': 0x191970,\n\t\t'mintcream': 0xF5FFFA,\n\t\t'mistyrose': 0xFFE4E1,\n\t\t'moccasin': 0xFFE4B5,\n\t\t'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080,\n\t\t'oldlace': 0xFDF5E6,\n\t\t'olive': 0x808000,\n\t\t'olivedrab': 0x6B8E23,\n\t\t'orange': 0xFFA500,\n\t\t'orangered': 0xFF4500,\n\t\t'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA,\n\t\t'palegreen': 0x98FB98,\n\t\t'paleturquoise': 0xAFEEEE,\n\t\t'palevioletred': 0xDB7093,\n\t\t'papayawhip': 0xFFEFD5,\n\t\t'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F,\n\t\t'pink': 0xFFC0CB,\n\t\t'plum': 0xDDA0DD,\n\t\t'powderblue': 0xB0E0E6,\n\t\t'purple': 0x800080,\n\t\t'rebeccapurple': 0x663399,\n\t\t'red': 0xFF0000,\n\t\t'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1,\n\t\t'saddlebrown': 0x8B4513,\n\t\t'salmon': 0xFA8072,\n\t\t'sandybrown': 0xF4A460,\n\t\t'seagreen': 0x2E8B57,\n\t\t'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D,\n\t\t'silver': 0xC0C0C0,\n\t\t'skyblue': 0x87CEEB,\n\t\t'slateblue': 0x6A5ACD,\n\t\t'slategray': 0x708090,\n\t\t'slategrey': 0x708090,\n\t\t'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F,\n\t\t'steelblue': 0x4682B4,\n\t\t'tan': 0xD2B48C,\n\t\t'teal': 0x008080,\n\t\t'thistle': 0xD8BFD8,\n\t\t'tomato': 0xFF6347,\n\t\t'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE,\n\t\t'wheat': 0xF5DEB3,\n\t\t'white': 0xFFFFFF,\n\t\t'whitesmoke': 0xF5F5F5,\n\t\t'yellow': 0xFFFF00,\n\t\t'yellowgreen': 0x9ACD32\n\t};\n\tconst _hslA = {\n\t\th: 0,\n\t\ts: 0,\n\t\tl: 0\n\t};\n\tconst _hslB = {\n\t\th: 0,\n\t\ts: 0,\n\t\tl: 0\n\t};\n\n\tfunction hue2rgb(p, q, t) {\n\t\tif (t < 0) t += 1;\n\t\tif (t > 1) t -= 1;\n\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\tif (t < 1 / 2) return q;\n\t\tif (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n\t\treturn p;\n\t}\n\n\tfunction SRGBToLinear(c) {\n\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t}\n\n\tfunction LinearToSRGB(c) {\n\t\treturn c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n\t}\n\n\tclass Color {\n\t\tconstructor(r, g, b) {\n\t\t\tif (g === undefined && b === undefined) {\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set(r);\n\t\t\t}\n\n\t\t\treturn this.setRGB(r, g, b);\n\t\t}\n\n\t\tset(value) {\n\t\t\tif (value && value.isColor) {\n\t\t\t\tthis.copy(value);\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\tthis.setHex(value);\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tthis.setStyle(value);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetHex(hex) {\n\t\t\thex = Math.floor(hex);\n\t\t\tthis.r = (hex >> 16 & 255) / 255;\n\t\t\tthis.g = (hex >> 8 & 255) / 255;\n\t\t\tthis.b = (hex & 255) / 255;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRGB(r, g, b) {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetHSL(h, s, l) {\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = euclideanModulo(h, 1);\n\t\t\ts = clamp(s, 0, 1);\n\t\t\tl = clamp(l, 0, 1);\n\n\t\t\tif (s === 0) {\n\t\t\t\tthis.r = this.g = this.b = l;\n\t\t\t} else {\n\t\t\t\tconst p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n\t\t\t\tconst q = 2 * l - p;\n\t\t\t\tthis.r = hue2rgb(q, p, h + 1 / 3);\n\t\t\t\tthis.g = hue2rgb(q, p, h);\n\t\t\t\tthis.b = hue2rgb(q, p, h - 1 / 3);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetStyle(style) {\n\t\t\tfunction handleAlpha(string) {\n\t\t\t\tif (string === undefined) return;\n\n\t\t\t\tif (parseFloat(string) < 1) {\n\t\t\t\t\tconsole.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet m;\n\n\t\t\tif (m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style)) {\n\t\t\t\t// rgb / hsl\n\t\t\t\tlet color;\n\t\t\t\tconst name = m[1];\n\t\t\t\tconst components = m[2];\n\n\t\t\t\tswitch (name) {\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\t\t\t\t\t\tif (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min(255, parseInt(color[1], 10)) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min(255, parseInt(color[2], 10)) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min(255, parseInt(color[3], 10)) / 255;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min(100, parseInt(color[1], 10)) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min(100, parseInt(color[2], 10)) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min(100, parseInt(color[3], 10)) / 100;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\t\t\t\t\t\tif (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tconst h = parseFloat(color[1]) / 360;\n\t\t\t\t\t\t\tconst s = parseInt(color[2], 10) / 100;\n\t\t\t\t\t\t\tconst l = parseInt(color[3], 10) / 100;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this.setHSL(h, s, l);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n\t\t\t\t// hex color\n\t\t\t\tconst hex = m[1];\n\t\t\t\tconst size = hex.length;\n\n\t\t\t\tif (size === 3) {\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n\t\t\t\t\tthis.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n\t\t\t\t\tthis.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n\t\t\t\t\treturn this;\n\t\t\t\t} else if (size === 6) {\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n\t\t\t\t\tthis.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n\t\t\t\t\tthis.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (style && style.length > 0) {\n\t\t\t\treturn this.setColorName(style);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetColorName(style) {\n\t\t\t// color keywords\n\t\t\tconst hex = _colorKeywords[style.toLowerCase()];\n\n\t\t\tif (hex !== undefined) {\n\t\t\t\t// red\n\t\t\t\tthis.setHex(hex);\n\t\t\t} else {\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn('THREE.Color: Unknown color ' + style);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.r, this.g, this.b);\n\t\t}\n\n\t\tcopy(color) {\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyGammaToLinear(color, gammaFactor = 2.0) {\n\t\t\tthis.r = Math.pow(color.r, gammaFactor);\n\t\t\tthis.g = Math.pow(color.g, gammaFactor);\n\t\t\tthis.b = Math.pow(color.b, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyLinearToGamma(color, gammaFactor = 2.0) {\n\t\t\tconst safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n\t\t\tthis.r = Math.pow(color.r, safeInverse);\n\t\t\tthis.g = Math.pow(color.g, safeInverse);\n\t\t\tthis.b = Math.pow(color.b, safeInverse);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertGammaToLinear(gammaFactor) {\n\t\t\tthis.copyGammaToLinear(this, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertLinearToGamma(gammaFactor) {\n\t\t\tthis.copyLinearToGamma(this, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopySRGBToLinear(color) {\n\t\t\tthis.r = SRGBToLinear(color.r);\n\t\t\tthis.g = SRGBToLinear(color.g);\n\t\t\tthis.b = SRGBToLinear(color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyLinearToSRGB(color) {\n\t\t\tthis.r = LinearToSRGB(color.r);\n\t\t\tthis.g = LinearToSRGB(color.g);\n\t\t\tthis.b = LinearToSRGB(color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertSRGBToLinear() {\n\t\t\tthis.copySRGBToLinear(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertLinearToSRGB() {\n\t\t\tthis.copyLinearToSRGB(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetHex() {\n\t\t\treturn this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n\t\t}\n\n\t\tgetHexString() {\n\t\t\treturn ('000000' + this.getHex().toString(16)).slice(-6);\n\t\t}\n\n\t\tgetHSL(target) {\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Color: .getHSL() target is now required');\n\t\t\t\ttarget = {\n\t\t\t\t\th: 0,\n\t\t\t\t\ts: 0,\n\t\t\t\t\tl: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst r = this.r,\n\t\t\t\t\t\tg = this.g,\n\t\t\t\t\t\tb = this.b;\n\t\t\tconst max = Math.max(r, g, b);\n\t\t\tconst min = Math.min(r, g, b);\n\t\t\tlet hue, saturation;\n\t\t\tconst lightness = (min + max) / 2.0;\n\n\t\t\tif (min === max) {\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\t\t\t} else {\n\t\t\t\tconst delta = max - min;\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n\t\t\t\tswitch (max) {\n\t\t\t\t\tcase r:\n\t\t\t\t\t\thue = (g - b) / delta + (g < b ? 6 : 0);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase g:\n\t\t\t\t\t\thue = (b - r) / delta + 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase b:\n\t\t\t\t\t\thue = (r - g) / delta + 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\t\t\t}\n\n\t\t\ttarget.h = hue;\n\t\t\ttarget.s = saturation;\n\t\t\ttarget.l = lightness;\n\t\t\treturn target;\n\t\t}\n\n\t\tgetStyle() {\n\t\t\treturn 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\n\t\t}\n\n\t\toffsetHSL(h, s, l) {\n\t\t\tthis.getHSL(_hslA);\n\t\t\t_hslA.h += h;\n\t\t\t_hslA.s += s;\n\t\t\t_hslA.l += l;\n\t\t\tthis.setHSL(_hslA.h, _hslA.s, _hslA.l);\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(color) {\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\taddColors(color1, color2) {\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(color) {\n\t\t\tthis.r = Math.max(0, this.r - color.r);\n\t\t\tthis.g = Math.max(0, this.g - color.g);\n\t\t\tthis.b = Math.max(0, this.b - color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(color) {\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerp(color, alpha) {\n\t\t\tthis.r += (color.r - this.r) * alpha;\n\t\t\tthis.g += (color.g - this.g) * alpha;\n\t\t\tthis.b += (color.b - this.b) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpColors(color1, color2, alpha) {\n\t\t\tthis.r = color1.r + (color2.r - color1.r) * alpha;\n\t\t\tthis.g = color1.g + (color2.g - color1.g) * alpha;\n\t\t\tthis.b = color1.b + (color2.b - color1.b) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpHSL(color, alpha) {\n\t\t\tthis.getHSL(_hslA);\n\t\t\tcolor.getHSL(_hslB);\n\t\t\tconst h = lerp(_hslA.h, _hslB.h, alpha);\n\t\t\tconst s = lerp(_hslA.s, _hslB.s, alpha);\n\t\t\tconst l = lerp(_hslA.l, _hslB.l, alpha);\n\t\t\tthis.setHSL(h, s, l);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(c) {\n\t\t\treturn c.r === this.r && c.g === this.g && c.b === this.b;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.r = array[offset];\n\t\t\tthis.g = array[offset + 1];\n\t\t\tthis.b = array[offset + 2];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.r;\n\t\t\tarray[offset + 1] = this.g;\n\t\t\tarray[offset + 2] = this.b;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index) {\n\t\t\tthis.r = attribute.getX(index);\n\t\t\tthis.g = attribute.getY(index);\n\t\t\tthis.b = attribute.getZ(index);\n\n\t\t\tif (attribute.normalized === true) {\n\t\t\t\t// assuming Uint8Array\n\t\t\t\tthis.r /= 255;\n\t\t\t\tthis.g /= 255;\n\t\t\t\tthis.b /= 255;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\treturn this.getHex();\n\t\t}\n\n\t}\n\n\tColor.NAMES = _colorKeywords;\n\tColor.prototype.isColor = true;\n\tColor.prototype.r = 1;\n\tColor.prototype.g = 1;\n\tColor.prototype.b = 1;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.Multiply,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\tdepthTest: <bool>,\n\t *\tdepthWrite: <bool>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>\n\t * }\n\t */\n\n\tclass MeshBasicMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\t\tthis.color = new Color(0xffffff); // emissive\n\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tconst _vector$9 = /*@__PURE__*/new Vector3();\n\n\tconst _vector2 = /*@__PURE__*/new Vector2();\n\n\tclass BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tif (Array.isArray(array)) {\n\t\t\t\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\t\t\t}\n\n\t\t\tthis.name = '';\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\t\tthis.usage = StaticDrawUsage;\n\t\t\tthis.updateRange = {\n\t\t\t\toffset: 0,\n\t\t\t\tcount: -1\n\t\t\t};\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tonUploadCallback() {}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetUsage(value) {\n\t\t\tthis.usage = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\t\t\tthis.usage = source.usage;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyAt(index1, attribute, index2) {\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor (let i = 0, l = this.itemSize; i < l; i++) {\n\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyArray(array) {\n\t\t\tthis.array.set(array);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyColorsArray(colors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = colors.length; i < l; i++) {\n\t\t\t\tlet color = colors[i];\n\n\t\t\t\tif (color === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\n\t\t\t\t\tcolor = new Color();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = color.r;\n\t\t\t\tarray[offset++] = color.g;\n\t\t\t\tarray[offset++] = color.b;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector2sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector2();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector3sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\tarray[offset++] = vector.z;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector4sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector4();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\tarray[offset++] = vector.z;\n\t\t\t\tarray[offset++] = vector.w;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tif (this.itemSize === 2) {\n\t\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t\t_vector2.fromBufferAttribute(this, i);\n\n\t\t\t\t\t_vector2.applyMatrix3(m);\n\n\t\t\t\t\tthis.setXY(i, _vector2.x, _vector2.y);\n\t\t\t\t}\n\t\t\t} else if (this.itemSize === 3) {\n\t\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t\t_vector$9.fromBufferAttribute(this, i);\n\n\t\t\t\t\t_vector$9.applyMatrix3(m);\n\n\t\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.applyMatrix4(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.applyNormalMatrix(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.transformDirection(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(value, offset = 0) {\n\t\t\tthis.array.set(value, offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetX(index) {\n\t\t\treturn this.array[index * this.itemSize];\n\t\t}\n\n\t\tsetX(index, x) {\n\t\t\tthis.array[index * this.itemSize] = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetY(index) {\n\t\t\treturn this.array[index * this.itemSize + 1];\n\t\t}\n\n\t\tsetY(index, y) {\n\t\t\tthis.array[index * this.itemSize + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetZ(index) {\n\t\t\treturn this.array[index * this.itemSize + 2];\n\t\t}\n\n\t\tsetZ(index, z) {\n\t\t\tthis.array[index * this.itemSize + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetW(index) {\n\t\t\treturn this.array[index * this.itemSize + 3];\n\t\t}\n\n\t\tsetW(index, w) {\n\t\t\tthis.array[index * this.itemSize + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXY(index, x, y) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZ(index, x, y, z) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\tthis.array[index + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZW(index, x, y, z, w) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\tthis.array[index + 2] = z;\n\t\t\tthis.array[index + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tonUpload(callback) {\n\t\t\tthis.onUploadCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.array, this.itemSize).copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call(this.array),\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (this.usage !== StaticDrawUsage) data.usage = this.usage;\n\t\t\tif (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tBufferAttribute.prototype.isBufferAttribute = true; //\n\n\tclass Int8BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int8Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint8BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint8Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint8ClampedArray(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Int16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Int32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Float16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\n\tclass Float32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Float32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Float64BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Float64Array(array), itemSize, normalized);\n\t\t}\n\n\t} //\n\n\tfunction arrayMax(array) {\n\t\tif (array.length === 0) return -Infinity;\n\t\tlet max = array[0];\n\n\t\tfor (let i = 1, l = array.length; i < l; ++i) {\n\t\t\tif (array[i] > max) max = array[i];\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconst TYPED_ARRAYS = {\n\t\tInt8Array: Int8Array,\n\t\tUint8Array: Uint8Array,\n\t\tUint8ClampedArray: Uint8ClampedArray,\n\t\tInt16Array: Int16Array,\n\t\tUint16Array: Uint16Array,\n\t\tInt32Array: Int32Array,\n\t\tUint32Array: Uint32Array,\n\t\tFloat32Array: Float32Array,\n\t\tFloat64Array: Float64Array\n\t};\n\n\tfunction getTypedArray(type, buffer) {\n\t\treturn new TYPED_ARRAYS[type](buffer);\n\t}\n\n\tlet _id = 0;\n\n\tconst _m1 = /*@__PURE__*/new Matrix4();\n\n\tconst _obj = /*@__PURE__*/new Object3D();\n\n\tconst _offset = /*@__PURE__*/new Vector3();\n\n\tconst _box$1 = /*@__PURE__*/new Box3();\n\n\tconst _boxMorphTargets = /*@__PURE__*/new Box3();\n\n\tconst _vector$8 = /*@__PURE__*/new Vector3();\n\n\tclass BufferGeometry extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: _id++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.morphTargetsRelative = false;\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\t\tthis.drawRange = {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: Infinity\n\t\t\t};\n\t\t\tthis.userData = {};\n\t\t}\n\n\t\tgetIndex() {\n\t\t\treturn this.index;\n\t\t}\n\n\t\tsetIndex(index) {\n\t\t\tif (Array.isArray(index)) {\n\t\t\t\tthis.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n\t\t\t} else {\n\t\t\t\tthis.index = index;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetAttribute(name) {\n\t\t\treturn this.attributes[name];\n\t\t}\n\n\t\tsetAttribute(name, attribute) {\n\t\t\tthis.attributes[name] = attribute;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeleteAttribute(name) {\n\t\t\tdelete this.attributes[name];\n\t\t\treturn this;\n\t\t}\n\n\t\thasAttribute(name) {\n\t\t\treturn this.attributes[name] !== undefined;\n\t\t}\n\n\t\taddGroup(start, count, materialIndex = 0) {\n\t\t\tthis.groups.push({\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex\n\t\t\t});\n\t\t}\n\n\t\tclearGroups() {\n\t\t\tthis.groups = [];\n\t\t}\n\n\t\tsetDrawRange(start, count) {\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tconst position = this.attributes.position;\n\n\t\t\tif (position !== undefined) {\n\t\t\t\tposition.applyMatrix4(matrix);\n\t\t\t\tposition.needsUpdate = true;\n\t\t\t}\n\n\t\t\tconst normal = this.attributes.normal;\n\n\t\t\tif (normal !== undefined) {\n\t\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\t\t\t\tnormal.applyNormalMatrix(normalMatrix);\n\t\t\t\tnormal.needsUpdate = true;\n\t\t\t}\n\n\t\t\tconst tangent = this.attributes.tangent;\n\n\t\t\tif (tangent !== undefined) {\n\t\t\t\ttangent.transformDirection(matrix);\n\t\t\t\ttangent.needsUpdate = true;\n\t\t\t}\n\n\t\t\tif (this.boundingBox !== null) {\n\t\t\t\tthis.computeBoundingBox();\n\t\t\t}\n\n\t\t\tif (this.boundingSphere !== null) {\n\t\t\t\tthis.computeBoundingSphere();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\t_m1.makeRotationFromQuaternion(q);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateX(angle) {\n\t\t\t// rotate geometry around world x-axis\n\t\t\t_m1.makeRotationX(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateY(angle) {\n\t\t\t// rotate geometry around world y-axis\n\t\t\t_m1.makeRotationY(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateZ(angle) {\n\t\t\t// rotate geometry around world z-axis\n\t\t\t_m1.makeRotationZ(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(x, y, z) {\n\t\t\t// translate geometry\n\t\t\t_m1.makeTranslation(x, y, z);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(x, y, z) {\n\t\t\t// scale geometry\n\t\t\t_m1.makeScale(x, y, z);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\tlookAt(vector) {\n\t\t\t_obj.lookAt(vector);\n\n\t\t\t_obj.updateMatrix();\n\n\t\t\tthis.applyMatrix4(_obj.matrix);\n\t\t\treturn this;\n\t\t}\n\n\t\tcenter() {\n\t\t\tthis.computeBoundingBox();\n\t\t\tthis.boundingBox.getCenter(_offset).negate();\n\t\t\tthis.translate(_offset.x, _offset.y, _offset.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tconst position = [];\n\n\t\t\tfor (let i = 0, l = points.length; i < l; i++) {\n\t\t\t\tconst point = points[i];\n\t\t\t\tposition.push(point.x, point.y, point.z || 0);\n\t\t\t}\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(position, 3));\n\t\t\treturn this;\n\t\t}\n\n\t\tcomputeBoundingBox() {\n\t\t\tif (this.boundingBox === null) {\n\t\t\t\tthis.boundingBox = new Box3();\n\t\t\t}\n\n\t\t\tconst position = this.attributes.position;\n\t\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif (position && position.isGLBufferAttribute) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n\t\t\t\tthis.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (position !== undefined) {\n\t\t\t\tthis.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\n\t\t\t\t\t\t_box$1.setFromBufferAttribute(morphAttribute);\n\n\t\t\t\t\t\tif (this.morphTargetsRelative) {\n\t\t\t\t\t\t\t_vector$8.addVectors(this.boundingBox.min, _box$1.min);\n\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_vector$8);\n\n\t\t\t\t\t\t\t_vector$8.addVectors(this.boundingBox.max, _box$1.max);\n\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_vector$8);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_box$1.min);\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_box$1.max);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.boundingBox.makeEmpty();\n\t\t\t}\n\n\t\t\tif (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t}\n\t\t}\n\n\t\tcomputeBoundingSphere() {\n\t\t\tif (this.boundingSphere === null) {\n\t\t\t\tthis.boundingSphere = new Sphere();\n\t\t\t}\n\n\t\t\tconst position = this.attributes.position;\n\t\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif (position && position.isGLBufferAttribute) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n\t\t\t\tthis.boundingSphere.set(new Vector3(), Infinity);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\t// first, find the center of the bounding sphere\n\t\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t\t_box$1.setFromBufferAttribute(position); // process morph attributes if present\n\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\n\t\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n\t\t\t\t\t\tif (this.morphTargetsRelative) {\n\t\t\t\t\t\t\t_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_vector$8);\n\n\t\t\t\t\t\t\t_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_vector$8);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_box$1.expandByPoint(_boxMorphTargets.min);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_boxMorphTargets.max);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n\t\t\t\tlet maxRadiusSq = 0;\n\n\t\t\t\tfor (let i = 0, il = position.count; i < il; i++) {\n\t\t\t\t\t_vector$8.fromBufferAttribute(position, i);\n\n\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n\t\t\t\t} // process morph attributes if present\n\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\t\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\t\tfor (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n\t\t\t\t\t\t\t_vector$8.fromBufferAttribute(morphAttribute, j);\n\n\t\t\t\t\t\t\tif (morphTargetsRelative) {\n\t\t\t\t\t\t\t\t_offset.fromBufferAttribute(position, j);\n\n\t\t\t\t\t\t\t\t_vector$8.add(_offset);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n\t\t\t\tif (isNaN(this.boundingSphere.radius)) {\n\t\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcomputeFaceNormals() {// backwards compatibility\n\t\t}\n\n\t\tcomputeTangents() {\n\t\t\tconst index = this.index;\n\t\t\tconst attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n\t\t\t// (per vertex tangents)\n\n\t\t\tif (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n\t\t\t\tconsole.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst indices = index.array;\n\t\t\tconst positions = attributes.position.array;\n\t\t\tconst normals = attributes.normal.array;\n\t\t\tconst uvs = attributes.uv.array;\n\t\t\tconst nVertices = positions.length / 3;\n\n\t\t\tif (attributes.tangent === undefined) {\n\t\t\t\tthis.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n\t\t\t}\n\n\t\t\tconst tangents = attributes.tangent.array;\n\t\t\tconst tan1 = [],\n\t\t\t\t\t\ttan2 = [];\n\n\t\t\tfor (let i = 0; i < nVertices; i++) {\n\t\t\t\ttan1[i] = new Vector3();\n\t\t\t\ttan2[i] = new Vector3();\n\t\t\t}\n\n\t\t\tconst vA = new Vector3(),\n\t\t\t\t\t\tvB = new Vector3(),\n\t\t\t\t\t\tvC = new Vector3(),\n\t\t\t\t\t\tuvA = new Vector2(),\n\t\t\t\t\t\tuvB = new Vector2(),\n\t\t\t\t\t\tuvC = new Vector2(),\n\t\t\t\t\t\tsdir = new Vector3(),\n\t\t\t\t\t\ttdir = new Vector3();\n\n\t\t\tfunction handleTriangle(a, b, c) {\n\t\t\t\tvA.fromArray(positions, a * 3);\n\t\t\t\tvB.fromArray(positions, b * 3);\n\t\t\t\tvC.fromArray(positions, c * 3);\n\t\t\t\tuvA.fromArray(uvs, a * 2);\n\t\t\t\tuvB.fromArray(uvs, b * 2);\n\t\t\t\tuvC.fromArray(uvs, c * 2);\n\t\t\t\tvB.sub(vA);\n\t\t\t\tvC.sub(vA);\n\t\t\t\tuvB.sub(uvA);\n\t\t\t\tuvC.sub(uvA);\n\t\t\t\tconst r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\t\tif (!isFinite(r)) return;\n\t\t\t\tsdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n\t\t\t\ttdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n\t\t\t\ttan1[a].add(sdir);\n\t\t\t\ttan1[b].add(sdir);\n\t\t\t\ttan1[c].add(sdir);\n\t\t\t\ttan2[a].add(tdir);\n\t\t\t\ttan2[b].add(tdir);\n\t\t\t\ttan2[c].add(tdir);\n\t\t\t}\n\n\t\t\tlet groups = this.groups;\n\n\t\t\tif (groups.length === 0) {\n\t\t\t\tgroups = [{\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tcount: indices.length\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tfor (let i = 0, il = groups.length; i < il; ++i) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor (let j = start, jl = start + count; j < jl; j += 3) {\n\t\t\t\t\thandleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst tmp = new Vector3(),\n\t\t\t\t\t\ttmp2 = new Vector3();\n\t\t\tconst n = new Vector3(),\n\t\t\t\t\t\tn2 = new Vector3();\n\n\t\t\tfunction handleVertex(v) {\n\t\t\t\tn.fromArray(normals, v * 3);\n\t\t\t\tn2.copy(n);\n\t\t\t\tconst t = tan1[v]; // Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy(t);\n\t\t\t\ttmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n\t\t\t\ttmp2.crossVectors(n2, t);\n\t\t\t\tconst test = tmp2.dot(tan2[v]);\n\t\t\t\tconst w = test < 0.0 ? -1.0 : 1.0;\n\t\t\t\ttangents[v * 4] = tmp.x;\n\t\t\t\ttangents[v * 4 + 1] = tmp.y;\n\t\t\t\ttangents[v * 4 + 2] = tmp.z;\n\t\t\t\ttangents[v * 4 + 3] = w;\n\t\t\t}\n\n\t\t\tfor (let i = 0, il = groups.length; i < il; ++i) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor (let j = start, jl = start + count; j < jl; j += 3) {\n\t\t\t\t\thandleVertex(indices[j + 0]);\n\t\t\t\t\thandleVertex(indices[j + 1]);\n\t\t\t\t\thandleVertex(indices[j + 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcomputeVertexNormals() {\n\t\t\tconst index = this.index;\n\t\t\tconst positionAttribute = this.getAttribute('position');\n\n\t\t\tif (positionAttribute !== undefined) {\n\t\t\t\tlet normalAttribute = this.getAttribute('normal');\n\n\t\t\t\tif (normalAttribute === undefined) {\n\t\t\t\t\tnormalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n\t\t\t\t\tthis.setAttribute('normal', normalAttribute);\n\t\t\t\t} else {\n\t\t\t\t\t// reset existing normals to zero\n\t\t\t\t\tfor (let i = 0, il = normalAttribute.count; i < il; i++) {\n\t\t\t\t\t\tnormalAttribute.setXYZ(i, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst pA = new Vector3(),\n\t\t\t\t\t\t\tpB = new Vector3(),\n\t\t\t\t\t\t\tpC = new Vector3();\n\t\t\t\tconst nA = new Vector3(),\n\t\t\t\t\t\t\tnB = new Vector3(),\n\t\t\t\t\t\t\tnC = new Vector3();\n\t\t\t\tconst cb = new Vector3(),\n\t\t\t\t\t\t\tab = new Vector3(); // indexed elements\n\n\t\t\t\tif (index) {\n\t\t\t\t\tfor (let i = 0, il = index.count; i < il; i += 3) {\n\t\t\t\t\t\tconst vA = index.getX(i + 0);\n\t\t\t\t\t\tconst vB = index.getX(i + 1);\n\t\t\t\t\t\tconst vC = index.getX(i + 2);\n\t\t\t\t\t\tpA.fromBufferAttribute(positionAttribute, vA);\n\t\t\t\t\t\tpB.fromBufferAttribute(positionAttribute, vB);\n\t\t\t\t\t\tpC.fromBufferAttribute(positionAttribute, vC);\n\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\tcb.cross(ab);\n\t\t\t\t\t\tnA.fromBufferAttribute(normalAttribute, vA);\n\t\t\t\t\t\tnB.fromBufferAttribute(normalAttribute, vB);\n\t\t\t\t\t\tnC.fromBufferAttribute(normalAttribute, vC);\n\t\t\t\t\t\tnA.add(cb);\n\t\t\t\t\t\tnB.add(cb);\n\t\t\t\t\t\tnC.add(cb);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\t\t\t\tfor (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n\t\t\t\t\t\tpA.fromBufferAttribute(positionAttribute, i + 0);\n\t\t\t\t\t\tpB.fromBufferAttribute(positionAttribute, i + 1);\n\t\t\t\t\t\tpC.fromBufferAttribute(positionAttribute, i + 2);\n\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\tcb.cross(ab);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\t\t\t\tnormalAttribute.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tmerge(geometry, offset) {\n\t\t\tif (!(geometry && geometry.isBufferGeometry)) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (offset === undefined) {\n\t\t\t\toffset = 0;\n\t\t\t\tconsole.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n\t\t\t}\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tif (geometry.attributes[key] === undefined) continue;\n\t\t\t\tconst attribute1 = attributes[key];\n\t\t\t\tconst attributeArray1 = attribute1.array;\n\t\t\t\tconst attribute2 = geometry.attributes[key];\n\t\t\t\tconst attributeArray2 = attribute2.array;\n\t\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\t\tconst length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n\t\t\t\tfor (let i = 0, j = attributeOffset; i < length; i++, j++) {\n\t\t\t\t\tattributeArray1[j] = attributeArray2[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tnormalizeNormals() {\n\t\t\tconst normals = this.attributes.normal;\n\n\t\t\tfor (let i = 0, il = normals.count; i < il; i++) {\n\t\t\t\t_vector$8.fromBufferAttribute(normals, i);\n\n\t\t\t\t_vector$8.normalize();\n\n\t\t\t\tnormals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n\t\t\t}\n\t\t}\n\n\t\ttoNonIndexed() {\n\t\t\tfunction convertBufferAttribute(attribute, indices) {\n\t\t\t\tconst array = attribute.array;\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst normalized = attribute.normalized;\n\t\t\t\tconst array2 = new array.constructor(indices.length * itemSize);\n\t\t\t\tlet index = 0,\n\t\t\t\t\t\tindex2 = 0;\n\n\t\t\t\tfor (let i = 0, l = indices.length; i < l; i++) {\n\t\t\t\t\tindex = indices[i] * itemSize;\n\n\t\t\t\t\tfor (let j = 0; j < itemSize; j++) {\n\t\t\t\t\t\tarray2[index2++] = array[index++];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new BufferAttribute(array2, itemSize, normalized);\n\t\t\t} //\n\n\n\t\t\tif (this.index === null) {\n\t\t\t\tconsole.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst geometry2 = new BufferGeometry();\n\t\t\tconst indices = this.index.array;\n\t\t\tconst attributes = this.attributes; // attributes\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attribute = attributes[name];\n\t\t\t\tconst newAttribute = convertBufferAttribute(attribute, indices);\n\t\t\t\tgeometry2.setAttribute(name, newAttribute);\n\t\t\t} // morph attributes\n\n\n\t\t\tconst morphAttributes = this.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst morphArray = [];\n\t\t\t\tconst morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor (let i = 0, il = morphAttribute.length; i < il; i++) {\n\t\t\t\t\tconst attribute = morphAttribute[i];\n\t\t\t\t\tconst newAttribute = convertBufferAttribute(attribute, indices);\n\t\t\t\t\tmorphArray.push(newAttribute);\n\t\t\t\t}\n\n\t\t\t\tgeometry2.morphAttributes[name] = morphArray;\n\t\t\t}\n\n\t\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n\t\t\tconst groups = this.groups;\n\n\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tgeometry2.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t}\n\n\t\t\treturn geometry2;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t}; // standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n\t\t\tif (this.parameters !== undefined) {\n\t\t\t\tconst parameters = this.parameters;\n\n\t\t\t\tfor (const key in parameters) {\n\t\t\t\t\tif (parameters[key] !== undefined) data[key] = parameters[key];\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t} // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n\t\t\tdata.data = {\n\t\t\t\tattributes: {}\n\t\t\t};\n\t\t\tconst index = this.index;\n\n\t\t\tif (index !== null) {\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: Array.prototype.slice.call(index.array)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tdata.data.attributes[key] = attribute.toJSON(data.data);\n\t\t\t}\n\n\t\t\tconst morphAttributes = {};\n\t\t\tlet hasMorphAttributes = false;\n\n\t\t\tfor (const key in this.morphAttributes) {\n\t\t\t\tconst attributeArray = this.morphAttributes[key];\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0, il = attributeArray.length; i < il; i++) {\n\t\t\t\t\tconst attribute = attributeArray[i];\n\t\t\t\t\tarray.push(attribute.toJSON(data.data));\n\t\t\t\t}\n\n\t\t\t\tif (array.length > 0) {\n\t\t\t\t\tmorphAttributes[key] = array;\n\t\t\t\t\thasMorphAttributes = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasMorphAttributes) {\n\t\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\t\t\t}\n\n\t\t\tconst groups = this.groups;\n\n\t\t\tif (groups.length > 0) {\n\t\t\t\tdata.data.groups = JSON.parse(JSON.stringify(groups));\n\t\t\t}\n\n\t\t\tconst boundingSphere = this.boundingSphere;\n\n\t\t\tif (boundingSphere !== null) {\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tclone() {\n\t\t\t/*\n\t\t\t // Handle primitives\n\t\t\t\t const parameters = this.parameters;\n\t\t\t\t if ( parameters !== undefined ) {\n\t\t\t\t const values = [];\n\t\t\t\t for ( const key in parameters ) {\n\t\t\t\t values.push( parameters[ key ] );\n\t\t\t\t }\n\t\t\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t\t this.constructor.apply( geometry, values );\n\t\t\t return geometry;\n\t\t\t\t }\n\t\t\t\t return new this.constructor().copy( this );\n\t\t\t */\n\t\t\treturn new BufferGeometry().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\t// reset\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null; // used for storing cloned, shared data\n\n\t\t\tconst data = {}; // name\n\n\t\t\tthis.name = source.name; // index\n\n\t\t\tconst index = source.index;\n\n\t\t\tif (index !== null) {\n\t\t\t\tthis.setIndex(index.clone(data));\n\t\t\t} // attributes\n\n\n\t\t\tconst attributes = source.attributes;\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attribute = attributes[name];\n\t\t\t\tthis.setAttribute(name, attribute.clone(data));\n\t\t\t} // morph attributes\n\n\n\t\t\tconst morphAttributes = source.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst array = [];\n\t\t\t\tconst morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor (let i = 0, l = morphAttribute.length; i < l; i++) {\n\t\t\t\t\tarray.push(morphAttribute[i].clone(data));\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[name] = array;\n\t\t\t}\n\n\t\t\tthis.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n\t\t\tconst groups = source.groups;\n\n\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tthis.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t} // bounding box\n\n\n\t\t\tconst boundingBox = source.boundingBox;\n\n\t\t\tif (boundingBox !== null) {\n\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\t\t} // bounding sphere\n\n\n\t\t\tconst boundingSphere = source.boundingSphere;\n\n\t\t\tif (boundingSphere !== null) {\n\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\t\t} // draw range\n\n\n\t\t\tthis.drawRange.start = source.drawRange.start;\n\t\t\tthis.drawRange.count = source.drawRange.count; // user data\n\n\t\t\tthis.userData = source.userData;\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tBufferGeometry.prototype.isBufferGeometry = true;\n\n\tconst _inverseMatrix$2 = /*@__PURE__*/new Matrix4();\n\n\tconst _ray$2 = /*@__PURE__*/new Ray();\n\n\tconst _sphere$3 = /*@__PURE__*/new Sphere();\n\n\tconst _vA$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vB$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vC$1 = /*@__PURE__*/new Vector3();\n\n\tconst _tempA = /*@__PURE__*/new Vector3();\n\n\tconst _tempB = /*@__PURE__*/new Vector3();\n\n\tconst _tempC = /*@__PURE__*/new Vector3();\n\n\tconst _morphA = /*@__PURE__*/new Vector3();\n\n\tconst _morphB = /*@__PURE__*/new Vector3();\n\n\tconst _morphC = /*@__PURE__*/new Vector3();\n\n\tconst _uvA$1 = /*@__PURE__*/new Vector2();\n\n\tconst _uvB$1 = /*@__PURE__*/new Vector2();\n\n\tconst _uvC$1 = /*@__PURE__*/new Vector2();\n\n\tconst _intersectionPoint = /*@__PURE__*/new Vector3();\n\n\tconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\n\tclass Mesh extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Mesh';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\n\t\t\tif (source.morphTargetInfluences !== undefined) {\n\t\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\t\t\t}\n\n\t\t\tif (source.morphTargetDictionary !== undefined) {\n\t\t\t\tthis.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n\t\t\t}\n\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst material = this.material;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tif (material === undefined) return; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy(geometry.boundingSphere);\n\n\t\t\t_sphere$3.applyMatrix4(matrixWorld);\n\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //\n\n\t\t\t_inverseMatrix$2.copy(matrixWorld).invert();\n\n\t\t\t_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing\n\n\n\t\t\tif (geometry.boundingBox !== null) {\n\t\t\t\tif (_ray$2.intersectsBox(geometry.boundingBox) === false) return;\n\t\t\t}\n\n\t\t\tlet intersection;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\t\tconst uv = geometry.attributes.uv;\n\t\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\t\tconst groups = geometry.groups;\n\t\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\t// indexed buffer geometry\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0, il = groups.length; i < il; i++) {\n\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\t\t\t\t\t\t\tconst start = Math.max(group.start, drawRange.start);\n\t\t\t\t\t\t\tconst end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\t\tfor (let j = start, jl = end; j < jl; j += 3) {\n\t\t\t\t\t\t\t\tconst a = index.getX(j);\n\t\t\t\t\t\t\t\tconst b = index.getX(j + 1);\n\t\t\t\t\t\t\t\tconst c = index.getX(j + 2);\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\tfor (let i = start, il = end; i < il; i += 3) {\n\t\t\t\t\t\t\tconst a = index.getX(i);\n\t\t\t\t\t\t\tconst b = index.getX(i + 1);\n\t\t\t\t\t\t\tconst c = index.getX(i + 2);\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (position !== undefined) {\n\t\t\t\t\t// non-indexed buffer geometry\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0, il = groups.length; i < il; i++) {\n\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\t\t\t\t\t\t\tconst start = Math.max(group.start, drawRange.start);\n\t\t\t\t\t\t\tconst end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\t\tfor (let j = start, jl = end; j < jl; j += 3) {\n\t\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\t\tconst c = j + 2;\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\t\tconst end = Math.min(position.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\tfor (let i = start, il = end; i < il; i += 3) {\n\t\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\t\tconst c = i + 2;\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t}\n\n\tMesh.prototype.isMesh = true;\n\n\tfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n\t\tlet intersect;\n\n\t\tif (material.side === BackSide) {\n\t\t\tintersect = ray.intersectTriangle(pC, pB, pA, true, point);\n\t\t} else {\n\t\t\tintersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n\t\t}\n\n\t\tif (intersect === null) return null;\n\n\t\t_intersectionPointWorld.copy(point);\n\n\t\t_intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n\t\tconst distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n\t\tif (distance < raycaster.near || distance > raycaster.far) return null;\n\t\treturn {\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectionPointWorld.clone(),\n\t\t\tobject: object\n\t\t};\n\t}\n\n\tfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n\t\t_vA$1.fromBufferAttribute(position, a);\n\n\t\t_vB$1.fromBufferAttribute(position, b);\n\n\t\t_vC$1.fromBufferAttribute(position, c);\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif (material.morphTargets && morphPosition && morphInfluences) {\n\t\t\t_morphA.set(0, 0, 0);\n\n\t\t\t_morphB.set(0, 0, 0);\n\n\t\t\t_morphC.set(0, 0, 0);\n\n\t\t\tfor (let i = 0, il = morphPosition.length; i < il; i++) {\n\t\t\t\tconst influence = morphInfluences[i];\n\t\t\t\tconst morphAttribute = morphPosition[i];\n\t\t\t\tif (influence === 0) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute(morphAttribute, a);\n\n\t\t\t\t_tempB.fromBufferAttribute(morphAttribute, b);\n\n\t\t\t\t_tempC.fromBufferAttribute(morphAttribute, c);\n\n\t\t\t\tif (morphTargetsRelative) {\n\t\t\t\t\t_morphA.addScaledVector(_tempA, influence);\n\n\t\t\t\t\t_morphB.addScaledVector(_tempB, influence);\n\n\t\t\t\t\t_morphC.addScaledVector(_tempC, influence);\n\t\t\t\t} else {\n\t\t\t\t\t_morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n\n\t\t\t\t\t_morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n\n\t\t\t\t\t_morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_vA$1.add(_morphA);\n\n\t\t\t_vB$1.add(_morphB);\n\n\t\t\t_vC$1.add(_morphC);\n\t\t}\n\n\t\tif (object.isSkinnedMesh) {\n\t\t\tobject.boneTransform(a, _vA$1);\n\t\t\tobject.boneTransform(b, _vB$1);\n\t\t\tobject.boneTransform(c, _vC$1);\n\t\t}\n\n\t\tconst intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n\n\t\tif (intersection) {\n\t\t\tif (uv) {\n\t\t\t\t_uvA$1.fromBufferAttribute(uv, a);\n\n\t\t\t\t_uvB$1.fromBufferAttribute(uv, b);\n\n\t\t\t\t_uvC$1.fromBufferAttribute(uv, c);\n\n\t\t\t\tintersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n\t\t\t}\n\n\t\t\tif (uv2) {\n\t\t\t\t_uvA$1.fromBufferAttribute(uv2, a);\n\n\t\t\t\t_uvB$1.fromBufferAttribute(uv2, b);\n\n\t\t\t\t_uvC$1.fromBufferAttribute(uv2, c);\n\n\t\t\t\tintersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\t\t\tTriangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n\t\t\tintersection.face = face;\n\t\t}\n\n\t\treturn intersection;\n\t}\n\n\tclass BoxGeometry extends BufferGeometry {\n\t\tconstructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'BoxGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\t\tconst scope = this; // segments\n\n\t\t\twidthSegments = Math.floor(widthSegments);\n\t\t\theightSegments = Math.floor(heightSegments);\n\t\t\tdepthSegments = Math.floor(depthSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet numberOfVertices = 0;\n\t\t\tlet groupStart = 0; // build each side of the box geometry\n\n\t\t\tbuildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n\t\t\tbuildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n\t\t\tbuildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n\t\t\tbuildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n\t\t\tbuildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n\t\t\tbuildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n\t\t\t// build geometry\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\tfunction buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n\t\t\t\tconst segmentWidth = width / gridX;\n\t\t\t\tconst segmentHeight = height / gridY;\n\t\t\t\tconst widthHalf = width / 2;\n\t\t\t\tconst heightHalf = height / 2;\n\t\t\t\tconst depthHalf = depth / 2;\n\t\t\t\tconst gridX1 = gridX + 1;\n\t\t\t\tconst gridY1 = gridY + 1;\n\t\t\t\tlet vertexCounter = 0;\n\t\t\t\tlet groupCount = 0;\n\t\t\t\tconst vector = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\t\tfor (let iy = 0; iy < gridY1; iy++) {\n\t\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\t\tfor (let ix = 0; ix < gridX1; ix++) {\n\t\t\t\t\t\tconst x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n\t\t\t\t\t\tvector[u] = x * udir;\n\t\t\t\t\t\tvector[v] = y * vdir;\n\t\t\t\t\t\tvector[w] = depthHalf; // now apply vector to vertex buffer\n\n\t\t\t\t\t\tvertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n\t\t\t\t\t\tvector[u] = 0;\n\t\t\t\t\t\tvector[v] = 0;\n\t\t\t\t\t\tvector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n\t\t\t\t\t\tnormals.push(vector.x, vector.y, vector.z); // uvs\n\n\t\t\t\t\t\tuvs.push(ix / gridX);\n\t\t\t\t\t\tuvs.push(1 - iy / gridY); // counters\n\n\t\t\t\t\t\tvertexCounter += 1;\n\t\t\t\t\t}\n\t\t\t\t} // indices\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\n\t\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * (iy + 1);\n\t\t\t\t\t\tconst c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n\t\t\t\t\t\tconst d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d); // increase counter\n\n\t\t\t\t\t\tgroupCount += 6;\n\t\t\t\t\t}\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount; // update total number of vertices\n\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Uniform Utilities\n\t */\n\tfunction cloneUniforms(src) {\n\t\tconst dst = {};\n\n\t\tfor (const u in src) {\n\t\t\tdst[u] = {};\n\n\t\t\tfor (const p in src[u]) {\n\t\t\t\tconst property = src[u][p];\n\n\t\t\t\tif (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n\t\t\t\t\tdst[u][p] = property.clone();\n\t\t\t\t} else if (Array.isArray(property)) {\n\t\t\t\t\tdst[u][p] = property.slice();\n\t\t\t\t} else {\n\t\t\t\t\tdst[u][p] = property;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dst;\n\t}\n\tfunction mergeUniforms(uniforms) {\n\t\tconst merged = {};\n\n\t\tfor (let u = 0; u < uniforms.length; u++) {\n\t\t\tconst tmp = cloneUniforms(uniforms[u]);\n\n\t\t\tfor (const p in tmp) {\n\t\t\t\tmerged[p] = tmp[p];\n\t\t\t}\n\t\t}\n\n\t\treturn merged;\n\t} // Legacy\n\n\tconst UniformsUtils = {\n\t\tclone: cloneUniforms,\n\t\tmerge: mergeUniforms\n\t};\n\n\tvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\n\tvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\n\t/**\n\t * parameters = {\n\t *\tdefines: { \"label\" : \"value\" },\n\t *\tuniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *\tfragmentShader: <string>,\n\t *\tvertexShader: <string>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tlights: <bool>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass ShaderMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShaderMaterial';\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\t\tthis.vertexShader = default_vertex;\n\t\t\tthis.fragmentShader = default_fragment;\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false; // set to use scene fog\n\n\t\t\tthis.lights = false; // set to use scene lights\n\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false,\n\t\t\t\t// set to use derivatives\n\t\t\t\tfragDepth: false,\n\t\t\t\t// set to use fragment depth values\n\t\t\t\tdrawBuffers: false,\n\t\t\t\t// set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\n\t\t\t}; // When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [1, 1, 1],\n\t\t\t\t'uv': [0, 0],\n\t\t\t\t'uv2': [0, 0]\n\t\t\t};\n\t\t\tthis.index0AttributeName = undefined;\n\t\t\tthis.uniformsNeedUpdate = false;\n\t\t\tthis.glslVersion = null;\n\n\t\t\tif (parameters !== undefined) {\n\t\t\t\tif (parameters.attributes !== undefined) {\n\t\t\t\t\tconsole.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n\t\t\t\t}\n\n\t\t\t\tthis.setValues(parameters);\n\t\t\t}\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\t\tthis.uniforms = cloneUniforms(source.uniforms);\n\t\t\tthis.defines = Object.assign({}, source.defines);\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.extensions = Object.assign({}, source.extensions);\n\t\t\tthis.glslVersion = source.glslVersion;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.glslVersion = this.glslVersion;\n\t\t\tdata.uniforms = {};\n\n\t\t\tfor (const name in this.uniforms) {\n\t\t\t\tconst uniform = this.uniforms[name];\n\t\t\t\tconst value = uniform.value;\n\n\t\t\t\tif (value && value.isTexture) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 't',\n\t\t\t\t\t\tvalue: value.toJSON(meta).uuid\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isColor) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'c',\n\t\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector2) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v2',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector3) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v3',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector4) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v4',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isMatrix3) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'm3',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isMatrix4) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'm4',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Object.keys(this.defines).length > 0) data.defines = this.defines;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\t\tconst extensions = {};\n\n\t\t\tfor (const key in this.extensions) {\n\t\t\t\tif (this.extensions[key] === true) extensions[key] = true;\n\t\t\t}\n\n\t\t\tif (Object.keys(extensions).length > 0) data.extensions = extensions;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tclass Camera extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Camera';\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\t\tthis.projectionMatrixInverse = new Matrix4();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.matrixWorldInverse.copy(source.matrixWorldInverse);\n\t\t\tthis.projectionMatrix.copy(source.projectionMatrix);\n\t\t\tthis.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetWorldDirection(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Camera: .getWorldDirection() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tconst e = this.matrixWorld.elements;\n\t\t\treturn target.set(-e[8], -e[9], -e[10]).normalize();\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tthis.matrixWorldInverse.copy(this.matrixWorld).invert();\n\t\t}\n\n\t\tupdateWorldMatrix(updateParents, updateChildren) {\n\t\t\tsuper.updateWorldMatrix(updateParents, updateChildren);\n\t\t\tthis.matrixWorldInverse.copy(this.matrixWorld).invert();\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tCamera.prototype.isCamera = true;\n\n\tclass PerspectiveCamera extends Camera {\n\t\tconstructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\t\tthis.fov = fov;\n\t\t\tthis.zoom = 1;\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.focus = 10;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.view = null;\n\t\t\tthis.filmGauge = 35; // width of the film (default in millimeters)\n\n\t\t\tthis.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign({}, source.view);\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\t\t\treturn this;\n\t\t}\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\n\n\t\tsetFocalLength(focalLength) {\n\t\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\t\tthis.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\n\n\t\tgetFocalLength() {\n\t\t\tconst vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\t}\n\n\t\tgetEffectiveFOV() {\n\t\t\treturn RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n\t\t}\n\n\t\tgetFilmWidth() {\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min(this.aspect, 1);\n\t\t}\n\n\t\tgetFilmHeight() {\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max(this.aspect, 1);\n\t\t}\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *\t +---+---+---+\n\t\t *\t | A | B | C |\n\t\t *\t +---+---+---+\n\t\t *\t | D | E | F |\n\t\t *\t +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *\t const w = 1920;\n\t\t *\t const h = 1080;\n\t\t *\t const fullWidth = w * 3;\n\t\t *\t const fullHeight = h * 2;\n\t\t *\n\t\t *\t --A--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *\t --B--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *\t --C--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *\t --D--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *\t --E--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *\t --F--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *\t Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\n\n\t\tsetViewOffset(fullWidth, fullHeight, x, y, width, height) {\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tif (this.view === null) {\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tclearViewOffset() {\n\t\t\tif (this.view !== null) {\n\t\t\t\tthis.view.enabled = false;\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tupdateProjectionMatrix() {\n\t\t\tconst near = this.near;\n\t\t\tlet top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n\t\t\tlet height = 2 * top;\n\t\t\tlet width = this.aspect * height;\n\t\t\tlet left = -0.5 * width;\n\t\t\tconst view = this.view;\n\n\t\t\tif (this.view !== null && this.view.enabled) {\n\t\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\t\t\t}\n\n\t\t\tconst skew = this.filmOffset;\n\t\t\tif (skew !== 0) left += near * skew / this.getFilmWidth();\n\t\t\tthis.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n\t\t\tthis.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\t\t\tdata.object.aspect = this.aspect;\n\t\t\tif (this.view !== null) data.object.view = Object.assign({}, this.view);\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\n\tconst fov = 90,\n\t\t\t\taspect = 1;\n\n\tclass CubeCamera extends Object3D {\n\t\tconstructor(near, far, renderTarget) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubeCamera';\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget !== true) {\n\t\t\t\tconsole.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.renderTarget = renderTarget;\n\t\t\tconst cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPX.layers = this.layers;\n\t\t\tcameraPX.up.set(0, -1, 0);\n\t\t\tcameraPX.lookAt(new Vector3(1, 0, 0));\n\t\t\tthis.add(cameraPX);\n\t\t\tconst cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNX.layers = this.layers;\n\t\t\tcameraNX.up.set(0, -1, 0);\n\t\t\tcameraNX.lookAt(new Vector3(-1, 0, 0));\n\t\t\tthis.add(cameraNX);\n\t\t\tconst cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPY.layers = this.layers;\n\t\t\tcameraPY.up.set(0, 0, 1);\n\t\t\tcameraPY.lookAt(new Vector3(0, 1, 0));\n\t\t\tthis.add(cameraPY);\n\t\t\tconst cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNY.layers = this.layers;\n\t\t\tcameraNY.up.set(0, 0, -1);\n\t\t\tcameraNY.lookAt(new Vector3(0, -1, 0));\n\t\t\tthis.add(cameraNY);\n\t\t\tconst cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPZ.layers = this.layers;\n\t\t\tcameraPZ.up.set(0, -1, 0);\n\t\t\tcameraPZ.lookAt(new Vector3(0, 0, 1));\n\t\t\tthis.add(cameraPZ);\n\t\t\tconst cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNZ.layers = this.layers;\n\t\t\tcameraNZ.up.set(0, -1, 0);\n\t\t\tcameraNZ.lookAt(new Vector3(0, 0, -1));\n\t\t\tthis.add(cameraNZ);\n\t\t}\n\n\t\tupdate(renderer, scene) {\n\t\t\tif (this.parent === null) this.updateMatrixWorld();\n\t\t\tconst renderTarget = this.renderTarget;\n\t\t\tconst [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\trenderer.xr.enabled = false;\n\t\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\t\trenderer.setRenderTarget(renderTarget, 0);\n\t\t\trenderer.render(scene, cameraPX);\n\t\t\trenderer.setRenderTarget(renderTarget, 1);\n\t\t\trenderer.render(scene, cameraNX);\n\t\t\trenderer.setRenderTarget(renderTarget, 2);\n\t\t\trenderer.render(scene, cameraPY);\n\t\t\trenderer.setRenderTarget(renderTarget, 3);\n\t\t\trenderer.render(scene, cameraNY);\n\t\t\trenderer.setRenderTarget(renderTarget, 4);\n\t\t\trenderer.render(scene, cameraPZ);\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\t\trenderer.setRenderTarget(renderTarget, 5);\n\t\t\trenderer.render(scene, cameraNZ);\n\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t}\n\n\t}\n\n\tclass CubeTexture extends Texture {\n\t\tconstructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\t\tformat = format !== undefined ? format : RGBFormat;\n\t\t\tsuper(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding); // Why CubeTexture._needsFlipEnvMap is necessary:\n\t\t\t//\n\t\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\t\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t\t// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)\n\t\t\t// when using WebGLCubeRenderTarget.texture as a cube texture.\n\n\t\t\tthis._needsFlipEnvMap = true;\n\t\t\tthis.flipY = false;\n\t\t}\n\n\t\tget images() {\n\t\t\treturn this.image;\n\t\t}\n\n\t\tset images(value) {\n\t\t\tthis.image = value;\n\t\t}\n\n\t}\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\t\tconstructor(size, options, dummy) {\n\t\t\tif (Number.isInteger(options)) {\n\t\t\t\tconsole.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');\n\t\t\t\toptions = dummy;\n\t\t\t}\n\n\t\t\tsuper(size, size, options);\n\t\t\toptions = options || {};\n\t\t\tthis.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\t\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\t\t\tthis.texture._needsFlipEnvMap = false;\n\t\t}\n\n\t\tfromEquirectangularTexture(renderer, texture) {\n\t\t\tthis.texture.type = texture.type;\n\t\t\tthis.texture.format = RGBAFormat; // see #18859\n\n\t\t\tthis.texture.encoding = texture.encoding;\n\t\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\t\tthis.texture.minFilter = texture.minFilter;\n\t\t\tthis.texture.magFilter = texture.magFilter;\n\t\t\tconst shader = {\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: {\n\t\t\t\t\t\tvalue: null\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tvertexShader:\n\t\t\t\t/* glsl */\n\t\t\t\t`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\t\t\t\tfragmentShader:\n\t\t\t\t/* glsl */\n\t\t\t\t`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t\t};\n\t\t\tconst geometry = new BoxGeometry(5, 5, 5);\n\t\t\tconst material = new ShaderMaterial({\n\t\t\t\tname: 'CubemapFromEquirect',\n\t\t\t\tuniforms: cloneUniforms(shader.uniforms),\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tblending: NoBlending\n\t\t\t});\n\t\t\tmaterial.uniforms.tEquirect.value = texture;\n\t\t\tconst mesh = new Mesh(geometry, material);\n\t\t\tconst currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n\t\t\tif (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n\t\t\tconst camera = new CubeCamera(1, 10, this);\n\t\t\tcamera.update(renderer, mesh);\n\t\t\ttexture.minFilter = currentMinFilter;\n\t\t\tmesh.geometry.dispose();\n\t\t\tmesh.material.dispose();\n\t\t\treturn this;\n\t\t}\n\n\t\tclear(renderer, color, depth, stencil) {\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\trenderer.setRenderTarget(this, i);\n\t\t\t\trenderer.clear(color, depth, stencil);\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t}\n\n\t}\n\n\tWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\n\tconst _sphere$2 = /*@__PURE__*/new Sphere();\n\n\tconst _vector$7 = /*@__PURE__*/new Vector3();\n\n\tclass Frustum {\n\t\tconstructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n\t\t\tthis.planes = [p0, p1, p2, p3, p4, p5];\n\t\t}\n\n\t\tset(p0, p1, p2, p3, p4, p5) {\n\t\t\tconst planes = this.planes;\n\t\t\tplanes[0].copy(p0);\n\t\t\tplanes[1].copy(p1);\n\t\t\tplanes[2].copy(p2);\n\t\t\tplanes[3].copy(p3);\n\t\t\tplanes[4].copy(p4);\n\t\t\tplanes[5].copy(p5);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(frustum) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tplanes[i].copy(frustum.planes[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromProjectionMatrix(m) {\n\t\t\tconst planes = this.planes;\n\t\t\tconst me = m.elements;\n\t\t\tconst me0 = me[0],\n\t\t\t\t\t\tme1 = me[1],\n\t\t\t\t\t\tme2 = me[2],\n\t\t\t\t\t\tme3 = me[3];\n\t\t\tconst me4 = me[4],\n\t\t\t\t\t\tme5 = me[5],\n\t\t\t\t\t\tme6 = me[6],\n\t\t\t\t\t\tme7 = me[7];\n\t\t\tconst me8 = me[8],\n\t\t\t\t\t\tme9 = me[9],\n\t\t\t\t\t\tme10 = me[10],\n\t\t\t\t\t\tme11 = me[11];\n\t\t\tconst me12 = me[12],\n\t\t\t\t\t\tme13 = me[13],\n\t\t\t\t\t\tme14 = me[14],\n\t\t\t\t\t\tme15 = me[15];\n\t\t\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n\t\t\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n\t\t\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n\t\t\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n\t\t\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n\t\t\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n\t\t\treturn this;\n\t\t}\n\n\t\tintersectsObject(object) {\n\t\t\tconst geometry = object.geometry;\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n\t\t\treturn this.intersectsSphere(_sphere$2);\n\t\t}\n\n\t\tintersectsSprite(sprite) {\n\t\t\t_sphere$2.center.set(0, 0, 0);\n\n\t\t\t_sphere$2.radius = 0.7071067811865476;\n\n\t\t\t_sphere$2.applyMatrix4(sprite.matrixWorld);\n\n\t\t\treturn this.intersectsSphere(_sphere$2);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\tconst planes = this.planes;\n\t\t\tconst center = sphere.center;\n\t\t\tconst negRadius = -sphere.radius;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst distance = planes[i].distanceToPoint(center);\n\n\t\t\t\tif (distance < negRadius) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst plane = planes[i]; // corner at max distance\n\n\t\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tif (plane.distanceToPoint(_vector$7) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tif (planes[i].distanceToPoint(point) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tfunction WebGLAnimation() {\n\t\tlet context = null;\n\t\tlet isAnimating = false;\n\t\tlet animationLoop = null;\n\t\tlet requestId = null;\n\n\t\tfunction onAnimationFrame(time, frame) {\n\t\t\tanimationLoop(time, frame);\n\t\t\trequestId = context.requestAnimationFrame(onAnimationFrame);\n\t\t}\n\n\t\treturn {\n\t\t\tstart: function () {\n\t\t\t\tif (isAnimating === true) return;\n\t\t\t\tif (animationLoop === null) return;\n\t\t\t\trequestId = context.requestAnimationFrame(onAnimationFrame);\n\t\t\t\tisAnimating = true;\n\t\t\t},\n\t\t\tstop: function () {\n\t\t\t\tcontext.cancelAnimationFrame(requestId);\n\t\t\t\tisAnimating = false;\n\t\t\t},\n\t\t\tsetAnimationLoop: function (callback) {\n\t\t\t\tanimationLoop = callback;\n\t\t\t},\n\t\t\tsetContext: function (value) {\n\t\t\t\tcontext = value;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction WebGLAttributes(gl, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst buffers = new WeakMap();\n\n\t\tfunction createBuffer(attribute, bufferType) {\n\t\t\tconst array = attribute.array;\n\t\t\tconst usage = attribute.usage;\n\t\t\tconst buffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(bufferType, buffer);\n\t\t\tgl.bufferData(bufferType, array, usage);\n\t\t\tattribute.onUploadCallback();\n\t\t\tlet type = gl.FLOAT;\n\n\t\t\tif (array instanceof Float32Array) {\n\t\t\t\ttype = gl.FLOAT;\n\t\t\t} else if (array instanceof Float64Array) {\n\t\t\t\tconsole.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');\n\t\t\t} else if (array instanceof Uint16Array) {\n\t\t\t\tif (attribute.isFloat16BufferAttribute) {\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\ttype = gl.HALF_FLOAT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\t}\n\t\t\t} else if (array instanceof Int16Array) {\n\t\t\t\ttype = gl.SHORT;\n\t\t\t} else if (array instanceof Uint32Array) {\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t} else if (array instanceof Int32Array) {\n\t\t\t\ttype = gl.INT;\n\t\t\t} else if (array instanceof Int8Array) {\n\t\t\t\ttype = gl.BYTE;\n\t\t\t} else if (array instanceof Uint8Array) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t} else if (array instanceof Uint8ClampedArray) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tbuffer: buffer,\n\t\t\t\ttype: type,\n\t\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\t\t}\n\n\t\tfunction updateBuffer(buffer, attribute, bufferType) {\n\t\t\tconst array = attribute.array;\n\t\t\tconst updateRange = attribute.updateRange;\n\t\t\tgl.bindBuffer(bufferType, buffer);\n\n\t\t\tif (updateRange.count === -1) {\n\t\t\t\t// Not using update ranges\n\t\t\t\tgl.bufferSubData(bufferType, 0, array);\n\t\t\t} else {\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tgl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n\t\t\t\t} else {\n\t\t\t\t\tgl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n\t\t\t\t}\n\n\t\t\t\tupdateRange.count = -1; // reset range\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction get(attribute) {\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\treturn buffers.get(attribute);\n\t\t}\n\n\t\tfunction remove(attribute) {\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\tconst data = buffers.get(attribute);\n\n\t\t\tif (data) {\n\t\t\t\tgl.deleteBuffer(data.buffer);\n\t\t\t\tbuffers.delete(attribute);\n\t\t\t}\n\t\t}\n\n\t\tfunction update(attribute, bufferType) {\n\t\t\tif (attribute.isGLBufferAttribute) {\n\t\t\t\tconst cached = buffers.get(attribute);\n\n\t\t\t\tif (!cached || cached.version < attribute.version) {\n\t\t\t\t\tbuffers.set(attribute, {\n\t\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\t\tversion: attribute.version\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\tconst data = buffers.get(attribute);\n\n\t\t\tif (data === undefined) {\n\t\t\t\tbuffers.set(attribute, createBuffer(attribute, bufferType));\n\t\t\t} else if (data.version < attribute.version) {\n\t\t\t\tupdateBuffer(data.buffer, attribute, bufferType);\n\t\t\t\tdata.version = attribute.version;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tclass PlaneGeometry extends BufferGeometry {\n\t\tconstructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PlaneGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\t\tconst width_half = width / 2;\n\t\t\tconst height_half = height / 2;\n\t\t\tconst gridX = Math.floor(widthSegments);\n\t\t\tconst gridY = Math.floor(heightSegments);\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\t\t\tconst segment_width = width / gridX;\n\t\t\tconst segment_height = height / gridY; //\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\n\t\t\tfor (let iy = 0; iy < gridY1; iy++) {\n\t\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\t\tfor (let ix = 0; ix < gridX1; ix++) {\n\t\t\t\t\tconst x = ix * segment_width - width_half;\n\t\t\t\t\tvertices.push(x, -y, 0);\n\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\tuvs.push(ix / gridX);\n\t\t\t\t\tuvs.push(1 - iy / gridY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\t\tconst b = ix + gridX1 * (iy + 1);\n\t\t\t\t\tconst c = ix + 1 + gridX1 * (iy + 1);\n\t\t\t\t\tconst d = ix + 1 + gridX1 * iy;\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\n\tvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\n\tvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\\tfloat invAlpha = 1.0 / roughness;\\n\\tfloat cos2h = NoH * NoH;\\n\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 H = normalize( V + L );\\n\\tfloat dotNH = saturate( dot( N, H ) );\\n\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\n\tvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\n\tvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\n\tvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\n\tvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\n\tvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = - mvPosition.z;\\n#endif\";\n\n\tvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\n\tvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\n\tvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\n\tvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\n\tvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\\n#endif\\n#ifdef CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheen;\\n#endif\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularRoughness;\\n\\tvec3 specularColor;\\n#ifdef CLEARCOAT\\n\\tfloat clearcoat;\\n\\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(\t\t0, 1,\t\t0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tccIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\\t\\t\\tmaterial.specularRoughness,\\n\\t\\t\\tdirectLight.direction,\\n\\t\\t\\tgeometry,\\n\\t\\t\\tmaterial.sheenColor\\n\\t\\t);\\n\\t#else\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\n\\t#endif\\n\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t\\tfloat ccDotNL = ccDotNV;\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\n\tvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\n\tvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\\t#ifdef CLEARCOAT\\n\\t\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\\t#endif\\n#endif\";\n\n\tvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\n\tvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\n\tvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\n\tvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\n\tvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\n\n\tvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\";\n\n\tvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\n\n\tvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\";\n\n\tvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\n\tvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\n\tvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\n\tvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\tf.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\tf.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\n\tvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(\t1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,\t1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,\t1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\n\tvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSNMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\\n\\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\\n\\tvec3 f90 = vec3( 1.0 );\\n\\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\\n\\t\\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationColor, attenuationDistance);\\n\\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\\n#endif\";\n\n\tvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec4 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\\n\\t\\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\\n\\t\\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\\n\\t\\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\\n\\t\\treturn normalize(refractionVector) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness(float roughness, float ior) {\\n\\t\\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\\n\\t}\\n\\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\\n\\t\\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\\n\\t\\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\\n\\t}\\n\\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tif (attenuationDistance == 0.0) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\\n\\t\\tfloat NdotV = saturate(dot(n, viewDir));\\n\\t\\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\\n\\t\\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\\n\\t\\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\\n\\t}\\n#endif\";\n\n\tvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\n\tvar uv_vertex = \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\n\tvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\n\tvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\n\tvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\n\tvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\n\tvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define REFLECTIVITY\\n\\t#define CLEARCOAT\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform vec3 attenuationColor;\\n\\tuniform float attenuationDistance;\\n#endif\\n#ifdef REFLECTIVITY\\n\\tuniform float reflectivity;\\n#endif\\n#ifdef CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <transmission_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat totalTransmission = transmission;\\n\\t\\tfloat thicknessFactor = thickness;\\n\\t#endif\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\tvec3 rawDiffuseColor = diffuseColor.rgb;\\n\\t#include <transmission_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec4 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition;\\n#endif\\n}\";\n\n\tvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\n\tvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\n\tvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\n\tvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tconst ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_vertex: fog_vertex,\n\t\tfog_pars_vertex: fog_pars_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars_begin: lights_pars_begin,\n\t\tlights_toon_fragment: lights_toon_fragment,\n\t\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_fragment_begin: lights_fragment_begin,\n\t\tlights_fragment_maps: lights_fragment_maps,\n\t\tlights_fragment_end: lights_fragment_end,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_fragment_begin: normal_fragment_begin,\n\t\tnormal_fragment_maps: normal_fragment_maps,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\t\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\t\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\tdithering_fragment: dithering_fragment,\n\t\tdithering_pars_fragment: dithering_pars_fragment,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\ttransmission_fragment: transmission_fragment,\n\t\ttransmission_pars_fragment: transmission_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\t\tbackground_frag: background_frag,\n\t\tbackground_vert: background_vert,\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshmatcap_frag: meshmatcap_frag,\n\t\tmeshmatcap_vert: meshmatcap_vert,\n\t\tmeshtoon_frag: meshtoon_frag,\n\t\tmeshtoon_vert: meshtoon_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert,\n\t\tsprite_frag: sprite_frag,\n\t\tsprite_vert: sprite_vert\n\t};\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tconst UniformsLib = {\n\t\tcommon: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t},\n\t\t\tuv2Transform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tspecularmap: {\n\t\t\tspecularMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tenvmap: {\n\t\t\tenvMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tflipEnvMap: {\n\t\t\t\tvalue: -1\n\t\t\t},\n\t\t\treflectivity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\trefractionRatio: {\n\t\t\t\tvalue: 0.98\n\t\t\t},\n\t\t\tmaxMipLevel: {\n\t\t\t\tvalue: 0\n\t\t\t}\n\t\t},\n\t\taomap: {\n\t\t\taoMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\taoMapIntensity: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\tlightmap: {\n\t\t\tlightMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tlightMapIntensity: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\temissivemap: {\n\t\t\temissiveMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tbumpmap: {\n\t\t\tbumpMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tbumpScale: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\tnormalmap: {\n\t\t\tnormalMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tnormalScale: {\n\t\t\t\tvalue: new Vector2(1, 1)\n\t\t\t}\n\t\t},\n\t\tdisplacementmap: {\n\t\t\tdisplacementMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tdisplacementScale: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t\tdisplacementBias: {\n\t\t\t\tvalue: 0\n\t\t\t}\n\t\t},\n\t\troughnessmap: {\n\t\t\troughnessMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tmetalnessmap: {\n\t\t\tmetalnessMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tgradientmap: {\n\t\t\tgradientMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tfog: {\n\t\t\tfogDensity: {\n\t\t\t\tvalue: 0.00025\n\t\t\t},\n\t\t\tfogNear: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t\tfogFar: {\n\t\t\t\tvalue: 2000\n\t\t\t},\n\t\t\tfogColor: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t}\n\t\t},\n\t\tlights: {\n\t\t\tambientLightColor: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tlightProbe: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tdirectionalLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdirectionalLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdirectionalShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tdirectionalShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tspotLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tspotLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tspotShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tspotShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tpointLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpointLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {},\n\t\t\t\t\tshadowCameraNear: {},\n\t\t\t\t\tshadowCameraFar: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpointShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tpointShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\themisphereLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\t\trectAreaLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\twidth: {},\n\t\t\t\t\theight: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tltc_1: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tltc_2: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tpoints: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t},\n\t\tsprite: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tcenter: {\n\t\t\t\tvalue: new Vector2(0.5, 0.5)\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tvalue: 0.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t}\n\t};\n\n\tconst ShaderLib = {\n\t\tbasic: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\t},\n\t\tlambert: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\t},\n\t\tphong: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t},\n\t\t\t\tspecular: {\n\t\t\t\t\tvalue: new Color(0x111111)\n\t\t\t\t},\n\t\t\t\tshininess: {\n\t\t\t\t\tvalue: 30\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\t},\n\t\tstandard: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t},\n\t\t\t\troughness: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t},\n\t\t\t\tmetalness: {\n\t\t\t\t\tvalue: 0.0\n\t\t\t\t},\n\t\t\t\tenvMapIntensity: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t} // temporary\n\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\t},\n\t\ttoon: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\t\t},\n\t\tmatcap: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {\n\t\t\t\tmatcap: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\t\t},\n\t\tpoints: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\t},\n\t\tdashed: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {\n\t\t\t\tscale: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tdashSize: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\ttotalSize: {\n\t\t\t\t\tvalue: 2\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\t},\n\t\tdepth: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\t},\n\t\tnormal: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\t},\n\t\tsprite: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\t\tfragmentShader: ShaderChunk.sprite_frag\n\t\t},\n\t\tbackground: {\n\t\t\tuniforms: {\n\t\t\t\tuvTransform: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t},\n\t\t\t\tt2D: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: ShaderChunk.background_vert,\n\t\t\tfragmentShader: ShaderChunk.background_frag\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\tcube: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.envmap, {\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\t},\n\t\tequirect: {\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\t},\n\t\tdistanceRGBA: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {\n\t\t\t\treferencePosition: {\n\t\t\t\t\tvalue: new Vector3()\n\t\t\t\t},\n\t\t\t\tnearDistance: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tfarDistance: {\n\t\t\t\t\tvalue: 1000\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\t},\n\t\tshadow: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {\n\t\t\t\tcolor: {\n\t\t\t\t\tvalue: new Color(0x00000)\n\t\t\t\t},\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\t\tfragmentShader: ShaderChunk.shadow_frag\n\t\t}\n\t};\n\tShaderLib.physical = {\n\t\tuniforms: mergeUniforms([ShaderLib.standard.uniforms, {\n\t\t\tclearcoat: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tclearcoatMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tclearcoatRoughness: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tclearcoatRoughnessMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tclearcoatNormalScale: {\n\t\t\t\tvalue: new Vector2(1, 1)\n\t\t\t},\n\t\t\tclearcoatNormalMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tsheen: {\n\t\t\t\tvalue: new Color(0x000000)\n\t\t\t},\n\t\t\ttransmission: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\ttransmissionMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\ttransmissionSamplerSize: {\n\t\t\t\tvalue: new Vector2()\n\t\t\t},\n\t\t\ttransmissionSamplerMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tthickness: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tthicknessMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tattenuationDistance: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tattenuationColor: {\n\t\t\t\tvalue: new Color(0x000000)\n\t\t\t}\n\t\t}]),\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t};\n\n\tfunction WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {\n\t\tconst clearColor = new Color(0x000000);\n\t\tlet clearAlpha = 0;\n\t\tlet planeMesh;\n\t\tlet boxMesh;\n\t\tlet currentBackground = null;\n\t\tlet currentBackgroundVersion = 0;\n\t\tlet currentTonemapping = null;\n\n\t\tfunction render(renderList, scene) {\n\t\t\tlet forceClear = false;\n\t\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\t\tif (background && background.isTexture) {\n\t\t\t\tbackground = cubemaps.get(background);\n\t\t\t} // Ignore background in AR\n\t\t\t// TODO: Reconsider this.\n\n\n\t\t\tconst xr = renderer.xr;\n\t\t\tconst session = xr.getSession && xr.getSession();\n\n\t\t\tif (session && session.environmentBlendMode === 'additive') {\n\t\t\t\tbackground = null;\n\t\t\t}\n\n\t\t\tif (background === null) {\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t} else if (background && background.isColor) {\n\t\t\t\tsetClear(background, 1);\n\t\t\t\tforceClear = true;\n\t\t\t}\n\n\t\t\tif (renderer.autoClear || forceClear) {\n\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t}\n\n\t\t\tif (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n\t\t\t\tif (boxMesh === undefined) {\n\t\t\t\t\tboxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms(ShaderLib.cube.uniforms),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t}));\n\t\t\t\t\tboxMesh.geometry.deleteAttribute('normal');\n\t\t\t\t\tboxMesh.geometry.deleteAttribute('uv');\n\n\t\t\t\t\tboxMesh.onBeforeRender = function (renderer, scene, camera) {\n\t\t\t\t\t\tthis.matrixWorld.copyPosition(camera.matrixWorld);\n\t\t\t\t\t}; // enable code injection for non-built-in material\n\n\n\t\t\t\t\tObject.defineProperty(boxMesh.material, 'envMap', {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tobjects.update(boxMesh);\n\t\t\t\t}\n\n\t\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\t\tboxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;\n\n\t\t\t\tif (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n\t\t\t\t\tboxMesh.material.needsUpdate = true;\n\t\t\t\t\tcurrentBackground = background;\n\t\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\t\t\t\t} // push to the pre-sorted opaque render list\n\n\n\t\t\t\trenderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n\t\t\t} else if (background && background.isTexture) {\n\t\t\t\tif (planeMesh === undefined) {\n\t\t\t\t\tplaneMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms(ShaderLib.background.uniforms),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t}));\n\t\t\t\t\tplaneMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material\n\n\t\t\t\t\tObject.defineProperty(planeMesh.material, 'map', {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tobjects.update(planeMesh);\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\t\tif (background.matrixAutoUpdate === true) {\n\t\t\t\t\tbackground.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n\t\t\t\tif (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n\t\t\t\t\tplaneMesh.material.needsUpdate = true;\n\t\t\t\t\tcurrentBackground = background;\n\t\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\t\t\t\t} // push to the pre-sorted opaque render list\n\n\n\t\t\t\trenderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n\t\t\t}\n\t\t}\n\n\t\tfunction setClear(color, alpha) {\n\t\t\tstate.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n\t\t}\n\n\t\treturn {\n\t\t\tgetClearColor: function () {\n\t\t\t\treturn clearColor;\n\t\t\t},\n\t\t\tsetClearColor: function (color, alpha = 1) {\n\t\t\t\tclearColor.set(color);\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t},\n\t\t\tgetClearAlpha: function () {\n\t\t\t\treturn clearAlpha;\n\t\t\t},\n\t\t\tsetClearAlpha: function (alpha) {\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t},\n\t\t\trender: render\n\t\t};\n\t}\n\n\tfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n\t\tconst maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\t\tconst extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n\t\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\t\tconst bindingStates = {};\n\t\tconst defaultState = createBindingState(null);\n\t\tlet currentState = defaultState;\n\n\t\tfunction setup(object, material, program, geometry, index) {\n\t\t\tlet updateBuffers = false;\n\n\t\t\tif (vaoAvailable) {\n\t\t\t\tconst state = getBindingState(geometry, program, material);\n\n\t\t\t\tif (currentState !== state) {\n\t\t\t\t\tcurrentState = state;\n\t\t\t\t\tbindVertexArrayObject(currentState.object);\n\t\t\t\t}\n\n\t\t\t\tupdateBuffers = needsUpdate(geometry, index);\n\t\t\t\tif (updateBuffers) saveCache(geometry, index);\n\t\t\t} else {\n\t\t\t\tconst wireframe = material.wireframe === true;\n\n\t\t\t\tif (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n\t\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\t\tcurrentState.program = program.id;\n\t\t\t\t\tcurrentState.wireframe = wireframe;\n\t\t\t\t\tupdateBuffers = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh === true) {\n\t\t\t\tupdateBuffers = true;\n\t\t\t}\n\n\t\t\tif (index !== null) {\n\t\t\t\tattributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n\t\t\t}\n\n\t\t\tif (updateBuffers) {\n\t\t\t\tsetupVertexAttributes(object, material, program, geometry);\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createVertexArrayObject() {\n\t\t\tif (capabilities.isWebGL2) return gl.createVertexArray();\n\t\t\treturn extension.createVertexArrayOES();\n\t\t}\n\n\t\tfunction bindVertexArrayObject(vao) {\n\t\t\tif (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n\t\t\treturn extension.bindVertexArrayOES(vao);\n\t\t}\n\n\t\tfunction deleteVertexArrayObject(vao) {\n\t\t\tif (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n\t\t\treturn extension.deleteVertexArrayOES(vao);\n\t\t}\n\n\t\tfunction getBindingState(geometry, program, material) {\n\t\t\tconst wireframe = material.wireframe === true;\n\t\t\tlet programMap = bindingStates[geometry.id];\n\n\t\t\tif (programMap === undefined) {\n\t\t\t\tprogramMap = {};\n\t\t\t\tbindingStates[geometry.id] = programMap;\n\t\t\t}\n\n\t\t\tlet stateMap = programMap[program.id];\n\n\t\t\tif (stateMap === undefined) {\n\t\t\t\tstateMap = {};\n\t\t\t\tprogramMap[program.id] = stateMap;\n\t\t\t}\n\n\t\t\tlet state = stateMap[wireframe];\n\n\t\t\tif (state === undefined) {\n\t\t\t\tstate = createBindingState(createVertexArrayObject());\n\t\t\t\tstateMap[wireframe] = state;\n\t\t\t}\n\n\t\t\treturn state;\n\t\t}\n\n\t\tfunction createBindingState(vao) {\n\t\t\tconst newAttributes = [];\n\t\t\tconst enabledAttributes = [];\n\t\t\tconst attributeDivisors = [];\n\n\t\t\tfor (let i = 0; i < maxVertexAttributes; i++) {\n\t\t\t\tnewAttributes[i] = 0;\n\t\t\t\tenabledAttributes[i] = 0;\n\t\t\t\tattributeDivisors[i] = 0;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\t\tgeometry: null,\n\t\t\t\tprogram: null,\n\t\t\t\twireframe: false,\n\t\t\t\tnewAttributes: newAttributes,\n\t\t\t\tenabledAttributes: enabledAttributes,\n\t\t\t\tattributeDivisors: attributeDivisors,\n\t\t\t\tobject: vao,\n\t\t\t\tattributes: {},\n\t\t\t\tindex: null\n\t\t\t};\n\t\t}\n\n\t\tfunction needsUpdate(geometry, index) {\n\t\t\tconst cachedAttributes = currentState.attributes;\n\t\t\tconst geometryAttributes = geometry.attributes;\n\t\t\tlet attributesNum = 0;\n\n\t\t\tfor (const key in geometryAttributes) {\n\t\t\t\tconst cachedAttribute = cachedAttributes[key];\n\t\t\t\tconst geometryAttribute = geometryAttributes[key];\n\t\t\t\tif (cachedAttribute === undefined) return true;\n\t\t\t\tif (cachedAttribute.attribute !== geometryAttribute) return true;\n\t\t\t\tif (cachedAttribute.data !== geometryAttribute.data) return true;\n\t\t\t\tattributesNum++;\n\t\t\t}\n\n\t\t\tif (currentState.attributesNum !== attributesNum) return true;\n\t\t\tif (currentState.index !== index) return true;\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction saveCache(geometry, index) {\n\t\t\tconst cache = {};\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tlet attributesNum = 0;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif (attribute.data) {\n\t\t\t\t\tdata.data = attribute.data;\n\t\t\t\t}\n\n\t\t\t\tcache[key] = data;\n\t\t\t\tattributesNum++;\n\t\t\t}\n\n\t\t\tcurrentState.attributes = cache;\n\t\t\tcurrentState.attributesNum = attributesNum;\n\t\t\tcurrentState.index = index;\n\t\t}\n\n\t\tfunction initAttributes() {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\n\t\t\tfor (let i = 0, il = newAttributes.length; i < il; i++) {\n\t\t\t\tnewAttributes[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfunction enableAttribute(attribute) {\n\t\t\tenableAttributeAndDivisor(attribute, 0);\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor(attribute, meshPerAttribute) {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\t\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\t\tconst attributeDivisors = currentState.attributeDivisors;\n\t\t\tnewAttributes[attribute] = 1;\n\n\t\t\tif (enabledAttributes[attribute] === 0) {\n\t\t\t\tgl.enableVertexAttribArray(attribute);\n\t\t\t\tenabledAttributes[attribute] = 1;\n\t\t\t}\n\n\t\t\tif (attributeDivisors[attribute] !== meshPerAttribute) {\n\t\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n\t\t\t\textension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n\t\t\t\tattributeDivisors[attribute] = meshPerAttribute;\n\t\t\t}\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\t\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\t\tfor (let i = 0, il = enabledAttributes.length; i < il; i++) {\n\t\t\t\tif (enabledAttributes[i] !== newAttributes[i]) {\n\t\t\t\t\tgl.disableVertexAttribArray(i);\n\t\t\t\t\tenabledAttributes[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction vertexAttribPointer(index, size, type, normalized, stride, offset) {\n\t\t\tif (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {\n\t\t\t\tgl.vertexAttribIPointer(index, size, type, stride, offset);\n\t\t\t} else {\n\t\t\t\tgl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n\t\t\t}\n\t\t}\n\n\t\tfunction setupVertexAttributes(object, material, program, geometry) {\n\t\t\tif (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n\t\t\t\tif (extensions.get('ANGLE_instanced_arrays') === null) return;\n\t\t\t}\n\n\t\t\tinitAttributes();\n\t\t\tconst geometryAttributes = geometry.attributes;\n\t\t\tconst programAttributes = program.getAttributes();\n\t\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor (const name in programAttributes) {\n\t\t\t\tconst programAttribute = programAttributes[name];\n\n\t\t\t\tif (programAttribute >= 0) {\n\t\t\t\t\tconst geometryAttribute = geometryAttributes[name];\n\n\t\t\t\t\tif (geometryAttribute !== undefined) {\n\t\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\t\t\t\t\t\tconst attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t\tif (geometryAttribute.isInterleavedBufferAttribute) {\n\t\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif (data && data.isInstancedInterleavedBuffer) {\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\n\n\t\t\t\t\t\t\t\tif (geometry._maxInstanceCount === undefined) {\n\t\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tenableAttribute(programAttribute);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\t\tvertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (geometryAttribute.isInstancedBufferAttribute) {\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\n\n\t\t\t\t\t\t\t\tif (geometry._maxInstanceCount === undefined) {\n\t\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tenableAttribute(programAttribute);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\t\tvertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (name === 'instanceMatrix') {\n\t\t\t\t\t\tconst attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 0, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 1, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 2, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 3, 1);\n\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);\n\t\t\t\t\t} else if (name === 'instanceColor') {\n\t\t\t\t\t\tconst attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, 1);\n\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);\n\t\t\t\t\t} else if (materialDefaultAttributeValues !== undefined) {\n\t\t\t\t\t\tconst value = materialDefaultAttributeValues[name];\n\n\t\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\t\tswitch (value.length) {\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib2fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib3fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib4fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib1fv(programAttribute, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdisableUnusedAttributes();\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\treset();\n\n\t\t\tfor (const geometryId in bindingStates) {\n\t\t\t\tconst programMap = bindingStates[geometryId];\n\n\t\t\t\tfor (const programId in programMap) {\n\t\t\t\t\tconst stateMap = programMap[programId];\n\n\t\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete programMap[programId];\n\t\t\t\t}\n\n\t\t\t\tdelete bindingStates[geometryId];\n\t\t\t}\n\t\t}\n\n\t\tfunction releaseStatesOfGeometry(geometry) {\n\t\t\tif (bindingStates[geometry.id] === undefined) return;\n\t\t\tconst programMap = bindingStates[geometry.id];\n\n\t\t\tfor (const programId in programMap) {\n\t\t\t\tconst stateMap = programMap[programId];\n\n\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[programId];\n\t\t\t}\n\n\t\t\tdelete bindingStates[geometry.id];\n\t\t}\n\n\t\tfunction releaseStatesOfProgram(program) {\n\t\t\tfor (const geometryId in bindingStates) {\n\t\t\t\tconst programMap = bindingStates[geometryId];\n\t\t\t\tif (programMap[program.id] === undefined) continue;\n\t\t\t\tconst stateMap = programMap[program.id];\n\n\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[program.id];\n\t\t\t}\n\t\t}\n\n\t\tfunction reset() {\n\t\t\tresetDefaultState();\n\t\t\tif (currentState === defaultState) return;\n\t\t\tcurrentState = defaultState;\n\t\t\tbindVertexArrayObject(currentState.object);\n\t\t} // for backward-compatilibity\n\n\n\t\tfunction resetDefaultState() {\n\t\t\tdefaultState.geometry = null;\n\t\t\tdefaultState.program = null;\n\t\t\tdefaultState.wireframe = false;\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\treset: reset,\n\t\t\tresetDefaultState: resetDefaultState,\n\t\t\tdispose: dispose,\n\t\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes\n\t\t};\n\t}\n\n\tfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tlet mode;\n\n\t\tfunction setMode(value) {\n\t\t\tmode = value;\n\t\t}\n\n\t\tfunction render(start, count) {\n\t\t\tgl.drawArrays(mode, start, count);\n\t\t\tinfo.update(count, mode, 1);\n\t\t}\n\n\t\tfunction renderInstances(start, count, primcount) {\n\t\t\tif (primcount === 0) return;\n\t\t\tlet extension, methodName;\n\n\t\t\tif (isWebGL2) {\n\t\t\t\textension = gl;\n\t\t\t\tmethodName = 'drawArraysInstanced';\n\t\t\t} else {\n\t\t\t\textension = extensions.get('ANGLE_instanced_arrays');\n\t\t\t\tmethodName = 'drawArraysInstancedANGLE';\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textension[methodName](mode, start, count, primcount);\n\t\t\tinfo.update(count, mode, primcount);\n\t\t} //\n\n\n\t\tthis.setMode = setMode;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t}\n\n\tfunction WebGLCapabilities(gl, extensions, parameters) {\n\t\tlet maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\t\t\tif (maxAnisotropy !== undefined) return maxAnisotropy;\n\n\t\t\tif (extensions.has('EXT_texture_filter_anisotropic') === true) {\n\t\t\t\tconst extension = extensions.get('EXT_texture_filter_anisotropic');\n\t\t\t\tmaxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\t\t\t} else {\n\t\t\t\tmaxAnisotropy = 0;\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\t\t}\n\n\t\tfunction getMaxPrecision(precision) {\n\t\t\tif (precision === 'highp') {\n\t\t\t\tif (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {\n\t\t\t\t\treturn 'highp';\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\t\t\t}\n\n\t\t\tif (precision === 'mediump') {\n\t\t\t\tif (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {\n\t\t\t\t\treturn 'mediump';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\t\t}\n\t\t/* eslint-disable no-undef */\n\n\n\t\tconst isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;\n\t\t/* eslint-enable no-undef */\n\n\t\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tconst maxPrecision = getMaxPrecision(precision);\n\n\t\tif (maxPrecision !== precision) {\n\t\t\tconsole.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');\n\t\t\tprecision = maxPrecision;\n\t\t}\n\n\t\tconst drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');\n\t\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\t\tconst maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\t\tconst maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n\t\tconst maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\t\tconst maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\t\tconst maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\t\tconst maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n\t\tconst maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);\n\t\tconst maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\t\tconst vertexTextures = maxVertexTextures > 0;\n\t\tconst floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');\n\t\tconst floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\tconst maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;\n\t\treturn {\n\t\t\tisWebGL2: isWebGL2,\n\t\t\tdrawBuffers: drawBuffers,\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures,\n\t\t\tmaxSamples: maxSamples\n\t\t};\n\t}\n\n\tfunction WebGLClipping(properties) {\n\t\tconst scope = this;\n\t\tlet globalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false;\n\t\tconst plane = new Plane(),\n\t\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\t\t\t\tuniform = {\n\t\t\tvalue: null,\n\t\t\tneedsUpdate: false\n\t\t};\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function (planes, enableLocalClipping, camera) {\n\t\t\tconst enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 || localClippingEnabled;\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\t\tglobalState = projectPlanes(planes, camera, 0);\n\t\t\tnumGlobalPlanes = planes.length;\n\t\t\treturn enabled;\n\t\t};\n\n\t\tthis.beginShadows = function () {\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes(null);\n\t\t};\n\n\t\tthis.endShadows = function () {\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\t\t};\n\n\t\tthis.setState = function (material, camera, useCache) {\n\t\t\tconst planes = material.clippingPlanes,\n\t\t\t\t\t\tclipIntersection = material.clipIntersection,\n\t\t\t\t\t\tclipShadows = material.clipShadows;\n\t\t\tconst materialProperties = properties.get(material);\n\n\t\t\tif (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n\t\t\t\t// there's no local clipping\n\t\t\t\tif (renderingShadows) {\n\t\t\t\t\t// there's no global clipping\n\t\t\t\t\tprojectPlanes(null);\n\t\t\t\t} else {\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\t\tlGlobal = nGlobal * 4;\n\t\t\t\tlet dstArray = materialProperties.clippingState || null;\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n\t\t\t\tfor (let i = 0; i !== lGlobal; ++i) {\n\t\t\t\t\tdstArray[i] = globalState[i];\n\t\t\t\t}\n\n\t\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\t\t\t}\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\t\t\tif (uniform.value !== globalState) {\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\t\t}\n\n\t\tfunction projectPlanes(planes, camera, dstOffset, skipTransform) {\n\t\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\t\tlet dstArray = null;\n\n\t\t\tif (nPlanes !== 0) {\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif (skipTransform !== true || dstArray === null) {\n\t\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix(viewMatrix);\n\n\t\t\t\t\tif (dstArray === null || dstArray.length < flatSize) {\n\t\t\t\t\t\tdstArray = new Float32Array(flatSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n\t\t\t\t\t\tplane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n\t\t\t\t\t\tplane.normal.toArray(dstArray, i4);\n\t\t\t\t\t\tdstArray[i4 + 3] = plane.constant;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\tscope.numIntersection = 0;\n\t\t\treturn dstArray;\n\t\t}\n\t}\n\n\tfunction WebGLCubeMaps(renderer) {\n\t\tlet cubemaps = new WeakMap();\n\n\t\tfunction mapTextureMapping(texture, mapping) {\n\t\t\tif (mapping === EquirectangularReflectionMapping) {\n\t\t\t\ttexture.mapping = CubeReflectionMapping;\n\t\t\t} else if (mapping === EquirectangularRefractionMapping) {\n\t\t\t\ttexture.mapping = CubeRefractionMapping;\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction get(texture) {\n\t\t\tif (texture && texture.isTexture) {\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n\t\t\t\t\tif (cubemaps.has(texture)) {\n\t\t\t\t\t\tconst cubemap = cubemaps.get(texture).texture;\n\t\t\t\t\t\treturn mapTextureMapping(cubemap, texture.mapping);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif (image && image.height > 0) {\n\t\t\t\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture(renderer, texture);\n\t\t\t\t\t\t\tcubemaps.set(texture, renderTarget);\n\t\t\t\t\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t\t\t\t\t\ttexture.addEventListener('dispose', onTextureDispose);\n\t\t\t\t\t\t\treturn mapTextureMapping(renderTarget.texture, texture.mapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction onTextureDispose(event) {\n\t\t\tconst texture = event.target;\n\t\t\ttexture.removeEventListener('dispose', onTextureDispose);\n\t\t\tconst cubemap = cubemaps.get(texture);\n\n\t\t\tif (cubemap !== undefined) {\n\t\t\t\tcubemaps.delete(texture);\n\t\t\t\tcubemap.dispose();\n\t\t\t}\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tcubemaps = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction WebGLExtensions(gl) {\n\t\tconst extensions = {};\n\n\t\tfunction getExtension(name) {\n\t\t\tif (extensions[name] !== undefined) {\n\t\t\t\treturn extensions[name];\n\t\t\t}\n\n\t\t\tlet extension;\n\n\t\t\tswitch (name) {\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension(name);\n\t\t\t}\n\n\t\t\textensions[name] = extension;\n\t\t\treturn extension;\n\t\t}\n\n\t\treturn {\n\t\t\thas: function (name) {\n\t\t\t\treturn getExtension(name) !== null;\n\t\t\t},\n\t\t\tinit: function (capabilities) {\n\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\tgetExtension('EXT_color_buffer_float');\n\t\t\t\t} else {\n\t\t\t\t\tgetExtension('WEBGL_depth_texture');\n\t\t\t\t\tgetExtension('OES_texture_float');\n\t\t\t\t\tgetExtension('OES_texture_half_float');\n\t\t\t\t\tgetExtension('OES_texture_half_float_linear');\n\t\t\t\t\tgetExtension('OES_standard_derivatives');\n\t\t\t\t\tgetExtension('OES_element_index_uint');\n\t\t\t\t\tgetExtension('OES_vertex_array_object');\n\t\t\t\t\tgetExtension('ANGLE_instanced_arrays');\n\t\t\t\t}\n\n\t\t\t\tgetExtension('OES_texture_float_linear');\n\t\t\t\tgetExtension('EXT_color_buffer_half_float');\n\t\t\t},\n\t\t\tget: function (name) {\n\t\t\t\tconst extension = getExtension(name);\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\n\t\t\t\t}\n\n\t\t\t\treturn extension;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n\t\tconst geometries = {};\n\t\tconst wireframeAttributes = new WeakMap();\n\n\t\tfunction onGeometryDispose(event) {\n\t\t\tconst geometry = event.target;\n\n\t\t\tif (geometry.index !== null) {\n\t\t\t\tattributes.remove(geometry.index);\n\t\t\t}\n\n\t\t\tfor (const name in geometry.attributes) {\n\t\t\t\tattributes.remove(geometry.attributes[name]);\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener('dispose', onGeometryDispose);\n\t\t\tdelete geometries[geometry.id];\n\t\t\tconst attribute = wireframeAttributes.get(geometry);\n\n\t\t\tif (attribute) {\n\t\t\t\tattributes.remove(attribute);\n\t\t\t\twireframeAttributes.delete(geometry);\n\t\t\t}\n\n\t\t\tbindingStates.releaseStatesOfGeometry(geometry);\n\n\t\t\tif (geometry.isInstancedBufferGeometry === true) {\n\t\t\t\tdelete geometry._maxInstanceCount;\n\t\t\t} //\n\n\n\t\t\tinfo.memory.geometries--;\n\t\t}\n\n\t\tfunction get(object, geometry) {\n\t\t\tif (geometries[geometry.id] === true) return geometry;\n\t\t\tgeometry.addEventListener('dispose', onGeometryDispose);\n\t\t\tgeometries[geometry.id] = true;\n\t\t\tinfo.memory.geometries++;\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction update(geometry) {\n\t\t\tconst geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\t\tfor (const name in geometryAttributes) {\n\t\t\t\tattributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);\n\t\t\t} // morph targets\n\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst array = morphAttributes[name];\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\tattributes.update(array[i], gl.ARRAY_BUFFER);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateWireframeAttribute(geometry) {\n\t\t\tconst indices = [];\n\t\t\tconst geometryIndex = geometry.index;\n\t\t\tconst geometryPosition = geometry.attributes.position;\n\t\t\tlet version = 0;\n\n\t\t\tif (geometryIndex !== null) {\n\t\t\t\tconst array = geometryIndex.array;\n\t\t\t\tversion = geometryIndex.version;\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i += 3) {\n\t\t\t\t\tconst a = array[i + 0];\n\t\t\t\t\tconst b = array[i + 1];\n\t\t\t\t\tconst c = array[i + 2];\n\t\t\t\t\tindices.push(a, b, b, c, c, a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst array = geometryPosition.array;\n\t\t\t\tversion = geometryPosition.version;\n\n\t\t\t\tfor (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n\t\t\t\t\tconst a = i + 0;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\t\t\t\t\tindices.push(a, b, b, c, c, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n\t\t\tattribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates\n\t\t\t//\n\n\t\t\tconst previousAttribute = wireframeAttributes.get(geometry);\n\t\t\tif (previousAttribute) attributes.remove(previousAttribute); //\n\n\t\t\twireframeAttributes.set(geometry, attribute);\n\t\t}\n\n\t\tfunction getWireframeAttribute(geometry) {\n\t\t\tconst currentAttribute = wireframeAttributes.get(geometry);\n\n\t\t\tif (currentAttribute) {\n\t\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\t\tif (geometryIndex !== null) {\n\t\t\t\t\t// if the attribute is obsolete, create a new one\n\t\t\t\t\tif (currentAttribute.version < geometryIndex.version) {\n\t\t\t\t\t\tupdateWireframeAttribute(geometry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdateWireframeAttribute(geometry);\n\t\t\t}\n\n\t\t\treturn wireframeAttributes.get(geometry);\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tupdate: update,\n\t\t\tgetWireframeAttribute: getWireframeAttribute\n\t\t};\n\t}\n\n\tfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tlet mode;\n\n\t\tfunction setMode(value) {\n\t\t\tmode = value;\n\t\t}\n\n\t\tlet type, bytesPerElement;\n\n\t\tfunction setIndex(value) {\n\t\t\ttype = value.type;\n\t\t\tbytesPerElement = value.bytesPerElement;\n\t\t}\n\n\t\tfunction render(start, count) {\n\t\t\tgl.drawElements(mode, count, type, start * bytesPerElement);\n\t\t\tinfo.update(count, mode, 1);\n\t\t}\n\n\t\tfunction renderInstances(start, count, primcount) {\n\t\t\tif (primcount === 0) return;\n\t\t\tlet extension, methodName;\n\n\t\t\tif (isWebGL2) {\n\t\t\t\textension = gl;\n\t\t\t\tmethodName = 'drawElementsInstanced';\n\t\t\t} else {\n\t\t\t\textension = extensions.get('ANGLE_instanced_arrays');\n\t\t\t\tmethodName = 'drawElementsInstancedANGLE';\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textension[methodName](mode, count, type, start * bytesPerElement, primcount);\n\t\t\tinfo.update(count, mode, primcount);\n\t\t} //\n\n\n\t\tthis.setMode = setMode;\n\t\tthis.setIndex = setIndex;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t}\n\n\tfunction WebGLInfo(gl) {\n\t\tconst memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\t\tconst render = {\n\t\t\tframe: 0,\n\t\t\tcalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0\n\t\t};\n\n\t\tfunction update(count, mode, instanceCount) {\n\t\t\trender.calls++;\n\n\t\t\tswitch (mode) {\n\t\t\t\tcase gl.TRIANGLES:\n\t\t\t\t\trender.triangles += instanceCount * (count / 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINES:\n\t\t\t\t\trender.lines += instanceCount * (count / 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINE_STRIP:\n\t\t\t\t\trender.lines += instanceCount * (count - 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINE_LOOP:\n\t\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.POINTS:\n\t\t\t\t\trender.points += instanceCount * count;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('THREE.WebGLInfo: Unknown draw mode:', mode);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction reset() {\n\t\t\trender.frame++;\n\t\t\trender.calls = 0;\n\t\t\trender.triangles = 0;\n\t\t\trender.points = 0;\n\t\t\trender.lines = 0;\n\t\t}\n\n\t\treturn {\n\t\t\tmemory: memory,\n\t\t\trender: render,\n\t\t\tprograms: null,\n\t\t\tautoReset: true,\n\t\t\treset: reset,\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tfunction numericalSort(a, b) {\n\t\treturn a[0] - b[0];\n\t}\n\n\tfunction absNumericalSort(a, b) {\n\t\treturn Math.abs(b[1]) - Math.abs(a[1]);\n\t}\n\n\tfunction WebGLMorphtargets(gl) {\n\t\tconst influencesList = {};\n\t\tconst morphInfluences = new Float32Array(8);\n\t\tconst workInfluences = [];\n\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tworkInfluences[i] = [i, 0];\n\t\t}\n\n\t\tfunction update(object, geometry, material, program) {\n\t\t\tconst objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\t\t\tlet influences = influencesList[geometry.id];\n\n\t\t\tif (influences === undefined) {\n\t\t\t\t// initialise list\n\t\t\t\tinfluences = [];\n\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tinfluences[i] = [i, 0];\n\t\t\t\t}\n\n\t\t\t\tinfluencesList[geometry.id] = influences;\n\t\t\t} // Collect influences\n\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst influence = influences[i];\n\t\t\t\tinfluence[0] = i;\n\t\t\t\tinfluence[1] = objectInfluences[i];\n\t\t\t}\n\n\t\t\tinfluences.sort(absNumericalSort);\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif (i < length && influences[i][1]) {\n\t\t\t\t\tworkInfluences[i][0] = influences[i][0];\n\t\t\t\t\tworkInfluences[i][1] = influences[i][1];\n\t\t\t\t} else {\n\t\t\t\t\tworkInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tworkInfluences[i][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworkInfluences.sort(numericalSort);\n\t\t\tconst morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\t\tconst morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst influence = workInfluences[i];\n\t\t\t\tconst index = influence[0];\n\t\t\t\tconst value = influence[1];\n\n\t\t\t\tif (index !== Number.MAX_SAFE_INTEGER && value) {\n\t\t\t\t\tif (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n\t\t\t\t\t\tgeometry.setAttribute('morphTarget' + i, morphTargets[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n\t\t\t\t\t\tgeometry.setAttribute('morphNormal' + i, morphNormals[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[i] = value;\n\t\t\t\t\tmorphInfluencesSum += value;\n\t\t\t\t} else {\n\t\t\t\t\tif (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n\t\t\t\t\t\tgeometry.deleteAttribute('morphTarget' + i);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n\t\t\t\t\t\tgeometry.deleteAttribute('morphNormal' + i);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[i] = 0;\n\t\t\t\t}\n\t\t\t} // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\t\t\tprogram.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n\t\t\tprogram.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n\t\t}\n\n\t\treturn {\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tfunction WebGLObjects(gl, geometries, attributes, info) {\n\t\tlet updateMap = new WeakMap();\n\n\t\tfunction update(object) {\n\t\t\tconst frame = info.render.frame;\n\t\t\tconst geometry = object.geometry;\n\t\t\tconst buffergeometry = geometries.get(object, geometry); // Update once per frame\n\n\t\t\tif (updateMap.get(buffergeometry) !== frame) {\n\t\t\t\tgeometries.update(buffergeometry);\n\t\t\t\tupdateMap.set(buffergeometry, frame);\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh) {\n\t\t\t\tif (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {\n\t\t\t\t\tobject.addEventListener('dispose', onInstancedMeshDispose);\n\t\t\t\t}\n\n\t\t\t\tattributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);\n\n\t\t\t\tif (object.instanceColor !== null) {\n\t\t\t\t\tattributes.update(object.instanceColor, gl.ARRAY_BUFFER);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buffergeometry;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tupdateMap = new WeakMap();\n\t\t}\n\n\t\tfunction onInstancedMeshDispose(event) {\n\t\t\tconst instancedMesh = event.target;\n\t\t\tinstancedMesh.removeEventListener('dispose', onInstancedMeshDispose);\n\t\t\tattributes.remove(instancedMesh.instanceMatrix);\n\t\t\tif (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);\n\t\t}\n\n\t\treturn {\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tclass DataTexture2DArray extends Texture {\n\t\tconstructor(data = null, width = 1, height = 1, depth = 1) {\n\t\t\tsuper(null);\n\t\t\tthis.image = {\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdepth\n\t\t\t};\n\t\t\tthis.magFilter = NearestFilter;\n\t\t\tthis.minFilter = NearestFilter;\n\t\t\tthis.wrapR = ClampToEdgeWrapping;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\n\tclass DataTexture3D extends Texture {\n\t\tconstructor(data = null, width = 1, height = 1, depth = 1) {\n\t\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t\t// Users can still set in DataTexture3D directly.\n\t\t\t//\n\t\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t\t// \ttexture.anisotropy = 16;\n\t\t\t//\n\t\t\t// See #14839\n\t\t\tsuper(null);\n\t\t\tthis.image = {\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdepth\n\t\t\t};\n\t\t\tthis.magFilter = NearestFilter;\n\t\t\tthis.minFilter = NearestFilter;\n\t\t\tthis.wrapR = ClampToEdgeWrapping;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture3D.prototype.isDataTexture3D = true;\n\n\t/**\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [textures] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *\t\tthe 'textures' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (textures factorizations):\n\t *\n\t * .upload( gl, seq, values, textures )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (textures factorizations):\n\t *\n\t * .setValue( gl, name, value, textures )\n\t *\n\t * \t\tsets uniform with\tname 'name' to 'value'\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\tconst emptyTexture = new Texture();\n\tconst emptyTexture2dArray = new DataTexture2DArray();\n\tconst emptyTexture3d = new DataTexture3D();\n\tconst emptyCubeTexture = new CubeTexture(); // --- Utilities ---\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tconst arrayCacheF32 = [];\n\tconst arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms\n\n\tconst mat4array = new Float32Array(16);\n\tconst mat3array = new Float32Array(9);\n\tconst mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices\n\n\tfunction flatten(array, nBlocks, blockSize) {\n\t\tconst firstElem = array[0];\n\t\tif (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tconst n = nBlocks * blockSize;\n\t\tlet r = arrayCacheF32[n];\n\n\t\tif (r === undefined) {\n\t\t\tr = new Float32Array(n);\n\t\t\tarrayCacheF32[n] = r;\n\t\t}\n\n\t\tif (nBlocks !== 0) {\n\t\t\tfirstElem.toArray(r, 0);\n\n\t\t\tfor (let i = 1, offset = 0; i !== nBlocks; ++i) {\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[i].toArray(r, offset);\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tfunction arraysEqual(a, b) {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0, l = a.length; i < l; i++) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction copyArray(a, b) {\n\t\tfor (let i = 0, l = b.length; i < l; i++) {\n\t\t\ta[i] = b[i];\n\t\t}\n\t} // Texture unit allocation\n\n\n\tfunction allocTexUnits(textures, n) {\n\t\tlet r = arrayCacheI32[n];\n\n\t\tif (r === undefined) {\n\t\t\tr = new Int32Array(n);\n\t\t\tarrayCacheI32[n] = r;\n\t\t}\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\tr[i] = textures.allocateTextureUnit();\n\t\t}\n\n\t\treturn r;\n\t} // --- Setters ---\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\t// Single scalar\n\n\n\tfunction setValueV1f(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1f(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single float vector (from flat array or THREE.VectorN)\n\n\n\tfunction setValueV2f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y) {\n\t\t\t\tgl.uniform2f(this.addr, v.x, v.y);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform2fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t}\n\n\tfunction setValueV3f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n\t\t\t\tgl.uniform3f(this.addr, v.x, v.y, v.z);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t\tcache[2] = v.z;\n\t\t\t}\n\t\t} else if (v.r !== undefined) {\n\t\t\tif (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n\t\t\t\tgl.uniform3f(this.addr, v.r, v.g, v.b);\n\t\t\t\tcache[0] = v.r;\n\t\t\t\tcache[1] = v.g;\n\t\t\t\tcache[2] = v.b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform3fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t}\n\n\tfunction setValueV4f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\n\t\t\t\tgl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t\tcache[2] = v.z;\n\t\t\t\tcache[3] = v.w;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform4fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t} // Single matrix (from flat array or THREE.MatrixN)\n\n\n\tfunction setValueM2(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix2fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat2array.set(elements);\n\t\t\tgl.uniformMatrix2fv(this.addr, false, mat2array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t}\n\n\tfunction setValueM3(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix3fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat3array.set(elements);\n\t\t\tgl.uniformMatrix3fv(this.addr, false, mat3array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t}\n\n\tfunction setValueM4(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix4fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat4array.set(elements);\n\t\t\tgl.uniformMatrix4fv(this.addr, false, mat4array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t} // Single integer / boolean\n\n\n\tfunction setValueV1i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1i(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single integer / boolean vector (from flat array)\n\n\n\tfunction setValueV2i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform2iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV3i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform3iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV4i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform4iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t} // Single unsigned integer\n\n\n\tfunction setValueV1ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1ui(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single unsigned integer vector (from flat array)\n\n\n\tfunction setValueV2ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform2uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV3ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform3uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV4ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform4uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t} // Single texture (2D / Cube)\n\n\n\tfunction setValueT1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.safeSetTexture2D(v || emptyTexture, unit);\n\t}\n\n\tfunction setValueT3D1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.setTexture3D(v || emptyTexture3d, unit);\n\t}\n\n\tfunction setValueT6(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.safeSetTextureCube(v || emptyCubeTexture, unit);\n\t}\n\n\tfunction setValueT2DArray1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.setTexture2DArray(v || emptyTexture2dArray, unit);\n\t} // Helper to pick the right setter for the singular case\n\n\n\tfunction getSingularSetter(type) {\n\t\tswitch (type) {\n\t\t\tcase 0x1406:\n\t\t\t\treturn setValueV1f;\n\t\t\t// FLOAT\n\n\t\t\tcase 0x8b50:\n\t\t\t\treturn setValueV2f;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b51:\n\t\t\t\treturn setValueV3f;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b52:\n\t\t\t\treturn setValueV4f;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5a:\n\t\t\t\treturn setValueM2;\n\t\t\t// _MAT2\n\n\t\t\tcase 0x8b5b:\n\t\t\t\treturn setValueM3;\n\t\t\t// _MAT3\n\n\t\t\tcase 0x8b5c:\n\t\t\t\treturn setValueM4;\n\t\t\t// _MAT4\n\n\t\t\tcase 0x1404:\n\t\t\tcase 0x8b56:\n\t\t\t\treturn setValueV1i;\n\t\t\t// INT, BOOL\n\n\t\t\tcase 0x8b53:\n\t\t\tcase 0x8b57:\n\t\t\t\treturn setValueV2i;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b54:\n\t\t\tcase 0x8b58:\n\t\t\t\treturn setValueV3i;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b55:\n\t\t\tcase 0x8b59:\n\t\t\t\treturn setValueV4i;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x1405:\n\t\t\t\treturn setValueV1ui;\n\t\t\t// UINT\n\n\t\t\tcase 0x8dc6:\n\t\t\t\treturn setValueV2ui;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8dc7:\n\t\t\t\treturn setValueV3ui;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8dc8:\n\t\t\t\treturn setValueV4ui;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5e: // SAMPLER_2D\n\n\t\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\n\t\t\tcase 0x8dca: // INT_SAMPLER_2D\n\n\t\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n\t\t\tcase 0x8b62:\n\t\t\t\t// SAMPLER_2D_SHADOW\n\t\t\t\treturn setValueT1;\n\n\t\t\tcase 0x8b5f: // SAMPLER_3D\n\n\t\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\n\t\t\tcase 0x8dd3:\n\t\t\t\t// UNSIGNED_INT_SAMPLER_3D\n\t\t\t\treturn setValueT3D1;\n\n\t\t\tcase 0x8b60: // SAMPLER_CUBE\n\n\t\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dc5:\n\t\t\t\t// SAMPLER_CUBE_SHADOW\n\t\t\t\treturn setValueT6;\n\n\t\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dc4:\n\t\t\t\t// SAMPLER_2D_ARRAY_SHADOW\n\t\t\t\treturn setValueT2DArray1;\n\t\t}\n\t} // Array of scalars\n\n\n\tfunction setValueV1fArray(gl, v) {\n\t\tgl.uniform1fv(this.addr, v);\n\t} // Array of vectors (from flat array or array of THREE.VectorN)\n\n\n\tfunction setValueV2fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 2);\n\t\tgl.uniform2fv(this.addr, data);\n\t}\n\n\tfunction setValueV3fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 3);\n\t\tgl.uniform3fv(this.addr, data);\n\t}\n\n\tfunction setValueV4fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 4);\n\t\tgl.uniform4fv(this.addr, data);\n\t} // Array of matrices (from flat array or array of THREE.MatrixN)\n\n\n\tfunction setValueM2Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 4);\n\t\tgl.uniformMatrix2fv(this.addr, false, data);\n\t}\n\n\tfunction setValueM3Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 9);\n\t\tgl.uniformMatrix3fv(this.addr, false, data);\n\t}\n\n\tfunction setValueM4Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 16);\n\t\tgl.uniformMatrix4fv(this.addr, false, data);\n\t} // Array of integer / boolean\n\n\n\tfunction setValueV1iArray(gl, v) {\n\t\tgl.uniform1iv(this.addr, v);\n\t} // Array of integer / boolean vectors (from flat array)\n\n\n\tfunction setValueV2iArray(gl, v) {\n\t\tgl.uniform2iv(this.addr, v);\n\t}\n\n\tfunction setValueV3iArray(gl, v) {\n\t\tgl.uniform3iv(this.addr, v);\n\t}\n\n\tfunction setValueV4iArray(gl, v) {\n\t\tgl.uniform4iv(this.addr, v);\n\t} // Array of unsigned integer\n\n\n\tfunction setValueV1uiArray(gl, v) {\n\t\tgl.uniform1uiv(this.addr, v);\n\t} // Array of unsigned integer vectors (from flat array)\n\n\n\tfunction setValueV2uiArray(gl, v) {\n\t\tgl.uniform2uiv(this.addr, v);\n\t}\n\n\tfunction setValueV3uiArray(gl, v) {\n\t\tgl.uniform3uiv(this.addr, v);\n\t}\n\n\tfunction setValueV4uiArray(gl, v) {\n\t\tgl.uniform4uiv(this.addr, v);\n\t} // Array of textures (2D / Cube)\n\n\n\tfunction setValueT1Array(gl, v, textures) {\n\t\tconst n = v.length;\n\t\tconst units = allocTexUnits(textures, n);\n\t\tgl.uniform1iv(this.addr, units);\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\ttextures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\n\t\t}\n\t}\n\n\tfunction setValueT6Array(gl, v, textures) {\n\t\tconst n = v.length;\n\t\tconst units = allocTexUnits(textures, n);\n\t\tgl.uniform1iv(this.addr, units);\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\ttextures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\n\t\t}\n\t} // Helper to pick the right setter for a pure (bottom-level) array\n\n\n\tfunction getPureArraySetter(type) {\n\t\tswitch (type) {\n\t\t\tcase 0x1406:\n\t\t\t\treturn setValueV1fArray;\n\t\t\t// FLOAT\n\n\t\t\tcase 0x8b50:\n\t\t\t\treturn setValueV2fArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b51:\n\t\t\t\treturn setValueV3fArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b52:\n\t\t\t\treturn setValueV4fArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5a:\n\t\t\t\treturn setValueM2Array;\n\t\t\t// _MAT2\n\n\t\t\tcase 0x8b5b:\n\t\t\t\treturn setValueM3Array;\n\t\t\t// _MAT3\n\n\t\t\tcase 0x8b5c:\n\t\t\t\treturn setValueM4Array;\n\t\t\t// _MAT4\n\n\t\t\tcase 0x1404:\n\t\t\tcase 0x8b56:\n\t\t\t\treturn setValueV1iArray;\n\t\t\t// INT, BOOL\n\n\t\t\tcase 0x8b53:\n\t\t\tcase 0x8b57:\n\t\t\t\treturn setValueV2iArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b54:\n\t\t\tcase 0x8b58:\n\t\t\t\treturn setValueV3iArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b55:\n\t\t\tcase 0x8b59:\n\t\t\t\treturn setValueV4iArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x1405:\n\t\t\t\treturn setValueV1uiArray;\n\t\t\t// UINT\n\n\t\t\tcase 0x8dc6:\n\t\t\t\treturn setValueV2uiArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8dc7:\n\t\t\t\treturn setValueV3uiArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8dc8:\n\t\t\t\treturn setValueV4uiArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5e: // SAMPLER_2D\n\n\t\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\n\t\t\tcase 0x8dca: // INT_SAMPLER_2D\n\n\t\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n\t\t\tcase 0x8b62:\n\t\t\t\t// SAMPLER_2D_SHADOW\n\t\t\t\treturn setValueT1Array;\n\n\t\t\tcase 0x8b60: // SAMPLER_CUBE\n\n\t\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dc5:\n\t\t\t\t// SAMPLER_CUBE_SHADOW\n\t\t\t\treturn setValueT6Array;\n\t\t}\n\t} // --- Uniform Classes ---\n\n\n\tfunction SingleUniform(id, activeInfo, addr) {\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n\t}\n\n\tfunction PureArrayUniform(id, activeInfo, addr) {\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n\t}\n\n\tPureArrayUniform.prototype.updateCache = function (data) {\n\t\tconst cache = this.cache;\n\n\t\tif (data instanceof Float32Array && cache.length !== data.length) {\n\t\t\tthis.cache = new Float32Array(data.length);\n\t\t}\n\n\t\tcopyArray(cache, data);\n\t};\n\n\tfunction StructuredUniform(id) {\n\t\tthis.id = id;\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\t}\n\n\tStructuredUniform.prototype.setValue = function (gl, value, textures) {\n\t\tconst seq = this.seq;\n\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i];\n\t\t\tu.setValue(gl, value[u.id], textures);\n\t\t}\n\t}; // --- Top-level ---\n\t// Parser - builds up the property tree from the path strings\n\n\n\tconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g; // extracts\n\t// \t- the identifier (member name or array index)\n\t//\t- followed by an optional right bracket (found when array index)\n\t//\t- followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform(container, uniformObject) {\n\t\tcontainer.seq.push(uniformObject);\n\t\tcontainer.map[uniformObject.id] = uniformObject;\n\t}\n\n\tfunction parseUniform(activeInfo, addr, container) {\n\t\tconst path = activeInfo.name,\n\t\t\t\t\tpathLength = path.length; // reset RegExp object, because of the early exit of a previous run\n\n\t\tRePathPart.lastIndex = 0;\n\n\t\twhile (true) {\n\t\t\tconst match = RePathPart.exec(path),\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex;\n\t\t\tlet id = match[1];\n\t\t\tconst idIsIndex = match[2] === ']',\n\t\t\t\t\t\tsubscript = match[3];\n\t\t\tif (idIsIndex) id = id | 0; // convert to integer\n\n\t\t\tif (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\t\t\taddUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\t\t\tconst map = container.map;\n\t\t\t\tlet next = map[id];\n\n\t\t\t\tif (next === undefined) {\n\t\t\t\t\tnext = new StructuredUniform(id);\n\t\t\t\t\taddUniform(container, next);\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\t\t\t}\n\t\t}\n\t} // Root Container\n\n\n\tfunction WebGLUniforms(gl, program) {\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\t\tconst n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n\t\tfor (let i = 0; i < n; ++i) {\n\t\t\tconst info = gl.getActiveUniform(program, i),\n\t\t\t\t\t\taddr = gl.getUniformLocation(program, info.name);\n\t\t\tparseUniform(info, addr, this);\n\t\t}\n\t}\n\n\tWebGLUniforms.prototype.setValue = function (gl, name, value, textures) {\n\t\tconst u = this.map[name];\n\t\tif (u !== undefined) u.setValue(gl, value, textures);\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function (gl, object, name) {\n\t\tconst v = object[name];\n\t\tif (v !== undefined) this.setValue(gl, name, v);\n\t}; // Static interface\n\n\n\tWebGLUniforms.upload = function (gl, seq, values, textures) {\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i],\n\t\t\t\t\t\tv = values[u.id];\n\n\t\t\tif (v.needsUpdate !== false) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue(gl, v.value, textures);\n\t\t\t}\n\t\t}\n\t};\n\n\tWebGLUniforms.seqWithValue = function (seq, values) {\n\t\tconst r = [];\n\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i];\n\t\t\tif (u.id in values) r.push(u);\n\t\t}\n\n\t\treturn r;\n\t};\n\n\tfunction WebGLShader(gl, type, string) {\n\t\tconst shader = gl.createShader(type);\n\t\tgl.shaderSource(shader, string);\n\t\tgl.compileShader(shader);\n\t\treturn shader;\n\t}\n\n\tlet programIdCount = 0;\n\n\tfunction addLineNumbers(string) {\n\t\tconst lines = string.split('\\n');\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlines[i] = i + 1 + ': ' + lines[i];\n\t\t}\n\n\t\treturn lines.join('\\n');\n\t}\n\n\tfunction getEncodingComponents(encoding) {\n\t\tswitch (encoding) {\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn ['Linear', '( value )'];\n\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn ['sRGB', '( value )'];\n\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn ['RGBE', '( value )'];\n\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn ['RGBM', '( value, 7.0 )'];\n\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn ['RGBM', '( value, 16.0 )'];\n\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn ['RGBD', '( value, 256.0 )'];\n\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n\n\t\t\tcase LogLuvEncoding:\n\t\t\t\treturn ['LogLuv', '( value )'];\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);\n\t\t\t\treturn ['Linear', '( value )'];\n\t\t}\n\t}\n\n\tfunction getShaderErrors(gl, shader, type) {\n\t\tconst status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t\tconst log = gl.getShaderInfoLog(shader).trim();\n\t\tif (status && log === '') return ''; // --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst source = gl.getShaderSource(shader);\n\t\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers(source);\n\t}\n\n\tfunction getTexelDecodingFunction(functionName, encoding) {\n\t\tconst components = getEncodingComponents(encoding);\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n\t}\n\n\tfunction getTexelEncodingFunction(functionName, encoding) {\n\t\tconst components = getEncodingComponents(encoding);\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';\n\t}\n\n\tfunction getToneMappingFunction(functionName, toneMapping) {\n\t\tlet toneMappingName;\n\n\t\tswitch (toneMapping) {\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = 'Reinhard';\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\t\tbreak;\n\n\t\t\tcase ACESFilmicToneMapping:\n\t\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\t\tbreak;\n\n\t\t\tcase CustomToneMapping:\n\t\t\t\ttoneMappingName = 'Custom';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t}\n\n\t\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\t}\n\n\tfunction generateExtensions(parameters) {\n\t\tconst chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];\n\t\treturn chunks.filter(filterEmptyLine).join('\\n');\n\t}\n\n\tfunction generateDefines(defines) {\n\t\tconst chunks = [];\n\n\t\tfor (const name in defines) {\n\t\t\tconst value = defines[name];\n\t\t\tif (value === false) continue;\n\t\t\tchunks.push('#define ' + name + ' ' + value);\n\t\t}\n\n\t\treturn chunks.join('\\n');\n\t}\n\n\tfunction fetchAttributeLocations(gl, program) {\n\t\tconst attributes = {};\n\t\tconst n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst info = gl.getActiveAttrib(program, i);\n\t\t\tconst name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\t\tattributes[name] = gl.getAttribLocation(program, name);\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\tfunction filterEmptyLine(string) {\n\t\treturn string !== '';\n\t}\n\n\tfunction replaceLightNums(string, parameters) {\n\t\treturn string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n\t}\n\n\tfunction replaceClippingPlaneNums(string, parameters) {\n\t\treturn string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n\t} // Resolve Includes\n\n\n\tconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n\tfunction resolveIncludes(string) {\n\t\treturn string.replace(includePattern, includeReplacer);\n\t}\n\n\tfunction includeReplacer(match, include) {\n\t\tconst string = ShaderChunk[include];\n\n\t\tif (string === undefined) {\n\t\t\tthrow new Error('Can not resolve #include <' + include + '>');\n\t\t}\n\n\t\treturn resolveIncludes(string);\n\t} // Unroll Loops\n\n\n\tconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\tconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\n\tfunction unrollLoops(string) {\n\t\treturn string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n\t}\n\n\tfunction deprecatedLoopReplacer(match, start, end, snippet) {\n\t\tconsole.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');\n\t\treturn loopReplacer(match, start, end, snippet);\n\t}\n\n\tfunction loopReplacer(match, start, end, snippet) {\n\t\tlet string = '';\n\n\t\tfor (let i = parseInt(start); i < parseInt(end); i++) {\n\t\t\tstring += snippet.replace(/\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);\n\t\t}\n\n\t\treturn string;\n\t} //\n\n\n\tfunction generatePrecision(parameters) {\n\t\tlet precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n\t\tif (parameters.precision === 'highp') {\n\t\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\t\t} else if (parameters.precision === 'mediump') {\n\t\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\t\t} else if (parameters.precision === 'lowp') {\n\t\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\t\t}\n\n\t\treturn precisionstring;\n\t}\n\n\tfunction generateShadowMapTypeDefine(parameters) {\n\t\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif (parameters.shadowMapType === PCFShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\t} else if (parameters.shadowMapType === PCFSoftShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\t} else if (parameters.shadowMapType === VSMShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\t\t}\n\n\t\treturn shadowMapTypeDefine;\n\t}\n\n\tfunction generateEnvMapTypeDefine(parameters) {\n\t\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.envMapMode) {\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapTypeDefine;\n\t}\n\n\tfunction generateEnvMapModeDefine(parameters) {\n\t\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.envMapMode) {\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapModeDefine;\n\t}\n\n\tfunction generateEnvMapBlendingDefine(parameters) {\n\t\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.combine) {\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapBlendingDefine;\n\t}\n\n\tfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n\t\tconst gl = renderer.getContext();\n\t\tconst defines = parameters.defines;\n\t\tlet vertexShader = parameters.vertexShader;\n\t\tlet fragmentShader = parameters.fragmentShader;\n\t\tconst shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n\t\tconst envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n\t\tconst envMapModeDefine = generateEnvMapModeDefine(parameters);\n\t\tconst envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n\t\tconst gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;\n\t\tconst customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);\n\t\tconst customDefines = generateDefines(defines);\n\t\tconst program = gl.createProgram();\n\t\tlet prefixVertex, prefixFragment;\n\t\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\t\tif (parameters.isRawShaderMaterial) {\n\t\t\tprefixVertex = [customDefines].filter(filterEmptyLine).join('\\n');\n\n\t\t\tif (prefixVertex.length > 0) {\n\t\t\t\tprefixVertex += '\\n';\n\t\t\t}\n\n\t\t\tprefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\\n');\n\n\t\t\tif (prefixFragment.length > 0) {\n\t\t\t\tprefixFragment += '\\n';\n\t\t\t}\n\t\t} else {\n\t\t\tprefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '\tattribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '\tattribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '\tattribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '\tattribute vec4 color;', '#elif defined( USE_COLOR )', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\\n'].filter(filterEmptyLine).join('\\n');\n\t\t\tprefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\tparameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\\n'].filter(filterEmptyLine).join('\\n');\n\t\t}\n\n\t\tvertexShader = resolveIncludes(vertexShader);\n\t\tvertexShader = replaceLightNums(vertexShader, parameters);\n\t\tvertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n\t\tfragmentShader = resolveIncludes(fragmentShader);\n\t\tfragmentShader = replaceLightNums(fragmentShader, parameters);\n\t\tfragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n\t\tvertexShader = unrollLoops(vertexShader);\n\t\tfragmentShader = unrollLoops(fragmentShader);\n\n\t\tif (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n\t\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\t\t\tversionString = '#version 300 es\\n';\n\t\t\tprefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\\n') + '\\n' + prefixVertex;\n\t\t\tprefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\\n') + '\\n' + prefixFragment;\n\t\t}\n\n\t\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\t\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tconst glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);\n\t\tconst glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);\n\t\tgl.attachShader(program, glVertexShader);\n\t\tgl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.\n\n\t\tif (parameters.index0AttributeName !== undefined) {\n\t\t\tgl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n\t\t} else if (parameters.morphTargets === true) {\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation(program, 0, 'position');\n\t\t}\n\n\t\tgl.linkProgram(program); // check for link errors\n\n\t\tif (renderer.debug.checkShaderErrors) {\n\t\t\tconst programLog = gl.getProgramInfoLog(program).trim();\n\t\t\tconst vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n\t\t\tconst fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n\t\t\tlet runnable = true;\n\t\t\tlet haveDiagnostics = true;\n\n\t\t\tif (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n\t\t\t\trunnable = false;\n\t\t\t\tconst vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');\n\t\t\t\tconst fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');\n\t\t\t\tconsole.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);\n\t\t\t} else if (programLog !== '') {\n\t\t\t\tconsole.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);\n\t\t\t} else if (vertexLog === '' || fragmentLog === '') {\n\t\t\t\thaveDiagnostics = false;\n\t\t\t}\n\n\t\t\tif (haveDiagnostics) {\n\t\t\t\tthis.diagnostics = {\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tprogramLog: programLog,\n\t\t\t\t\tvertexShader: {\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\t\t\t\t},\n\t\t\t\t\tfragmentShader: {\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t} // Clean up\n\t\t// Crashes in iOS9 and iOS10. #18402\n\t\t// gl.detachShader( program, glVertexShader );\n\t\t// gl.detachShader( program, glFragmentShader );\n\n\n\t\tgl.deleteShader(glVertexShader);\n\t\tgl.deleteShader(glFragmentShader); // set up caching for uniform locations\n\n\t\tlet cachedUniforms;\n\n\t\tthis.getUniforms = function () {\n\t\t\tif (cachedUniforms === undefined) {\n\t\t\t\tcachedUniforms = new WebGLUniforms(gl, program);\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\t\t}; // set up caching for attribute locations\n\n\n\t\tlet cachedAttributes;\n\n\t\tthis.getAttributes = function () {\n\t\t\tif (cachedAttributes === undefined) {\n\t\t\t\tcachedAttributes = fetchAttributeLocations(gl, program);\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\t\t}; // free resource\n\n\n\t\tthis.destroy = function () {\n\t\t\tbindingStates.releaseStatesOfProgram(this);\n\t\t\tgl.deleteProgram(program);\n\t\t\tthis.program = undefined;\n\t\t}; //\n\n\n\t\tthis.name = parameters.shaderName;\n\t\tthis.id = programIdCount++;\n\t\tthis.cacheKey = cacheKey;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\t\treturn this;\n\t}\n\n\tfunction WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {\n\t\tconst programs = [];\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\t\tconst floatVertexTextures = capabilities.floatVertexTextures;\n\t\tconst maxVertexUniforms = capabilities.maxVertexUniforms;\n\t\tconst vertexTextures = capabilities.vertexTextures;\n\t\tlet precision = capabilities.precision;\n\t\tconst shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshToonMaterial: 'toon',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tMeshMatcapMaterial: 'matcap',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points',\n\t\t\tShadowMaterial: 'shadow',\n\t\t\tSpriteMaterial: 'sprite'\n\t\t};\n\t\tconst parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];\n\n\t\tfunction getMaxBones(object) {\n\t\t\tconst skeleton = object.skeleton;\n\t\t\tconst bones = skeleton.bones;\n\n\t\t\tif (floatVertexTextures) {\n\t\t\t\treturn 1024;\n\t\t\t} else {\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//\t- leave some extra space for other uniforms\n\t\t\t\t//\t- limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//\t\t(up to 54 should be safe)\n\t\t\t\tconst nVertexUniforms = maxVertexUniforms;\n\t\t\t\tconst nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n\t\t\t\tconst maxBones = Math.min(nVertexMatrices, bones.length);\n\n\t\t\t\tif (maxBones < bones.length) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\t\t\t}\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap(map) {\n\t\t\tlet encoding;\n\n\t\t\tif (map && map.isTexture) {\n\t\t\t\tencoding = map.encoding;\n\t\t\t} else if (map && map.isWebGLRenderTarget) {\n\t\t\t\tconsole.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\\'t use render targets as textures. Use their .texture property instead.');\n\t\t\t\tencoding = map.texture.encoding;\n\t\t\t} else {\n\t\t\t\tencoding = LinearEncoding;\n\t\t\t}\n\n\t\t\treturn encoding;\n\t\t}\n\n\t\tfunction getParameters(material, lights, shadows, scene, object) {\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst envMap = cubemaps.get(material.envMap || environment);\n\t\t\tconst shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tconst maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n\n\t\t\tif (material.precision !== null) {\n\t\t\t\tprecision = capabilities.getMaxPrecision(material.precision);\n\n\t\t\t\tif (precision !== material.precision) {\n\t\t\t\t\tconsole.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet vertexShader, fragmentShader;\n\n\t\t\tif (shaderID) {\n\t\t\t\tconst shader = ShaderLib[shaderID];\n\t\t\t\tvertexShader = shader.vertexShader;\n\t\t\t\tfragmentShader = shader.fragmentShader;\n\t\t\t} else {\n\t\t\t\tvertexShader = material.vertexShader;\n\t\t\t\tfragmentShader = material.fragmentShader;\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\tconst parameters = {\n\t\t\t\tisWebGL2: isWebGL2,\n\t\t\t\tshaderID: shaderID,\n\t\t\t\tshaderName: material.type,\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tdefines: material.defines,\n\t\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\t\tglslVersion: material.glslVersion,\n\t\t\t\tprecision: precision,\n\t\t\t\tinstancing: object.isInstancedMesh === true,\n\t\t\t\tinstancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n\t\t\t\tsupportsVertexTextures: vertexTextures,\n\t\t\t\toutputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,\n\t\t\t\tmap: !!material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap(material.map),\n\t\t\t\tmatcap: !!material.matcap,\n\t\t\t\tmatcapEncoding: getTextureEncodingFromMap(material.matcap),\n\t\t\t\tenvMap: !!envMap,\n\t\t\t\tenvMapMode: envMap && envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap(envMap),\n\t\t\t\tenvMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),\n\t\t\t\tlightMap: !!material.lightMap,\n\t\t\t\tlightMapEncoding: getTextureEncodingFromMap(material.lightMap),\n\t\t\t\taoMap: !!material.aoMap,\n\t\t\t\temissiveMap: !!material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),\n\t\t\t\tbumpMap: !!material.bumpMap,\n\t\t\t\tnormalMap: !!material.normalMap,\n\t\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\t\ttangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n\t\t\t\tclearcoatMap: !!material.clearcoatMap,\n\t\t\t\tclearcoatRoughnessMap: !!material.clearcoatRoughnessMap,\n\t\t\t\tclearcoatNormalMap: !!material.clearcoatNormalMap,\n\t\t\t\tdisplacementMap: !!material.displacementMap,\n\t\t\t\troughnessMap: !!material.roughnessMap,\n\t\t\t\tmetalnessMap: !!material.metalnessMap,\n\t\t\t\tspecularMap: !!material.specularMap,\n\t\t\t\talphaMap: !!material.alphaMap,\n\t\t\t\tgradientMap: !!material.gradientMap,\n\t\t\t\tsheen: !!material.sheen,\n\t\t\t\ttransmission: !!material.transmission,\n\t\t\t\ttransmissionMap: !!material.transmissionMap,\n\t\t\t\tthicknessMap: !!material.thicknessMap,\n\t\t\t\tcombine: material.combine,\n\t\t\t\tvertexTangents: material.normalMap && material.vertexTangents,\n\t\t\t\tvertexColors: material.vertexColors,\n\t\t\t\tvertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n\t\t\t\tvertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap,\n\t\t\t\tuvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap) && !!material.displacementMap,\n\t\t\t\tfog: !!fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp2: fog && fog.isFogExp2,\n\t\t\t\tflatShading: !!material.flatShading,\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\t\tskinning: object.isSkinnedMesh === true && maxBones > 0,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: floatVertexTextures,\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\t\tnumClipIntersection: clipping.numIntersection,\n\t\t\t\tdithering: material.dithering,\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\t\t\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\t\t\t\tdepthPacking: material.depthPacking !== undefined ? material.depthPacking : false,\n\t\t\t\tindex0AttributeName: material.index0AttributeName,\n\t\t\t\textensionDerivatives: material.extensions && material.extensions.derivatives,\n\t\t\t\textensionFragDepth: material.extensions && material.extensions.fragDepth,\n\t\t\t\textensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n\t\t\t\textensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n\t\t\t\trendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),\n\t\t\t\trendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),\n\t\t\t\trendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),\n\t\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\t\t\t};\n\t\t\treturn parameters;\n\t\t}\n\n\t\tfunction getProgramCacheKey(parameters) {\n\t\t\tconst array = [];\n\n\t\t\tif (parameters.shaderID) {\n\t\t\t\tarray.push(parameters.shaderID);\n\t\t\t} else {\n\t\t\t\tarray.push(parameters.fragmentShader);\n\t\t\t\tarray.push(parameters.vertexShader);\n\t\t\t}\n\n\t\t\tif (parameters.defines !== undefined) {\n\t\t\t\tfor (const name in parameters.defines) {\n\t\t\t\t\tarray.push(name);\n\t\t\t\t\tarray.push(parameters.defines[name]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parameters.isRawShaderMaterial === false) {\n\t\t\t\tfor (let i = 0; i < parameterNames.length; i++) {\n\t\t\t\t\tarray.push(parameters[parameterNames[i]]);\n\t\t\t\t}\n\n\t\t\t\tarray.push(renderer.outputEncoding);\n\t\t\t\tarray.push(renderer.gammaFactor);\n\t\t\t}\n\n\t\t\tarray.push(parameters.customProgramCacheKey);\n\t\t\treturn array.join();\n\t\t}\n\n\t\tfunction getUniforms(material) {\n\t\t\tconst shaderID = shaderIDs[material.type];\n\t\t\tlet uniforms;\n\n\t\t\tif (shaderID) {\n\t\t\t\tconst shader = ShaderLib[shaderID];\n\t\t\t\tuniforms = UniformsUtils.clone(shader.uniforms);\n\t\t\t} else {\n\t\t\t\tuniforms = material.uniforms;\n\t\t\t}\n\n\t\t\treturn uniforms;\n\t\t}\n\n\t\tfunction acquireProgram(parameters, cacheKey) {\n\t\t\tlet program; // Check if code has been already compiled\n\n\t\t\tfor (let p = 0, pl = programs.length; p < pl; p++) {\n\t\t\t\tconst preexistingProgram = programs[p];\n\n\t\t\t\tif (preexistingProgram.cacheKey === cacheKey) {\n\t\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t\t++program.usedTimes;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (program === undefined) {\n\t\t\t\tprogram = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n\t\t\t\tprograms.push(program);\n\t\t\t}\n\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction releaseProgram(program) {\n\t\t\tif (--program.usedTimes === 0) {\n\t\t\t\t// Remove from unordered set\n\t\t\t\tconst i = programs.indexOf(program);\n\t\t\t\tprograms[i] = programs[programs.length - 1];\n\t\t\t\tprograms.pop(); // Free WebGL resources\n\n\t\t\t\tprogram.destroy();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgetParameters: getParameters,\n\t\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\t\tgetUniforms: getUniforms,\n\t\t\tacquireProgram: acquireProgram,\n\t\t\treleaseProgram: releaseProgram,\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tprograms: programs\n\t\t};\n\t}\n\n\tfunction WebGLProperties() {\n\t\tlet properties = new WeakMap();\n\n\t\tfunction get(object) {\n\t\t\tlet map = properties.get(object);\n\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = {};\n\t\t\t\tproperties.set(object, map);\n\t\t\t}\n\n\t\t\treturn map;\n\t\t}\n\n\t\tfunction remove(object) {\n\t\t\tproperties.delete(object);\n\t\t}\n\n\t\tfunction update(object, key, value) {\n\t\t\tproperties.get(object)[key] = value;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tproperties = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction painterSortStable(a, b) {\n\t\tif (a.groupOrder !== b.groupOrder) {\n\t\t\treturn a.groupOrder - b.groupOrder;\n\t\t} else if (a.renderOrder !== b.renderOrder) {\n\t\t\treturn a.renderOrder - b.renderOrder;\n\t\t} else if (a.program !== b.program) {\n\t\t\treturn a.program.id - b.program.id;\n\t\t} else if (a.material.id !== b.material.id) {\n\t\t\treturn a.material.id - b.material.id;\n\t\t} else if (a.z !== b.z) {\n\t\t\treturn a.z - b.z;\n\t\t} else {\n\t\t\treturn a.id - b.id;\n\t\t}\n\t}\n\n\tfunction reversePainterSortStable(a, b) {\n\t\tif (a.groupOrder !== b.groupOrder) {\n\t\t\treturn a.groupOrder - b.groupOrder;\n\t\t} else if (a.renderOrder !== b.renderOrder) {\n\t\t\treturn a.renderOrder - b.renderOrder;\n\t\t} else if (a.z !== b.z) {\n\t\t\treturn b.z - a.z;\n\t\t} else {\n\t\t\treturn a.id - b.id;\n\t\t}\n\t}\n\n\tfunction WebGLRenderList(properties) {\n\t\tconst renderItems = [];\n\t\tlet renderItemsIndex = 0;\n\t\tconst opaque = [];\n\t\tconst transmissive = [];\n\t\tconst transparent = [];\n\t\tconst defaultProgram = {\n\t\t\tid: -1\n\t\t};\n\n\t\tfunction init() {\n\t\t\trenderItemsIndex = 0;\n\t\t\topaque.length = 0;\n\t\t\ttransmissive.length = 0;\n\t\t\ttransparent.length = 0;\n\t\t}\n\n\t\tfunction getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n\t\t\tlet renderItem = renderItems[renderItemsIndex];\n\t\t\tconst materialProperties = properties.get(material);\n\n\t\t\tif (renderItem === undefined) {\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tprogram: materialProperties.program || defaultProgram,\n\t\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\t\tz: z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\t\t\t\trenderItems[renderItemsIndex] = renderItem;\n\t\t\t} else {\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.program = materialProperties.program || defaultProgram;\n\t\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\t\trenderItem.z = z;\n\t\t\t\trenderItem.group = group;\n\t\t\t}\n\n\t\t\trenderItemsIndex++;\n\t\t\treturn renderItem;\n\t\t}\n\n\t\tfunction push(object, geometry, material, groupOrder, z, group) {\n\t\t\tconst renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\ttransmissive.push(renderItem);\n\t\t\t} else if (material.transparent === true) {\n\t\t\t\ttransparent.push(renderItem);\n\t\t\t} else {\n\t\t\t\topaque.push(renderItem);\n\t\t\t}\n\t\t}\n\n\t\tfunction unshift(object, geometry, material, groupOrder, z, group) {\n\t\t\tconst renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\ttransmissive.unshift(renderItem);\n\t\t\t} else if (material.transparent === true) {\n\t\t\t\ttransparent.unshift(renderItem);\n\t\t\t} else {\n\t\t\t\topaque.unshift(renderItem);\n\t\t\t}\n\t\t}\n\n\t\tfunction sort(customOpaqueSort, customTransparentSort) {\n\t\t\tif (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n\t\t\tif (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);\n\t\t\tif (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);\n\t\t}\n\n\t\tfunction finish() {\n\t\t\t// Clear references from inactive renderItems in the list\n\t\t\tfor (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n\t\t\t\tconst renderItem = renderItems[i];\n\t\t\t\tif (renderItem.id === null) break;\n\t\t\t\trenderItem.id = null;\n\t\t\t\trenderItem.object = null;\n\t\t\t\trenderItem.geometry = null;\n\t\t\t\trenderItem.material = null;\n\t\t\t\trenderItem.program = null;\n\t\t\t\trenderItem.group = null;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\topaque: opaque,\n\t\t\ttransmissive: transmissive,\n\t\t\ttransparent: transparent,\n\t\t\tinit: init,\n\t\t\tpush: push,\n\t\t\tunshift: unshift,\n\t\t\tfinish: finish,\n\t\t\tsort: sort\n\t\t};\n\t}\n\n\tfunction WebGLRenderLists(properties) {\n\t\tlet lists = new WeakMap();\n\n\t\tfunction get(scene, renderCallDepth) {\n\t\t\tlet list;\n\n\t\t\tif (lists.has(scene) === false) {\n\t\t\t\tlist = new WebGLRenderList(properties);\n\t\t\t\tlists.set(scene, [list]);\n\t\t\t} else {\n\t\t\t\tif (renderCallDepth >= lists.get(scene).length) {\n\t\t\t\t\tlist = new WebGLRenderList(properties);\n\t\t\t\t\tlists.get(scene).push(list);\n\t\t\t\t} else {\n\t\t\t\t\tlist = lists.get(scene)[renderCallDepth];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tlists = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction UniformsCache() {\n\t\tconst lights = {};\n\t\treturn {\n\t\t\tget: function (light) {\n\t\t\t\tif (lights[light.id] !== undefined) {\n\t\t\t\t\treturn lights[light.id];\n\t\t\t\t}\n\n\t\t\t\tlet uniforms;\n\n\t\t\t\tswitch (light.type) {\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlights[light.id] = uniforms;\n\t\t\t\treturn uniforms;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction ShadowUniformsCache() {\n\t\tconst lights = {};\n\t\treturn {\n\t\t\tget: function (light) {\n\t\t\t\tif (lights[light.id] !== undefined) {\n\t\t\t\t\treturn lights[light.id];\n\t\t\t\t}\n\n\t\t\t\tlet uniforms;\n\n\t\t\t\tswitch (light.type) {\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t}\n\n\t\t\t\tlights[light.id] = uniforms;\n\t\t\t\treturn uniforms;\n\t\t\t}\n\t\t};\n\t}\n\n\tlet nextVersion = 0;\n\n\tfunction shadowCastingLightsFirst(lightA, lightB) {\n\t\treturn (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n\t}\n\n\tfunction WebGLLights(extensions, capabilities) {\n\t\tconst cache = new UniformsCache();\n\t\tconst shadowCache = ShadowUniformsCache();\n\t\tconst state = {\n\t\t\tversion: 0,\n\t\t\thash: {\n\t\t\t\tdirectionalLength: -1,\n\t\t\t\tpointLength: -1,\n\t\t\t\tspotLength: -1,\n\t\t\t\trectAreaLength: -1,\n\t\t\t\themiLength: -1,\n\t\t\t\tnumDirectionalShadows: -1,\n\t\t\t\tnumPointShadows: -1,\n\t\t\t\tnumSpotShadows: -1\n\t\t\t},\n\t\t\tambient: [0, 0, 0],\n\t\t\tprobe: [],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadow: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadow: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\trectArea: [],\n\t\t\trectAreaLTC1: null,\n\t\t\trectAreaLTC2: null,\n\t\t\tpoint: [],\n\t\t\tpointShadow: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: []\n\t\t};\n\n\t\tfor (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n\t\tconst vector3 = new Vector3();\n\t\tconst matrix4 = new Matrix4();\n\t\tconst matrix42 = new Matrix4();\n\n\t\tfunction setup(lights) {\n\t\t\tlet r = 0,\n\t\t\t\t\tg = 0,\n\t\t\t\t\tb = 0;\n\n\t\t\tfor (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n\t\t\tlet directionalLength = 0;\n\t\t\tlet pointLength = 0;\n\t\t\tlet spotLength = 0;\n\t\t\tlet rectAreaLength = 0;\n\t\t\tlet hemiLength = 0;\n\t\t\tlet numDirectionalShadows = 0;\n\t\t\tlet numPointShadows = 0;\n\t\t\tlet numSpotShadows = 0;\n\t\t\tlights.sort(shadowCastingLightsFirst);\n\n\t\t\tfor (let i = 0, l = lights.length; i < l; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tconst color = light.color;\n\t\t\t\tconst intensity = light.intensity;\n\t\t\t\tconst distance = light.distance;\n\t\t\t\tconst shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n\t\t\t\tif (light.isAmbientLight) {\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\t\t\t\t} else if (light.isLightProbe) {\n\t\t\t\t\tfor (let j = 0; j < 9; j++) {\n\t\t\t\t\t\tstate.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n\t\t\t\t\t}\n\t\t\t\t} else if (light.isDirectionalLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tstate.directionalShadow[directionalLength] = shadowUniforms;\n\t\t\t\t\t\tstate.directionalShadowMap[directionalLength] = shadowMap;\n\t\t\t\t\t\tstate.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumDirectionalShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.directional[directionalLength] = uniforms;\n\t\t\t\t\tdirectionalLength++;\n\t\t\t\t} else if (light.isSpotLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.color.copy(color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.distance = distance;\n\t\t\t\t\tuniforms.coneCos = Math.cos(light.angle);\n\t\t\t\t\tuniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n\t\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tstate.spotShadow[spotLength] = shadowUniforms;\n\t\t\t\t\t\tstate.spotShadowMap[spotLength] = shadowMap;\n\t\t\t\t\t\tstate.spotShadowMatrix[spotLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumSpotShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.spot[spotLength] = uniforms;\n\t\t\t\t\tspotLength++;\n\t\t\t\t} else if (light.isRectAreaLight) {\n\t\t\t\t\tconst uniforms = cache.get(light); // (a) intensity is the total visible light emitted\n\t\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\t\t\t\t\t// (b) intensity is the brightness of the light\n\n\t\t\t\t\tuniforms.color.copy(color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\t\t\t\t\tuniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\t\t\t\t\tstate.rectArea[rectAreaLength] = uniforms;\n\t\t\t\t\trectAreaLength++;\n\t\t\t\t} else if (light.isPointLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\t\t\t\t\t\tstate.pointShadow[pointLength] = shadowUniforms;\n\t\t\t\t\t\tstate.pointShadowMap[pointLength] = shadowMap;\n\t\t\t\t\t\tstate.pointShadowMatrix[pointLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumPointShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.point[pointLength] = uniforms;\n\t\t\t\t\tpointLength++;\n\t\t\t\t} else if (light.isHemisphereLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n\t\t\t\t\tstate.hemi[hemiLength] = uniforms;\n\t\t\t\t\themiLength++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rectAreaLength > 0) {\n\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\t// WebGL 2\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\t\t\t\t} else {\n\t\t\t\t\t// WebGL 1\n\t\t\t\t\tif (extensions.has('OES_texture_float_linear') === true) {\n\t\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\t\t\t\t\t} else if (extensions.has('OES_texture_half_float_linear') === true) {\n\t\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.ambient[0] = r;\n\t\t\tstate.ambient[1] = g;\n\t\t\tstate.ambient[2] = b;\n\t\t\tconst hash = state.hash;\n\n\t\t\tif (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n\t\t\t\tstate.directional.length = directionalLength;\n\t\t\t\tstate.spot.length = spotLength;\n\t\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\t\tstate.point.length = pointLength;\n\t\t\t\tstate.hemi.length = hemiLength;\n\t\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\t\tstate.spotShadowMatrix.length = numSpotShadows;\n\t\t\t\thash.directionalLength = directionalLength;\n\t\t\t\thash.pointLength = pointLength;\n\t\t\t\thash.spotLength = spotLength;\n\t\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\t\thash.hemiLength = hemiLength;\n\t\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\t\thash.numPointShadows = numPointShadows;\n\t\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\t\tstate.version = nextVersion++;\n\t\t\t}\n\t\t}\n\n\t\tfunction setupView(lights, camera) {\n\t\t\tlet directionalLength = 0;\n\t\t\tlet pointLength = 0;\n\t\t\tlet spotLength = 0;\n\t\t\tlet rectAreaLength = 0;\n\t\t\tlet hemiLength = 0;\n\t\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\t\tfor (let i = 0, l = lights.length; i < l; i++) {\n\t\t\t\tconst light = lights[i];\n\n\t\t\t\tif (light.isDirectionalLight) {\n\t\t\t\t\tconst uniforms = state.directional[directionalLength];\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tvector3.setFromMatrixPosition(light.target.matrixWorld);\n\t\t\t\t\tuniforms.direction.sub(vector3);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tdirectionalLength++;\n\t\t\t\t} else if (light.isSpotLight) {\n\t\t\t\t\tconst uniforms = state.spot[spotLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix);\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tvector3.setFromMatrixPosition(light.target.matrixWorld);\n\t\t\t\t\tuniforms.direction.sub(vector3);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tspotLength++;\n\t\t\t\t} else if (light.isRectAreaLight) {\n\t\t\t\t\tconst uniforms = state.rectArea[rectAreaLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n\t\t\t\t\tmatrix42.identity();\n\t\t\t\t\tmatrix4.copy(light.matrixWorld);\n\t\t\t\t\tmatrix4.premultiply(viewMatrix);\n\t\t\t\t\tmatrix42.extractRotation(matrix4);\n\t\t\t\t\tuniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\t\t\t\t\tuniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\t\t\t\t\tuniforms.halfWidth.applyMatrix4(matrix42);\n\t\t\t\t\tuniforms.halfHeight.applyMatrix4(matrix42);\n\t\t\t\t\trectAreaLength++;\n\t\t\t\t} else if (light.isPointLight) {\n\t\t\t\t\tconst uniforms = state.point[pointLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix);\n\t\t\t\t\tpointLength++;\n\t\t\t\t} else if (light.isHemisphereLight) {\n\t\t\t\t\tconst uniforms = state.hemi[hemiLength];\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tuniforms.direction.normalize();\n\t\t\t\t\themiLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\tsetupView: setupView,\n\t\t\tstate: state\n\t\t};\n\t}\n\n\tfunction WebGLRenderState(extensions, capabilities) {\n\t\tconst lights = new WebGLLights(extensions, capabilities);\n\t\tconst lightsArray = [];\n\t\tconst shadowsArray = [];\n\n\t\tfunction init() {\n\t\t\tlightsArray.length = 0;\n\t\t\tshadowsArray.length = 0;\n\t\t}\n\n\t\tfunction pushLight(light) {\n\t\t\tlightsArray.push(light);\n\t\t}\n\n\t\tfunction pushShadow(shadowLight) {\n\t\t\tshadowsArray.push(shadowLight);\n\t\t}\n\n\t\tfunction setupLights() {\n\t\t\tlights.setup(lightsArray);\n\t\t}\n\n\t\tfunction setupLightsView(camera) {\n\t\t\tlights.setupView(lightsArray, camera);\n\t\t}\n\n\t\tconst state = {\n\t\t\tlightsArray: lightsArray,\n\t\t\tshadowsArray: shadowsArray,\n\t\t\tlights: lights\n\t\t};\n\t\treturn {\n\t\t\tinit: init,\n\t\t\tstate: state,\n\t\t\tsetupLights: setupLights,\n\t\t\tsetupLightsView: setupLightsView,\n\t\t\tpushLight: pushLight,\n\t\t\tpushShadow: pushShadow\n\t\t};\n\t}\n\n\tfunction WebGLRenderStates(extensions, capabilities) {\n\t\tlet renderStates = new WeakMap();\n\n\t\tfunction get(scene, renderCallDepth = 0) {\n\t\t\tlet renderState;\n\n\t\t\tif (renderStates.has(scene) === false) {\n\t\t\t\trenderState = new WebGLRenderState(extensions, capabilities);\n\t\t\t\trenderStates.set(scene, [renderState]);\n\t\t\t} else {\n\t\t\t\tif (renderCallDepth >= renderStates.get(scene).length) {\n\t\t\t\t\trenderState = new WebGLRenderState(extensions, capabilities);\n\t\t\t\t\trenderStates.get(scene).push(renderState);\n\t\t\t\t} else {\n\t\t\t\t\trenderState = renderStates.get(scene)[renderCallDepth];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn renderState;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\trenderStates = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\t/**\n\t * parameters = {\n\t *\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>\n\t * }\n\t */\n\n\tclass MeshDepthMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\n\t *\treferencePosition: <float>,\n\t *\tnearDistance: <float>,\n\t *\tfarDistance: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>\n\t *\n\t * }\n\t */\n\n\tclass MeshDistanceMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshDistanceMaterial';\n\t\t\tthis.referencePosition = new Vector3();\n\t\t\tthis.nearDistance = 1;\n\t\t\tthis.farDistance = 1000;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.fog = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.referencePosition.copy(source.referencePosition);\n\t\t\tthis.nearDistance = source.nearDistance;\n\t\t\tthis.farDistance = source.farDistance;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\n\tvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean * HALF_SAMPLE_RATE;\\n\\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\n\tvar vsm_vert = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\n\tfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n\t\tlet _frustum = new Frustum();\n\n\t\tconst _shadowMapSize = new Vector2(),\n\t\t\t\t\t_viewportSize = new Vector2(),\n\t\t\t\t\t_viewport = new Vector4(),\n\t\t\t\t\t_depthMaterials = [],\n\t\t\t\t\t_distanceMaterials = [],\n\t\t\t\t\t_materialCache = {},\n\t\t\t\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\t\tconst shadowSide = {\n\t\t\t0: BackSide,\n\t\t\t1: FrontSide,\n\t\t\t2: DoubleSide\n\t\t};\n\t\tconst shadowMaterialVertical = new ShaderMaterial({\n\t\t\tdefines: {\n\t\t\t\tSAMPLE_RATE: 2.0 / 8.0,\n\t\t\t\tHALF_SAMPLE_RATE: 1.0 / 8.0\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\tshadow_pass: {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\tresolution: {\n\t\t\t\t\tvalue: new Vector2()\n\t\t\t\t},\n\t\t\t\tradius: {\n\t\t\t\t\tvalue: 4.0\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: vsm_vert,\n\t\t\tfragmentShader: vsm_frag\n\t\t});\n\t\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\t\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\t\tconst fullScreenTri = new BufferGeometry();\n\t\tfullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n\t\tconst fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n\t\tconst scope = this;\n\t\tthis.enabled = false;\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.render = function (lights, scene, camera) {\n\t\t\tif (scope.enabled === false) return;\n\t\t\tif (scope.autoUpdate === false && scope.needsUpdate === false) return;\n\t\t\tif (lights.length === 0) return;\n\n\t\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\n\t\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\n\t\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\t\tconst _state = _renderer.state; // Set GL state for depth map.\n\n\t\t\t_state.setBlending(NoBlending);\n\n\t\t\t_state.buffers.color.setClear(1, 1, 1, 1);\n\n\t\t\t_state.buffers.depth.setTest(true);\n\n\t\t\t_state.setScissorTest(false); // render depth map\n\n\n\t\t\tfor (let i = 0, il = lights.length; i < il; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif (shadow === undefined) {\n\t\t\t\t\tconsole.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n\t\t\t\t_shadowMapSize.copy(shadow.mapSize);\n\n\t\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t\t_shadowMapSize.multiply(shadowFrameExtents);\n\n\t\t\t\t_viewportSize.copy(shadow.mapSize);\n\n\t\t\t\tif (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n\t\t\t\t\tif (_shadowMapSize.x > _maxTextureSize) {\n\t\t\t\t\t\t_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n\t\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_shadowMapSize.y > _maxTextureSize) {\n\t\t\t\t\t\t_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n\t\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n\t\t\t\t\tconst pars = {\n\t\t\t\t\t\tminFilter: LinearFilter,\n\t\t\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\t\t\tformat: RGBAFormat\n\t\t\t\t\t};\n\t\t\t\t\tshadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\t\t\t\t\tshadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.camera.updateProjectionMatrix();\n\t\t\t\t}\n\n\t\t\t\tif (shadow.map === null) {\n\t\t\t\t\tconst pars = {\n\t\t\t\t\t\tminFilter: NearestFilter,\n\t\t\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\t\t\tformat: RGBAFormat\n\t\t\t\t\t};\n\t\t\t\t\tshadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\t\t\t\t\tshadow.camera.updateProjectionMatrix();\n\t\t\t\t}\n\n\t\t\t\t_renderer.setRenderTarget(shadow.map);\n\n\t\t\t\t_renderer.clear();\n\n\t\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\t\tfor (let vp = 0; vp < viewportCount; vp++) {\n\t\t\t\t\tconst viewport = shadow.getViewport(vp);\n\n\t\t\t\t\t_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n\t\t\t\t\t_state.viewport(_viewport);\n\n\t\t\t\t\tshadow.updateMatrices(light, vp);\n\t\t\t\t\t_frustum = shadow.getFrustum();\n\t\t\t\t\trenderObject(scene, camera, shadow.camera, light, this.type);\n\t\t\t\t} // do blur pass for VSM\n\n\n\t\t\t\tif (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n\t\t\t\t\tVSMPass(shadow, camera);\n\t\t\t\t}\n\n\t\t\t\tshadow.needsUpdate = false;\n\t\t\t}\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t\t_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n\t\t};\n\n\t\tfunction VSMPass(shadow, camera) {\n\t\t\tconst geometry = _objects.update(fullScreenMesh); // vertical pass\n\n\n\t\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n\t\t\t_renderer.setRenderTarget(shadow.mapPass);\n\n\t\t\t_renderer.clear();\n\n\t\t\t_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass\n\n\n\t\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\n\t\t\t_renderer.setRenderTarget(shadow.map);\n\n\t\t\t_renderer.clear();\n\n\t\t\t_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n\t\t}\n\n\t\tfunction getDepthMaterialVariant(useMorphing) {\n\t\t\tconst index = useMorphing << 0;\n\t\t\tlet material = _depthMaterials[index];\n\n\t\t\tif (material === undefined) {\n\t\t\t\tmaterial = new MeshDepthMaterial({\n\t\t\t\t\tdepthPacking: RGBADepthPacking,\n\t\t\t\t\tmorphTargets: useMorphing\n\t\t\t\t});\n\t\t\t\t_depthMaterials[index] = material;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getDistanceMaterialVariant(useMorphing) {\n\t\t\tconst index = useMorphing << 0;\n\t\t\tlet material = _distanceMaterials[index];\n\n\t\t\tif (material === undefined) {\n\t\t\t\tmaterial = new MeshDistanceMaterial({\n\t\t\t\t\tmorphTargets: useMorphing\n\t\t\t\t});\n\t\t\t\t_distanceMaterials[index] = material;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {\n\t\t\tlet result = null;\n\t\t\tlet getMaterialVariant = getDepthMaterialVariant;\n\t\t\tlet customMaterial = object.customDepthMaterial;\n\n\t\t\tif (light.isPointLight === true) {\n\t\t\t\tgetMaterialVariant = getDistanceMaterialVariant;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\t\t}\n\n\t\t\tif (customMaterial === undefined) {\n\t\t\t\tlet useMorphing = false;\n\n\t\t\t\tif (material.morphTargets === true) {\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\t\t\t}\n\n\t\t\t\tresult = getMaterialVariant(useMorphing);\n\t\t\t} else {\n\t\t\t\tresult = customMaterial;\n\t\t\t}\n\n\t\t\tif (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\t\t\t\tconst keyA = result.uuid,\n\t\t\t\t\t\t\tkeyB = material.uuid;\n\t\t\t\tlet materialsForVariant = _materialCache[keyA];\n\n\t\t\t\tif (materialsForVariant === undefined) {\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[keyA] = materialsForVariant;\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[keyB];\n\n\t\t\t\tif (cachedMaterial === undefined) {\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[keyB] = cachedMaterial;\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tif (type === VSMShadowMap) {\n\t\t\t\tresult.side = material.shadowSide !== null ? material.shadowSide : material.side;\n\t\t\t} else {\n\t\t\t\tresult.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n\t\t\t}\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\t\tresult.clipIntersection = material.clipIntersection;\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n\t\t\t\tresult.referencePosition.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\t\tresult.farDistance = shadowCameraFar;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction renderObject(object, camera, shadowCamera, light, type) {\n\t\t\tif (object.visible === false) return;\n\t\t\tconst visible = object.layers.test(camera.layers);\n\n\t\t\tif (visible && (object.isMesh || object.isLine || object.isPoints)) {\n\t\t\t\tif ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n\t\t\t\t\tconst geometry = _objects.update(object);\n\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor (let k = 0, kl = groups.length; k < kl; k++) {\n\t\t\t\t\t\t\tconst group = groups[k];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\n\t\t\t\t\t\t\tif (groupMaterial && groupMaterial.visible) {\n\t\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (material.visible) {\n\t\t\t\t\t\tconst depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);\n\n\t\t\t\t\t\t_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\trenderObject(children[i], camera, shadowCamera, light, type);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction WebGLState(gl, extensions, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tfunction ColorBuffer() {\n\t\t\tlet locked = false;\n\t\t\tconst color = new Vector4();\n\t\t\tlet currentColorMask = null;\n\t\t\tconst currentColorClear = new Vector4(0, 0, 0, 0);\n\t\t\treturn {\n\t\t\t\tsetMask: function (colorMask) {\n\t\t\t\t\tif (currentColorMask !== colorMask && !locked) {\n\t\t\t\t\t\tgl.colorMask(colorMask, colorMask, colorMask, colorMask);\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (r, g, b, a, premultipliedAlpha) {\n\t\t\t\t\tif (premultipliedAlpha === true) {\n\t\t\t\t\t\tr *= a;\n\t\t\t\t\t\tg *= a;\n\t\t\t\t\t\tb *= a;\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.set(r, g, b, a);\n\n\t\t\t\t\tif (currentColorClear.equals(color) === false) {\n\t\t\t\t\t\tgl.clearColor(r, g, b, a);\n\t\t\t\t\t\tcurrentColorClear.copy(color);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set(-1, 0, 0, 0); // set to invalid state\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\t\t\tlet locked = false;\n\t\t\tlet currentDepthMask = null;\n\t\t\tlet currentDepthFunc = null;\n\t\t\tlet currentDepthClear = null;\n\t\t\treturn {\n\t\t\t\tsetTest: function (depthTest) {\n\t\t\t\t\tif (depthTest) {\n\t\t\t\t\t\tenable(gl.DEPTH_TEST);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisable(gl.DEPTH_TEST);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetMask: function (depthMask) {\n\t\t\t\t\tif (currentDepthMask !== depthMask && !locked) {\n\t\t\t\t\t\tgl.depthMask(depthMask);\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetFunc: function (depthFunc) {\n\t\t\t\t\tif (currentDepthFunc !== depthFunc) {\n\t\t\t\t\t\tif (depthFunc) {\n\t\t\t\t\t\t\tswitch (depthFunc) {\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.NEVER);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.ALWAYS);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LESS);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.EQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.GEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.GREATER);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.NOTEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (depth) {\n\t\t\t\t\tif (currentDepthClear !== depth) {\n\t\t\t\t\t\tgl.clearDepth(depth);\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\t\t\tlet locked = false;\n\t\t\tlet currentStencilMask = null;\n\t\t\tlet currentStencilFunc = null;\n\t\t\tlet currentStencilRef = null;\n\t\t\tlet currentStencilFuncMask = null;\n\t\t\tlet currentStencilFail = null;\n\t\t\tlet currentStencilZFail = null;\n\t\t\tlet currentStencilZPass = null;\n\t\t\tlet currentStencilClear = null;\n\t\t\treturn {\n\t\t\t\tsetTest: function (stencilTest) {\n\t\t\t\t\tif (!locked) {\n\t\t\t\t\t\tif (stencilTest) {\n\t\t\t\t\t\t\tenable(gl.STENCIL_TEST);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdisable(gl.STENCIL_TEST);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetMask: function (stencilMask) {\n\t\t\t\t\tif (currentStencilMask !== stencilMask && !locked) {\n\t\t\t\t\t\tgl.stencilMask(stencilMask);\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetFunc: function (stencilFunc, stencilRef, stencilMask) {\n\t\t\t\t\tif (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n\t\t\t\t\t\tgl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetOp: function (stencilFail, stencilZFail, stencilZPass) {\n\t\t\t\t\tif (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n\t\t\t\t\t\tgl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n\t\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (stencil) {\n\t\t\t\t\tif (currentStencilClear !== stencil) {\n\t\t\t\t\t\tgl.clearStencil(stencil);\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\t\t\t\t}\n\t\t\t};\n\t\t} //\n\n\n\t\tconst colorBuffer = new ColorBuffer();\n\t\tconst depthBuffer = new DepthBuffer();\n\t\tconst stencilBuffer = new StencilBuffer();\n\t\tlet enabledCapabilities = {};\n\t\tlet xrFramebuffer = null;\n\t\tlet currentBoundFramebuffers = {};\n\t\tlet currentProgram = null;\n\t\tlet currentBlendingEnabled = false;\n\t\tlet currentBlending = null;\n\t\tlet currentBlendEquation = null;\n\t\tlet currentBlendSrc = null;\n\t\tlet currentBlendDst = null;\n\t\tlet currentBlendEquationAlpha = null;\n\t\tlet currentBlendSrcAlpha = null;\n\t\tlet currentBlendDstAlpha = null;\n\t\tlet currentPremultipledAlpha = false;\n\t\tlet currentFlipSided = null;\n\t\tlet currentCullFace = null;\n\t\tlet currentLineWidth = null;\n\t\tlet currentPolygonOffsetFactor = null;\n\t\tlet currentPolygonOffsetUnits = null;\n\t\tconst maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\t\tlet lineWidthAvailable = false;\n\t\tlet version = 0;\n\t\tconst glVersion = gl.getParameter(gl.VERSION);\n\n\t\tif (glVersion.indexOf('WebGL') !== -1) {\n\t\t\tversion = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n\t\t\tlineWidthAvailable = version >= 1.0;\n\t\t} else if (glVersion.indexOf('OpenGL ES') !== -1) {\n\t\t\tversion = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n\t\t\tlineWidthAvailable = version >= 2.0;\n\t\t}\n\n\t\tlet currentTextureSlot = null;\n\t\tlet currentBoundTextures = {};\n\t\tconst scissorParam = gl.getParameter(gl.SCISSOR_BOX);\n\t\tconst viewportParam = gl.getParameter(gl.VIEWPORT);\n\t\tconst currentScissor = new Vector4().fromArray(scissorParam);\n\t\tconst currentViewport = new Vector4().fromArray(viewportParam);\n\n\t\tfunction createTexture(type, target, count) {\n\t\t\tconst data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n\n\t\t\tconst texture = gl.createTexture();\n\t\t\tgl.bindTexture(type, texture);\n\t\t\tgl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\tgl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tgl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tconst emptyTextures = {};\n\t\temptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);\n\t\temptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init\n\n\t\tcolorBuffer.setClear(0, 0, 0, 1);\n\t\tdepthBuffer.setClear(1);\n\t\tstencilBuffer.setClear(0);\n\t\tenable(gl.DEPTH_TEST);\n\t\tdepthBuffer.setFunc(LessEqualDepth);\n\t\tsetFlipSided(false);\n\t\tsetCullFace(CullFaceBack);\n\t\tenable(gl.CULL_FACE);\n\t\tsetBlending(NoBlending); //\n\n\t\tfunction enable(id) {\n\t\t\tif (enabledCapabilities[id] !== true) {\n\t\t\t\tgl.enable(id);\n\t\t\t\tenabledCapabilities[id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction disable(id) {\n\t\t\tif (enabledCapabilities[id] !== false) {\n\t\t\t\tgl.disable(id);\n\t\t\t\tenabledCapabilities[id] = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindXRFramebuffer(framebuffer) {\n\t\t\tif (framebuffer !== xrFramebuffer) {\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t\t\t\txrFramebuffer = framebuffer;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindFramebuffer(target, framebuffer) {\n\t\t\tif (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n\t\t\tif (currentBoundFramebuffers[target] !== framebuffer) {\n\t\t\t\tgl.bindFramebuffer(target, framebuffer);\n\t\t\t\tcurrentBoundFramebuffers[target] = framebuffer;\n\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\t\t\t\t\tif (target === gl.DRAW_FRAMEBUFFER) {\n\t\t\t\t\t\tcurrentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target === gl.FRAMEBUFFER) {\n\t\t\t\t\t\tcurrentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction useProgram(program) {\n\t\t\tif (currentProgram !== program) {\n\t\t\t\tgl.useProgram(program);\n\t\t\t\tcurrentProgram = program;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tconst equationToGL = {\n\t\t\t[AddEquation]: gl.FUNC_ADD,\n\t\t\t[SubtractEquation]: gl.FUNC_SUBTRACT,\n\t\t\t[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tif (isWebGL2) {\n\t\t\tequationToGL[MinEquation] = gl.MIN;\n\t\t\tequationToGL[MaxEquation] = gl.MAX;\n\t\t} else {\n\t\t\tconst extension = extensions.get('EXT_blend_minmax');\n\n\t\t\tif (extension !== null) {\n\t\t\t\tequationToGL[MinEquation] = extension.MIN_EXT;\n\t\t\t\tequationToGL[MaxEquation] = extension.MAX_EXT;\n\t\t\t}\n\t\t}\n\n\t\tconst factorToGL = {\n\t\t\t[ZeroFactor]: gl.ZERO,\n\t\t\t[OneFactor]: gl.ONE,\n\t\t\t[SrcColorFactor]: gl.SRC_COLOR,\n\t\t\t[SrcAlphaFactor]: gl.SRC_ALPHA,\n\t\t\t[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[DstColorFactor]: gl.DST_COLOR,\n\t\t\t[DstAlphaFactor]: gl.DST_ALPHA,\n\t\t\t[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t\tfunction setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n\t\t\tif (blending === NoBlending) {\n\t\t\t\tif (currentBlendingEnabled === true) {\n\t\t\t\t\tdisable(gl.BLEND);\n\t\t\t\t\tcurrentBlendingEnabled = false;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (currentBlendingEnabled === false) {\n\t\t\t\tenable(gl.BLEND);\n\t\t\t\tcurrentBlendingEnabled = true;\n\t\t\t}\n\n\t\t\tif (blending !== CustomBlending) {\n\t\t\t\tif (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n\t\t\t\t\tif (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n\t\t\t\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (premultipliedAlpha) {\n\t\t\t\t\t\tswitch (blending) {\n\t\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ONE, gl.ONE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error('THREE.WebGLState: Invalid blending: ', blending);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (blending) {\n\t\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error('THREE.WebGLState: Invalid blending: ', blending);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\t\t\t\tcurrentBlending = blending;\n\t\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t} // custom blending\n\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n\t\t\t\tgl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\t\t}\n\n\t\t\tif (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n\t\t\t\tgl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = null;\n\t\t}\n\n\t\tfunction setMaterial(material, frontFaceCW) {\n\t\t\tmaterial.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);\n\t\t\tlet flipSided = material.side === BackSide;\n\t\t\tif (frontFaceCW) flipSided = !flipSided;\n\t\t\tsetFlipSided(flipSided);\n\t\t\tmaterial.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n\t\t\tdepthBuffer.setFunc(material.depthFunc);\n\t\t\tdepthBuffer.setTest(material.depthTest);\n\t\t\tdepthBuffer.setMask(material.depthWrite);\n\t\t\tcolorBuffer.setMask(material.colorWrite);\n\t\t\tconst stencilWrite = material.stencilWrite;\n\t\t\tstencilBuffer.setTest(stencilWrite);\n\n\t\t\tif (stencilWrite) {\n\t\t\t\tstencilBuffer.setMask(material.stencilWriteMask);\n\t\t\t\tstencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n\t\t\t\tstencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n\t\t\t}\n\n\t\t\tsetPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n\t\t\tmaterial.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t} //\n\n\n\t\tfunction setFlipSided(flipSided) {\n\t\t\tif (currentFlipSided !== flipSided) {\n\t\t\t\tif (flipSided) {\n\t\t\t\t\tgl.frontFace(gl.CW);\n\t\t\t\t} else {\n\t\t\t\t\tgl.frontFace(gl.CCW);\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\t\t\t}\n\t\t}\n\n\t\tfunction setCullFace(cullFace) {\n\t\t\tif (cullFace !== CullFaceNone) {\n\t\t\t\tenable(gl.CULL_FACE);\n\n\t\t\t\tif (cullFace !== currentCullFace) {\n\t\t\t\t\tif (cullFace === CullFaceBack) {\n\t\t\t\t\t\tgl.cullFace(gl.BACK);\n\t\t\t\t\t} else if (cullFace === CullFaceFront) {\n\t\t\t\t\t\tgl.cullFace(gl.FRONT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgl.cullFace(gl.FRONT_AND_BACK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisable(gl.CULL_FACE);\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\t\t}\n\n\t\tfunction setLineWidth(width) {\n\t\t\tif (width !== currentLineWidth) {\n\t\t\t\tif (lineWidthAvailable) gl.lineWidth(width);\n\t\t\t\tcurrentLineWidth = width;\n\t\t\t}\n\t\t}\n\n\t\tfunction setPolygonOffset(polygonOffset, factor, units) {\n\t\t\tif (polygonOffset) {\n\t\t\t\tenable(gl.POLYGON_OFFSET_FILL);\n\n\t\t\t\tif (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n\t\t\t\t\tgl.polygonOffset(factor, units);\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisable(gl.POLYGON_OFFSET_FILL);\n\t\t\t}\n\t\t}\n\n\t\tfunction setScissorTest(scissorTest) {\n\t\t\tif (scissorTest) {\n\t\t\t\tenable(gl.SCISSOR_TEST);\n\t\t\t} else {\n\t\t\t\tdisable(gl.SCISSOR_TEST);\n\t\t\t}\n\t\t} // texture\n\n\n\t\tfunction activeTexture(webglSlot) {\n\t\t\tif (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif (currentTextureSlot !== webglSlot) {\n\t\t\t\tgl.activeTexture(webglSlot);\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindTexture(webglType, webglTexture) {\n\t\t\tif (currentTextureSlot === null) {\n\t\t\t\tactiveTexture();\n\t\t\t}\n\n\t\t\tlet boundTexture = currentBoundTextures[currentTextureSlot];\n\n\t\t\tif (boundTexture === undefined) {\n\t\t\t\tboundTexture = {\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\ttexture: undefined\n\t\t\t\t};\n\t\t\t\tcurrentBoundTextures[currentTextureSlot] = boundTexture;\n\t\t\t}\n\n\t\t\tif (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n\t\t\t\tgl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\t\t\t}\n\t\t}\n\n\t\tfunction unbindTexture() {\n\t\t\tconst boundTexture = currentBoundTextures[currentTextureSlot];\n\n\t\t\tif (boundTexture !== undefined && boundTexture.type !== undefined) {\n\t\t\t\tgl.bindTexture(boundTexture.type, null);\n\t\t\t\tboundTexture.type = undefined;\n\t\t\t\tboundTexture.texture = undefined;\n\t\t\t}\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\t\t\ttry {\n\t\t\t\tgl.compressedTexImage2D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction texImage2D() {\n\t\t\ttry {\n\t\t\t\tgl.texImage2D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction texImage3D() {\n\t\t\ttry {\n\t\t\t\tgl.texImage3D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction scissor(scissor) {\n\t\t\tif (currentScissor.equals(scissor) === false) {\n\t\t\t\tgl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\n\t\t\t\tcurrentScissor.copy(scissor);\n\t\t\t}\n\t\t}\n\n\t\tfunction viewport(viewport) {\n\t\t\tif (currentViewport.equals(viewport) === false) {\n\t\t\t\tgl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\n\t\t\t\tcurrentViewport.copy(viewport);\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction reset() {\n\t\t\t// reset state\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tgl.disable(gl.CULL_FACE);\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tgl.disable(gl.POLYGON_OFFSET_FILL);\n\t\t\tgl.disable(gl.SCISSOR_TEST);\n\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\tgl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\tgl.blendFunc(gl.ONE, gl.ZERO);\n\t\t\tgl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n\t\t\tgl.colorMask(true, true, true, true);\n\t\t\tgl.clearColor(0, 0, 0, 0);\n\t\t\tgl.depthMask(true);\n\t\t\tgl.depthFunc(gl.LESS);\n\t\t\tgl.clearDepth(1);\n\t\t\tgl.stencilMask(0xffffffff);\n\t\t\tgl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);\n\t\t\tgl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\t\t\tgl.clearStencil(0);\n\t\t\tgl.cullFace(gl.BACK);\n\t\t\tgl.frontFace(gl.CCW);\n\t\t\tgl.polygonOffset(0, 0);\n\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t\tif (isWebGL2 === true) {\n\t\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n\t\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n\t\t\t}\n\n\t\t\tgl.useProgram(null);\n\t\t\tgl.lineWidth(1);\n\t\t\tgl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tgl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals\n\n\t\t\tenabledCapabilities = {};\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\t\t\txrFramebuffer = null;\n\t\t\tcurrentBoundFramebuffers = {};\n\t\t\tcurrentProgram = null;\n\t\t\tcurrentBlendingEnabled = false;\n\t\t\tcurrentBlending = null;\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\t\t\tcurrentPremultipledAlpha = false;\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\t\t\tcurrentLineWidth = null;\n\t\t\tcurrentPolygonOffsetFactor = null;\n\t\t\tcurrentPolygonOffsetUnits = null;\n\t\t\tcurrentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tcurrentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\t\t}\n\n\t\treturn {\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tbindFramebuffer: bindFramebuffer,\n\t\t\tbindXRFramebuffer: bindXRFramebuffer,\n\t\t\tuseProgram: useProgram,\n\t\t\tsetBlending: setBlending,\n\t\t\tsetMaterial: setMaterial,\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\t\tsetScissorTest: setScissorTest,\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tunbindTexture: unbindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\t\t\ttexImage3D: texImage3D,\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\t\t\treset: reset\n\t\t};\n\t}\n\n\tfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst maxTextures = capabilities.maxTextures;\n\t\tconst maxCubemapSize = capabilities.maxCubemapSize;\n\t\tconst maxTextureSize = capabilities.maxTextureSize;\n\t\tconst maxSamples = capabilities.maxSamples;\n\n\t\tconst _videoTextures = new WeakMap();\n\n\t\tlet _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\n\t\tlet useOffscreenCanvas = false;\n\n\t\ttry {\n\t\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;\n\t\t} catch (err) {// Ignore any errors\n\t\t}\n\n\t\tfunction createCanvas(width, height) {\n\t\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\t\t\treturn useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\t}\n\n\t\tfunction resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n\t\t\tlet scale = 1; // handle case if texture exceeds max size\n\n\t\t\tif (image.width > maxSize || image.height > maxSize) {\n\t\t\t\tscale = maxSize / Math.max(image.width, image.height);\n\t\t\t} // only perform resize if necessary\n\n\n\t\t\tif (scale < 1 || needsPowerOfTwo === true) {\n\t\t\t\t// only perform resize for certain image types\n\t\t\t\tif (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n\t\t\t\t\tconst floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n\t\t\t\t\tconst width = floor(scale * image.width);\n\t\t\t\t\tconst height = floor(scale * image.height);\n\t\t\t\t\tif (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas\n\n\t\t\t\t\tconst canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\tconst context = canvas.getContext('2d');\n\t\t\t\t\tcontext.drawImage(image, 0, 0, width, height);\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');\n\t\t\t\t\treturn canvas;\n\t\t\t\t} else {\n\t\t\t\t\tif ('data' in image) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn image;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn image;\n\t\t}\n\n\t\tfunction isPowerOfTwo$1(image) {\n\t\t\treturn isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo(texture) {\n\t\t\tif (isWebGL2) return false;\n\t\t\treturn texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\t}\n\n\t\tfunction textureNeedsGenerateMipmaps(texture, supportsMips) {\n\t\t\treturn texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\t}\n\n\t\tfunction generateMipmap(target, texture, width, height) {\n\t\t\t_gl.generateMipmap(target);\n\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\ttextureProperties.__maxMipLevel = Math.log2(Math.max(width, height));\n\t\t}\n\n\t\tfunction getInternalFormat(internalFormatName, glFormat, glType) {\n\t\t\tif (isWebGL2 === false) return glFormat;\n\n\t\t\tif (internalFormatName !== null) {\n\t\t\t\tif (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n\t\t\t}\n\n\t\t\tlet internalFormat = glFormat;\n\n\t\t\tif (glFormat === _gl.RED) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.R32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;\n\t\t\t}\n\n\t\t\tif (glFormat === _gl.RGB) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;\n\t\t\t}\n\n\t\t\tif (glFormat === _gl.RGBA) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;\n\t\t\t}\n\n\t\t\tif (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {\n\t\t\t\textensions.get('EXT_color_buffer_float');\n\t\t\t}\n\n\t\t\treturn internalFormat;\n\t\t} // Fallback filters for non-power-of-2 textures\n\n\n\t\tfunction filterFallback(f) {\n\t\t\tif (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n\t\t\t\treturn _gl.NEAREST;\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\t\t} //\n\n\n\t\tfunction onTextureDispose(event) {\n\t\t\tconst texture = event.target;\n\t\t\ttexture.removeEventListener('dispose', onTextureDispose);\n\t\t\tdeallocateTexture(texture);\n\n\t\t\tif (texture.isVideoTexture) {\n\t\t\t\t_videoTextures.delete(texture);\n\t\t\t}\n\n\t\t\tinfo.memory.textures--;\n\t\t}\n\n\t\tfunction onRenderTargetDispose(event) {\n\t\t\tconst renderTarget = event.target;\n\t\t\trenderTarget.removeEventListener('dispose', onRenderTargetDispose);\n\t\t\tdeallocateRenderTarget(renderTarget);\n\t\t} //\n\n\n\t\tfunction deallocateTexture(texture) {\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (textureProperties.__webglInit === undefined) return;\n\n\t\t\t_gl.deleteTexture(textureProperties.__webglTexture);\n\n\t\t\tproperties.remove(texture);\n\t\t}\n\n\t\tfunction deallocateRenderTarget(renderTarget) {\n\t\t\tconst texture = renderTarget.texture;\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (!renderTarget) return;\n\n\t\t\tif (textureProperties.__webglTexture !== undefined) {\n\t\t\t\t_gl.deleteTexture(textureProperties.__webglTexture);\n\n\t\t\t\tinfo.memory.textures--;\n\t\t\t}\n\n\t\t\tif (renderTarget.depthTexture) {\n\t\t\t\trenderTarget.depthTexture.dispose();\n\t\t\t}\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\t_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n\n\t\t\t\t\tif (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n\t\t\t\tif (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n\t\t\t\tif (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\tif (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n\t\t\t\tif (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n\t\t\t}\n\n\t\t\tif (renderTarget.isWebGLMultipleRenderTargets) {\n\t\t\t\tfor (let i = 0, il = texture.length; i < il; i++) {\n\t\t\t\t\tconst attachmentProperties = properties.get(texture[i]);\n\n\t\t\t\t\tif (attachmentProperties.__webglTexture) {\n\t\t\t\t\t\t_gl.deleteTexture(attachmentProperties.__webglTexture);\n\n\t\t\t\t\t\tinfo.memory.textures--;\n\t\t\t\t\t}\n\n\t\t\t\t\tproperties.remove(texture[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproperties.remove(texture);\n\t\t\tproperties.remove(renderTarget);\n\t\t} //\n\n\n\t\tlet textureUnits = 0;\n\n\t\tfunction resetTextureUnits() {\n\t\t\ttextureUnits = 0;\n\t\t}\n\n\t\tfunction allocateTextureUnit() {\n\t\t\tconst textureUnit = textureUnits;\n\n\t\t\tif (textureUnit >= maxTextures) {\n\t\t\t\tconsole.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);\n\t\t\t}\n\n\t\t\ttextureUnits += 1;\n\t\t\treturn textureUnit;\n\t\t} //\n\n\n\t\tfunction setTexture2D(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (texture.isVideoTexture) updateVideoTexture(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif (image === undefined) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');\n\t\t\t\t} else if (image.complete === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');\n\t\t\t\t} else {\n\t\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTexture2DArray(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTexture3D(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTextureCube(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadCubeTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\t\t}\n\n\t\tconst wrappingToGL = {\n\t\t\t[RepeatWrapping]: _gl.REPEAT,\n\t\t\t[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,\n\t\t\t[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT\n\t\t};\n\t\tconst filterToGL = {\n\t\t\t[NearestFilter]: _gl.NEAREST,\n\t\t\t[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,\n\t\t\t[LinearFilter]: _gl.LINEAR,\n\t\t\t[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tfunction setTextureParameters(textureType, texture, supportsMips) {\n\t\t\tif (supportsMips) {\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n\n\t\t\t\tif (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);\n\t\t\t} else {\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n\n\t\t\t\tif (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);\n\t\t\t\t}\n\n\t\t\t\tif (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));\n\n\t\t\t\tif (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (extensions.has('EXT_texture_filter_anisotropic') === true) {\n\t\t\t\tconst extension = extensions.get('EXT_texture_filter_anisotropic');\n\t\t\t\tif (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\t\tif (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only\n\n\t\t\t\tif (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n\t\t\t\t\t_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n\n\t\t\t\t\tproperties.get(texture).__currentAnisotropy = texture.anisotropy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction initTexture(textureProperties, texture) {\n\t\t\tif (textureProperties.__webglInit === undefined) {\n\t\t\t\ttextureProperties.__webglInit = true;\n\t\t\t\ttexture.addEventListener('dispose', onTextureDispose);\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\t\tinfo.memory.textures++;\n\t\t\t}\n\t\t}\n\n\t\tfunction uploadTexture(textureProperties, texture, slot) {\n\t\t\tlet textureType = _gl.TEXTURE_2D;\n\t\t\tif (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\t\tif (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;\n\t\t\tinitTexture(textureProperties, texture);\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(textureType, textureProperties.__webglTexture);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n\t\t\tconst needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;\n\t\t\tconst image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n\t\t\tconst supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n\t\t\t\t\t\tglFormat = utils.convert(texture.format);\n\t\t\tlet glType = utils.convert(texture.type),\n\t\t\t\t\tglInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\tsetTextureParameters(textureType, texture, supportsMips);\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tif (texture.isDepthTexture) {\n\t\t\t\t// populate depth texture with dummy data\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tif (texture.type === FloatType) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\t\t\t\t} else if (texture.type === UnsignedIntType) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\t\t\t\t\t} else if (texture.type === UnsignedInt248Type) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (texture.type === FloatType) {\n\t\t\t\t\t\tconsole.error('WebGLRenderer: Floating point depth texture requires WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t} // validation checks for WebGL 1\n\n\n\t\t\t\tif (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\n\t\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\t\tglType = utils.convert(texture.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tglInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\n\t\t\t\t\tif (texture.type !== UnsignedInt248Type) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\n\t\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\t\tglType = utils.convert(texture.type);\n\t\t\t\t\t}\n\t\t\t\t} //\n\n\n\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n\t\t\t} else if (texture.isDataTexture) {\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\t\t\tif (mipmaps.length > 0 && supportsMips) {\n\t\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\t\tmipmap = mipmaps[i];\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t\t}\n\t\t\t} else if (texture.isCompressedTexture) {\n\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\tmipmap = mipmaps[i];\n\n\t\t\t\t\tif (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n\t\t\t\t\t\tif (glFormat !== null) {\n\t\t\t\t\t\t\tstate.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t} else if (texture.isDataTexture2DArray) {\n\t\t\t\tstate.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t} else if (texture.isDataTexture3D) {\n\t\t\t\tstate.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t} else {\n\t\t\t\t// regular Texture (image, video, canvas)\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\t\t\tif (mipmaps.length > 0 && supportsMips) {\n\t\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\t\tmipmap = mipmaps[i];\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\tgenerateMipmap(textureType, texture, image.width, image.height);\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tif (texture.onUpdate) texture.onUpdate(texture);\n\t\t}\n\n\t\tfunction uploadCubeTexture(textureProperties, texture, slot) {\n\t\t\tif (texture.image.length !== 6) return;\n\t\t\tinitTexture(textureProperties, texture);\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n\t\t\tconst isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n\t\t\tconst isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tif (!isCompressed && !isDataTexture) {\n\t\t\t\t\tcubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);\n\t\t\t\t} else {\n\t\t\t\t\tcubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst image = cubeImage[0],\n\t\t\t\t\t\tsupportsMips = isPowerOfTwo$1(image) || isWebGL2,\n\t\t\t\t\t\tglFormat = utils.convert(texture.format),\n\t\t\t\t\t\tglType = utils.convert(texture.type),\n\t\t\t\t\t\tglInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\tsetTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\t\t\tlet mipmaps;\n\n\t\t\tif (isCompressed) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tmipmaps = cubeImage[i].mipmaps;\n\n\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\n\t\t\t\t\t\tif (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n\t\t\t\t\t\t\tif (glFormat !== null) {\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t} else {\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tif (isDataTexture) {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n\n\t\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[i].image;\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n\n\t\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length;\n\t\t\t}\n\n\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tif (texture.onUpdate) texture.onUpdate(texture);\n\t\t} // Render targets\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\n\n\t\tfunction setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {\n\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\tconst glType = utils.convert(texture.type);\n\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n\t\t\tif (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\tstate.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n\t\t\t} else {\n\t\t\t\tstate.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\n\n\t\tfunction setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n\n\t\t\tif (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n\t\t\t\tlet glInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\t\tif (depthTexture && depthTexture.isDepthTexture) {\n\t\t\t\t\t\tif (depthTexture.type === FloatType) {\n\t\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\t\t\t\t\t} else if (depthTexture.type === UnsignedIntType) {\n\t\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n\t\t\t} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n\t\t\t} else {\n\t\t\t\t// Use the first texture for MRT so far\n\t\t\t\tconst texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;\n\t\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\t\tconst glType = utils.convert(texture.type);\n\t\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\t\t} // Setup resources for a Depth Texture for a FBO (needs an extension)\n\n\n\t\tfunction setupDepthTexture(framebuffer, renderTarget) {\n\t\t\tconst isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n\t\t\tif (isCube) throw new Error('Depth Texture with cube render targets is not supported');\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\tif (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\t\t} // upload an empty depth texture with framebuffer size\n\n\n\t\t\tif (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D(renderTarget.depthTexture, 0);\n\n\t\t\tconst webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n\n\t\t\tif (renderTarget.depthTexture.format === DepthFormat) {\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n\t\t\t} else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown depthTexture format');\n\t\t\t}\n\t\t} // Setup GL resources for a non-texture depth buffer\n\n\n\t\tfunction setupDepthRenderbuffer(renderTarget) {\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n\t\t\tif (renderTarget.depthTexture) {\n\t\t\t\tif (isCube) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\t\t\tsetupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n\t\t\t} else {\n\t\t\t\tif (isCube) {\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t} // Set up GL resources for the render target\n\n\n\t\tfunction setupRenderTarget(renderTarget) {\n\t\t\tconst texture = renderTarget.texture;\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\trenderTarget.addEventListener('dispose', onRenderTargetDispose);\n\n\t\t\tif (renderTarget.isWebGLMultipleRenderTargets !== true) {\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\t\t\tinfo.memory.textures++;\n\t\t\t}\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;\n\t\t\tconst isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;\n\t\t\tconst isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n\t\t\tconst supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858\n\n\t\t\tif (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {\n\t\t\t\ttexture.format = RGBAFormat;\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');\n\t\t\t} // Setup framebuffer\n\n\n\t\t\tif (isCube) {\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t\tif (isMultipleRenderTargets) {\n\t\t\t\t\tif (capabilities.drawBuffers) {\n\t\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\t\t\tconst attachmentProperties = properties.get(textures[i]);\n\n\t\t\t\t\t\t\tif (attachmentProperties.__webglTexture === undefined) {\n\t\t\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\t\t\t\t\t\t\t\tinfo.memory.textures++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');\n\t\t\t\t\t}\n\t\t\t\t} else if (isMultisample) {\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n\t\t\t\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\t\t\t\tconst glType = utils.convert(texture.type);\n\t\t\t\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n\t\t\t\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\n\t\t\t\t\t\tif (renderTarget.depthBuffer) {\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Setup color buffer\n\n\n\t\t\tif (isCube) {\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\t\t\t\tsetTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n\t\t\t\t}\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n\t\t\t} else if (isMultipleRenderTargets) {\n\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\tconst attachment = textures[i];\n\t\t\t\t\tconst attachmentProperties = properties.get(attachment);\n\t\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);\n\t\t\t\t\tsetTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);\n\t\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);\n\n\t\t\t\t\tif (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n\t\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, null);\n\t\t\t} else {\n\t\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\t\tif (isRenderTarget3D) {\n\t\t\t\t\t// Render targets containing layers, i.e: Texture 3D and 2d arrays\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\tconst isTexture3D = texture.isDataTexture3D;\n\t\t\t\t\t\tglTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(glTextureType, textureProperties.__webglTexture);\n\t\t\t\tsetTextureParameters(glTextureType, texture, supportsMips);\n\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, null);\n\t\t\t} // Setup depth and stencil buffers\n\n\n\t\t\tif (renderTarget.depthBuffer) {\n\t\t\t\tsetupDepthRenderbuffer(renderTarget);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap(renderTarget) {\n\t\t\tconst supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n\t\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\tconst texture = textures[i];\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\n\t\t\t\t\tconst webglTexture = properties.get(texture).__webglTexture;\n\n\t\t\t\t\tstate.bindTexture(target, webglTexture);\n\t\t\t\t\tgenerateMipmap(target, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t\tstate.bindTexture(target, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateMultisampleRenderTarget(renderTarget) {\n\t\t\tif (renderTarget.isWebGLMultisampleRenderTarget) {\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tconst width = renderTarget.width;\n\t\t\t\t\tconst height = renderTarget.height;\n\t\t\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\t\t\tif (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\t\tif (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\t\t\tstate.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\t\tstate.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\n\t\t\t\t\t_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);\n\n\t\t\t\t\tstate.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n\t\t\t\t\tstate.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getRenderTargetSamples(renderTarget) {\n\t\t\treturn isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;\n\t\t}\n\n\t\tfunction updateVideoTexture(texture) {\n\t\t\tconst frame = info.render.frame; // Check the last frame we updated the VideoTexture\n\n\t\t\tif (_videoTextures.get(texture) !== frame) {\n\t\t\t\t_videoTextures.set(texture, frame);\n\n\t\t\t\ttexture.update();\n\t\t\t}\n\t\t} // backwards compatibility\n\n\n\t\tlet warnedTexture2D = false;\n\t\tlet warnedTextureCube = false;\n\n\t\tfunction safeSetTexture2D(texture, slot) {\n\t\t\tif (texture && texture.isWebGLRenderTarget) {\n\t\t\t\tif (warnedTexture2D === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.');\n\t\t\t\t\twarnedTexture2D = true;\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\t\t\t}\n\n\t\t\tsetTexture2D(texture, slot);\n\t\t}\n\n\t\tfunction safeSetTextureCube(texture, slot) {\n\t\t\tif (texture && texture.isWebGLCubeRenderTarget) {\n\t\t\t\tif (warnedTextureCube === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.');\n\t\t\t\t\twarnedTextureCube = true;\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\t\t\t}\n\n\t\t\tsetTextureCube(texture, slot);\n\t\t} //\n\n\n\t\tthis.allocateTextureUnit = allocateTextureUnit;\n\t\tthis.resetTextureUnits = resetTextureUnits;\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTexture2DArray = setTexture2DArray;\n\t\tthis.setTexture3D = setTexture3D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\t\tthis.safeSetTexture2D = safeSetTexture2D;\n\t\tthis.safeSetTextureCube = safeSetTextureCube;\n\t}\n\n\tfunction WebGLUtils(gl, extensions, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tfunction convert(p) {\n\t\t\tlet extension;\n\t\t\tif (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n\t\t\tif (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;\n\t\t\tif (p === ByteType) return gl.BYTE;\n\t\t\tif (p === ShortType) return gl.SHORT;\n\t\t\tif (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n\t\t\tif (p === IntType) return gl.INT;\n\t\t\tif (p === UnsignedIntType) return gl.UNSIGNED_INT;\n\t\t\tif (p === FloatType) return gl.FLOAT;\n\n\t\t\tif (p === HalfFloatType) {\n\t\t\t\tif (isWebGL2) return gl.HALF_FLOAT;\n\t\t\t\textension = extensions.get('OES_texture_half_float');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.HALF_FLOAT_OES;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === AlphaFormat) return gl.ALPHA;\n\t\t\tif (p === RGBFormat) return gl.RGB;\n\t\t\tif (p === RGBAFormat) return gl.RGBA;\n\t\t\tif (p === LuminanceFormat) return gl.LUMINANCE;\n\t\t\tif (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n\t\t\tif (p === DepthFormat) return gl.DEPTH_COMPONENT;\n\t\t\tif (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n\t\t\tif (p === RedFormat) return gl.RED; // WebGL2 formats.\n\n\t\t\tif (p === RedIntegerFormat) return gl.RED_INTEGER;\n\t\t\tif (p === RGFormat) return gl.RG;\n\t\t\tif (p === RGIntegerFormat) return gl.RG_INTEGER;\n\t\t\tif (p === RGBIntegerFormat) return gl.RGB_INTEGER;\n\t\t\tif (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n\n\t\t\tif (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_s3tc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_pvrtc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_ETC1_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_etc1');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_etc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\t\tif (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_astc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\t// TODO Complete?\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGBA_BPTC_Format) {\n\t\t\t\textension = extensions.get('EXT_texture_compression_bptc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\t// TODO Complete?\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === UnsignedInt248Type) {\n\t\t\t\tif (isWebGL2) return gl.UNSIGNED_INT_24_8;\n\t\t\t\textension = extensions.get('WEBGL_depth_texture');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.UNSIGNED_INT_24_8_WEBGL;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tconvert: convert\n\t\t};\n\t}\n\n\tclass ArrayCamera extends PerspectiveCamera {\n\t\tconstructor(array = []) {\n\t\t\tsuper();\n\t\t\tthis.cameras = array;\n\t\t}\n\n\t}\n\n\tArrayCamera.prototype.isArrayCamera = true;\n\n\tclass Group extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Group';\n\t\t}\n\n\t}\n\n\tGroup.prototype.isGroup = true;\n\n\tconst _moveEvent = {\n\t\ttype: 'move'\n\t};\n\n\tclass WebXRController {\n\t\tconstructor() {\n\t\t\tthis._targetRay = null;\n\t\t\tthis._grip = null;\n\t\t\tthis._hand = null;\n\t\t}\n\n\t\tgetHandSpace() {\n\t\t\tif (this._hand === null) {\n\t\t\t\tthis._hand = new Group();\n\t\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\t\tthis._hand.visible = false;\n\t\t\t\tthis._hand.joints = {};\n\t\t\t\tthis._hand.inputState = {\n\t\t\t\t\tpinching: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn this._hand;\n\t\t}\n\n\t\tgetTargetRaySpace() {\n\t\t\tif (this._targetRay === null) {\n\t\t\t\tthis._targetRay = new Group();\n\t\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\t\tthis._targetRay.visible = false;\n\t\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\t\t\t}\n\n\t\t\treturn this._targetRay;\n\t\t}\n\n\t\tgetGripSpace() {\n\t\t\tif (this._grip === null) {\n\t\t\t\tthis._grip = new Group();\n\t\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\t\tthis._grip.visible = false;\n\t\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\t\tthis._grip.angularVelocity = new Vector3();\n\t\t\t}\n\n\t\t\treturn this._grip;\n\t\t}\n\n\t\tdispatchEvent(event) {\n\t\t\tif (this._targetRay !== null) {\n\t\t\t\tthis._targetRay.dispatchEvent(event);\n\t\t\t}\n\n\t\t\tif (this._grip !== null) {\n\t\t\t\tthis._grip.dispatchEvent(event);\n\t\t\t}\n\n\t\t\tif (this._hand !== null) {\n\t\t\t\tthis._hand.dispatchEvent(event);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tdisconnect(inputSource) {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'disconnected',\n\t\t\t\tdata: inputSource\n\t\t\t});\n\n\t\t\tif (this._targetRay !== null) {\n\t\t\t\tthis._targetRay.visible = false;\n\t\t\t}\n\n\t\t\tif (this._grip !== null) {\n\t\t\t\tthis._grip.visible = false;\n\t\t\t}\n\n\t\t\tif (this._hand !== null) {\n\t\t\t\tthis._hand.visible = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tupdate(inputSource, frame, referenceSpace) {\n\t\t\tlet inputPose = null;\n\t\t\tlet gripPose = null;\n\t\t\tlet handPose = null;\n\t\t\tconst targetRay = this._targetRay;\n\t\t\tconst grip = this._grip;\n\t\t\tconst hand = this._hand;\n\n\t\t\tif (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n\t\t\t\tif (targetRay !== null) {\n\t\t\t\t\tinputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n\t\t\t\t\tif (inputPose !== null) {\n\t\t\t\t\t\ttargetRay.matrix.fromArray(inputPose.transform.matrix);\n\t\t\t\t\t\ttargetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n\n\t\t\t\t\t\tif (inputPose.linearVelocity) {\n\t\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\t\ttargetRay.linearVelocity.copy(inputPose.linearVelocity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inputPose.angularVelocity) {\n\t\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\t\ttargetRay.angularVelocity.copy(inputPose.angularVelocity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.dispatchEvent(_moveEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hand && inputSource.hand) {\n\t\t\t\t\thandPose = true;\n\n\t\t\t\t\tfor (const inputjoint of inputSource.hand.values()) {\n\t\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\t\tconst jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n\t\t\t\t\t\tif (hand.joints[inputjoint.jointName] === undefined) {\n\t\t\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\t\t\tconst joint = new Group();\n\t\t\t\t\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\t\t\t\t\tjoint.visible = false;\n\t\t\t\t\t\t\thand.joints[inputjoint.jointName] = joint; // ??\n\n\t\t\t\t\t\t\thand.add(joint);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst joint = hand.joints[inputjoint.jointName];\n\n\t\t\t\t\t\tif (jointPose !== null) {\n\t\t\t\t\t\t\tjoint.matrix.fromArray(jointPose.transform.matrix);\n\t\t\t\t\t\t\tjoint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n\t\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjoint.visible = jointPose !== null;\n\t\t\t\t\t} // Custom events\n\t\t\t\t\t// Check pinchz\n\n\n\t\t\t\t\tconst indexTip = hand.joints['index-finger-tip'];\n\t\t\t\t\tconst thumbTip = hand.joints['thumb-tip'];\n\t\t\t\t\tconst distance = indexTip.position.distanceTo(thumbTip.position);\n\t\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\t\tif (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n\t\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n\t\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (grip !== null && inputSource.gripSpace) {\n\t\t\t\t\t\tgripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n\t\t\t\t\t\tif (gripPose !== null) {\n\t\t\t\t\t\t\tgrip.matrix.fromArray(gripPose.transform.matrix);\n\t\t\t\t\t\t\tgrip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n\t\t\t\t\t\t\tif (gripPose.linearVelocity) {\n\t\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\t\tgrip.linearVelocity.copy(gripPose.linearVelocity);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (gripPose.angularVelocity) {\n\t\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\t\tgrip.angularVelocity.copy(gripPose.angularVelocity);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetRay !== null) {\n\t\t\t\ttargetRay.visible = inputPose !== null;\n\t\t\t}\n\n\t\t\tif (grip !== null) {\n\t\t\t\tgrip.visible = gripPose !== null;\n\t\t\t}\n\n\t\t\tif (hand !== null) {\n\t\t\t\thand.visible = handPose !== null;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass WebXRManager extends EventDispatcher {\n\t\tconstructor(renderer, gl) {\n\t\t\tsuper();\n\t\t\tconst scope = this;\n\t\t\tconst state = renderer.state;\n\t\t\tlet session = null;\n\t\t\tlet framebufferScaleFactor = 1.0;\n\t\t\tlet referenceSpace = null;\n\t\t\tlet referenceSpaceType = 'local-floor';\n\t\t\tlet pose = null;\n\t\t\tconst controllers = [];\n\t\t\tconst inputSourcesMap = new Map(); //\n\n\t\t\tconst cameraL = new PerspectiveCamera();\n\t\t\tcameraL.layers.enable(1);\n\t\t\tcameraL.viewport = new Vector4();\n\t\t\tconst cameraR = new PerspectiveCamera();\n\t\t\tcameraR.layers.enable(2);\n\t\t\tcameraR.viewport = new Vector4();\n\t\t\tconst cameras = [cameraL, cameraR];\n\t\t\tconst cameraVR = new ArrayCamera();\n\t\t\tcameraVR.layers.enable(1);\n\t\t\tcameraVR.layers.enable(2);\n\t\t\tlet _currentDepthNear = null;\n\t\t\tlet _currentDepthFar = null; //\n\n\t\t\tthis.cameraAutoUpdate = true;\n\t\t\tthis.enabled = false;\n\t\t\tthis.isPresenting = false;\n\n\t\t\tthis.getController = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getTargetRaySpace();\n\t\t\t};\n\n\t\t\tthis.getControllerGrip = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getGripSpace();\n\t\t\t};\n\n\t\t\tthis.getHand = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getHandSpace();\n\t\t\t}; //\n\n\n\t\t\tfunction onSessionEvent(event) {\n\t\t\t\tconst controller = inputSourcesMap.get(event.inputSource);\n\n\t\t\t\tif (controller) {\n\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\ttype: event.type,\n\t\t\t\t\t\tdata: event.inputSource\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction onSessionEnd() {\n\t\t\t\tinputSourcesMap.forEach(function (controller, inputSource) {\n\t\t\t\t\tcontroller.disconnect(inputSource);\n\t\t\t\t});\n\t\t\t\tinputSourcesMap.clear();\n\t\t\t\t_currentDepthNear = null;\n\t\t\t\t_currentDepthFar = null; // restore framebuffer/rendering state\n\n\t\t\t\tstate.bindXRFramebuffer(null);\n\t\t\t\trenderer.setRenderTarget(renderer.getRenderTarget()); //\n\n\t\t\t\tanimation.stop();\n\t\t\t\tscope.isPresenting = false;\n\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\ttype: 'sessionend'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.setFramebufferScaleFactor = function (value) {\n\t\t\t\tframebufferScaleFactor = value;\n\n\t\t\t\tif (scope.isPresenting === true) {\n\t\t\t\t\tconsole.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.setReferenceSpaceType = function (value) {\n\t\t\t\treferenceSpaceType = value;\n\n\t\t\t\tif (scope.isPresenting === true) {\n\t\t\t\t\tconsole.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getReferenceSpace = function () {\n\t\t\t\treturn referenceSpace;\n\t\t\t};\n\n\t\t\tthis.getSession = function () {\n\t\t\t\treturn session;\n\t\t\t};\n\n\t\t\tthis.setSession = async function (value) {\n\t\t\t\tsession = value;\n\n\t\t\t\tif (session !== null) {\n\t\t\t\t\tsession.addEventListener('select', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('selectstart', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('selectend', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeeze', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeezestart', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeezeend', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('end', onSessionEnd);\n\t\t\t\t\tsession.addEventListener('inputsourceschange', onInputSourcesChange);\n\t\t\t\t\tconst attributes = gl.getContextAttributes();\n\n\t\t\t\t\tif (attributes.xrCompatible !== true) {\n\t\t\t\t\t\tawait gl.makeXRCompatible();\n\t\t\t\t\t}\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: attributes.alpha,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t}; // eslint-disable-next-line no-undef\n\n\t\t\t\t\tconst baseLayer = new XRWebGLLayer(session, gl, layerInit);\n\t\t\t\t\tsession.updateRenderState({\n\t\t\t\t\t\tbaseLayer: baseLayer\n\t\t\t\t\t});\n\t\t\t\t\treferenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n\t\t\t\t\tanimation.setContext(session);\n\t\t\t\t\tanimation.start();\n\t\t\t\t\tscope.isPresenting = true;\n\t\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\t\ttype: 'sessionstart'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction onInputSourcesChange(event) {\n\t\t\t\tconst inputSources = session.inputSources; // Assign inputSources to available controllers\n\n\t\t\t\tfor (let i = 0; i < controllers.length; i++) {\n\t\t\t\t\tinputSourcesMap.set(inputSources[i], controllers[i]);\n\t\t\t\t} // Notify disconnected\n\n\n\t\t\t\tfor (let i = 0; i < event.removed.length; i++) {\n\t\t\t\t\tconst inputSource = event.removed[i];\n\t\t\t\t\tconst controller = inputSourcesMap.get(inputSource);\n\n\t\t\t\t\tif (controller) {\n\t\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'disconnected',\n\t\t\t\t\t\t\tdata: inputSource\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinputSourcesMap.delete(inputSource);\n\t\t\t\t\t}\n\t\t\t\t} // Notify connected\n\n\n\t\t\t\tfor (let i = 0; i < event.added.length; i++) {\n\t\t\t\t\tconst inputSource = event.added[i];\n\t\t\t\t\tconst controller = inputSourcesMap.get(inputSource);\n\n\t\t\t\t\tif (controller) {\n\t\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'connected',\n\t\t\t\t\t\t\tdata: inputSource\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tconst cameraLPos = new Vector3();\n\t\t\tconst cameraRPos = new Vector3();\n\t\t\t/**\n\t\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t\t * the cameras' projection and world matrices have already been set.\n\t\t\t * And that near and far planes are identical for both cameras.\n\t\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t\t */\n\n\t\t\tfunction setProjectionFromUnion(camera, cameraL, cameraR) {\n\t\t\t\tcameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n\t\t\t\tcameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n\t\t\t\tconst ipd = cameraLPos.distanceTo(cameraRPos);\n\t\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\t\tconst projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n\t\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t\t// Use the left camera for these values.\n\n\t\t\t\tconst near = projL[14] / (projL[10] - 1);\n\t\t\t\tconst far = projL[14] / (projL[10] + 1);\n\t\t\t\tconst topFov = (projL[9] + 1) / projL[5];\n\t\t\t\tconst bottomFov = (projL[9] - 1) / projL[5];\n\t\t\t\tconst leftFov = (projL[8] - 1) / projL[0];\n\t\t\t\tconst rightFov = (projR[8] + 1) / projR[0];\n\t\t\t\tconst left = near * leftFov;\n\t\t\t\tconst right = near * rightFov; // Calculate the new camera's position offset from the\n\t\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\n\t\t\t\tconst zOffset = ipd / (-leftFov + rightFov);\n\t\t\t\tconst xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n\t\t\t\tcameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tcamera.translateX(xOffset);\n\t\t\t\tcamera.translateZ(zOffset);\n\t\t\t\tcamera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tcamera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n\t\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t\t// although must now be relative to the new union camera.\n\n\t\t\t\tconst near2 = near + zOffset;\n\t\t\t\tconst far2 = far + zOffset;\n\t\t\t\tconst left2 = left - xOffset;\n\t\t\t\tconst right2 = right + (ipd - xOffset);\n\t\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\t\t\t\tcamera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n\t\t\t}\n\n\t\t\tfunction updateCamera(camera, parent) {\n\t\t\t\tif (parent === null) {\n\t\t\t\t\tcamera.matrixWorld.copy(camera.matrix);\n\t\t\t\t} else {\n\t\t\t\t\tcamera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n\t\t\t\t}\n\n\t\t\t\tcamera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n\t\t\t}\n\n\t\t\tthis.updateCamera = function (camera) {\n\t\t\t\tif (session === null) return;\n\t\t\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\t\tif (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n\t\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\t\t\t\t\tsession.updateRenderState({\n\t\t\t\t\t\tdepthNear: cameraVR.near,\n\t\t\t\t\t\tdepthFar: cameraVR.far\n\t\t\t\t\t});\n\t\t\t\t\t_currentDepthNear = cameraVR.near;\n\t\t\t\t\t_currentDepthFar = cameraVR.far;\n\t\t\t\t}\n\n\t\t\t\tconst parent = camera.parent;\n\t\t\t\tconst cameras = cameraVR.cameras;\n\t\t\t\tupdateCamera(cameraVR, parent);\n\n\t\t\t\tfor (let i = 0; i < cameras.length; i++) {\n\t\t\t\t\tupdateCamera(cameras[i], parent);\n\t\t\t\t} // update camera and its children\n\n\n\t\t\t\tcamera.matrixWorld.copy(cameraVR.matrixWorld);\n\t\t\t\tcamera.matrix.copy(cameraVR.matrix);\n\t\t\t\tcamera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tconst children = camera.children;\n\n\t\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchildren[i].updateMatrixWorld(true);\n\t\t\t\t} // update projection matrix for proper view frustum culling\n\n\n\t\t\t\tif (cameras.length === 2) {\n\t\t\t\t\tsetProjectionFromUnion(cameraVR, cameraL, cameraR);\n\t\t\t\t} else {\n\t\t\t\t\t// assume single camera setup (AR)\n\t\t\t\t\tcameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getCamera = function () {\n\t\t\t\treturn cameraVR;\n\t\t\t}; // Animation Loop\n\n\n\t\t\tlet onAnimationFrameCallback = null;\n\n\t\t\tfunction onAnimationFrame(time, frame) {\n\t\t\t\tpose = frame.getViewerPose(referenceSpace);\n\n\t\t\t\tif (pose !== null) {\n\t\t\t\t\tconst views = pose.views;\n\t\t\t\t\tconst baseLayer = session.renderState.baseLayer;\n\t\t\t\t\tstate.bindXRFramebuffer(baseLayer.framebuffer);\n\t\t\t\t\tlet cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list\n\n\t\t\t\t\tif (views.length !== cameraVR.cameras.length) {\n\t\t\t\t\t\tcameraVR.cameras.length = 0;\n\t\t\t\t\t\tcameraVRNeedsUpdate = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < views.length; i++) {\n\t\t\t\t\t\tconst view = views[i];\n\t\t\t\t\t\tconst viewport = baseLayer.getViewport(view);\n\t\t\t\t\t\tconst camera = cameras[i];\n\t\t\t\t\t\tcamera.matrix.fromArray(view.transform.matrix);\n\t\t\t\t\t\tcamera.projectionMatrix.fromArray(view.projectionMatrix);\n\t\t\t\t\t\tcamera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tcameraVR.matrix.copy(camera.matrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cameraVRNeedsUpdate === true) {\n\t\t\t\t\t\t\tcameraVR.cameras.push(camera);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} //\n\n\n\t\t\t\tconst inputSources = session.inputSources;\n\n\t\t\t\tfor (let i = 0; i < controllers.length; i++) {\n\t\t\t\t\tconst controller = controllers[i];\n\t\t\t\t\tconst inputSource = inputSources[i];\n\t\t\t\t\tcontroller.update(inputSource, frame, referenceSpace);\n\t\t\t\t}\n\n\t\t\t\tif (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n\t\t\t}\n\n\t\t\tconst animation = new WebGLAnimation();\n\t\t\tanimation.setAnimationLoop(onAnimationFrame);\n\n\t\t\tthis.setAnimationLoop = function (callback) {\n\t\t\t\tonAnimationFrameCallback = callback;\n\t\t\t};\n\n\t\t\tthis.dispose = function () {};\n\t\t}\n\n\t}\n\n\tfunction WebGLMaterials(properties) {\n\t\tfunction refreshFogUniforms(uniforms, fog) {\n\t\t\tuniforms.fogColor.value.copy(fog.color);\n\n\t\t\tif (fog.isFog) {\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\t\t} else if (fog.isFogExp2) {\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {\n\t\t\tif (material.isMeshBasicMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t} else if (material.isMeshLambertMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsLambert(uniforms, material);\n\t\t\t} else if (material.isMeshToonMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsToon(uniforms, material);\n\t\t\t} else if (material.isMeshPhongMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsPhong(uniforms, material);\n\t\t\t} else if (material.isMeshStandardMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\n\t\t\t\tif (material.isMeshPhysicalMaterial) {\n\t\t\t\t\trefreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n\t\t\t\t} else {\n\t\t\t\t\trefreshUniformsStandard(uniforms, material);\n\t\t\t\t}\n\t\t\t} else if (material.isMeshMatcapMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsMatcap(uniforms, material);\n\t\t\t} else if (material.isMeshDepthMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsDepth(uniforms, material);\n\t\t\t} else if (material.isMeshDistanceMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsDistance(uniforms, material);\n\t\t\t} else if (material.isMeshNormalMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsNormal(uniforms, material);\n\t\t\t} else if (material.isLineBasicMaterial) {\n\t\t\t\trefreshUniformsLine(uniforms, material);\n\n\t\t\t\tif (material.isLineDashedMaterial) {\n\t\t\t\t\trefreshUniformsDash(uniforms, material);\n\t\t\t\t}\n\t\t\t} else if (material.isPointsMaterial) {\n\t\t\t\trefreshUniformsPoints(uniforms, material, pixelRatio, height);\n\t\t\t} else if (material.isSpriteMaterial) {\n\t\t\t\trefreshUniformsSprites(uniforms, material);\n\t\t\t} else if (material.isShadowMaterial) {\n\t\t\t\tuniforms.color.value.copy(material.color);\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t} else if (material.isShaderMaterial) {\n\t\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsCommon(uniforms, material) {\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tif (material.color) {\n\t\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\t}\n\n\t\t\tif (material.emissive) {\n\t\t\t\tuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\t\t\t}\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (material.specularMap) {\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t}\n\n\t\t\tconst envMap = properties.get(material).envMap;\n\n\t\t\tif (envMap) {\n\t\t\t\tuniforms.envMap.value = envMap;\n\t\t\t\tuniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tconst maxMipLevel = properties.get(envMap).__maxMipLevel;\n\n\t\t\t\tif (maxMipLevel !== undefined) {\n\t\t\t\t\tuniforms.maxMipLevel.value = maxMipLevel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (material.lightMap) {\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\t\t}\n\n\t\t\tif (material.aoMap) {\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. displacementMap map\n\t\t\t// 4. normal map\n\t\t\t// 5. bump map\n\t\t\t// 6. roughnessMap map\n\t\t\t// 7. metalnessMap map\n\t\t\t// 8. alphaMap map\n\t\t\t// 9. emissiveMap map\n\t\t\t// 10. clearcoat map\n\t\t\t// 11. clearcoat normal map\n\t\t\t// 12. clearcoat roughnessMap map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.specularMap) {\n\t\t\t\tuvScaleMap = material.specularMap;\n\t\t\t} else if (material.displacementMap) {\n\t\t\t\tuvScaleMap = material.displacementMap;\n\t\t\t} else if (material.normalMap) {\n\t\t\t\tuvScaleMap = material.normalMap;\n\t\t\t} else if (material.bumpMap) {\n\t\t\t\tuvScaleMap = material.bumpMap;\n\t\t\t} else if (material.roughnessMap) {\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\t\t} else if (material.metalnessMap) {\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t} else if (material.emissiveMap) {\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\t\t} else if (material.clearcoatMap) {\n\t\t\t\tuvScaleMap = material.clearcoatMap;\n\t\t\t} else if (material.clearcoatNormalMap) {\n\t\t\t\tuvScaleMap = material.clearcoatNormalMap;\n\t\t\t} else if (material.clearcoatRoughnessMap) {\n\t\t\t\tuvScaleMap = material.clearcoatRoughnessMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\t// backwards compatibility\n\t\t\t\tif (uvScaleMap.isWebGLRenderTarget) {\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t\t\t}\n\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t} // uv repeat and offset setting priorities for uv2\n\t\t\t// 1. ao map\n\t\t\t// 2. light map\n\n\n\t\t\tlet uv2ScaleMap;\n\n\t\t\tif (material.aoMap) {\n\t\t\t\tuv2ScaleMap = material.aoMap;\n\t\t\t} else if (material.lightMap) {\n\t\t\t\tuv2ScaleMap = material.lightMap;\n\t\t\t}\n\n\t\t\tif (uv2ScaleMap !== undefined) {\n\t\t\t\t// backwards compatibility\n\t\t\t\tif (uv2ScaleMap.isWebGLRenderTarget) {\n\t\t\t\t\tuv2ScaleMap = uv2ScaleMap.texture;\n\t\t\t\t}\n\n\t\t\t\tif (uv2ScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuv2ScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsLine(uniforms, material) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t}\n\n\t\tfunction refreshUniformsDash(uniforms, material) {\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\t\t}\n\n\t\tfunction refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * pixelRatio;\n\t\t\tuniforms.scale.value = height * 0.5;\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. alpha map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsSprites(uniforms, material) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.rotation.value = material.rotation;\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. alpha map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsLambert(uniforms, material) {\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsPhong(uniforms, material) {\n\t\t\tuniforms.specular.value.copy(material.specular);\n\t\t\tuniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsToon(uniforms, material) {\n\t\t\tif (material.gradientMap) {\n\t\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\t\t\t}\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsStandard(uniforms, material) {\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif (material.roughnessMap) {\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\t\t}\n\n\t\t\tif (material.metalnessMap) {\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\t\t}\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\n\t\t\tconst envMap = properties.get(material).envMap;\n\n\t\t\tif (envMap) {\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {\n\t\t\trefreshUniformsStandard(uniforms, material);\n\t\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\t\t\tif (material.sheen) uniforms.sheen.value.copy(material.sheen);\n\n\t\t\tif (material.clearcoatMap) {\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\t\t\t}\n\n\t\t\tif (material.clearcoatRoughnessMap) {\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\t\t\t}\n\n\t\t\tif (material.clearcoatNormalMap) {\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\tif (material.side === BackSide) {\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\n\t\t\tif (material.transmissionMap) {\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\t\t\t}\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\t\tuniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif (material.thicknessMap) {\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy(material.attenuationColor);\n\t\t}\n\n\t\tfunction refreshUniformsMatcap(uniforms, material) {\n\t\t\tif (material.matcap) {\n\t\t\t\tuniforms.matcap.value = material.matcap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsDepth(uniforms, material) {\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsDistance(uniforms, material) {\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\n\t\t\tuniforms.referencePosition.value.copy(material.referencePosition);\n\t\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\t\tuniforms.farDistance.value = material.farDistance;\n\t\t}\n\n\t\tfunction refreshUniformsNormal(uniforms, material) {\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\trefreshFogUniforms: refreshFogUniforms,\n\t\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t\t};\n\t}\n\n\tfunction createCanvasElement() {\n\t\tconst canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\tcanvas.style.display = 'block';\n\t\treturn canvas;\n\t}\n\n\tfunction WebGLRenderer(parameters) {\n\t\tparameters = parameters || {};\n\n\t\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n\t\t\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\t\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t\t\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t\t\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null; // render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = []; // public properties\n\n\t\tthis.domElement = _canvas; // Debug configuration container\n\n\t\tthis.debug = {\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true\n\t\t}; // clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true; // scene graph\n\n\t\tthis.sortObjects = true; // user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false; // physically based shading\n\n\t\tthis.gammaFactor = 2.0; // for backwards compatibility\n\n\t\tthis.outputEncoding = LinearEncoding; // physical lights\n\n\t\tthis.physicallyCorrectLights = false; // tone mapping\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0; // internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false; // internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\n\t\tlet _currentMaterialId = -1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\n\t\tconst _currentScissor = new Vector4();\n\n\t\tlet _currentScissorTest = null; //\n\n\t\tlet _width = _canvas.width;\n\t\tlet _height = _canvas.height;\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4(0, 0, _width, _height);\n\n\t\tconst _scissor = new Vector4(0, 0, _width, _height);\n\n\t\tlet _scissorTest = false; //\n\n\t\tconst _currentDrawBuffers = []; // frustum\n\n\t\tconst _frustum = new Frustum(); // clipping\n\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false; // transmission\n\n\t\tlet _transmissionRenderTarget = null; // camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _emptyScene = {\n\t\t\tbackground: null,\n\t\t\tfog: null,\n\t\t\tenvironment: null,\n\t\t\toverrideMaterial: null,\n\t\t\tisScene: true\n\t\t};\n\n\t\tfunction getTargetPixelRatio() {\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\t} // initialize\n\n\n\t\tlet _gl = _context;\n\n\t\tfunction getContext(contextNames, contextAttributes) {\n\t\t\tfor (let i = 0; i < contextNames.length; i++) {\n\t\t\t\tconst contextName = contextNames[i];\n\n\t\t\t\tconst context = _canvas.getContext(contextName, contextAttributes);\n\n\t\t\t\tif (context !== null) return context;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\t\tpowerPreference: _powerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n\t\t\t}; // event listeners must be registered before WebGL context is created, see #12753\n\n\t\t\t_canvas.addEventListener('webglcontextlost', onContextLost, false);\n\n\t\t\t_canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n\n\t\t\tif (_gl === null) {\n\t\t\t\tconst contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n\n\t\t\t\tif (_this.isWebGL1Renderer === true) {\n\t\t\t\t\tcontextNames.shift();\n\t\t\t\t}\n\n\t\t\t\t_gl = getContext(contextNames, contextAttributes);\n\n\t\t\t\tif (_gl === null) {\n\t\t\t\t\tif (getContext(contextNames)) {\n\t\t\t\t\t\tthrow new Error('Error creating WebGL context with your selected attributes.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Error creating WebGL context.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\n\t\t\tif (_gl.getShaderPrecisionFormat === undefined) {\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'rangeMin': 1,\n\t\t\t\t\t\t'rangeMax': 1,\n\t\t\t\t\t\t'precision': 1\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('THREE.WebGLRenderer: ' + error.message);\n\t\t\tthrow error;\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\t\tlet utils, bindingStates;\n\n\t\tfunction initGLContext() {\n\t\t\textensions = new WebGLExtensions(_gl);\n\t\t\tcapabilities = new WebGLCapabilities(_gl, extensions, parameters);\n\t\t\textensions.init(capabilities);\n\t\t\tutils = new WebGLUtils(_gl, extensions, capabilities);\n\t\t\tstate = new WebGLState(_gl, extensions, capabilities);\n\t\t\t_currentDrawBuffers[0] = _gl.BACK;\n\t\t\tinfo = new WebGLInfo(_gl);\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n\t\t\tcubemaps = new WebGLCubeMaps(_this);\n\t\t\tattributes = new WebGLAttributes(_gl, capabilities);\n\t\t\tbindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n\t\t\tgeometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n\t\t\tobjects = new WebGLObjects(_gl, geometries, attributes, info);\n\t\t\tmorphtargets = new WebGLMorphtargets(_gl);\n\t\t\tclipping = new WebGLClipping(properties);\n\t\t\tprogramCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);\n\t\t\tmaterials = new WebGLMaterials(properties);\n\t\t\trenderLists = new WebGLRenderLists(properties);\n\t\t\trenderStates = new WebGLRenderStates(extensions, capabilities);\n\t\t\tbackground = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);\n\t\t\tshadowMap = new WebGLShadowMap(_this, objects, capabilities);\n\t\t\tbufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n\t\t\tinfo.programs = programCache.programs;\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\t\t}\n\n\t\tinitGLContext(); // xr\n\n\t\tconst xr = new WebXRManager(_this, _gl);\n\t\tthis.xr = xr; // API\n\n\t\tthis.getContext = function () {\n\t\t\treturn _gl;\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\t\t\treturn _gl.getContextAttributes();\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\t\t\tconst extension = extensions.get('WEBGL_lose_context');\n\t\t\tif (extension) extension.loseContext();\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\t\t\tconst extension = extensions.get('WEBGL_lose_context');\n\t\t\tif (extension) extension.restoreContext();\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\t\t\treturn _pixelRatio;\n\t\t};\n\n\t\tthis.setPixelRatio = function (value) {\n\t\t\tif (value === undefined) return;\n\t\t\t_pixelRatio = value;\n\t\t\tthis.setSize(_width, _height, false);\n\t\t};\n\n\t\tthis.getSize = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set(_width, _height);\n\t\t};\n\n\t\tthis.setSize = function (width, height, updateStyle) {\n\t\t\tif (xr.isPresenting) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_canvas.width = Math.floor(width * _pixelRatio);\n\t\t\t_canvas.height = Math.floor(height * _pixelRatio);\n\n\t\t\tif (updateStyle !== false) {\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\t\t\t}\n\n\t\t\tthis.setViewport(0, 0, width, height);\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function (width, height, pixelRatio) {\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_pixelRatio = pixelRatio;\n\t\t\t_canvas.width = Math.floor(width * pixelRatio);\n\t\t\t_canvas.height = Math.floor(height * pixelRatio);\n\t\t\tthis.setViewport(0, 0, width, height);\n\t\t};\n\n\t\tthis.getCurrentViewport = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');\n\t\t\t\ttarget = new Vector4();\n\t\t\t}\n\n\t\t\treturn target.copy(_currentViewport);\n\t\t};\n\n\t\tthis.getViewport = function (target) {\n\t\t\treturn target.copy(_viewport);\n\t\t};\n\n\t\tthis.setViewport = function (x, y, width, height) {\n\t\t\tif (x.isVector4) {\n\t\t\t\t_viewport.set(x.x, x.y, x.z, x.w);\n\t\t\t} else {\n\t\t\t\t_viewport.set(x, y, width, height);\n\t\t\t}\n\n\t\t\tstate.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n\t\t};\n\n\t\tthis.getScissor = function (target) {\n\t\t\treturn target.copy(_scissor);\n\t\t};\n\n\t\tthis.setScissor = function (x, y, width, height) {\n\t\t\tif (x.isVector4) {\n\t\t\t\t_scissor.set(x.x, x.y, x.z, x.w);\n\t\t\t} else {\n\t\t\t\t_scissor.set(x, y, width, height);\n\t\t\t}\n\n\t\t\tstate.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\t\t\treturn _scissorTest;\n\t\t};\n\n\t\tthis.setScissorTest = function (boolean) {\n\t\t\tstate.setScissorTest(_scissorTest = boolean);\n\t\t};\n\n\t\tthis.setOpaqueSort = function (method) {\n\t\t\t_opaqueSort = method;\n\t\t};\n\n\t\tthis.setTransparentSort = function (method) {\n\t\t\t_transparentSort = method;\n\t\t}; // Clearing\n\n\n\t\tthis.getClearColor = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');\n\t\t\t\ttarget = new Color();\n\t\t\t}\n\n\t\t\treturn target.copy(background.getClearColor());\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\t\t\tbackground.setClearColor.apply(background, arguments);\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\t\t\treturn background.getClearAlpha();\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\t\t\tbackground.setClearAlpha.apply(background, arguments);\n\t\t};\n\n\t\tthis.clear = function (color, depth, stencil) {\n\t\t\tlet bits = 0;\n\t\t\tif (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear(bits);\n\t\t};\n\n\t\tthis.clearColor = function () {\n\t\t\tthis.clear(true, false, false);\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\t\t\tthis.clear(false, true, false);\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\t\t\tthis.clear(false, false, true);\n\t\t}; //\n\n\n\t\tthis.dispose = function () {\n\t\t\t_canvas.removeEventListener('webglcontextlost', onContextLost, false);\n\n\t\t\t_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\txr.dispose();\n\t\t\txr.removeEventListener('sessionstart', onXRSessionStart);\n\t\t\txr.removeEventListener('sessionend', onXRSessionEnd);\n\n\t\t\tif (_transmissionRenderTarget) {\n\t\t\t\t_transmissionRenderTarget.dispose();\n\n\t\t\t\t_transmissionRenderTarget = null;\n\t\t\t}\n\n\t\t\tanimation.stop();\n\t\t}; // Events\n\n\n\t\tfunction onContextLost(event) {\n\t\t\tevent.preventDefault();\n\t\t\tconsole.log('THREE.WebGLRenderer: Context Lost.');\n\t\t\t_isContextLost = true;\n\t\t}\n\n\t\tfunction onContextRestore()\n\t\t/* event */\n\t\t{\n\t\t\tconsole.log('THREE.WebGLRenderer: Context Restored.');\n\t\t\t_isContextLost = false;\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\t\t\tinitGLContext();\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\t\t}\n\n\t\tfunction onMaterialDispose(event) {\n\t\t\tconst material = event.target;\n\t\t\tmaterial.removeEventListener('dispose', onMaterialDispose);\n\t\t\tdeallocateMaterial(material);\n\t\t} // Buffer deallocation\n\n\n\t\tfunction deallocateMaterial(material) {\n\t\t\treleaseMaterialProgramReferences(material);\n\t\t\tproperties.remove(material);\n\t\t}\n\n\t\tfunction releaseMaterialProgramReferences(material) {\n\t\t\tconst programs = properties.get(material).programs;\n\n\t\t\tif (programs !== undefined) {\n\t\t\t\tprograms.forEach(function (program) {\n\t\t\t\t\tprogramCache.releaseProgram(program);\n\t\t\t\t});\n\t\t\t}\n\t\t} // Buffer rendering\n\n\n\t\tfunction renderObjectImmediate(object, program) {\n\t\t\tobject.render(function (object) {\n\t\t\t\t_this.renderBufferImmediate(object, program);\n\t\t\t});\n\t\t}\n\n\t\tthis.renderBufferImmediate = function (object, program) {\n\t\t\tbindingStates.initAttributes();\n\t\t\tconst buffers = properties.get(object);\n\t\t\tif (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();\n\t\t\tif (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();\n\t\t\tif (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();\n\t\t\tif (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();\n\t\t\tconst programAttributes = program.getAttributes();\n\n\t\t\tif (object.hasPositions) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.position);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasNormals) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.normal);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasUvs) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.uv);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasColors) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.color);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tbindingStates.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays(_gl.TRIANGLES, 0, object.count);\n\n\t\t\tobject.count = 0;\n\t\t};\n\n\t\tthis.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n\t\t\tif (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n\t\t\tconst program = setProgram(camera, scene, material, object);\n\t\t\tstate.setMaterial(material, frontFaceCW); //\n\n\t\t\tlet index = geometry.index;\n\t\t\tconst position = geometry.attributes.position; //\n\n\t\t\tif (index === null) {\n\t\t\t\tif (position === undefined || position.count === 0) return;\n\t\t\t} else if (index.count === 0) {\n\t\t\t\treturn;\n\t\t\t} //\n\n\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif (material.wireframe === true) {\n\t\t\t\tindex = geometries.getWireframeAttribute(geometry);\n\t\t\t\trangeFactor = 2;\n\t\t\t}\n\n\t\t\tif (material.morphTargets || material.morphNormals) {\n\t\t\t\tmorphtargets.update(object, geometry, material, program);\n\t\t\t}\n\n\t\t\tbindingStates.setup(object, material, program, geometry, index);\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif (index !== null) {\n\t\t\t\tattribute = attributes.get(index);\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex(attribute);\n\t\t\t} //\n\n\n\t\t\tconst dataCount = index !== null ? index.count : position.count;\n\t\t\tconst rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tconst rangeCount = geometry.drawRange.count * rangeFactor;\n\t\t\tconst groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tconst groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\t\tconst drawStart = Math.max(rangeStart, groupStart);\n\t\t\tconst drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n\t\t\tconst drawCount = Math.max(0, drawEnd - drawStart + 1);\n\t\t\tif (drawCount === 0) return; //\n\n\t\t\tif (object.isMesh) {\n\t\t\t\tif (material.wireframe === true) {\n\t\t\t\t\tstate.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n\t\t\t\t\trenderer.setMode(_gl.LINES);\n\t\t\t\t} else {\n\t\t\t\t\trenderer.setMode(_gl.TRIANGLES);\n\t\t\t\t}\n\t\t\t} else if (object.isLine) {\n\t\t\t\tlet lineWidth = material.linewidth;\n\t\t\t\tif (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth(lineWidth * getTargetPixelRatio());\n\n\t\t\t\tif (object.isLineSegments) {\n\t\t\t\t\trenderer.setMode(_gl.LINES);\n\t\t\t\t} else if (object.isLineLoop) {\n\t\t\t\t\trenderer.setMode(_gl.LINE_LOOP);\n\t\t\t\t} else {\n\t\t\t\t\trenderer.setMode(_gl.LINE_STRIP);\n\t\t\t\t}\n\t\t\t} else if (object.isPoints) {\n\t\t\t\trenderer.setMode(_gl.POINTS);\n\t\t\t} else if (object.isSprite) {\n\t\t\t\trenderer.setMode(_gl.TRIANGLES);\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh) {\n\t\t\t\trenderer.renderInstances(drawStart, drawCount, object.count);\n\t\t\t} else if (geometry.isInstancedBufferGeometry) {\n\t\t\t\tconst instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n\t\t\t\trenderer.renderInstances(drawStart, drawCount, instanceCount);\n\t\t\t} else {\n\t\t\t\trenderer.render(drawStart, drawCount);\n\t\t\t}\n\t\t}; // Compile\n\n\n\t\tthis.compile = function (scene, camera) {\n\t\t\tcurrentRenderState = renderStates.get(scene);\n\t\t\tcurrentRenderState.init();\n\t\t\tscene.traverseVisible(function (object) {\n\t\t\t\tif (object.isLight && object.layers.test(camera.layers)) {\n\t\t\t\t\tcurrentRenderState.pushLight(object);\n\n\t\t\t\t\tif (object.castShadow) {\n\t\t\t\t\t\tcurrentRenderState.pushShadow(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tcurrentRenderState.setupLights();\n\t\t\tscene.traverse(function (object) {\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif (material) {\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0; i < material.length; i++) {\n\t\t\t\t\t\t\tconst material2 = material[i];\n\t\t\t\t\t\t\tgetProgram(material2, scene, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetProgram(material, scene, object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}; // Animation Loop\n\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame(time) {\n\t\t\tif (onAnimationFrameCallback) onAnimationFrameCallback(time);\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\t\t\tanimation.stop();\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\t\t\tanimation.start();\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop(onAnimationFrame);\n\t\tif (typeof window !== 'undefined') animation.setContext(window);\n\n\t\tthis.setAnimationLoop = function (callback) {\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop(callback);\n\t\t\tcallback === null ? animation.stop() : animation.start();\n\t\t};\n\n\t\txr.addEventListener('sessionstart', onXRSessionStart);\n\t\txr.addEventListener('sessionend', onXRSessionEnd); // Rendering\n\n\t\tthis.render = function (scene, camera) {\n\t\t\tif (camera !== undefined && camera.isCamera !== true) {\n\t\t\t\tconsole.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_isContextLost === true) return; // update scene graph\n\n\t\t\tif (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n\t\t\tif (camera.parent === null) camera.updateMatrixWorld();\n\n\t\t\tif (xr.enabled === true && xr.isPresenting === true) {\n\t\t\t\tif (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\t\t\t} //\n\n\n\t\t\tif (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n\t\t\tcurrentRenderState = renderStates.get(scene, renderStateStack.length);\n\t\t\tcurrentRenderState.init();\n\t\t\trenderStateStack.push(currentRenderState);\n\n\t\t\t_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n\t\t\t_frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n\t\t\tcurrentRenderList = renderLists.get(scene, renderListStack.length);\n\t\t\tcurrentRenderList.init();\n\t\t\trenderListStack.push(currentRenderList);\n\t\t\tprojectObject(scene, camera, 0, _this.sortObjects);\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif (_this.sortObjects === true) {\n\t\t\t\tcurrentRenderList.sort(_opaqueSort, _transparentSort);\n\t\t\t} //\n\n\n\t\t\tif (_clippingEnabled === true) clipping.beginShadows();\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\t\t\tshadowMap.render(shadowsArray, scene, camera);\n\t\t\tcurrentRenderState.setupLights();\n\t\t\tcurrentRenderState.setupLightsView(camera);\n\t\t\tif (_clippingEnabled === true) clipping.endShadows(); //\n\n\t\t\tif (this.info.autoReset === true) this.info.reset(); //\n\n\t\t\tbackground.render(currentRenderList, scene); // render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\t\t\tif (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n\t\t\tif (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);\n\t\t\tif (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //\n\n\t\t\tif (_currentRenderTarget !== null) {\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\t\t\ttextures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget(_currentRenderTarget);\n\t\t\t} //\n\n\n\t\t\tif (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest(true);\n\t\t\tstate.buffers.depth.setMask(true);\n\t\t\tstate.buffers.color.setMask(true);\n\t\t\tstate.setPolygonOffset(false); // _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = -1;\n\t\t\t_currentCamera = null;\n\t\t\trenderStateStack.pop();\n\n\t\t\tif (renderStateStack.length > 0) {\n\t\t\t\tcurrentRenderState = renderStateStack[renderStateStack.length - 1];\n\t\t\t} else {\n\t\t\t\tcurrentRenderState = null;\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif (renderListStack.length > 0) {\n\t\t\t\tcurrentRenderList = renderListStack[renderListStack.length - 1];\n\t\t\t} else {\n\t\t\t\tcurrentRenderList = null;\n\t\t\t}\n\t\t};\n\n\t\tfunction projectObject(object, camera, groupOrder, sortObjects) {\n\t\t\tif (object.visible === false) return;\n\t\t\tconst visible = object.layers.test(camera.layers);\n\n\t\t\tif (visible) {\n\t\t\t\tif (object.isGroup) {\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\t\t\t\t} else if (object.isLOD) {\n\t\t\t\t\tif (object.autoUpdate === true) object.update(camera);\n\t\t\t\t} else if (object.isLight) {\n\t\t\t\t\tcurrentRenderState.pushLight(object);\n\n\t\t\t\t\tif (object.castShadow) {\n\t\t\t\t\t\tcurrentRenderState.pushShadow(object);\n\t\t\t\t\t}\n\t\t\t\t} else if (object.isSprite) {\n\t\t\t\t\tif (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n\t\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update(object);\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif (material.visible) {\n\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (object.isImmediateRenderObject) {\n\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);\n\t\t\t\t} else if (object.isMesh || object.isLine || object.isPoints) {\n\t\t\t\t\tif (object.isSkinnedMesh) {\n\t\t\t\t\t\t// update skeleton only once in a frame\n\t\t\t\t\t\tif (object.skeleton.frame !== info.render.frame) {\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!object.frustumCulled || _frustum.intersectsObject(object)) {\n\t\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update(object);\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\n\t\t\t\t\t\t\t\tif (groupMaterial && groupMaterial.visible) {\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (material.visible) {\n\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tprojectObject(children[i], camera, groupOrder, sortObjects);\n\t\t\t}\n\t\t}\n\n\t\tfunction renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {\n\t\t\tif (_transmissionRenderTarget === null) {\n\t\t\t\t_transmissionRenderTarget = new WebGLRenderTarget(1024, 1024, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\t\twrapS: ClampToEdgeWrapping,\n\t\t\t\t\twrapT: ClampToEdgeWrapping\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\n\t\t\t_this.setRenderTarget(_transmissionRenderTarget);\n\n\t\t\t_this.clear();\n\n\t\t\trenderObjects(opaqueObjects, scene, camera);\n\t\t\ttextures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n\t\t\t_this.setRenderTarget(currentRenderTarget);\n\n\t\t\trenderObjects(transmissiveObjects, scene, camera);\n\t\t}\n\n\t\tfunction renderObjects(renderList, scene, camera) {\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor (let i = 0, l = renderList.length; i < l; i++) {\n\t\t\t\tconst renderItem = renderList[i];\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif (camera.isArrayCamera) {\n\t\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\t\tfor (let j = 0, jl = cameras.length; j < jl; j++) {\n\t\t\t\t\t\tconst camera2 = cameras[j];\n\n\t\t\t\t\t\tif (object.layers.test(camera2.layers)) {\n\t\t\t\t\t\t\tstate.viewport(_currentViewport.copy(camera2.viewport));\n\t\t\t\t\t\t\tcurrentRenderState.setupLightsView(camera2);\n\t\t\t\t\t\t\trenderObject(object, scene, camera2, geometry, material, group);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trenderObject(object, scene, camera, geometry, material, group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction renderObject(object, scene, camera, geometry, material, group) {\n\t\t\tobject.onBeforeRender(_this, scene, camera, geometry, material, group);\n\t\t\tobject.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n\t\t\tobject.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n\t\t\tif (object.isImmediateRenderObject) {\n\t\t\t\tconst program = setProgram(camera, scene, material, object);\n\t\t\t\tstate.setMaterial(material);\n\t\t\t\tbindingStates.reset();\n\t\t\t\trenderObjectImmediate(object, program);\n\t\t\t} else {\n\t\t\t\t_this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\t\t\t}\n\n\t\t\tobject.onAfterRender(_this, scene, camera, geometry, material, group);\n\t\t}\n\n\t\tfunction getProgram(material, scene, object) {\n\t\t\tif (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\t\t\tconst lightsStateVersion = lights.state.version;\n\t\t\tconst parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey(parameters);\n\t\t\tlet programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);\n\n\t\t\tif (programs === undefined) {\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener('dispose', onMaterialDispose);\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\t\t\t}\n\n\t\t\tlet program = programs.get(programCacheKey);\n\n\t\t\tif (program !== undefined) {\n\t\t\t\t// early out if program and light state is identical\n\t\t\t\tif (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n\t\t\t\t\tupdateCommonMaterialProperties(material, parameters);\n\t\t\t\t\treturn program;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparameters.uniforms = programCache.getUniforms(material);\n\t\t\t\tmaterial.onBuild(parameters, _this);\n\t\t\t\tmaterial.onBeforeCompile(parameters, _this);\n\t\t\t\tprogram = programCache.acquireProgram(parameters, programCacheKey);\n\t\t\t\tprograms.set(programCacheKey, program);\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties(material, parameters); // store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights(material);\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif (materialProperties.needsLights) {\n\t\t\t\t// wire up the material to this renderer's lighting state\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms\n\t\t\t}\n\n\t\t\tconst progUniforms = program.getUniforms();\n\t\t\tconst uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties(material, parameters) {\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t}\n\n\t\tfunction setProgram(camera, scene, material, object) {\n\t\t\tif (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n\t\t\tconst envMap = cubemaps.get(material.envMap || environment);\n\t\t\tconst vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif (_clippingEnabled === true) {\n\t\t\t\tif (_localClippingEnabled === true || camera !== _currentCamera) {\n\t\t\t\t\tconst useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\n\t\t\t\t\tclipping.setState(material, camera, useCache);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif (material.version === materialProperties.__version) {\n\t\t\t\tif (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.outputEncoding !== encoding) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (object.isInstancedMesh && materialProperties.instancing === false) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.envMap !== envMap) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (material.fog && materialProperties.fog !== fog) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.vertexAlphas !== vertexAlphas) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\t\t\t} //\n\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif (needsProgramChange === true) {\n\t\t\t\tprogram = getProgram(material, scene, object);\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif (state.useProgram(program.program)) {\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\t\t\t}\n\n\t\t\tif (material.id !== _currentMaterialId) {\n\t\t\t\t_currentMaterialId = material.id;\n\t\t\t\trefreshMaterial = true;\n\t\t\t}\n\n\t\t\tif (refreshProgram || _currentCamera !== camera) {\n\t\t\t\tp_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n\n\t\t\t\tif (capabilities.logarithmicDepthBuffer) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n\t\t\t\t}\n\n\t\t\t\tif (_currentCamera !== camera) {\n\t\t\t\t\t_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true; // set to true on material change\n\n\t\t\t\t\trefreshLights = true; // remains set until update done\n\t\t\t\t} // load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\n\t\t\t\tif (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n\t\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif (uCamPos !== undefined) {\n\t\t\t\t\t\tuCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);\n\t\t\t\t}\n\n\t\t\t\tif (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n\t\t\t\t}\n\t\t\t} // skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// otherwise textures used for skinning can take over texture units reserved for other material textures\n\n\n\t\t\tif (object.isSkinnedMesh) {\n\t\t\t\tp_uniforms.setOptional(_gl, object, 'bindMatrix');\n\t\t\t\tp_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif (skeleton) {\n\t\t\t\t\tif (capabilities.floatVertexTextures) {\n\t\t\t\t\t\tif (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n\t\t\t\t\t\tp_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\n\t\t\t\t\t\tp_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n\t\t\t}\n\n\t\t\tif (refreshMaterial) {\n\t\t\t\tp_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\n\n\t\t\t\tif (materialProperties.needsLights) {\n\t\t\t\t\t// the current material requires lighting info\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n\t\t\t\t} // refresh uniforms common to several materials\n\n\n\t\t\t\tif (fog && material.fog) {\n\t\t\t\t\tmaterials.refreshFogUniforms(m_uniforms, fog);\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n\t\t\t\tWebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n\t\t\t}\n\n\t\t\tif (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n\t\t\t\tWebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\t\t\t}\n\n\t\t\tif (material.isSpriteMaterial) {\n\t\t\t\tp_uniforms.setValue(_gl, 'center', object.center);\n\t\t\t} // common matrices\n\n\n\t\t\tp_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n\t\t\tp_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n\t\t\tp_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n\t\t\treturn program;\n\t\t} // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\n\t\tfunction markUniformsLightsNeedsUpdate(uniforms, value) {\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\t}\n\n\t\tfunction materialNeedsLights(material) {\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\t\t\treturn _currentActiveCubeFace;\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\t\t\treturn _currentActiveMipmapLevel;\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\t\t\treturn _currentRenderTarget;\n\t\t};\n\n\t\tthis.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tif (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {\n\t\t\t\ttextures.setupRenderTarget(renderTarget);\n\t\t\t}\n\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif (renderTarget) {\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif (texture.isDataTexture3D || texture.isDataTexture2DArray) {\n\t\t\t\t\tisRenderTarget3D = true;\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n\t\t\t\tif (renderTarget.isWebGLCubeRenderTarget) {\n\t\t\t\t\tframebuffer = __webglFramebuffer[activeCubeFace];\n\t\t\t\t\tisCube = true;\n\t\t\t\t} else if (renderTarget.isWebGLMultisampleRenderTarget) {\n\t\t\t\t\tframebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n\t\t\t\t} else {\n\t\t\t\t\tframebuffer = __webglFramebuffer;\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy(renderTarget.viewport);\n\n\t\t\t\t_currentScissor.copy(renderTarget.scissor);\n\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\t\t} else {\n\t\t\t\t_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n\n\t\t\t\t_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n\n\t\t\t\t_currentScissorTest = _scissorTest;\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\tif (framebufferBound && capabilities.drawBuffers) {\n\t\t\t\tlet needsUpdate = false;\n\n\t\t\t\tif (renderTarget) {\n\t\t\t\t\tif (renderTarget.isWebGLMultipleRenderTargets) {\n\t\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\t\tif (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {\n\t\t\t\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\t\t\t\t_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_currentDrawBuffers.length = textures.length;\n\t\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {\n\t\t\t\t\t\t\t_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;\n\t\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\t\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {\n\t\t\t\t\t\t_currentDrawBuffers[0] = _gl.BACK;\n\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (needsUpdate) {\n\t\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\t\t_gl.drawBuffers(_currentDrawBuffers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\textensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.viewport(_currentViewport);\n\t\t\tstate.scissor(_currentScissor);\n\t\t\tstate.setScissorTest(_currentScissorTest);\n\n\t\t\tif (isCube) {\n\t\t\t\tconst textureProperties = properties.get(renderTarget.texture);\n\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n\t\t\t} else if (isRenderTarget3D) {\n\t\t\t\tconst textureProperties = properties.get(renderTarget.texture);\n\t\t\t\tconst layer = activeCubeFace || 0;\n\n\t\t\t\t_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n\t\t\t}\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n\t\t\tif (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n\t\t\t\tframebuffer = framebuffer[activeCubeFaceIndex];\n\t\t\t}\n\n\t\t\tif (framebuffer) {\n\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));\n\n\t\t\t\t\tif (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t!halfFloatSupportedByExt) {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\t\t\t\t\tif (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n\t\t\t\t\t\t\t_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\t\t\t\t\tconst framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function (position, texture, level = 0) {\n\t\t\tconst levelScale = Math.pow(2, -level);\n\t\t\tconst width = Math.floor(texture.image.width * levelScale);\n\t\t\tconst height = Math.floor(texture.image.height * levelScale);\n\t\t\tlet glFormat = utils.convert(texture.format);\n\n\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100\n\t\t\t\tif (glFormat === _gl.RGB) glFormat = _gl.RGB8;\n\t\t\t\tif (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;\n\t\t\t}\n\n\t\t\ttextures.setTexture2D(texture, 0);\n\n\t\t\t_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);\n\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {\n\t\t\tconst width = srcTexture.image.width;\n\t\t\tconst height = srcTexture.image.height;\n\t\t\tconst glFormat = utils.convert(dstTexture.format);\n\t\t\tconst glType = utils.convert(dstTexture.type);\n\t\t\ttextures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei\n\t\t\t// parameters, make sure they are correct for the dstTexture\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n\t\t\tif (srcTexture.isDataTexture) {\n\t\t\t\t_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n\t\t\t} else {\n\t\t\t\tif (srcTexture.isCompressedTexture) {\n\t\t\t\t\t_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);\n\t\t\t\t}\n\t\t\t} // Generate mipmaps only when copying level 0\n\n\n\t\t\tif (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {\n\t\t\tif (_this.isWebGL1Renderer) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdata\n\t\t\t} = srcTexture.image;\n\t\t\tconst glFormat = utils.convert(dstTexture.format);\n\t\t\tconst glType = utils.convert(dstTexture.type);\n\t\t\tlet glTarget;\n\n\t\t\tif (dstTexture.isDataTexture3D) {\n\t\t\t\ttextures.setTexture3D(dstTexture, 0);\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\t\t\t} else if (dstTexture.isDataTexture2DArray) {\n\t\t\t\ttextures.setTexture2DArray(dstTexture, 0);\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n\t\t\tconst unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n\n\t\t\tconst unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n\n\t\t\tconst unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n\n\t\t\tconst unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n\n\t\t\tconst unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, width);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, height);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);\n\n\t\t\t_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0\n\n\n\t\t\tif (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.initTexture = function (texture) {\n\t\t\ttextures.setTexture2D(texture, 0);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.resetState = function () {\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\t\t};\n\n\t\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n\t\t\t\tdetail: this\n\t\t\t})); // eslint-disable-line no-undef\n\n\t\t}\n\t}\n\n\tclass WebGL1Renderer extends WebGLRenderer {}\n\n\tWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\n\tclass FogExp2 {\n\t\tconstructor(color, density = 0.00025) {\n\t\t\tthis.name = '';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.density = density;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new FogExp2(this.color, this.density);\n\t\t}\n\n\t\ttoJSON()\n\t\t/* meta */\n\t\t{\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\t}\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tclass Fog {\n\t\tconstructor(color, near = 1, far = 1000) {\n\t\t\tthis.name = '';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Fog(this.color, this.near, this.far);\n\t\t}\n\n\t\ttoJSON()\n\t\t/* meta */\n\t\t{\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\t}\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tclass Scene extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Scene';\n\t\t\tthis.background = null;\n\t\t\tthis.environment = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t\t\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n\t\t\t\t\tdetail: this\n\t\t\t\t})); // eslint-disable-line no-undef\n\n\t\t\t}\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tif (source.background !== null) this.background = source.background.clone();\n\t\t\tif (source.environment !== null) this.environment = source.environment.clone();\n\t\t\tif (source.fog !== null) this.fog = source.fog.clone();\n\t\t\tif (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tif (this.background !== null) data.object.background = this.background.toJSON(meta);\n\t\t\tif (this.environment !== null) data.object.environment = this.environment.toJSON(meta);\n\t\t\tif (this.fog !== null) data.object.fog = this.fog.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tScene.prototype.isScene = true;\n\n\tclass InterleavedBuffer {\n\t\tconstructor(array, stride) {\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\t\tthis.usage = StaticDrawUsage;\n\t\t\tthis.updateRange = {\n\t\t\t\toffset: 0,\n\t\t\t\tcount: -1\n\t\t\t};\n\t\t\tthis.version = 0;\n\t\t\tthis.uuid = generateUUID();\n\t\t}\n\n\t\tonUploadCallback() {}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetUsage(value) {\n\t\t\tthis.usage = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.usage = source.usage;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyAt(index1, attribute, index2) {\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor (let i = 0, l = this.stride; i < l; i++) {\n\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(value, offset = 0) {\n\t\t\tthis.array.set(value, offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tif (data.arrayBuffers === undefined) {\n\t\t\t\tdata.arrayBuffers = {};\n\t\t\t}\n\n\t\t\tif (this.array.buffer._uuid === undefined) {\n\t\t\t\tthis.array.buffer._uuid = generateUUID();\n\t\t\t}\n\n\t\t\tif (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n\t\t\t\tdata.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n\t\t\t}\n\n\t\t\tconst array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n\t\t\tconst ib = new this.constructor(array, this.stride);\n\t\t\tib.setUsage(this.usage);\n\t\t\treturn ib;\n\t\t}\n\n\t\tonUpload(callback) {\n\t\t\tthis.onUploadCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tif (data.arrayBuffers === undefined) {\n\t\t\t\tdata.arrayBuffers = {};\n\t\t\t} // generate UUID for array buffer if necessary\n\n\n\t\t\tif (this.array.buffer._uuid === undefined) {\n\t\t\t\tthis.array.buffer._uuid = generateUUID();\n\t\t\t}\n\n\t\t\tif (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n\t\t\t\tdata.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n\t\t\t} //\n\n\n\t\t\treturn {\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tstride: this.stride\n\t\t\t};\n\t\t}\n\n\t}\n\n\tInterleavedBuffer.prototype.isInterleavedBuffer = true;\n\n\tconst _vector$6 = /*@__PURE__*/new Vector3();\n\n\tclass InterleavedBufferAttribute {\n\t\tconstructor(interleavedBuffer, itemSize, offset, normalized) {\n\t\t\tthis.name = '';\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\t\tthis.normalized = normalized === true;\n\t\t}\n\n\t\tget count() {\n\t\t\treturn this.data.count;\n\t\t}\n\n\t\tget array() {\n\t\t\treturn this.data.array;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tthis.data.needsUpdate = value;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tfor (let i = 0, l = this.data.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.applyMatrix4(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.applyNormalMatrix(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.transformDirection(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(index, x) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset] = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(index, y) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(index, z) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetW(index, w) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetX(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset];\n\t\t}\n\n\t\tgetY(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 1];\n\t\t}\n\n\t\tgetZ(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 2];\n\t\t}\n\n\t\tgetW(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 3];\n\t\t}\n\n\t\tsetXY(index, x, y) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZ(index, x, y, z) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\tthis.data.array[index + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZW(index, x, y, z, w) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\tthis.data.array[index + 2] = z;\n\t\t\tthis.data.array[index + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tif (data === undefined) {\n\t\t\t\tconsole.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\t\tfor (let j = 0; j < this.itemSize; j++) {\n\t\t\t\t\t\tarray.push(this.data.array[index + j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n\t\t\t} else {\n\t\t\t\tif (data.interleavedBuffers === undefined) {\n\t\t\t\t\tdata.interleavedBuffers = {};\n\t\t\t\t}\n\n\t\t\t\tif (data.interleavedBuffers[this.data.uuid] === undefined) {\n\t\t\t\t\tdata.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n\t\t\t\t}\n\n\t\t\t\treturn new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tif (data === undefined) {\n\t\t\t\tconsole.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\t\tfor (let j = 0; j < this.itemSize; j++) {\n\t\t\t\t\t\tarray.push(this.data.array[index + j]);\n\t\t\t\t\t}\n\t\t\t\t} // deinterleave data and save it as an ordinary buffer attribute for now\n\n\n\t\t\t\treturn {\n\t\t\t\t\titemSize: this.itemSize,\n\t\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: this.normalized\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// save as true interlaved attribtue\n\t\t\t\tif (data.interleavedBuffers === undefined) {\n\t\t\t\t\tdata.interleavedBuffers = {};\n\t\t\t\t}\n\n\t\t\t\tif (data.interleavedBuffers[this.data.uuid] === undefined) {\n\t\t\t\t\tdata.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\t\titemSize: this.itemSize,\n\t\t\t\t\tdata: this.data.uuid,\n\t\t\t\t\toffset: this.offset,\n\t\t\t\t\tnormalized: this.normalized\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t}\n\n\tInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\trotation: <float>,\n\t *\tsizeAttenuation: <bool>\n\t * }\n\t */\n\n\tclass SpriteMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SpriteMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.rotation = 0;\n\t\t\tthis.sizeAttenuation = true;\n\t\t\tthis.transparent = true;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.rotation = source.rotation;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpriteMaterial.prototype.isSpriteMaterial = true;\n\n\tlet _geometry;\n\n\tconst _intersectPoint = /*@__PURE__*/new Vector3();\n\n\tconst _worldScale = /*@__PURE__*/new Vector3();\n\n\tconst _mvPosition = /*@__PURE__*/new Vector3();\n\n\tconst _alignedPosition = /*@__PURE__*/new Vector2();\n\n\tconst _rotatedPosition = /*@__PURE__*/new Vector2();\n\n\tconst _viewWorldMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _vA = /*@__PURE__*/new Vector3();\n\n\tconst _vB = /*@__PURE__*/new Vector3();\n\n\tconst _vC = /*@__PURE__*/new Vector3();\n\n\tconst _uvA = /*@__PURE__*/new Vector2();\n\n\tconst _uvB = /*@__PURE__*/new Vector2();\n\n\tconst _uvC = /*@__PURE__*/new Vector2();\n\n\tclass Sprite extends Object3D {\n\t\tconstructor(material) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Sprite';\n\n\t\t\tif (_geometry === undefined) {\n\t\t\t\t_geometry = new BufferGeometry();\n\t\t\t\tconst float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n\t\t\t\tconst interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n\t\t\t\t_geometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n\t\t\t\t_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\n\t\t\t\t_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n\t\t\t}\n\n\t\t\tthis.geometry = _geometry;\n\t\t\tthis.material = material !== undefined ? material : new SpriteMaterial();\n\t\t\tthis.center = new Vector2(0.5, 0.5);\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tif (raycaster.camera === null) {\n\t\t\t\tconsole.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n\t\t\t}\n\n\t\t\t_worldScale.setFromMatrixScale(this.matrixWorld);\n\n\t\t\t_viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n\n\t\t\tthis.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n\n\t\t\t_mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n\t\t\tif (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n\t\t\t\t_worldScale.multiplyScalar(-_mvPosition.z);\n\t\t\t}\n\n\t\t\tconst rotation = this.material.rotation;\n\t\t\tlet sin, cos;\n\n\t\t\tif (rotation !== 0) {\n\t\t\t\tcos = Math.cos(rotation);\n\t\t\t\tsin = Math.sin(rotation);\n\t\t\t}\n\n\t\t\tconst center = this.center;\n\t\t\ttransformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\t\t\ttransformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\t\t\ttransformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n\t\t\t_uvA.set(0, 0);\n\n\t\t\t_uvB.set(1, 0);\n\n\t\t\t_uvC.set(1, 1); // check first triangle\n\n\n\t\t\tlet intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n\t\t\tif (intersect === null) {\n\t\t\t\t// check second triangle\n\t\t\t\ttransformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n\t\t\t\t_uvB.set(0, 1);\n\n\t\t\t\tintersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n\n\t\t\t\tif (intersect === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n\t\t\tif (distance < raycaster.near || distance > raycaster.far) return;\n\t\t\tintersects.push({\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: _intersectPoint.clone(),\n\t\t\t\tuv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\t\t\t});\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tif (source.center !== undefined) this.center.copy(source.center);\n\t\t\tthis.material = source.material;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSprite.prototype.isSprite = true;\n\n\tfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n\t\t// compute position in camera space\n\t\t_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero\n\n\n\t\tif (sin !== undefined) {\n\t\t\t_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n\t\t\t_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n\t\t} else {\n\t\t\t_rotatedPosition.copy(_alignedPosition);\n\t\t}\n\n\t\tvertexPosition.copy(mvPosition);\n\t\tvertexPosition.x += _rotatedPosition.x;\n\t\tvertexPosition.y += _rotatedPosition.y; // transform to world space\n\n\t\tvertexPosition.applyMatrix4(_viewWorldMatrix);\n\t}\n\n\tconst _v1$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$1 = /*@__PURE__*/new Vector3();\n\n\tclass LOD extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis._currentLevel = 0;\n\t\t\tthis.type = 'LOD';\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t},\n\t\t\t\tisLOD: {\n\t\t\t\t\tvalue: true\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.autoUpdate = true;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source, false);\n\t\t\tconst levels = source.levels;\n\n\t\t\tfor (let i = 0, l = levels.length; i < l; i++) {\n\t\t\t\tconst level = levels[i];\n\t\t\t\tthis.addLevel(level.object.clone(), level.distance);\n\t\t\t}\n\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\treturn this;\n\t\t}\n\n\t\taddLevel(object, distance = 0) {\n\t\t\tdistance = Math.abs(distance);\n\t\t\tconst levels = this.levels;\n\t\t\tlet l;\n\n\t\t\tfor (l = 0; l < levels.length; l++) {\n\t\t\t\tif (distance < levels[l].distance) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlevels.splice(l, 0, {\n\t\t\t\tdistance: distance,\n\t\t\t\tobject: object\n\t\t\t});\n\t\t\tthis.add(object);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetCurrentLevel() {\n\t\t\treturn this._currentLevel;\n\t\t}\n\n\t\tgetObjectForDistance(distance) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 0) {\n\t\t\t\tlet i, l;\n\n\t\t\t\tfor (i = 1, l = levels.length; i < l; i++) {\n\t\t\t\t\tif (distance < levels[i].distance) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn levels[i - 1].object;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 0) {\n\t\t\t\t_v1$2.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(_v1$2);\n\t\t\t\tthis.getObjectForDistance(distance).raycast(raycaster, intersects);\n\t\t\t}\n\t\t}\n\n\t\tupdate(camera) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 1) {\n\t\t\t\t_v1$2.setFromMatrixPosition(camera.matrixWorld);\n\n\t\t\t\t_v2$1.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\tconst distance = _v1$2.distanceTo(_v2$1) / camera.zoom;\n\t\t\t\tlevels[0].object.visible = true;\n\t\t\t\tlet i, l;\n\n\t\t\t\tfor (i = 1, l = levels.length; i < l; i++) {\n\t\t\t\t\tif (distance >= levels[i].distance) {\n\t\t\t\t\t\tlevels[i - 1].object.visible = false;\n\t\t\t\t\t\tlevels[i].object.visible = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._currentLevel = i - 1;\n\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tlevels[i].object.visible = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tif (this.autoUpdate === false) data.object.autoUpdate = false;\n\t\t\tdata.object.levels = [];\n\t\t\tconst levels = this.levels;\n\n\t\t\tfor (let i = 0, l = levels.length; i < l; i++) {\n\t\t\t\tconst level = levels[i];\n\t\t\t\tdata.object.levels.push({\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tconst _basePosition = /*@__PURE__*/new Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/new Vector4();\n\n\tconst _skinWeight = /*@__PURE__*/new Vector4();\n\n\tconst _vector$5 = /*@__PURE__*/new Vector3();\n\n\tconst _matrix = /*@__PURE__*/new Matrix4();\n\n\tclass SkinnedMesh extends Mesh {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'SkinnedMesh';\n\t\t\tthis.bindMode = 'attached';\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.bindMode = source.bindMode;\n\t\t\tthis.bindMatrix.copy(source.bindMatrix);\n\t\t\tthis.bindMatrixInverse.copy(source.bindMatrixInverse);\n\t\t\tthis.skeleton = source.skeleton;\n\t\t\treturn this;\n\t\t}\n\n\t\tbind(skeleton, bindMatrix) {\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif (bindMatrix === undefined) {\n\t\t\t\tthis.updateMatrixWorld(true);\n\t\t\t\tthis.skeleton.calculateInverses();\n\t\t\t\tbindMatrix = this.matrixWorld;\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy(bindMatrix);\n\t\t\tthis.bindMatrixInverse.copy(bindMatrix).invert();\n\t\t}\n\n\t\tpose() {\n\t\t\tthis.skeleton.pose();\n\t\t}\n\n\t\tnormalizeSkinWeights() {\n\t\t\tconst vector = new Vector4();\n\t\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor (let i = 0, l = skinWeight.count; i < l; i++) {\n\t\t\t\tvector.x = skinWeight.getX(i);\n\t\t\t\tvector.y = skinWeight.getY(i);\n\t\t\t\tvector.z = skinWeight.getZ(i);\n\t\t\t\tvector.w = skinWeight.getW(i);\n\t\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\t\tif (scale !== Infinity) {\n\t\t\t\t\tvector.multiplyScalar(scale);\n\t\t\t\t} else {\n\t\t\t\t\tvector.set(1, 0, 0, 0); // do something reasonable\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n\t\t\t}\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\n\t\t\tif (this.bindMode === 'attached') {\n\t\t\t\tthis.bindMatrixInverse.copy(this.matrixWorld).invert();\n\t\t\t} else if (this.bindMode === 'detached') {\n\t\t\t\tthis.bindMatrixInverse.copy(this.bindMatrix).invert();\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n\t\t\t}\n\t\t}\n\n\t\tboneTransform(index, target) {\n\t\t\tconst skeleton = this.skeleton;\n\t\t\tconst geometry = this.geometry;\n\n\t\t\t_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n\t\t\t_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n\t\t\t_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);\n\n\t\t\ttarget.set(0, 0, 0);\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tconst weight = _skinWeight.getComponent(i);\n\n\t\t\t\tif (weight !== 0) {\n\t\t\t\t\tconst boneIndex = _skinIndex.getComponent(i);\n\n\t\t\t\t\t_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n\t\t\t\t\ttarget.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn target.applyMatrix4(this.bindMatrixInverse);\n\t\t}\n\n\t}\n\n\tSkinnedMesh.prototype.isSkinnedMesh = true;\n\n\tclass Bone extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Bone';\n\t\t}\n\n\t}\n\n\tBone.prototype.isBone = true;\n\n\tclass DataTexture extends Texture {\n\t\tconstructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n\t\t\tthis.image = {\n\t\t\t\tdata: data || null,\n\t\t\t\twidth: width || 1,\n\t\t\t\theight: height || 1\n\t\t\t};\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\tconst _offsetMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _identityMatrix = /*@__PURE__*/new Matrix4();\n\n\tclass Skeleton {\n\t\tconstructor(bones = [], boneInverses = []) {\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.bones = bones.slice(0);\n\t\t\tthis.boneInverses = boneInverses;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.boneTexture = null;\n\t\t\tthis.boneTextureSize = 0;\n\t\t\tthis.frame = -1;\n\t\t\tthis.init();\n\t\t}\n\n\t\tinit() {\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\t\t\tthis.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n\t\t\tif (boneInverses.length === 0) {\n\t\t\t\tthis.calculateInverses();\n\t\t\t} else {\n\t\t\t\t// handle special case\n\t\t\t\tif (bones.length !== boneInverses.length) {\n\t\t\t\t\tconsole.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n\t\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\t\t\tthis.boneInverses.push(new Matrix4());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalculateInverses() {\n\t\t\tthis.boneInverses.length = 0;\n\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst inverse = new Matrix4();\n\n\t\t\t\tif (this.bones[i]) {\n\t\t\t\t\tinverse.copy(this.bones[i].matrixWorld).invert();\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push(inverse);\n\t\t\t}\n\t\t}\n\n\t\tpose() {\n\t\t\t// recover the bind-time world matrices\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone) {\n\t\t\t\t\tbone.matrixWorld.copy(this.boneInverses[i]).invert();\n\t\t\t\t}\n\t\t\t} // compute the local matrices, positions, rotations and scales\n\n\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone) {\n\t\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\t\tbone.matrix.copy(bone.parent.matrixWorld).invert();\n\t\t\t\t\t\tbone.matrix.multiply(bone.matrixWorld);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbone.matrix.copy(bone.matrixWorld);\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\t\t\tconst boneMatrices = this.boneMatrices;\n\t\t\tconst boneTexture = this.boneTexture; // flatten bone matrices to array\n\n\t\t\tfor (let i = 0, il = bones.length; i < il; i++) {\n\t\t\t\t// compute the offset between the current and the original transform\n\t\t\t\tconst matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n\t\t\t\t_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n\t\t\t\t_offsetMatrix.toArray(boneMatrices, i * 16);\n\t\t\t}\n\n\t\t\tif (boneTexture !== null) {\n\t\t\t\tboneTexture.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Skeleton(this.bones, this.boneInverses);\n\t\t}\n\n\t\tcomputeBoneTexture() {\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\t\t\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//\twith\t8x8\tpixel texture max\t 16 bones * 4 pixels =\t(8 * 8)\n\t\t\t//\t\t\t 16x16 pixel texture max\t 64 bones * 4 pixels = (16 * 16)\n\t\t\t//\t\t\t 32x32 pixel texture max\t256 bones * 4 pixels = (32 * 32)\n\t\t\t//\t\t\t 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\t\tlet size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n\t\t\tsize = ceilPowerOfTwo(size);\n\t\t\tsize = Math.max(size, 4);\n\t\t\tconst boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n\t\t\tboneMatrices.set(this.boneMatrices); // copy current values\n\n\t\t\tconst boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n\t\t\tthis.boneMatrices = boneMatrices;\n\t\t\tthis.boneTexture = boneTexture;\n\t\t\tthis.boneTextureSize = size;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetBoneByName(name) {\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone.name === name) {\n\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tdispose() {\n\t\t\tif (this.boneTexture !== null) {\n\t\t\t\tthis.boneTexture.dispose();\n\t\t\t\tthis.boneTexture = null;\n\t\t\t}\n\t\t}\n\n\t\tfromJSON(json, bones) {\n\t\t\tthis.uuid = json.uuid;\n\n\t\t\tfor (let i = 0, l = json.bones.length; i < l; i++) {\n\t\t\t\tconst uuid = json.bones[i];\n\t\t\t\tlet bone = bones[uuid];\n\n\t\t\t\tif (bone === undefined) {\n\t\t\t\t\tconsole.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n\t\t\t\t\tbone = new Bone();\n\t\t\t\t}\n\n\t\t\t\tthis.bones.push(bone);\n\t\t\t\tthis.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n\t\t\t}\n\n\t\t\tthis.init();\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Skeleton',\n\t\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t\t},\n\t\t\t\tbones: [],\n\t\t\t\tboneInverses: []\n\t\t\t};\n\t\t\tdata.uuid = this.uuid;\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\n\t\t\tfor (let i = 0, l = bones.length; i < l; i++) {\n\t\t\t\tconst bone = bones[i];\n\t\t\t\tdata.bones.push(bone.uuid);\n\t\t\t\tconst boneInverse = boneInverses[i];\n\t\t\t\tdata.boneInverses.push(boneInverse.toArray());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _instanceIntersects = [];\n\n\tconst _mesh = /*@__PURE__*/new Mesh();\n\n\tclass InstancedMesh extends Mesh {\n\t\tconstructor(geometry, material, count) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n\t\t\tthis.instanceColor = null;\n\t\t\tthis.count = count;\n\t\t\tthis.frustumCulled = false;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.instanceMatrix.copy(source.instanceMatrix);\n\t\t\tif (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n\t\t\tthis.count = source.count;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetColorAt(index, color) {\n\t\t\tcolor.fromArray(this.instanceColor.array, index * 3);\n\t\t}\n\n\t\tgetMatrixAt(index, matrix) {\n\t\t\tmatrix.fromArray(this.instanceMatrix.array, index * 16);\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst raycastTimes = this.count;\n\t\t\t_mesh.geometry = this.geometry;\n\t\t\t_mesh.material = this.material;\n\t\t\tif (_mesh.material === undefined) return;\n\n\t\t\tfor (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n\t\t\t\t// calculate the world matrix for each instance\n\t\t\t\tthis.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n\t\t\t\t_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n\t\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t\t_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n\t\t\t\tfor (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n\t\t\t\t\tconst intersect = _instanceIntersects[i];\n\t\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\t\tintersect.object = this;\n\t\t\t\t\tintersects.push(intersect);\n\t\t\t\t}\n\n\t\t\t\t_instanceIntersects.length = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetColorAt(index, color) {\n\t\t\tif (this.instanceColor === null) {\n\t\t\t\tthis.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);\n\t\t\t}\n\n\t\t\tcolor.toArray(this.instanceColor.array, index * 3);\n\t\t}\n\n\t\tsetMatrixAt(index, matrix) {\n\t\t\tmatrix.toArray(this.instanceMatrix.array, index * 16);\n\t\t}\n\n\t\tupdateMorphTargets() {}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tInstancedMesh.prototype.isInstancedMesh = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tlinewidth: <float>,\n\t *\tlinecap: \"round\",\n\t *\tlinejoin: \"round\"\n\t * }\n\t */\n\n\tclass LineBasicMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tconst _start$1 = /*@__PURE__*/new Vector3();\n\n\tconst _end$1 = /*@__PURE__*/new Vector3();\n\n\tconst _inverseMatrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _ray$1 = /*@__PURE__*/new Ray();\n\n\tconst _sphere$1 = /*@__PURE__*/new Sphere();\n\n\tclass Line extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Line';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\tcomputeLineDistances() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\t// we assume non-indexed geometry\n\t\t\t\tif (geometry.index === null) {\n\t\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\t\tconst lineDistances = [0];\n\n\t\t\t\t\tfor (let i = 1, l = positionAttribute.count; i < l; i++) {\n\t\t\t\t\t\t_start$1.fromBufferAttribute(positionAttribute, i - 1);\n\n\t\t\t\t\t\t_end$1.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\tlineDistances[i] = lineDistances[i - 1];\n\t\t\t\t\t\tlineDistances[i] += _start$1.distanceTo(_end$1);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst threshold = raycaster.params.Line.threshold;\n\t\t\tconst drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$1.copy(geometry.boundingSphere);\n\n\t\t\t_sphere$1.applyMatrix4(matrixWorld);\n\n\t\t\t_sphere$1.radius += threshold;\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //\n\n\t\t\t_inverseMatrix$1.copy(matrixWorld).invert();\n\n\t\t\t_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n\n\t\t\tconst localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n\t\t\tconst localThresholdSq = localThreshold * localThreshold;\n\t\t\tconst vStart = new Vector3();\n\t\t\tconst vEnd = new Vector3();\n\t\t\tconst interSegment = new Vector3();\n\t\t\tconst interRay = new Vector3();\n\t\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end - 1; i < l; i += step) {\n\t\t\t\t\t\tconst a = index.getX(i);\n\t\t\t\t\t\tconst b = index.getX(i + 1);\n\t\t\t\t\t\tvStart.fromBufferAttribute(positionAttribute, a);\n\t\t\t\t\t\tvEnd.fromBufferAttribute(positionAttribute, b);\n\n\t\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n\t\t\t\t\t\tif (distSq > localThresholdSq) continue;\n\t\t\t\t\t\tinterRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(interRay);\n\t\t\t\t\t\tif (distance < raycaster.near || distance > raycaster.far) continue;\n\t\t\t\t\t\tintersects.push({\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4(this.matrixWorld),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end - 1; i < l; i += step) {\n\t\t\t\t\t\tvStart.fromBufferAttribute(positionAttribute, i);\n\t\t\t\t\t\tvEnd.fromBufferAttribute(positionAttribute, i + 1);\n\n\t\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n\t\t\t\t\t\tif (distSq > localThresholdSq) continue;\n\t\t\t\t\t\tinterRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(interRay);\n\t\t\t\t\t\tif (distance < raycaster.near || distance > raycaster.far) continue;\n\t\t\t\t\t\tintersects.push({\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4(this.matrixWorld),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tLine.prototype.isLine = true;\n\n\tconst _start = /*@__PURE__*/new Vector3();\n\n\tconst _end = /*@__PURE__*/new Vector3();\n\n\tclass LineSegments extends Line {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'LineSegments';\n\t\t}\n\n\t\tcomputeLineDistances() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\t// we assume non-indexed geometry\n\t\t\t\tif (geometry.index === null) {\n\t\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\t\tconst lineDistances = [];\n\n\t\t\t\t\tfor (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n\t\t\t\t\t\t_start.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\t_end.fromBufferAttribute(positionAttribute, i + 1);\n\n\t\t\t\t\t\tlineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n\t\t\t\t\t\tlineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineSegments.prototype.isLineSegments = true;\n\n\tclass LineLoop extends Line {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'LineLoop';\n\t\t}\n\n\t}\n\n\tLineLoop.prototype.isLineLoop = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tsize: <float>,\n\t *\tsizeAttenuation: <bool>\n\t *\n\t *\tmorphTargets: <bool>\n\t * }\n\t */\n\n\tclass PointsMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PointsMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _ray = /*@__PURE__*/new Ray();\n\n\tconst _sphere = /*@__PURE__*/new Sphere();\n\n\tconst _position$2 = /*@__PURE__*/new Vector3();\n\n\tclass Points extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Points';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst threshold = raycaster.params.Points.threshold;\n\t\t\tconst drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy(geometry.boundingSphere);\n\n\t\t\t_sphere.applyMatrix4(matrixWorld);\n\n\t\t\t_sphere.radius += threshold;\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n\t\t\t_inverseMatrix.copy(matrixWorld).invert();\n\n\t\t\t_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n\t\t\tconst localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n\t\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, il = end; i < il; i++) {\n\t\t\t\t\t\tconst a = index.getX(i);\n\n\t\t\t\t\t\t_position$2.fromBufferAttribute(positionAttribute, a);\n\n\t\t\t\t\t\ttestPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end; i < l; i++) {\n\t\t\t\t\t\t_position$2.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\ttestPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tPoints.prototype.isPoints = true;\n\n\tfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n\t\tconst rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n\t\tif (rayPointDistanceSq < localThresholdSq) {\n\t\t\tconst intersectPoint = new Vector3();\n\n\t\t\t_ray.closestPointToPoint(point, intersectPoint);\n\n\t\t\tintersectPoint.applyMatrix4(matrixWorld);\n\t\t\tconst distance = raycaster.ray.origin.distanceTo(intersectPoint);\n\t\t\tif (distance < raycaster.near || distance > raycaster.far) return;\n\t\t\tintersects.push({\n\t\t\t\tdistance: distance,\n\t\t\t\tdistanceToRay: Math.sqrt(rayPointDistanceSq),\n\t\t\t\tpoint: intersectPoint,\n\t\t\t\tindex: index,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\t\t\t});\n\t\t}\n\t}\n\n\tclass VideoTexture extends Texture {\n\t\tconstructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n\t\t\tsuper(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.format = format !== undefined ? format : RGBFormat;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tconst scope = this;\n\n\t\t\tfunction updateVideo() {\n\t\t\t\tscope.needsUpdate = true;\n\t\t\t\tvideo.requestVideoFrameCallback(updateVideo);\n\t\t\t}\n\n\t\t\tif ('requestVideoFrameCallback' in video) {\n\t\t\t\tvideo.requestVideoFrameCallback(updateVideo);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.image).copy(this);\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst video = this.image;\n\t\t\tconst hasVideoFrameCallback = ('requestVideoFrameCallback' in video);\n\n\t\t\tif (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tVideoTexture.prototype.isVideoTexture = true;\n\n\tclass CompressedTexture extends Texture {\n\t\tconstructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n\t\t\tthis.image = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t\tthis.mipmaps = mipmaps; // no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\n\t\t\tthis.flipY = false; // can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\n\t\t\tthis.generateMipmaps = false;\n\t\t}\n\n\t}\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\tclass CanvasTexture extends Texture {\n\t\tconstructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n\t\t\tsuper(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tCanvasTexture.prototype.isCanvasTexture = true;\n\n\tclass DepthTexture extends Texture {\n\t\tconstructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\t\tif (format !== DepthFormat && format !== DepthStencilFormat) {\n\t\t\t\tthrow new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\n\t\t\t}\n\n\t\t\tif (type === undefined && format === DepthFormat) type = UnsignedShortType;\n\t\t\tif (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.image = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps = false;\n\t\t}\n\n\t}\n\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\tclass CircleGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CircleGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tsegments = Math.max(3, segments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // center point\n\n\t\t\tvertices.push(0, 0, 0);\n\t\t\tnormals.push(0, 0, 1);\n\t\t\tuvs.push(0.5, 0.5);\n\n\t\t\tfor (let s = 0, i = 3; s <= segments; s++, i += 3) {\n\t\t\t\tconst segment = thetaStart + s / segments * thetaLength; // vertex\n\n\t\t\t\tvertex.x = radius * Math.cos(segment);\n\t\t\t\tvertex.y = radius * Math.sin(segment);\n\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\tnormals.push(0, 0, 1); // uvs\n\n\t\t\t\tuv.x = (vertices[i] / radius + 1) / 2;\n\t\t\t\tuv.y = (vertices[i + 1] / radius + 1) / 2;\n\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t} // indices\n\n\n\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\tindices.push(i, i + 1, 0);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass CylinderGeometry extends BufferGeometry {\n\t\tconstructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CylinderGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tconst scope = this;\n\t\t\tradialSegments = Math.floor(radialSegments);\n\t\t\theightSegments = Math.floor(heightSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet index = 0;\n\t\t\tconst indexArray = [];\n\t\t\tconst halfHeight = height / 2;\n\t\t\tlet groupStart = 0; // generate geometry\n\n\t\t\tgenerateTorso();\n\n\t\t\tif (openEnded === false) {\n\t\t\t\tif (radiusTop > 0) generateCap(true);\n\t\t\t\tif (radiusBottom > 0) generateCap(false);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\tfunction generateTorso() {\n\t\t\t\tconst normal = new Vector3();\n\t\t\t\tconst vertex = new Vector3();\n\t\t\t\tlet groupCount = 0; // this will be used to calculate the normal\n\n\t\t\t\tconst slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n\t\t\t\tfor (let y = 0; y <= heightSegments; y++) {\n\t\t\t\t\tconst indexRow = [];\n\t\t\t\t\tconst v = y / heightSegments; // calculate the radius of the current row\n\n\t\t\t\t\tconst radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n\t\t\t\t\tfor (let x = 0; x <= radialSegments; x++) {\n\t\t\t\t\t\tconst u = x / radialSegments;\n\t\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\t\t\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\t\t\tconst cosTheta = Math.cos(theta); // vertex\n\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = -v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\t\tnormal.set(sinTheta, slope, cosTheta).normalize();\n\t\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\t\tuvs.push(u, 1 - v); // save index of vertex in respective row\n\n\t\t\t\t\t\tindexRow.push(index++);\n\t\t\t\t\t} // now save vertices of the row in our index array\n\n\n\t\t\t\t\tindexArray.push(indexRow);\n\t\t\t\t} // generate indices\n\n\n\t\t\t\tfor (let x = 0; x < radialSegments; x++) {\n\t\t\t\t\tfor (let y = 0; y < heightSegments; y++) {\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\t\tconst a = indexArray[y][x];\n\t\t\t\t\t\tconst b = indexArray[y + 1][x];\n\t\t\t\t\t\tconst c = indexArray[y + 1][x + 1];\n\t\t\t\t\t\tconst d = indexArray[y][x + 1]; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d); // update group counter\n\n\t\t\t\t\t\tgroupCount += 6;\n\t\t\t\t\t}\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t}\n\n\t\t\tfunction generateCap(top) {\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tconst centerIndexStart = index;\n\t\t\t\tconst uv = new Vector2();\n\t\t\t\tconst vertex = new Vector3();\n\t\t\t\tlet groupCount = 0;\n\t\t\t\tconst radius = top === true ? radiusTop : radiusBottom;\n\t\t\t\tconst sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\t\tfor (let x = 1; x <= radialSegments; x++) {\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.push(0, halfHeight * sign, 0); // normal\n\n\t\t\t\t\tnormals.push(0, sign, 0); // uv\n\n\t\t\t\t\tuvs.push(0.5, 0.5); // increase index\n\n\t\t\t\t\tindex++;\n\t\t\t\t} // save the index of the last center vertex\n\n\n\t\t\t\tconst centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n\t\t\t\tfor (let x = 0; x <= radialSegments; x++) {\n\t\t\t\t\tconst u = x / radialSegments;\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\t\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\t\tconst sinTheta = Math.sin(theta); // vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormals.push(0, sign, 0); // uv\n\n\t\t\t\t\tuv.x = cosTheta * 0.5 + 0.5;\n\t\t\t\t\tuv.y = sinTheta * 0.5 * sign + 0.5;\n\t\t\t\t\tuvs.push(uv.x, uv.y); // increase index\n\n\t\t\t\t\tindex++;\n\t\t\t\t} // generate indices\n\n\n\t\t\t\tfor (let x = 0; x < radialSegments; x++) {\n\t\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\t\tif (top === true) {\n\t\t\t\t\t\t// face top\n\t\t\t\t\t\tindices.push(i, i + 1, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// face bottom\n\t\t\t\t\t\tindices.push(i + 1, i, c);\n\t\t\t\t\t}\n\n\t\t\t\t\tgroupCount += 3;\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass ConeGeometry extends CylinderGeometry {\n\t\tconstructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\n\t\t\tthis.type = 'ConeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t}\n\n\t}\n\n\tclass PolyhedronGeometry extends BufferGeometry {\n\t\tconstructor(vertices, indices, radius = 1, detail = 0) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t}; // default buffer data\n\n\t\t\tconst vertexBuffer = [];\n\t\t\tconst uvBuffer = []; // the subdivision creates the vertex buffer data\n\n\t\t\tsubdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n\t\t\tapplyRadius(radius); // finally, create the uv data\n\n\t\t\tgenerateUVs(); // build non-indexed geometry\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n\t\t\tif (detail === 0) {\n\t\t\t\tthis.computeVertexNormals(); // flat normals\n\t\t\t} else {\n\t\t\t\tthis.normalizeNormals(); // smooth normals\n\t\t\t} // helper functions\n\n\n\t\t\tfunction subdivide(detail) {\n\t\t\t\tconst a = new Vector3();\n\t\t\t\tconst b = new Vector3();\n\t\t\t\tconst c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\t\tfor (let i = 0; i < indices.length; i += 3) {\n\t\t\t\t\t// get the vertices of the face\n\t\t\t\t\tgetVertexByIndex(indices[i + 0], a);\n\t\t\t\t\tgetVertexByIndex(indices[i + 1], b);\n\t\t\t\t\tgetVertexByIndex(indices[i + 2], c); // perform subdivision\n\n\t\t\t\t\tsubdivideFace(a, b, c, detail);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction subdivideFace(a, b, c, detail) {\n\t\t\t\tconst cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\t\tconst v = []; // construct all of the vertices for this subdivision\n\n\t\t\t\tfor (let i = 0; i <= cols; i++) {\n\t\t\t\t\tv[i] = [];\n\t\t\t\t\tconst aj = a.clone().lerp(c, i / cols);\n\t\t\t\t\tconst bj = b.clone().lerp(c, i / cols);\n\t\t\t\t\tconst rows = cols - i;\n\n\t\t\t\t\tfor (let j = 0; j <= rows; j++) {\n\t\t\t\t\t\tif (j === 0 && i === cols) {\n\t\t\t\t\t\t\tv[i][j] = aj;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv[i][j] = aj.clone().lerp(bj, j / rows);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // construct all of the faces\n\n\n\t\t\t\tfor (let i = 0; i < cols; i++) {\n\t\t\t\t\tfor (let j = 0; j < 2 * (cols - i) - 1; j++) {\n\t\t\t\t\t\tconst k = Math.floor(j / 2);\n\n\t\t\t\t\t\tif (j % 2 === 0) {\n\t\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\t\tpushVertex(v[i][k]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction applyRadius(radius) {\n\t\t\t\tconst vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\t\t\t\t\tvertex.normalize().multiplyScalar(radius);\n\t\t\t\t\tvertexBuffer[i + 0] = vertex.x;\n\t\t\t\t\tvertexBuffer[i + 1] = vertex.y;\n\t\t\t\t\tvertexBuffer[i + 2] = vertex.z;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateUVs() {\n\t\t\t\tconst vertex = new Vector3();\n\n\t\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\t\t\t\t\tconst u = azimuth(vertex) / 2 / Math.PI + 0.5;\n\t\t\t\t\tconst v = inclination(vertex) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push(u, 1 - v);\n\t\t\t\t}\n\n\t\t\t\tcorrectUVs();\n\t\t\t\tcorrectSeam();\n\t\t\t}\n\n\t\t\tfunction correctSeam() {\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\t\t\tfor (let i = 0; i < uvBuffer.length; i += 6) {\n\t\t\t\t\t// uv data of a single face\n\t\t\t\t\tconst x0 = uvBuffer[i + 0];\n\t\t\t\t\tconst x1 = uvBuffer[i + 2];\n\t\t\t\t\tconst x2 = uvBuffer[i + 4];\n\t\t\t\t\tconst max = Math.max(x0, x1, x2);\n\t\t\t\t\tconst min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n\t\t\t\t\tif (max > 0.9 && min < 0.1) {\n\t\t\t\t\t\tif (x0 < 0.2) uvBuffer[i + 0] += 1;\n\t\t\t\t\t\tif (x1 < 0.2) uvBuffer[i + 2] += 1;\n\t\t\t\t\t\tif (x2 < 0.2) uvBuffer[i + 4] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction pushVertex(vertex) {\n\t\t\t\tvertexBuffer.push(vertex.x, vertex.y, vertex.z);\n\t\t\t}\n\n\t\t\tfunction getVertexByIndex(index, vertex) {\n\t\t\t\tconst stride = index * 3;\n\t\t\t\tvertex.x = vertices[stride + 0];\n\t\t\t\tvertex.y = vertices[stride + 1];\n\t\t\t\tvertex.z = vertices[stride + 2];\n\t\t\t}\n\n\t\t\tfunction correctUVs() {\n\t\t\t\tconst a = new Vector3();\n\t\t\t\tconst b = new Vector3();\n\t\t\t\tconst c = new Vector3();\n\t\t\t\tconst centroid = new Vector3();\n\t\t\t\tconst uvA = new Vector2();\n\t\t\t\tconst uvB = new Vector2();\n\t\t\t\tconst uvC = new Vector2();\n\n\t\t\t\tfor (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n\t\t\t\t\ta.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n\t\t\t\t\tb.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n\t\t\t\t\tc.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n\t\t\t\t\tuvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n\t\t\t\t\tuvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n\t\t\t\t\tuvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n\t\t\t\t\tcentroid.copy(a).add(b).add(c).divideScalar(3);\n\t\t\t\t\tconst azi = azimuth(centroid);\n\t\t\t\t\tcorrectUV(uvA, j + 0, a, azi);\n\t\t\t\t\tcorrectUV(uvB, j + 2, b, azi);\n\t\t\t\t\tcorrectUV(uvC, j + 4, c, azi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction correctUV(uv, stride, vector, azimuth) {\n\t\t\t\tif (azimuth < 0 && uv.x === 1) {\n\t\t\t\t\tuvBuffer[stride] = uv.x - 1;\n\t\t\t\t}\n\n\t\t\t\tif (vector.x === 0 && vector.z === 0) {\n\t\t\t\t\tuvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n\t\t\t\t}\n\t\t\t} // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n\t\t\tfunction azimuth(vector) {\n\t\t\t\treturn Math.atan2(vector.z, -vector.x);\n\t\t\t} // Angle above the XZ plane.\n\n\n\t\t\tfunction inclination(vector) {\n\t\t\t\treturn Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass DodecahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\t\t\tconst r = 1 / t;\n\t\t\tconst vertices = [// (±1, ±1, ±1)\n\t\t\t-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)\n\t\t\t0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)\n\t\t\t-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)\n\t\t\t-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];\n\t\t\tconst indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\tconst _v0 = new Vector3();\n\n\tconst _v1$1 = new Vector3();\n\n\tconst _normal = new Vector3();\n\n\tconst _triangle = new Triangle();\n\n\tclass EdgesGeometry extends BufferGeometry {\n\t\tconstructor(geometry, thresholdAngle) {\n\t\t\tsuper();\n\t\t\tthis.type = 'EdgesGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tthresholdAngle: thresholdAngle\n\t\t\t};\n\t\t\tthresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;\n\n\t\t\tif (geometry.isGeometry === true) {\n\t\t\t\tconsole.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow(10, precisionPoints);\n\t\t\tconst thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute('position');\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\t\t\tconst indexArr = [0, 0, 0];\n\t\t\tconst vertKeys = ['a', 'b', 'c'];\n\t\t\tconst hashes = new Array(3);\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\n\t\t\tfor (let i = 0; i < indexCount; i += 3) {\n\t\t\t\tif (indexAttr) {\n\t\t\t\t\tindexArr[0] = indexAttr.getX(i);\n\t\t\t\t\tindexArr[1] = indexAttr.getX(i + 1);\n\t\t\t\t\tindexArr[2] = indexAttr.getX(i + 2);\n\t\t\t\t} else {\n\t\t\t\t\tindexArr[0] = i;\n\t\t\t\t\tindexArr[1] = i + 1;\n\t\t\t\t\tindexArr[2] = i + 2;\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\tc\n\t\t\t\t} = _triangle;\n\t\t\t\ta.fromBufferAttribute(positionAttr, indexArr[0]);\n\t\t\t\tb.fromBufferAttribute(positionAttr, indexArr[1]);\n\t\t\t\tc.fromBufferAttribute(positionAttr, indexArr[2]);\n\n\t\t\t\t_triangle.getNormal(_normal); // create hashes for the edge from the vertices\n\n\n\t\t\t\thashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n\t\t\t\thashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n\t\t\t\thashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles\n\n\t\t\t\tif (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} // iterate over every edge\n\n\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = (j + 1) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[j];\n\t\t\t\t\tconst vecHash1 = hashes[jNext];\n\t\t\t\t\tconst v0 = _triangle[vertKeys[j]];\n\t\t\t\t\tconst v1 = _triangle[vertKeys[jNext]];\n\t\t\t\t\tconst hash = `${vecHash0}_${vecHash1}`;\n\t\t\t\t\tconst reverseHash = `${vecHash1}_${vecHash0}`;\n\n\t\t\t\t\tif (reverseHash in edgeData && edgeData[reverseHash]) {\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n\t\t\t\t\t\t\tvertices.push(v0.x, v0.y, v0.z);\n\t\t\t\t\t\t\tvertices.push(v1.x, v1.y, v1.z);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[reverseHash] = null;\n\t\t\t\t\t} else if (!(hash in edgeData)) {\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[hash] = {\n\t\t\t\t\t\t\tindex0: indexArr[j],\n\t\t\t\t\t\t\tindex1: indexArr[jNext],\n\t\t\t\t\t\t\tnormal: _normal.clone()\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // iterate over all remaining, unmatched edges and add them to the vertex array\n\n\n\t\t\tfor (const key in edgeData) {\n\t\t\t\tif (edgeData[key]) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tindex0,\n\t\t\t\t\t\tindex1\n\t\t\t\t\t} = edgeData[key];\n\n\t\t\t\t\t_v0.fromBufferAttribute(positionAttr, index0);\n\n\t\t\t\t\t_v1$1.fromBufferAttribute(positionAttr, index1);\n\n\t\t\t\t\tvertices.push(_v0.x, _v0.y, _v0.z);\n\t\t\t\t\tvertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t}\n\n\t}\n\n\t/**\n\t * Port from https://github.com/mapbox/earcut (v2.2.2)\n\t */\n\tconst Earcut = {\n\t\ttriangulate: function (data, holeIndices, dim) {\n\t\t\tdim = dim || 2;\n\t\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\t\tconst outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\t\t\tlet outerNode = linkedList(data, 0, outerLen, dim, true);\n\t\t\tconst triangles = [];\n\t\t\tif (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\t\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\t\t\tif (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n\t\t\tif (data.length > 80 * dim) {\n\t\t\t\tminX = maxX = data[0];\n\t\t\t\tminY = maxY = data[1];\n\n\t\t\t\tfor (let i = dim; i < outerLen; i += dim) {\n\t\t\t\t\tx = data[i];\n\t\t\t\t\ty = data[i + 1];\n\t\t\t\t\tif (x < minX) minX = x;\n\t\t\t\t\tif (y < minY) minY = y;\n\t\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\t} // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\n\t\t\t\tinvSize = Math.max(maxX - minX, maxY - minY);\n\t\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\t\t\t}\n\n\t\t\tearcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\t\t\treturn triangles;\n\t\t}\n\t}; // create a circular doubly linked list from polygon points in the specified winding order\n\n\tfunction linkedList(data, start, end, dim, clockwise) {\n\t\tlet i, last;\n\n\t\tif (clockwise === signedArea(data, start, end, dim) > 0) {\n\t\t\tfor (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n\t\t} else {\n\t\t\tfor (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n\t\t}\n\n\t\tif (last && equals(last, last.next)) {\n\t\t\tremoveNode(last);\n\t\t\tlast = last.next;\n\t\t}\n\n\t\treturn last;\n\t} // eliminate colinear or duplicate points\n\n\n\tfunction filterPoints(start, end) {\n\t\tif (!start) return start;\n\t\tif (!end) end = start;\n\t\tlet p = start,\n\t\t\t\tagain;\n\n\t\tdo {\n\t\t\tagain = false;\n\n\t\t\tif (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n\t\t\t\tremoveNode(p);\n\t\t\t\tp = end = p.prev;\n\t\t\t\tif (p === p.next) break;\n\t\t\t\tagain = true;\n\t\t\t} else {\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t} while (again || p !== end);\n\n\t\treturn end;\n\t} // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\n\tfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n\t\tif (!ear) return; // interlink polygon nodes in z-order\n\n\t\tif (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\t\tlet stop = ear,\n\t\t\t\tprev,\n\t\t\t\tnext; // iterate through ears, slicing them one by one\n\n\t\twhile (ear.prev !== ear.next) {\n\t\t\tprev = ear.prev;\n\t\t\tnext = ear.next;\n\n\t\t\tif (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n\t\t\t\t// cut off the triangle\n\t\t\t\ttriangles.push(prev.i / dim);\n\t\t\t\ttriangles.push(ear.i / dim);\n\t\t\t\ttriangles.push(next.i / dim);\n\t\t\t\tremoveNode(ear); // skipping the next vertex leads to less sliver triangles\n\n\t\t\t\tear = next.next;\n\t\t\t\tstop = next.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tear = next; // if we looped through the whole remaining polygon and can't find any more ears\n\n\t\t\tif (ear === stop) {\n\t\t\t\t// try filtering points and slicing again\n\t\t\t\tif (!pass) {\n\t\t\t\t\tearcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally\n\t\t\t\t} else if (pass === 1) {\n\t\t\t\t\tear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n\t\t\t\t\tearcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two\n\t\t\t\t} else if (pass === 2) {\n\t\t\t\t\tsplitEarcut(ear, triangles, dim, minX, minY, invSize);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // check whether a polygon node forms a valid ear with adjacent nodes\n\n\n\tfunction isEar(ear) {\n\t\tconst a = ear.prev,\n\t\t\t\t\tb = ear,\n\t\t\t\t\tc = ear.next;\n\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\t\t// now make sure we don't have other points inside the potential ear\n\n\t\tlet p = ear.next.next;\n\n\t\twhile (p !== ear.prev) {\n\t\t\tif (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction isEarHashed(ear, minX, minY, invSize) {\n\t\tconst a = ear.prev,\n\t\t\t\t\tb = ear,\n\t\t\t\t\tc = ear.next;\n\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\t\t// triangle bbox; min & max are calculated like this for speed\n\n\t\tconst minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n\t\t\t\t\tminTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n\t\t\t\t\tmaxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n\t\t\t\t\tmaxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;\n\n\t\tconst minZ = zOrder(minTX, minTY, minX, minY, invSize),\n\t\t\t\t\tmaxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\t\tlet p = ear.prevZ,\n\t\t\t\tn = ear.nextZ; // look for points inside the triangle in both directions\n\n\t\twhile (p && p.z >= minZ && n && n.z <= maxZ) {\n\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.prevZ;\n\t\t\tif (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n\t\t\tn = n.nextZ;\n\t\t} // look for remaining points in decreasing z-order\n\n\n\t\twhile (p && p.z >= minZ) {\n\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.prevZ;\n\t\t} // look for remaining points in increasing z-order\n\n\n\t\twhile (n && n.z <= maxZ) {\n\t\t\tif (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n\t\t\tn = n.nextZ;\n\t\t}\n\n\t\treturn true;\n\t} // go through all polygon nodes and cure small local self-intersections\n\n\n\tfunction cureLocalIntersections(start, triangles, dim) {\n\t\tlet p = start;\n\n\t\tdo {\n\t\t\tconst a = p.prev,\n\t\t\t\t\t\tb = p.next.next;\n\n\t\t\tif (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\t\t\t\ttriangles.push(a.i / dim);\n\t\t\t\ttriangles.push(p.i / dim);\n\t\t\t\ttriangles.push(b.i / dim); // remove two nodes involved\n\n\t\t\t\tremoveNode(p);\n\t\t\t\tremoveNode(p.next);\n\t\t\t\tp = start = b;\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\treturn filterPoints(p);\n\t} // try splitting polygon into two and triangulate them independently\n\n\n\tfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n\t\t// look for a valid diagonal that divides the polygon into two\n\t\tlet a = start;\n\n\t\tdo {\n\t\t\tlet b = a.next.next;\n\n\t\t\twhile (b !== a.prev) {\n\t\t\t\tif (a.i !== b.i && isValidDiagonal(a, b)) {\n\t\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\t\tlet c = splitPolygon(a, b); // filter colinear points around the cuts\n\n\t\t\t\t\ta = filterPoints(a, a.next);\n\t\t\t\t\tc = filterPoints(c, c.next); // run earcut on each half\n\n\t\t\t\t\tearcutLinked(a, triangles, dim, minX, minY, invSize);\n\t\t\t\t\tearcutLinked(c, triangles, dim, minX, minY, invSize);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tb = b.next;\n\t\t\t}\n\n\t\t\ta = a.next;\n\t\t} while (a !== start);\n\t} // link every hole into the outer loop, producing a single-ring polygon without holes\n\n\n\tfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n\t\tconst queue = [];\n\t\tlet i, len, start, end, list;\n\n\t\tfor (i = 0, len = holeIndices.length; i < len; i++) {\n\t\t\tstart = holeIndices[i] * dim;\n\t\t\tend = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n\t\t\tlist = linkedList(data, start, end, dim, false);\n\t\t\tif (list === list.next) list.steiner = true;\n\t\t\tqueue.push(getLeftmost(list));\n\t\t}\n\n\t\tqueue.sort(compareX); // process holes from left to right\n\n\t\tfor (i = 0; i < queue.length; i++) {\n\t\t\teliminateHole(queue[i], outerNode);\n\t\t\touterNode = filterPoints(outerNode, outerNode.next);\n\t\t}\n\n\t\treturn outerNode;\n\t}\n\n\tfunction compareX(a, b) {\n\t\treturn a.x - b.x;\n\t} // find a bridge between vertices that connects hole with an outer ring and and link it\n\n\n\tfunction eliminateHole(hole, outerNode) {\n\t\touterNode = findHoleBridge(hole, outerNode);\n\n\t\tif (outerNode) {\n\t\t\tconst b = splitPolygon(outerNode, hole); // filter collinear points around the cuts\n\n\t\t\tfilterPoints(outerNode, outerNode.next);\n\t\t\tfilterPoints(b, b.next);\n\t\t}\n\t} // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\n\tfunction findHoleBridge(hole, outerNode) {\n\t\tlet p = outerNode;\n\t\tconst hx = hole.x;\n\t\tconst hy = hole.y;\n\t\tlet qx = -Infinity,\n\t\t\t\tm; // find a segment intersected by a ray from the hole's leftmost point to the left;\n\t\t// segment's endpoint with lesser x will be potential connection point\n\n\t\tdo {\n\t\t\tif (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n\t\t\t\tconst x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n\t\t\t\tif (x <= hx && x > qx) {\n\t\t\t\t\tqx = x;\n\n\t\t\t\t\tif (x === hx) {\n\t\t\t\t\t\tif (hy === p.y) return p;\n\t\t\t\t\t\tif (hy === p.next.y) return p.next;\n\t\t\t\t\t}\n\n\t\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== outerNode);\n\n\t\tif (!m) return null;\n\t\tif (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\t\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t\t// if there are no points found, we have a valid connection;\n\t\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\t\tconst stop = m,\n\t\t\t\t\tmx = m.x,\n\t\t\t\t\tmy = m.y;\n\t\tlet tanMin = Infinity,\n\t\t\t\ttan;\n\t\tp = m;\n\n\t\tdo {\n\t\t\tif (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\t\t\t\ttan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n\t\t\t\tif (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n\t\t\t\t\tm = p;\n\t\t\t\t\ttanMin = tan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== stop);\n\n\t\treturn m;\n\t} // whether sector in vertex m contains sector in vertex p in the same coordinates\n\n\n\tfunction sectorContainsSector(m, p) {\n\t\treturn area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n\t} // interlink polygon nodes in z-order\n\n\n\tfunction indexCurve(start, minX, minY, invSize) {\n\t\tlet p = start;\n\n\t\tdo {\n\t\t\tif (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n\t\t\tp.prevZ = p.prev;\n\t\t\tp.nextZ = p.next;\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\tp.prevZ.nextZ = null;\n\t\tp.prevZ = null;\n\t\tsortLinked(p);\n\t} // Simon Tatham's linked list merge sort algorithm\n\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\n\tfunction sortLinked(list) {\n\t\tlet i,\n\t\t\t\tp,\n\t\t\t\tq,\n\t\t\t\te,\n\t\t\t\ttail,\n\t\t\t\tnumMerges,\n\t\t\t\tpSize,\n\t\t\t\tqSize,\n\t\t\t\tinSize = 1;\n\n\t\tdo {\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnumMerges = 0;\n\n\t\t\twhile (p) {\n\t\t\t\tnumMerges++;\n\t\t\t\tq = p;\n\t\t\t\tpSize = 0;\n\n\t\t\t\tfor (i = 0; i < inSize; i++) {\n\t\t\t\t\tpSize++;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tif (!q) break;\n\t\t\t\t}\n\n\t\t\t\tqSize = inSize;\n\n\t\t\t\twhile (pSize > 0 || qSize > 0 && q) {\n\t\t\t\t\tif (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\tpSize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\tqSize--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tail) tail.nextZ = e;else list = e;\n\t\t\t\t\te.prevZ = tail;\n\t\t\t\t\ttail = e;\n\t\t\t\t}\n\n\t\t\t\tp = q;\n\t\t\t}\n\n\t\t\ttail.nextZ = null;\n\t\t\tinSize *= 2;\n\t\t} while (numMerges > 1);\n\n\t\treturn list;\n\t} // z-order of a point given coords and inverse of the longer side of data bbox\n\n\n\tfunction zOrder(x, y, minX, minY, invSize) {\n\t\t// coords are transformed into non-negative 15-bit integer range\n\t\tx = 32767 * (x - minX) * invSize;\n\t\ty = 32767 * (y - minY) * invSize;\n\t\tx = (x | x << 8) & 0x00FF00FF;\n\t\tx = (x | x << 4) & 0x0F0F0F0F;\n\t\tx = (x | x << 2) & 0x33333333;\n\t\tx = (x | x << 1) & 0x55555555;\n\t\ty = (y | y << 8) & 0x00FF00FF;\n\t\ty = (y | y << 4) & 0x0F0F0F0F;\n\t\ty = (y | y << 2) & 0x33333333;\n\t\ty = (y | y << 1) & 0x55555555;\n\t\treturn x | y << 1;\n\t} // find the leftmost node of a polygon ring\n\n\n\tfunction getLeftmost(start) {\n\t\tlet p = start,\n\t\t\t\tleftmost = start;\n\n\t\tdo {\n\t\t\tif (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\treturn leftmost;\n\t} // check if a point lies within a convex triangle\n\n\n\tfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n\t\treturn (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n\t} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\n\tfunction isValidDiagonal(a, b) {\n\t\treturn a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges\n\t\tlocallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible\n\t\tarea(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n\t\tequals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n\t} // signed area of a triangle\n\n\n\tfunction area(p, q, r) {\n\t\treturn (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\t} // check if two points are equal\n\n\n\tfunction equals(p1, p2) {\n\t\treturn p1.x === p2.x && p1.y === p2.y;\n\t} // check if two segments intersect\n\n\n\tfunction intersects(p1, q1, p2, q2) {\n\t\tconst o1 = sign(area(p1, q1, p2));\n\t\tconst o2 = sign(area(p1, q1, q2));\n\t\tconst o3 = sign(area(p2, q2, p1));\n\t\tconst o4 = sign(area(p2, q2, q1));\n\t\tif (o1 !== o2 && o3 !== o4) return true; // general case\n\n\t\tif (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\n\t\tif (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\n\t\tif (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\n\t\tif (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\t\treturn false;\n\t} // for collinear points p, q, r, check if point q lies on segment pr\n\n\n\tfunction onSegment(p, q, r) {\n\t\treturn q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n\t}\n\n\tfunction sign(num) {\n\t\treturn num > 0 ? 1 : num < 0 ? -1 : 0;\n\t} // check if a polygon diagonal intersects any polygon segments\n\n\n\tfunction intersectsPolygon(a, b) {\n\t\tlet p = a;\n\n\t\tdo {\n\t\t\tif (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n\t\t\tp = p.next;\n\t\t} while (p !== a);\n\n\t\treturn false;\n\t} // check if a polygon diagonal is locally inside the polygon\n\n\n\tfunction locallyInside(a, b) {\n\t\treturn area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n\t} // check if the middle point of a polygon diagonal is inside the polygon\n\n\n\tfunction middleInside(a, b) {\n\t\tlet p = a,\n\t\t\t\tinside = false;\n\t\tconst px = (a.x + b.x) / 2,\n\t\t\t\t\tpy = (a.y + b.y) / 2;\n\n\t\tdo {\n\t\t\tif (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n\t\t\tp = p.next;\n\t\t} while (p !== a);\n\n\t\treturn inside;\n\t} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\n\tfunction splitPolygon(a, b) {\n\t\tconst a2 = new Node(a.i, a.x, a.y),\n\t\t\t\t\tb2 = new Node(b.i, b.x, b.y),\n\t\t\t\t\tan = a.next,\n\t\t\t\t\tbp = b.prev;\n\t\ta.next = b;\n\t\tb.prev = a;\n\t\ta2.next = an;\n\t\tan.prev = a2;\n\t\tb2.next = a2;\n\t\ta2.prev = b2;\n\t\tbp.next = b2;\n\t\tb2.prev = bp;\n\t\treturn b2;\n\t} // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\n\tfunction insertNode(i, x, y, last) {\n\t\tconst p = new Node(i, x, y);\n\n\t\tif (!last) {\n\t\t\tp.prev = p;\n\t\t\tp.next = p;\n\t\t} else {\n\t\t\tp.next = last.next;\n\t\t\tp.prev = last;\n\t\t\tlast.next.prev = p;\n\t\t\tlast.next = p;\n\t\t}\n\n\t\treturn p;\n\t}\n\n\tfunction removeNode(p) {\n\t\tp.next.prev = p.prev;\n\t\tp.prev.next = p.next;\n\t\tif (p.prevZ) p.prevZ.nextZ = p.nextZ;\n\t\tif (p.nextZ) p.nextZ.prevZ = p.prevZ;\n\t}\n\n\tfunction Node(i, x, y) {\n\t\t// vertex index in coordinates array\n\t\tthis.i = i; // vertex coordinates\n\n\t\tthis.x = x;\n\t\tthis.y = y; // previous and next vertex nodes in a polygon ring\n\n\t\tthis.prev = null;\n\t\tthis.next = null; // z-order curve value\n\n\t\tthis.z = null; // previous and next nodes in z-order\n\n\t\tthis.prevZ = null;\n\t\tthis.nextZ = null; // indicates whether this is a steiner point\n\n\t\tthis.steiner = false;\n\t}\n\n\tfunction signedArea(data, start, end, dim) {\n\t\tlet sum = 0;\n\n\t\tfor (let i = start, j = end - dim; i < end; i += dim) {\n\t\t\tsum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n\t\t\tj = i;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tclass ShapeUtils {\n\t\t// calculate area of the contour polygon\n\t\tstatic area(contour) {\n\t\t\tconst n = contour.length;\n\t\t\tlet a = 0.0;\n\n\t\t\tfor (let p = n - 1, q = 0; q < n; p = q++) {\n\t\t\t\ta += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\t\t}\n\n\t\tstatic isClockWise(pts) {\n\t\t\treturn ShapeUtils.area(pts) < 0;\n\t\t}\n\n\t\tstatic triangulateShape(contour, holes) {\n\t\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\n\t\t\tconst holeIndices = []; // array of hole indices\n\n\t\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\t\tremoveDupEndPts(contour);\n\t\t\taddContour(vertices, contour); //\n\n\t\t\tlet holeIndex = contour.length;\n\t\t\tholes.forEach(removeDupEndPts);\n\n\t\t\tfor (let i = 0; i < holes.length; i++) {\n\t\t\t\tholeIndices.push(holeIndex);\n\t\t\t\tholeIndex += holes[i].length;\n\t\t\t\taddContour(vertices, holes[i]);\n\t\t\t} //\n\n\n\t\t\tconst triangles = Earcut.triangulate(vertices, holeIndices); //\n\n\t\t\tfor (let i = 0; i < triangles.length; i += 3) {\n\t\t\t\tfaces.push(triangles.slice(i, i + 3));\n\t\t\t}\n\n\t\t\treturn faces;\n\t\t}\n\n\t}\n\n\tfunction removeDupEndPts(points) {\n\t\tconst l = points.length;\n\n\t\tif (l > 2 && points[l - 1].equals(points[0])) {\n\t\t\tpoints.pop();\n\t\t}\n\t}\n\n\tfunction addContour(vertices, contour) {\n\t\tfor (let i = 0; i < contour.length; i++) {\n\t\t\tvertices.push(contour[i].x);\n\t\t\tvertices.push(contour[i].y);\n\t\t}\n\t}\n\n\t/**\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves\n\t *\tsteps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *\tdepth: <float>, // Depth to extrude the shape\n\t *\n\t *\tbevelEnabled: <bool>, // turn on bevel\n\t *\tbevelThickness: <float>, // how deep into the original shape bevel goes\n\t *\tbevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n\t *\tbevelOffset: <float>, // how far from shape outline does bevel start\n\t *\tbevelSegments: <int>, // number of bevel layers\n\t *\n\t *\textrudePath: <THREE.Curve> // curve to extrude shape along\n\t *\n\t *\tUVGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t */\n\n\tclass ExtrudeGeometry extends BufferGeometry {\n\t\tconstructor(shapes, options) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t\tshapes = Array.isArray(shapes) ? shapes : [shapes];\n\t\t\tconst scope = this;\n\t\t\tconst verticesArray = [];\n\t\t\tconst uvArray = [];\n\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\taddShape(shape);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n\t\t\tthis.computeVertexNormals(); // functions\n\n\t\t\tfunction addShape(shape) {\n\t\t\t\tconst placeholder = []; // options\n\n\t\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\t\tlet depth = options.depth !== undefined ? options.depth : 100;\n\t\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\t\t\tconst extrudePath = options.extrudePath;\n\t\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n\t\t\t\tif (options.amount !== undefined) {\n\t\t\t\t\tconsole.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n\t\t\t\t\tdepth = options.amount;\n\t\t\t\t} //\n\n\n\t\t\t\tlet extrudePts,\n\t\t\t\t\t\textrudeByPath = false;\n\t\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\t\tif (extrudePath) {\n\t\t\t\t\textrudePts = extrudePath.getSpacedPoints(steps);\n\t\t\t\t\textrudeByPath = true;\n\t\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\t\t\t\t// SETUP TNB variables\n\t\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\t\tsplineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\t\tbinormal = new Vector3();\n\t\t\t\t\tnormal = new Vector3();\n\t\t\t\t\tposition2 = new Vector3();\n\t\t\t\t} // Safeguards if bevels are not enabled\n\n\n\t\t\t\tif (!bevelEnabled) {\n\t\t\t\t\tbevelSegments = 0;\n\t\t\t\t\tbevelThickness = 0;\n\t\t\t\t\tbevelSize = 0;\n\t\t\t\t\tbevelOffset = 0;\n\t\t\t\t} // Variables initialization\n\n\n\t\t\t\tconst shapePoints = shape.extractPoints(curveSegments);\n\t\t\t\tlet vertices = shapePoints.shape;\n\t\t\t\tconst holes = shapePoints.holes;\n\t\t\t\tconst reverse = !ShapeUtils.isClockWise(vertices);\n\n\t\t\t\tif (reverse) {\n\t\t\t\t\tvertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\n\t\t\t\t\t\tif (ShapeUtils.isClockWise(ahole)) {\n\t\t\t\t\t\t\tholes[h] = ahole.reverse();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape(vertices, holes);\n\t\t\t\t/* Vertices */\n\n\t\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\tvertices = vertices.concat(ahole);\n\t\t\t\t}\n\n\t\t\t\tfunction scalePt2(pt, vec, size) {\n\t\t\t\t\tif (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n\t\t\t\t\treturn vec.clone().multiplyScalar(size).add(pt);\n\t\t\t\t}\n\n\t\t\t\tconst vlen = vertices.length,\n\t\t\t\t\t\t\tflen = faces.length; // Find directions for point movement\n\n\t\t\t\tfunction getBevelVec(inPt, inPrev, inNext) {\n\t\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t\t//\t shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t\t//\n\t\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t\t//\tadjacent edges of inPt at a distance of 1 unit on the left side.\n\t\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\t\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\t\t\t\t\tconst v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n\t\t\t\t\tconst collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n\t\t\t\t\tif (Math.abs(collinear0) > Number.EPSILON) {\n\t\t\t\t\t\t// not collinear\n\t\t\t\t\t\t// length of vectors for normalizing\n\t\t\t\t\t\tconst v_prev_len = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\tconst v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n\t\t\t\t\t\tconst ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n\t\t\t\t\t\tconst ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n\t\t\t\t\t\tconst ptNextShift_x = inNext.x - v_next_y / v_next_len;\n\t\t\t\t\t\tconst ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n\t\t\t\t\t\tconst sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n\t\t\t\t\t\tv_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n\t\t\t\t\t\tv_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t\t//\tbut prevent crazy spikes\n\n\t\t\t\t\t\tconst v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n\t\t\t\t\t\tif (v_trans_lensq <= 2) {\n\t\t\t\t\t\t\treturn new Vector2(v_trans_x, v_trans_y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_trans_lensq / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// handle special case of collinear edges\n\t\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\t\tif (v_prev_x > Number.EPSILON) {\n\t\t\t\t\t\t\tif (v_next_x > Number.EPSILON) {\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (v_prev_x < -Number.EPSILON) {\n\t\t\t\t\t\t\t\tif (v_next_x < -Number.EPSILON) {\n\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (direction_eq) {\n\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\t\tv_trans_x = -v_prev_y;\n\t\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n\t\t\t\t}\n\n\t\t\t\tconst contourMovements = [];\n\n\t\t\t\tfor (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\tif (k === il) k = 0; //\t(j)---(i)---(k)\n\t\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\t\tcontourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n\t\t\t\t}\n\n\t\t\t\tconst holesMovements = [];\n\t\t\t\tlet oneHoleMovements,\n\t\t\t\t\t\tverticesMovements = contourMovements.concat();\n\n\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\toneHoleMovements = [];\n\n\t\t\t\t\tfor (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\t\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\t\tif (k === il) k = 0; //\t(j)---(i)---(k)\n\n\t\t\t\t\t\toneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n\t\t\t\t\t}\n\n\t\t\t\t\tholesMovements.push(oneHoleMovements);\n\t\t\t\t\tverticesMovements = verticesMovements.concat(oneHoleMovements);\n\t\t\t\t} // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n\t\t\t\tfor (let b = 0; b < bevelSegments; b++) {\n\t\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\tconst bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\t\t\t\t\tfor (let i = 0, il = contour.length; i < il; i++) {\n\t\t\t\t\t\tconst vert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t} // expand holes\n\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\tfor (let i = 0, il = ahole.length; i < il; i++) {\n\t\t\t\t\t\t\tconst vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\t\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst bs = bevelSize + bevelOffset; // Back facing vertices\n\n\t\t\t\tfor (let i = 0; i < vlen; i++) {\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\tv(vert.x, vert.y, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\t\t\t\t\tnormal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n\t\t\t\t\t\tbinormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n\t\t\t\t\t\tposition2.copy(extrudePts[0]).add(normal).add(binormal);\n\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t}\n\t\t\t\t} // Add stepped vertices...\n\t\t\t\t// Including front facing vertices\n\n\n\t\t\t\tfor (let s = 1; s <= steps; s++) {\n\t\t\t\t\tfor (let i = 0; i < vlen; i++) {\n\t\t\t\t\t\tconst vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\t\tv(vert.x, vert.y, depth / steps * s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\t\t\t\t\t\tnormal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n\t\t\t\t\t\t\tbinormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n\t\t\t\t\t\t\tposition2.copy(extrudePts[s]).add(normal).add(binormal);\n\t\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // Add bevel segments planes\n\t\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n\t\t\t\tfor (let b = bevelSegments - 1; b >= 0; b--) {\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\tconst bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\t\t\t\t\tfor (let i = 0, il = contour.length; i < il; i++) {\n\t\t\t\t\t\tconst vert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t} // expand holes\n\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\tfor (let i = 0, il = ahole.length; i < il; i++) {\n\t\t\t\t\t\t\tconst vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n\t\t\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tv(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Faces */\n\t\t\t\t// Top and bottom faces\n\n\n\t\t\t\tbuildLidFaces(); // Sides faces\n\n\t\t\t\tbuildSideFaces(); /////\tInternal functions\n\n\t\t\t\tfunction buildLidFaces() {\n\t\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\t\tif (bevelEnabled) {\n\t\t\t\t\t\tlet layer = 0; // steps + 1\n\n\t\t\t\t\t\tlet offset = vlen * layer; // Bottom faces\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[2] + offset, face[1] + offset, face[0] + offset);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\t\toffset = vlen * layer; // Top faces\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[0] + offset, face[1] + offset, face[2] + offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Bottom faces\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[2], face[1], face[0]);\n\t\t\t\t\t\t} // Top faces\n\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 0);\n\t\t\t\t} // Create faces for the z-sides of the shape\n\n\n\t\t\t\tfunction buildSideFaces() {\n\t\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\t\tlet layeroffset = 0;\n\t\t\t\t\tsidewalls(contour, layeroffset);\n\t\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\tsidewalls(ahole, layeroffset); //, true\n\n\t\t\t\t\t\tlayeroffset += ahole.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 1);\n\t\t\t\t}\n\n\t\t\t\tfunction sidewalls(contour, layeroffset) {\n\t\t\t\t\tlet i = contour.length;\n\n\t\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\t\tconst j = i;\n\t\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\t\tif (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\t\tfor (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n\t\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\t\tconst slen2 = vlen * (s + 1);\n\t\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\t\t\t\t\t\tf4(a, b, c, d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction v(x, y, z) {\n\t\t\t\t\tplaceholder.push(x);\n\t\t\t\t\tplaceholder.push(y);\n\t\t\t\t\tplaceholder.push(z);\n\t\t\t\t}\n\n\t\t\t\tfunction f3(a, b, c) {\n\t\t\t\t\taddVertex(a);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(c);\n\t\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\t\tconst uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t}\n\n\t\t\t\tfunction f4(a, b, c, d) {\n\t\t\t\t\taddVertex(a);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(d);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(c);\n\t\t\t\t\taddVertex(d);\n\t\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\t\tconst uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t}\n\n\t\t\t\tfunction addVertex(index) {\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 0]);\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 1]);\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 2]);\n\t\t\t\t}\n\n\t\t\t\tfunction addUV(vector2) {\n\t\t\t\t\tuvArray.push(vector2.x);\n\t\t\t\t\tuvArray.push(vector2.y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tconst shapes = this.parameters.shapes;\n\t\t\tconst options = this.parameters.options;\n\t\t\treturn toJSON$1(shapes, options, data);\n\t\t}\n\n\t}\n\n\tconst WorldUVGenerator = {\n\t\tgenerateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n\t\t\tconst a_x = vertices[indexA * 3];\n\t\t\tconst a_y = vertices[indexA * 3 + 1];\n\t\t\tconst b_x = vertices[indexB * 3];\n\t\t\tconst b_y = vertices[indexB * 3 + 1];\n\t\t\tconst c_x = vertices[indexC * 3];\n\t\t\tconst c_y = vertices[indexC * 3 + 1];\n\t\t\treturn [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n\t\t},\n\t\tgenerateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n\t\t\tconst a_x = vertices[indexA * 3];\n\t\t\tconst a_y = vertices[indexA * 3 + 1];\n\t\t\tconst a_z = vertices[indexA * 3 + 2];\n\t\t\tconst b_x = vertices[indexB * 3];\n\t\t\tconst b_y = vertices[indexB * 3 + 1];\n\t\t\tconst b_z = vertices[indexB * 3 + 2];\n\t\t\tconst c_x = vertices[indexC * 3];\n\t\t\tconst c_y = vertices[indexC * 3 + 1];\n\t\t\tconst c_z = vertices[indexC * 3 + 2];\n\t\t\tconst d_x = vertices[indexD * 3];\n\t\t\tconst d_y = vertices[indexD * 3 + 1];\n\t\t\tconst d_z = vertices[indexD * 3 + 2];\n\n\t\t\tif (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n\t\t\t\treturn [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n\t\t\t} else {\n\t\t\t\treturn [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction toJSON$1(shapes, options, data) {\n\t\tdata.shapes = [];\n\n\t\tif (Array.isArray(shapes)) {\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t}\n\t\t} else {\n\t\t\tdata.shapes.push(shapes.uuid);\n\t\t}\n\n\t\tif (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n\t\treturn data;\n\t}\n\n\tclass IcosahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\t\t\tconst vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];\n\t\t\tconst indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\tclass LatheGeometry extends BufferGeometry {\n\t\tconstructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LatheGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\t\tsegments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\t\tphiLength = clamp(phiLength, 0, Math.PI * 2); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst inverseSegments = 1.0 / segments;\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // generate vertices and uvs\n\n\t\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\t\t\t\tconst sin = Math.sin(phi);\n\t\t\t\tconst cos = Math.cos(phi);\n\n\t\t\t\tfor (let j = 0; j <= points.length - 1; j++) {\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = points[j].x * sin;\n\t\t\t\t\tvertex.y = points[j].y;\n\t\t\t\t\tvertex.z = points[j].x * cos;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / (points.length - 1);\n\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t}\n\t\t\t} // indices\n\n\n\t\t\tfor (let i = 0; i < segments; i++) {\n\t\t\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\t\t\tconst base = j + i * points.length;\n\t\t\t\t\tconst a = base;\n\t\t\t\t\tconst b = base + points.length;\n\t\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\t\tconst d = base + 1; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals\n\n\t\t\tthis.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\t\tif (phiLength === Math.PI * 2) {\n\t\t\t\tconst normals = this.attributes.normal.array;\n\t\t\t\tconst n1 = new Vector3();\n\t\t\t\tconst n2 = new Vector3();\n\t\t\t\tconst n = new Vector3(); // this is the buffer offset for the last line of vertices\n\n\t\t\t\tconst base = segments * points.length * 3;\n\n\t\t\t\tfor (let i = 0, j = 0; i < points.length; i++, j += 3) {\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\t\tn1.x = normals[j + 0];\n\t\t\t\t\tn1.y = normals[j + 1];\n\t\t\t\t\tn1.z = normals[j + 2]; // select the normal of the vertex in the last line\n\n\t\t\t\t\tn2.x = normals[base + j + 0];\n\t\t\t\t\tn2.y = normals[base + j + 1];\n\t\t\t\t\tn2.z = normals[base + j + 2]; // average normals\n\n\t\t\t\t\tn.addVectors(n1, n2).normalize(); // assign the new values to both normals\n\n\t\t\t\t\tnormals[j + 0] = normals[base + j + 0] = n.x;\n\t\t\t\t\tnormals[j + 1] = normals[base + j + 1] = n.y;\n\t\t\t\t\tnormals[j + 2] = normals[base + j + 2] = n.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass OctahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n\t\t\tconst indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n\t */\n\n\tclass ParametricGeometry extends BufferGeometry {\n\t\tconstructor(func, slices, stacks) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ParametricGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t}; // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\t\t\tconst EPS = 0.00001;\n\t\t\tconst normal = new Vector3();\n\t\t\tconst p0 = new Vector3(),\n\t\t\t\t\t\tp1 = new Vector3();\n\t\t\tconst pu = new Vector3(),\n\t\t\t\t\t\tpv = new Vector3();\n\n\t\t\tif (func.length < 3) {\n\t\t\t\tconsole.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');\n\t\t\t} // generate vertices, normals and uvs\n\n\n\t\t\tconst sliceCount = slices + 1;\n\n\t\t\tfor (let i = 0; i <= stacks; i++) {\n\t\t\t\tconst v = i / stacks;\n\n\t\t\t\tfor (let j = 0; j <= slices; j++) {\n\t\t\t\t\tconst u = j / slices; // vertex\n\n\t\t\t\t\tfunc(u, v, p0);\n\t\t\t\t\tvertices.push(p0.x, p0.y, p0.z); // normal\n\t\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\t\tif (u - EPS >= 0) {\n\t\t\t\t\t\tfunc(u - EPS, v, p1);\n\t\t\t\t\t\tpu.subVectors(p0, p1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc(u + EPS, v, p1);\n\t\t\t\t\t\tpu.subVectors(p1, p0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (v - EPS >= 0) {\n\t\t\t\t\t\tfunc(u, v - EPS, p1);\n\t\t\t\t\t\tpv.subVectors(p0, p1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc(u, v + EPS, p1);\n\t\t\t\t\t\tpv.subVectors(p1, p0);\n\t\t\t\t\t} // cross product of tangent vectors returns surface normal\n\n\n\t\t\t\t\tnormal.crossVectors(pu, pv).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(u, v);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let i = 0; i < stacks; i++) {\n\t\t\t\tfor (let j = 0; j < slices; j++) {\n\t\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\t\tconst c = (i + 1) * sliceCount + j + 1;\n\t\t\t\t\tconst d = (i + 1) * sliceCount + j; // faces one and two\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass RingGeometry extends BufferGeometry {\n\t\tconstructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'RingGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tthetaSegments = Math.max(3, thetaSegments);\n\t\t\tphiSegments = Math.max(1, phiSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // some helper variables\n\n\t\t\tlet radius = innerRadius;\n\t\t\tconst radiusStep = (outerRadius - innerRadius) / phiSegments;\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // generate vertices, normals and uvs\n\n\t\t\tfor (let j = 0; j <= phiSegments; j++) {\n\t\t\t\tfor (let i = 0; i <= thetaSegments; i++) {\n\t\t\t\t\t// values are generate from the inside of the ring to the outside\n\t\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength; // vertex\n\n\t\t\t\t\tvertex.x = radius * Math.cos(segment);\n\t\t\t\t\tvertex.y = radius * Math.sin(segment);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormals.push(0, 0, 1); // uv\n\n\t\t\t\t\tuv.x = (vertex.x / outerRadius + 1) / 2;\n\t\t\t\t\tuv.y = (vertex.y / outerRadius + 1) / 2;\n\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t} // increase the radius for next row of vertices\n\n\n\t\t\t\tradius += radiusStep;\n\t\t\t} // indices\n\n\n\t\t\tfor (let j = 0; j < phiSegments; j++) {\n\t\t\t\tconst thetaSegmentLevel = j * (thetaSegments + 1);\n\n\t\t\t\tfor (let i = 0; i < thetaSegments; i++) {\n\t\t\t\t\tconst segment = i + thetaSegmentLevel;\n\t\t\t\t\tconst a = segment;\n\t\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\t\tconst d = segment + 1; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass ShapeGeometry extends BufferGeometry {\n\t\tconstructor(shapes, curveSegments = 12) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShapeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\tcurveSegments: curveSegments\n\t\t\t}; // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet groupStart = 0;\n\t\t\tlet groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n\t\t\tif (Array.isArray(shapes) === false) {\n\t\t\t\taddShape(shapes);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\t\taddShape(shapes[i]);\n\t\t\t\t\tthis.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n\t\t\t\t\tgroupStart += groupCount;\n\t\t\t\t\tgroupCount = 0;\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n\t\t\tfunction addShape(shape) {\n\t\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\t\tconst points = shape.extractPoints(curveSegments);\n\t\t\t\tlet shapeVertices = points.shape;\n\t\t\t\tconst shapeHoles = points.holes; // check direction of vertices\n\n\t\t\t\tif (ShapeUtils.isClockWise(shapeVertices) === false) {\n\t\t\t\t\tshapeVertices = shapeVertices.reverse();\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0, l = shapeHoles.length; i < l; i++) {\n\t\t\t\t\tconst shapeHole = shapeHoles[i];\n\n\t\t\t\t\tif (ShapeUtils.isClockWise(shapeHole) === true) {\n\t\t\t\t\t\tshapeHoles[i] = shapeHole.reverse();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n\t\t\t\tfor (let i = 0, l = shapeHoles.length; i < l; i++) {\n\t\t\t\t\tconst shapeHole = shapeHoles[i];\n\t\t\t\t\tshapeVertices = shapeVertices.concat(shapeHole);\n\t\t\t\t} // vertices, normals, uvs\n\n\n\t\t\t\tfor (let i = 0, l = shapeVertices.length; i < l; i++) {\n\t\t\t\t\tconst vertex = shapeVertices[i];\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, 0);\n\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\tuvs.push(vertex.x, vertex.y); // world uvs\n\t\t\t\t} // incides\n\n\n\t\t\t\tfor (let i = 0, l = faces.length; i < l; i++) {\n\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\tconst a = face[0] + indexOffset;\n\t\t\t\t\tconst b = face[1] + indexOffset;\n\t\t\t\t\tconst c = face[2] + indexOffset;\n\t\t\t\t\tindices.push(a, b, c);\n\t\t\t\t\tgroupCount += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tconst shapes = this.parameters.shapes;\n\t\t\treturn toJSON(shapes, data);\n\t\t}\n\n\t}\n\n\tfunction toJSON(shapes, data) {\n\t\tdata.shapes = [];\n\n\t\tif (Array.isArray(shapes)) {\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t}\n\t\t} else {\n\t\t\tdata.shapes.push(shapes.uuid);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tclass SphereGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SphereGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\twidthSegments = Math.max(3, Math.floor(widthSegments));\n\t\t\theightSegments = Math.max(2, Math.floor(heightSegments));\n\t\t\tconst thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n\t\t\tlet index = 0;\n\t\t\tconst grid = [];\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3(); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // generate vertices, normals and uvs\n\n\t\t\tfor (let iy = 0; iy <= heightSegments; iy++) {\n\t\t\t\tconst verticesRow = [];\n\t\t\t\tconst v = iy / heightSegments; // special case for the poles\n\n\t\t\t\tlet uOffset = 0;\n\n\t\t\t\tif (iy == 0 && thetaStart == 0) {\n\t\t\t\t\tuOffset = 0.5 / widthSegments;\n\t\t\t\t} else if (iy == heightSegments && thetaEnd == Math.PI) {\n\t\t\t\t\tuOffset = -0.5 / widthSegments;\n\t\t\t\t}\n\n\t\t\t\tfor (let ix = 0; ix <= widthSegments; ix++) {\n\t\t\t\t\tconst u = ix / widthSegments; // vertex\n\n\t\t\t\t\tvertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\t\tvertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n\t\t\t\t\tvertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormal.copy(vertex).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(u + uOffset, 1 - v);\n\t\t\t\t\tverticesRow.push(index++);\n\t\t\t\t}\n\n\t\t\t\tgrid.push(verticesRow);\n\t\t\t} // indices\n\n\n\t\t\tfor (let iy = 0; iy < heightSegments; iy++) {\n\t\t\t\tfor (let ix = 0; ix < widthSegments; ix++) {\n\t\t\t\t\tconst a = grid[iy][ix + 1];\n\t\t\t\t\tconst b = grid[iy][ix];\n\t\t\t\t\tconst c = grid[iy + 1][ix];\n\t\t\t\t\tconst d = grid[iy + 1][ix + 1];\n\t\t\t\t\tif (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n\t\t\t\t\tif (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass TetrahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n\t\t\tconst indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *\tfont: <THREE.Font>, // font\n\t *\n\t *\tsize: <float>, // size of the text\n\t *\theight: <float>, // thickness to extrude text\n\t *\tcurveSegments: <int>, // number of points on the curves\n\t *\n\t *\tbevelEnabled: <bool>, // turn on bevel\n\t *\tbevelThickness: <float>, // how deep into text bevel goes\n\t *\tbevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n\t *\tbevelOffset: <float> // how far from text outline does bevel start\n\t * }\n\t */\n\n\tclass TextGeometry extends ExtrudeGeometry {\n\t\tconstructor(text, parameters = {}) {\n\t\t\tconst font = parameters.font;\n\n\t\t\tif (!(font && font.isFont)) {\n\t\t\t\tconsole.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');\n\t\t\t\treturn new BufferGeometry();\n\t\t\t}\n\n\t\t\tconst shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API\n\n\t\t\tparameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults\n\n\t\t\tif (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;\n\t\t\tif (parameters.bevelSize === undefined) parameters.bevelSize = 8;\n\t\t\tif (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;\n\t\t\tsuper(shapes, parameters);\n\t\t\tthis.type = 'TextGeometry';\n\t\t}\n\n\t}\n\n\tclass TorusGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TorusGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\t\tradialSegments = Math.floor(radialSegments);\n\t\t\ttubularSegments = Math.floor(tubularSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst center = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2; // vertex\n\n\t\t\t\t\tvertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n\t\t\t\t\tvertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n\t\t\t\t\tvertex.z = tube * Math.sin(v);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tcenter.x = radius * Math.cos(u);\n\t\t\t\t\tcenter.y = radius * Math.sin(u);\n\t\t\t\t\tnormal.subVectors(vertex, center).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(i / tubularSegments);\n\t\t\t\t\tuvs.push(j / radialSegments);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let j = 1; j <= radialSegments; j++) {\n\t\t\t\tfor (let i = 1; i <= tubularSegments; i++) {\n\t\t\t\t\t// indices\n\t\t\t\t\tconst a = (tubularSegments + 1) * j + i - 1;\n\t\t\t\t\tconst b = (tubularSegments + 1) * (j - 1) + i - 1;\n\t\t\t\t\tconst c = (tubularSegments + 1) * (j - 1) + i;\n\t\t\t\t\tconst d = (tubularSegments + 1) * j + i; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass TorusKnotGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\t\ttubularSegments = Math.floor(tubularSegments);\n\t\t\tradialSegments = Math.floor(radialSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\t\t\tconst P1 = new Vector3();\n\t\t\tconst P2 = new Vector3();\n\t\t\tconst B = new Vector3();\n\t\t\tconst T = new Vector3();\n\t\t\tconst N = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\tfor (let i = 0; i <= tubularSegments; ++i) {\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\t\t\tconst u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\t\tcalculatePositionOnCurve(u, p, q, radius, P1);\n\t\t\t\tcalculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n\t\t\t\tT.subVectors(P2, P1);\n\t\t\t\tN.addVectors(P2, P1);\n\t\t\t\tB.crossVectors(T, N);\n\t\t\t\tN.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it\n\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\n\t\t\t\tfor (let j = 0; j <= radialSegments; ++j) {\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tconst cx = -tube * Math.cos(v);\n\t\t\t\t\tconst cy = tube * Math.sin(v); // now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\t\tvertex.x = P1.x + (cx * N.x + cy * B.x);\n\t\t\t\t\tvertex.y = P1.y + (cx * N.y + cy * B.y);\n\t\t\t\t\tvertex.z = P1.z + (cx * N.z + cy * B.z);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\t\tnormal.subVectors(vertex, P1).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(i / tubularSegments);\n\t\t\t\t\tuvs.push(j / radialSegments);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let j = 1; j <= tubularSegments; j++) {\n\t\t\t\tfor (let i = 1; i <= radialSegments; i++) {\n\t\t\t\t\t// indices\n\t\t\t\t\tconst a = (radialSegments + 1) * (j - 1) + (i - 1);\n\t\t\t\t\tconst b = (radialSegments + 1) * j + (i - 1);\n\t\t\t\t\tconst c = (radialSegments + 1) * j + i;\n\t\t\t\t\tconst d = (radialSegments + 1) * (j - 1) + i; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n\t\t\tfunction calculatePositionOnCurve(u, p, q, radius, position) {\n\t\t\t\tconst cu = Math.cos(u);\n\t\t\t\tconst su = Math.sin(u);\n\t\t\t\tconst quOverP = q / p * u;\n\t\t\t\tconst cs = Math.cos(quOverP);\n\t\t\t\tposition.x = radius * (2 + cs) * 0.5 * cu;\n\t\t\t\tposition.y = radius * (2 + cs) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin(quOverP) * 0.5;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass TubeGeometry extends BufferGeometry {\n\t\tconstructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TubeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\t\tconst frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals\n\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\t\t\tconst uv = new Vector2();\n\t\t\tlet P = new Vector3(); // buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\t\t\tconst indices = []; // create buffer data\n\n\t\t\tgenerateBufferData(); // build geometry\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions\n\n\t\t\tfunction generateBufferData() {\n\t\t\t\tfor (let i = 0; i < tubularSegments; i++) {\n\t\t\t\t\tgenerateSegment(i);\n\t\t\t\t} // if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\n\t\t\t\tgenerateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\t\tgenerateUVs(); // finally create faces\n\n\t\t\t\tgenerateIndices();\n\t\t\t}\n\n\t\t\tfunction generateSegment(i) {\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\t\t\tP = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal\n\n\t\t\t\tconst N = frames.normals[i];\n\t\t\t\tconst B = frames.binormals[i]; // generate normals and vertices for the current segment\n\n\t\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tconst sin = Math.sin(v);\n\t\t\t\t\tconst cos = -Math.cos(v); // normal\n\n\t\t\t\t\tnormal.x = cos * N.x + sin * B.x;\n\t\t\t\t\tnormal.y = cos * N.y + sin * B.y;\n\t\t\t\t\tnormal.z = cos * N.z + sin * B.z;\n\t\t\t\t\tnormal.normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // vertex\n\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateIndices() {\n\t\t\t\tfor (let j = 1; j <= tubularSegments; j++) {\n\t\t\t\t\tfor (let i = 1; i <= radialSegments; i++) {\n\t\t\t\t\t\tconst a = (radialSegments + 1) * (j - 1) + (i - 1);\n\t\t\t\t\t\tconst b = (radialSegments + 1) * j + (i - 1);\n\t\t\t\t\t\tconst c = (radialSegments + 1) * j + i;\n\t\t\t\t\t\tconst d = (radialSegments + 1) * (j - 1) + i; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateUVs() {\n\t\t\t\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\t\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.path = this.parameters.path.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tclass WireframeGeometry extends BufferGeometry {\n\t\tconstructor(geometry) {\n\t\t\tsuper();\n\t\t\tthis.type = 'WireframeGeometry';\n\n\t\t\tif (geometry.isGeometry === true) {\n\t\t\t\tconsole.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\treturn;\n\t\t\t} // buffer\n\n\n\t\t\tconst vertices = []; // helper variables\n\n\t\t\tconst edge = [0, 0],\n\t\t\t\t\t\tedges = {};\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tif (geometry.index !== null) {\n\t\t\t\t// indexed BufferGeometry\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif (groups.length === 0) {\n\t\t\t\t\tgroups = [{\n\t\t\t\t\t\tstart: 0,\n\t\t\t\t\t\tcount: indices.count,\n\t\t\t\t\t\tmaterialIndex: 0\n\t\t\t\t\t}];\n\t\t\t\t} // create a data structure that contains all eges without duplicates\n\n\n\t\t\t\tfor (let o = 0, ol = groups.length; o < ol; ++o) {\n\t\t\t\t\tconst group = groups[o];\n\t\t\t\t\tconst start = group.start;\n\t\t\t\t\tconst count = group.count;\n\n\t\t\t\t\tfor (let i = start, l = start + count; i < l; i += 3) {\n\t\t\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t\t\tconst edge1 = indices.getX(i + j);\n\t\t\t\t\t\t\tconst edge2 = indices.getX(i + (j + 1) % 3);\n\t\t\t\t\t\t\tedge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\n\n\t\t\t\t\t\t\tedge[1] = Math.max(edge1, edge2);\n\t\t\t\t\t\t\tconst key = edge[0] + ',' + edge[1];\n\n\t\t\t\t\t\t\tif (edges[key] === undefined) {\n\t\t\t\t\t\t\t\tedges[key] = {\n\t\t\t\t\t\t\t\t\tindex1: edge[0],\n\t\t\t\t\t\t\t\t\tindex2: edge[1]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // generate vertices\n\n\n\t\t\t\tfor (const key in edges) {\n\t\t\t\t\tconst e = edges[key];\n\t\t\t\t\tvertex.fromBufferAttribute(position, e.index1);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\tvertex.fromBufferAttribute(position, e.index2);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// non-indexed BufferGeometry\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor (let i = 0, l = position.count / 3; i < l; i++) {\n\t\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tvertex.fromBufferAttribute(position, index1);\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\tconst index2 = 3 * i + (j + 1) % 3;\n\t\t\t\t\t\tvertex.fromBufferAttribute(position, index2);\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t}\n\n\t}\n\n\tvar Geometries = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tBoxGeometry: BoxGeometry,\n\t\tBoxBufferGeometry: BoxGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tCircleBufferGeometry: CircleGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tExtrudeBufferGeometry: ExtrudeGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tPlaneBufferGeometry: PlaneGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tShapeBufferGeometry: ShapeGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tSphereBufferGeometry: SphereGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tTextBufferGeometry: TextGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeGeometry,\n\t\tWireframeGeometry: WireframeGeometry\n\t});\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <THREE.Color>\n\t * }\n\t */\n\n\tclass ShadowMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShadowMaterial';\n\t\t\tthis.color = new Color(0x000000);\n\t\t\tthis.transparent = true;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\tclass RawShaderMaterial extends ShaderMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper(parameters);\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\t}\n\n\t}\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\troughness: <float>,\n\t *\tmetalness: <float>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\troughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmetalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tenvMapIntensity: <float>\n\t *\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshStandardMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.roughness = 1.0;\n\t\t\tthis.metalness = 0.0;\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.roughnessMap = null;\n\t\t\tthis.metalnessMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.vertexTangents = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': ''\n\t\t\t};\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\tthis.vertexTangents = source.vertexTangents;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tclearcoat: <float>,\n\t *\tclearcoatMap: new THREE.Texture( <Image> ),\n\t *\tclearcoatRoughness: <float>,\n\t *\tclearcoatRoughnessMap: new THREE.Texture( <Image> ),\n\t *\tclearcoatNormalScale: <Vector2>,\n\t *\tclearcoatNormalMap: new THREE.Texture( <Image> ),\n\t *\n\t *\treflectivity: <float>,\n\t *\tior: <float>,\n\t *\n\t *\tsheen: <Color>,\n\t *\n\t *\ttransmission: <float>,\n\t *\ttransmissionMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tthickness: <float>,\n\t *\tthicknessMap: new THREE.Texture( <Image> ),\n\t *\tattenuationDistance: <float>,\n\t *\tattenuationColor: <Color>\n\t * }\n\t */\n\n\tclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': '',\n\t\t\t\t'PHYSICAL': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\t\tthis.clearcoat = 0.0;\n\t\t\tthis.clearcoatMap = null;\n\t\t\tthis.clearcoatRoughness = 0.0;\n\t\t\tthis.clearcoatRoughnessMap = null;\n\t\t\tthis.clearcoatNormalScale = new Vector2(1, 1);\n\t\t\tthis.clearcoatNormalMap = null;\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\t\tObject.defineProperty(this, 'ior', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);\n\t\t\t\t},\n\t\t\t\tset: function (ior) {\n\t\t\t\t\tthis.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.sheen = null; // null will disable sheen bsdf\n\n\t\t\tthis.transmission = 0.0;\n\t\t\tthis.transmissionMap = null;\n\t\t\tthis.thickness = 0.01;\n\t\t\tthis.thicknessMap = null;\n\t\t\tthis.attenuationDistance = 0.0;\n\t\t\tthis.attenuationColor = new Color(1, 1, 1);\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': '',\n\t\t\t\t'PHYSICAL': ''\n\t\t\t};\n\t\t\tthis.clearcoat = source.clearcoat;\n\t\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\t\tthis.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n\t\t\tthis.reflectivity = source.reflectivity;\n\n\t\t\tif (source.sheen) {\n\t\t\t\tthis.sheen = (this.sheen || new Color()).copy(source.sheen);\n\t\t\t} else {\n\t\t\t\tthis.sheen = null;\n\t\t\t}\n\n\t\t\tthis.transmission = source.transmission;\n\t\t\tthis.transmissionMap = source.transmissionMap;\n\t\t\tthis.thickness = source.thickness;\n\t\t\tthis.thicknessMap = source.thicknessMap;\n\t\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\t\tthis.attenuationColor.copy(source.attenuationColor);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\tspecular: <hex>,\n\t *\tshininess: <float>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.MultiplyOperation,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshPhongMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.specular = new Color(0x111111);\n\t\t\tthis.shininess = 30;\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.specular.copy(source.specular);\n\t\t\tthis.shininess = source.shininess;\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\tgradientMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass MeshToonMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'TOON': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshToonMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.gradientMap = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.gradientMap = source.gradientMap;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\topacity: <float>,\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshNormalMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.Multiply,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass MeshLambertMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tmatcap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshMatcapMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'MATCAP': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshMatcapMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.matcap = null;\n\t\t\tthis.map = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'MATCAP': ''\n\t\t\t};\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.matcap = source.matcap;\n\t\t\tthis.map = source.map;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tlinewidth: <float>,\n\t *\n\t *\tscale: <float>,\n\t *\tdashSize: <float>,\n\t *\tgapSize: <float>\n\t * }\n\t */\n\n\tclass LineDashedMaterial extends LineBasicMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tvar Materials = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshToonMaterial: MeshToonMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshDistanceMaterial: MeshDistanceMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tMeshMatcapMaterial: MeshMatcapMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\tconst AnimationUtils = {\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function (array, from, to) {\n\t\t\tif (AnimationUtils.isTypedArray(array)) {\n\t\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\t\treturn new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n\t\t\t}\n\n\t\t\treturn array.slice(from, to);\n\t\t},\n\t\t// converts an array to a specific type\n\t\tconvertArray: function (array, type, forceClone) {\n\t\t\tif (!array || // let 'undefined' and 'null' pass\n\t\t\t!forceClone && array.constructor === type) return array;\n\n\t\t\tif (typeof type.BYTES_PER_ELEMENT === 'number') {\n\t\t\t\treturn new type(array); // create typed array\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call(array); // create Array\n\t\t},\n\t\tisTypedArray: function (object) {\n\t\t\treturn ArrayBuffer.isView(object) && !(object instanceof DataView);\n\t\t},\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function (times) {\n\t\t\tfunction compareTime(i, j) {\n\t\t\t\treturn times[i] - times[j];\n\t\t\t}\n\n\t\t\tconst n = times.length;\n\t\t\tconst result = new Array(n);\n\n\t\t\tfor (let i = 0; i !== n; ++i) result[i] = i;\n\n\t\t\tresult.sort(compareTime);\n\t\t\treturn result;\n\t\t},\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function (values, stride, order) {\n\t\t\tconst nValues = values.length;\n\t\t\tconst result = new values.constructor(nValues);\n\n\t\t\tfor (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n\t\t\t\tconst srcOffset = order[i] * stride;\n\n\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\tresult[dstOffset++] = values[srcOffset + j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n\t\t\tlet i = 1,\n\t\t\t\t\tkey = jsonKeys[0];\n\n\t\t\twhile (key !== undefined && key[valuePropertyName] === undefined) {\n\t\t\t\tkey = jsonKeys[i++];\n\t\t\t}\n\n\t\t\tif (key === undefined) return; // no data\n\n\t\t\tlet value = key[valuePropertyName];\n\t\t\tif (value === undefined) return; // no data\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalues.push.apply(values, value); // push all elements\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t} else if (value.toArray !== undefined) {\n\t\t\t\t// ...assume THREE.Math-ish\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalue.toArray(values, values.length);\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t}\n\t\t},\n\t\tsubclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {\n\t\t\tconst clip = sourceClip.clone();\n\t\t\tclip.name = name;\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tconst track = clip.tracks[i];\n\t\t\t\tconst valueSize = track.getValueSize();\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (let j = 0; j < track.times.length; ++j) {\n\t\t\t\t\tconst frame = track.times[j] * fps;\n\t\t\t\t\tif (frame < startFrame || frame >= endFrame) continue;\n\t\t\t\t\ttimes.push(track.times[j]);\n\n\t\t\t\t\tfor (let k = 0; k < valueSize; ++k) {\n\t\t\t\t\t\tvalues.push(track.values[j * valueSize + k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (times.length === 0) continue;\n\t\t\t\ttrack.times = AnimationUtils.convertArray(times, track.times.constructor);\n\t\t\t\ttrack.values = AnimationUtils.convertArray(values, track.values.constructor);\n\t\t\t\ttracks.push(track);\n\t\t\t}\n\n\t\t\tclip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n\t\t\tlet minStartTime = Infinity;\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tif (minStartTime > clip.tracks[i].times[0]) {\n\t\t\t\t\tminStartTime = clip.tracks[i].times[0];\n\t\t\t\t}\n\t\t\t} // shift all tracks such that clip begins at t=0\n\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tclip.tracks[i].shift(-1 * minStartTime);\n\t\t\t}\n\n\t\t\tclip.resetDuration();\n\t\t\treturn clip;\n\t\t},\n\t\tmakeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n\t\t\tif (fps <= 0) fps = 30;\n\t\t\tconst numTracks = referenceClip.tracks.length;\n\t\t\tconst referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n\t\t\tfor (let i = 0; i < numTracks; ++i) {\n\t\t\t\tconst referenceTrack = referenceClip.tracks[i];\n\t\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n\t\t\t\tif (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track\n\n\t\t\t\tconst targetTrack = targetClip.tracks.find(function (track) {\n\t\t\t\t\treturn track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n\t\t\t\t});\n\t\t\t\tif (targetTrack === undefined) continue;\n\t\t\t\tlet referenceOffset = 0;\n\t\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\t\t\tif (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n\t\t\t\t\treferenceOffset = referenceValueSize / 3;\n\t\t\t\t}\n\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\t\t\tif (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n\t\t\t\t\ttargetOffset = targetValueSize / 3;\n\t\t\t\t}\n\n\t\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\t\tlet referenceValue; // Find the value to subtract out of the track\n\n\t\t\t\tif (referenceTime <= referenceTrack.times[0]) {\n\t\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n\t\t\t\t} else if (referenceTime >= referenceTrack.times[lastIndex]) {\n\t\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n\t\t\t\t} else {\n\t\t\t\t\t// Interpolate to the reference value\n\t\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\t\tinterpolant.evaluate(referenceTime);\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n\t\t\t\t} // Conjugate the quaternion\n\n\n\t\t\t\tif (referenceTrackType === 'quaternion') {\n\t\t\t\t\tconst referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n\t\t\t\t\treferenceQuat.toArray(referenceValue);\n\t\t\t\t} // Subtract the reference value from all of the track values\n\n\n\t\t\t\tconst numTimes = targetTrack.times.length;\n\n\t\t\t\tfor (let j = 0; j < numTimes; ++j) {\n\t\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\t\t\tif (referenceTrackType === 'quaternion') {\n\t\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n\t\t\t\t\t\tfor (let k = 0; k < valueEnd; ++k) {\n\t\t\t\t\t\t\ttargetTrack.values[valueStart + k] -= referenceValue[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\t\t\treturn targetClip;\n\t\t}\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t */\n\tclass Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\t\tthis.settings = null;\n\t\t\tthis.DefaultSettings_ = {};\n\t\t}\n\n\t\tevaluate(t) {\n\t\t\tconst pp = this.parameterPositions;\n\t\t\tlet i1 = this._cachedIndex,\n\t\t\t\t\tt1 = pp[i1],\n\t\t\t\t\tt0 = pp[i1 - 1];\n\n\t\t\tvalidate_interval: {\n\t\t\t\tseek: {\n\t\t\t\t\tlet right;\n\n\t\t\t\t\tlinear_scan: {\n\t\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t//-\n\t\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if (!(t < t1)) {\n\t\t\t\t\t\t\tfor (let giveUpAt = i1 + 2;;) {\n\t\t\t\t\t\t\t\tif (t1 === undefined) {\n\t\t\t\t\t\t\t\t\tif (t < t0) break forward_scan; // after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_(i1 - 1, t, t0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (i1 === giveUpAt) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[++i1];\n\n\t\t\t\t\t\t\t\tif (t < t1) {\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // prepare binary search on the right side of the index\n\n\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\t\t\t\t\t} //- slower code:\n\t\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n\t\t\t\t\t\tif (!(t >= t0)) {\n\t\t\t\t\t\t\t// looping?\n\t\t\t\t\t\t\tconst t1global = pp[1];\n\n\t\t\t\t\t\t\tif (t < t1global) {\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\n\t\t\t\t\t\t\t\tt0 = t1global;\n\t\t\t\t\t\t\t} // linear reverse scan\n\n\n\t\t\t\t\t\t\tfor (let giveUpAt = i1 - 2;;) {\n\t\t\t\t\t\t\t\tif (t0 === undefined) {\n\t\t\t\t\t\t\t\t\t// before start\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_(0, t, t1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (i1 === giveUpAt) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[--i1 - 1];\n\n\t\t\t\t\t\t\t\tif (t >= t0) {\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // prepare binary search on the left side of the index\n\n\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\t\t\t\t\t} // the interval is valid\n\n\n\t\t\t\t\t\tbreak validate_interval;\n\t\t\t\t\t} // linear scan\n\t\t\t\t\t// binary search\n\n\n\t\t\t\t\twhile (i1 < right) {\n\t\t\t\t\t\tconst mid = i1 + right >>> 1;\n\n\t\t\t\t\t\tif (t < pp[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti1 = mid + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[i1];\n\t\t\t\t\tt0 = pp[i1 - 1]; // check boundary cases, again\n\n\t\t\t\t\tif (t0 === undefined) {\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_(0, t, t1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (t1 === undefined) {\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_(i1 - 1, t0, t);\n\t\t\t\t\t}\n\t\t\t\t} // seek\n\n\n\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\tthis.intervalChanged_(i1, t0, t1);\n\t\t\t} // validate_interval\n\n\n\t\t\treturn this.interpolate_(i1, t0, t, t1);\n\t\t}\n\n\t\tgetSettings_() {\n\t\t\treturn this.settings || this.DefaultSettings_;\n\t\t}\n\n\t\tcopySampleValue_(index) {\n\t\t\t// copies a sample value to the result buffer\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = index * stride;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = values[offset + i];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} // Template methods for derived classes:\n\n\n\t\tinterpolate_()\n\t\t/* i1, t0, t, t1 */\n\t\t{\n\t\t\tthrow new Error('call to abstract method'); // implementations shall return this.resultBuffer\n\t\t}\n\n\t\tintervalChanged_()\n\t\t/* i1, t0, t1 */\n\t\t{// empty\n\t\t}\n\n\t} // ALIAS DEFINITIONS\n\n\n\tInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\n\tInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t */\n\n\tclass CubicInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t\tthis._weightPrev = -0;\n\t\t\tthis._offsetPrev = -0;\n\t\t\tthis._weightNext = -0;\n\t\t\tthis._offsetNext = -0;\n\t\t\tthis.DefaultSettings_ = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\t\t}\n\n\t\tintervalChanged_(i1, t0, t1) {\n\t\t\tconst pp = this.parameterPositions;\n\t\t\tlet iPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\t\t\t\ttPrev = pp[iPrev],\n\t\t\t\t\ttNext = pp[iNext];\n\n\t\t\tif (tPrev === undefined) {\n\t\t\t\tswitch (this.getSettings_().endingStart) {\n\t\t\t\t\tcase ZeroSlopeEnding:\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ZeroCurvatureEnding\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tNext === undefined) {\n\t\t\t\tswitch (this.getSettings_().endingEnd) {\n\t\t\t\t\tcase ZeroSlopeEnding:\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[1] - pp[0];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ZeroCurvatureEnding\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst halfDt = (t1 - t0) * 0.5,\n\t\t\t\t\t\tstride = this.valueSize;\n\t\t\tthis._weightPrev = halfDt / (t0 - tPrev);\n\t\t\tthis._weightNext = halfDt / (tNext - t1);\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\to1 = i1 * stride,\n\t\t\t\t\t\to0 = o1 - stride,\n\t\t\t\t\t\toP = this._offsetPrev,\n\t\t\t\t\t\toN = this._offsetNext,\n\t\t\t\t\t\twP = this._weightPrev,\n\t\t\t\t\t\twN = this._weightNext,\n\t\t\t\t\t\tp = (t - t0) / (t1 - t0),\n\t\t\t\t\t\tpp = p * p,\n\t\t\t\t\t\tppp = pp * p; // evaluate polynomials\n\n\t\t\tconst sP = -wP * ppp + 2 * wP * pp - wP * p;\n\t\t\tconst s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n\t\t\tconst s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n\t\t\tconst sN = wN * ppp - wN * pp; // combine data linearly\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\tclass LinearInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\t\toffset0 = offset1 - stride,\n\t\t\t\t\t\tweight1 = (t - t0) / (t1 - t0),\n\t\t\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t */\n\n\tclass DiscreteInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1\n\t\t/*, t0, t, t1 */\n\t\t) {\n\t\t\treturn this.copySampleValue_(i1 - 1);\n\t\t}\n\n\t}\n\n\tclass KeyframeTrack {\n\t\tconstructor(name, times, values, interpolation) {\n\t\t\tif (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n\t\t\tif (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n\t\t\tthis.name = name;\n\t\t\tthis.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n\t\t\tthis.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n\t\t\tthis.setInterpolation(interpolation || this.DefaultInterpolation);\n\t\t} // Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\n\t\tstatic toJSON(track) {\n\t\t\tconst trackType = track.constructor;\n\t\t\tlet json; // derived classes can define a static toJSON method\n\n\t\t\tif (trackType.toJSON !== this.toJSON) {\n\t\t\t\tjson = trackType.toJSON(track);\n\t\t\t} else {\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray(track.times, Array),\n\t\t\t\t\t'values': AnimationUtils.convertArray(track.values, Array)\n\t\t\t\t};\n\t\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\t\tif (interpolation !== track.DefaultInterpolation) {\n\t\t\t\t\tjson.interpolation = interpolation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\t\t}\n\n\t\tInterpolantFactoryMethodDiscrete(result) {\n\t\t\treturn new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tInterpolantFactoryMethodLinear(result) {\n\t\t\treturn new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tInterpolantFactoryMethodSmooth(result) {\n\t\t\treturn new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tsetInterpolation(interpolation) {\n\t\t\tlet factoryMethod;\n\n\t\t\tswitch (interpolation) {\n\t\t\t\tcase InterpolateDiscrete:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (factoryMethod === undefined) {\n\t\t\t\tconst message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\t\tif (this.createInterpolant === undefined) {\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif (interpolation !== this.DefaultInterpolation) {\n\t\t\t\t\t\tthis.setInterpolation(this.DefaultInterpolation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(message); // fatal, in this case\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconsole.warn('THREE.KeyframeTrack:', message);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetInterpolation() {\n\t\t\tswitch (this.createInterpolant) {\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\t\t\t\treturn InterpolateSmooth;\n\t\t\t}\n\t\t}\n\n\t\tgetValueSize() {\n\t\t\treturn this.values.length / this.times.length;\n\t\t} // move all keyframes either forwards or backwards in time\n\n\n\t\tshift(timeOffset) {\n\t\t\tif (timeOffset !== 0.0) {\n\t\t\t\tconst times = this.times;\n\n\t\t\t\tfor (let i = 0, n = times.length; i !== n; ++i) {\n\t\t\t\t\ttimes[i] += timeOffset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\n\n\t\tscale(timeScale) {\n\t\t\tif (timeScale !== 1.0) {\n\t\t\t\tconst times = this.times;\n\n\t\t\t\tfor (let i = 0, n = times.length; i !== n; ++i) {\n\t\t\t\t\ttimes[i] *= timeScale;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\n\n\t\ttrim(startTime, endTime) {\n\t\t\tconst times = this.times,\n\t\t\t\t\t\tnKeys = times.length;\n\t\t\tlet from = 0,\n\t\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile (from !== nKeys && times[from] < startTime) {\n\t\t\t\t++from;\n\t\t\t}\n\n\t\t\twhile (to !== -1 && times[to] > endTime) {\n\t\t\t\t--to;\n\t\t\t}\n\n\t\t\t++to; // inclusive -> exclusive bound\n\n\t\t\tif (from !== 0 || to !== nKeys) {\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif (from >= to) {\n\t\t\t\t\tto = Math.max(to, 1);\n\t\t\t\t\tfrom = to - 1;\n\t\t\t\t}\n\n\t\t\t\tconst stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice(times, from, to);\n\t\t\t\tthis.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\n\n\t\tvalidate() {\n\t\t\tlet valid = true;\n\t\t\tconst valueSize = this.getValueSize();\n\n\t\t\tif (valueSize - Math.floor(valueSize) !== 0) {\n\t\t\t\tconsole.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\tconst times = this.times,\n\t\t\t\t\t\tvalues = this.values,\n\t\t\t\t\t\tnKeys = times.length;\n\n\t\t\tif (nKeys === 0) {\n\t\t\t\tconsole.error('THREE.KeyframeTrack: Track is empty.', this);\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\tlet prevTime = null;\n\n\t\t\tfor (let i = 0; i !== nKeys; i++) {\n\t\t\t\tconst currTime = times[i];\n\n\t\t\t\tif (typeof currTime === 'number' && isNaN(currTime)) {\n\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (prevTime !== null && prevTime > currTime) {\n\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\t\t\t}\n\n\t\t\tif (values !== undefined) {\n\t\t\t\tif (AnimationUtils.isTypedArray(values)) {\n\t\t\t\t\tfor (let i = 0, n = values.length; i !== n; ++i) {\n\t\t\t\t\t\tconst value = values[i];\n\n\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t} // removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\n\n\t\toptimize() {\n\t\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\t\tconst times = AnimationUtils.arraySlice(this.times),\n\t\t\t\t\t\tvalues = AnimationUtils.arraySlice(this.values),\n\t\t\t\t\t\tstride = this.getValueSize(),\n\t\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\t\t\t\t\tlastIndex = times.length - 1;\n\t\t\tlet writeIndex = 1;\n\n\t\t\tfor (let i = 1; i < lastIndex; ++i) {\n\t\t\t\tlet keep = false;\n\t\t\t\tconst time = times[i];\n\t\t\t\tconst timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif (time !== timeNext && (i !== 1 || time !== times[0])) {\n\t\t\t\t\tif (!smoothInterpolation) {\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\t\t\tconst value = values[offset + j];\n\n\t\t\t\t\t\t\tif (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t}\n\t\t\t\t} // in-place compaction\n\n\n\t\t\t\tif (keep) {\n\t\t\t\t\tif (i !== writeIndex) {\n\t\t\t\t\t\ttimes[writeIndex] = times[i];\n\t\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\t\t\tvalues[writeOffset + j] = values[readOffset + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t++writeIndex;\n\t\t\t\t}\n\t\t\t} // flush last keyframe (compaction looks ahead)\n\n\n\t\t\tif (lastIndex > 0) {\n\t\t\t\ttimes[writeIndex] = times[lastIndex];\n\n\t\t\t\tfor (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n\t\t\t\t\tvalues[writeOffset + j] = values[readOffset + j];\n\t\t\t\t}\n\n\t\t\t\t++writeIndex;\n\t\t\t}\n\n\t\t\tif (writeIndex !== times.length) {\n\t\t\t\tthis.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n\t\t\t\tthis.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n\t\t\t} else {\n\t\t\t\tthis.times = times;\n\t\t\t\tthis.values = values;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst times = AnimationUtils.arraySlice(this.times, 0);\n\t\t\tconst values = AnimationUtils.arraySlice(this.values, 0);\n\t\t\tconst TypedKeyframeTrack = this.constructor;\n\t\t\tconst track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n\t\t\ttrack.createInterpolant = this.createInterpolant;\n\t\t\treturn track;\n\t\t}\n\n\t}\n\n\tKeyframeTrack.prototype.TimeBufferType = Float32Array;\n\tKeyframeTrack.prototype.ValueBufferType = Float32Array;\n\tKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n\t/**\n\t * A Track of Boolean keyframe values.\n\t */\n\n\tclass BooleanKeyframeTrack extends KeyframeTrack {}\n\n\tBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\n\tBooleanKeyframeTrack.prototype.ValueBufferType = Array;\n\tBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\n\tBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\n\tBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed\n\n\t/**\n\t * A Track of keyframe values that represent color.\n\t */\n\n\tclass ColorKeyframeTrack extends KeyframeTrack {}\n\n\tColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited\n\n\t/**\n\t * A Track of numeric keyframe values.\n\t */\n\n\tclass NumberKeyframeTrack extends KeyframeTrack {}\n\n\tNumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t */\n\n\tclass QuaternionLinearInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\talpha = (t - t0) / (t1 - t0);\n\t\t\tlet offset = i1 * stride;\n\n\t\t\tfor (let end = offset + stride; offset !== end; offset += 4) {\n\t\t\t\tQuaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t * A Track of quaternion keyframe values.\n\t */\n\n\tclass QuaternionKeyframeTrack extends KeyframeTrack {\n\t\tInterpolantFactoryMethodLinear(result) {\n\t\t\treturn new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited\n\n\tQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\tQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n\t/**\n\t * A Track that interpolates Strings\n\t */\n\n\tclass StringKeyframeTrack extends KeyframeTrack {}\n\n\tStringKeyframeTrack.prototype.ValueTypeName = 'string';\n\tStringKeyframeTrack.prototype.ValueBufferType = Array;\n\tStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\n\tStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\n\tStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n\t/**\n\t * A Track of vectored keyframe values.\n\t */\n\n\tclass VectorKeyframeTrack extends KeyframeTrack {}\n\n\tVectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited\n\n\tclass AnimationClip {\n\t\tconstructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = duration;\n\t\t\tthis.blendMode = blendMode;\n\t\t\tthis.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n\t\t\tif (this.duration < 0) {\n\t\t\t\tthis.resetDuration();\n\t\t\t}\n\t\t}\n\n\t\tstatic parse(json) {\n\t\t\tconst tracks = [],\n\t\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\t\tframeTime = 1.0 / (json.fps || 1.0);\n\n\t\t\tfor (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n\t\t\t\ttracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n\t\t\t}\n\n\t\t\tconst clip = new this(json.name, json.duration, tracks, json.blendMode);\n\t\t\tclip.uuid = json.uuid;\n\t\t\treturn clip;\n\t\t}\n\n\t\tstatic toJSON(clip) {\n\t\t\tconst tracks = [],\n\t\t\t\t\t\tclipTracks = clip.tracks;\n\t\t\tconst json = {\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks,\n\t\t\t\t'uuid': clip.uuid,\n\t\t\t\t'blendMode': clip.blendMode\n\t\t\t};\n\n\t\t\tfor (let i = 0, n = clipTracks.length; i !== n; ++i) {\n\t\t\t\ttracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n\t\t\t}\n\n\t\t\treturn json;\n\t\t}\n\n\t\tstatic CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n\t\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < numMorphTargets; i++) {\n\t\t\t\tlet times = [];\n\t\t\t\tlet values = [];\n\t\t\t\ttimes.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n\t\t\t\tvalues.push(0, 1, 0);\n\t\t\t\tconst order = AnimationUtils.getKeyframeOrder(times);\n\t\t\t\ttimes = AnimationUtils.sortedArray(times, 1, order);\n\t\t\t\tvalues = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\n\t\t\t\tif (!noLoop && times[0] === 0) {\n\t\t\t\t\ttimes.push(numMorphTargets);\n\t\t\t\t\tvalues.push(values[0]);\n\t\t\t\t}\n\n\t\t\t\ttracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n\t\t\t}\n\n\t\t\treturn new this(name, -1, tracks);\n\t\t}\n\n\t\tstatic findByName(objectOrClipArray, name) {\n\t\t\tlet clipArray = objectOrClipArray;\n\n\t\t\tif (!Array.isArray(objectOrClipArray)) {\n\t\t\t\tconst o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < clipArray.length; i++) {\n\t\t\t\tif (clipArray[i].name === name) {\n\t\t\t\t\treturn clipArray[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tstatic CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n\t\t\tconst animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n\t\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\n\t\t\tfor (let i = 0, il = morphTargets.length; i < il; i++) {\n\t\t\t\tconst morphTarget = morphTargets[i];\n\t\t\t\tconst parts = morphTarget.name.match(pattern);\n\n\t\t\t\tif (parts && parts.length > 1) {\n\t\t\t\t\tconst name = parts[1];\n\t\t\t\t\tlet animationMorphTargets = animationToMorphTargets[name];\n\n\t\t\t\t\tif (!animationMorphTargets) {\n\t\t\t\t\t\tanimationToMorphTargets[name] = animationMorphTargets = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push(morphTarget);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst clips = [];\n\n\t\t\tfor (const name in animationToMorphTargets) {\n\t\t\t\tclips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n\t\t\t}\n\n\t\t\treturn clips;\n\t\t} // parse the animation.hierarchy format\n\n\n\t\tstatic parseAnimation(animation, bones) {\n\t\t\tif (!animation) {\n\t\t\t\tconsole.error('THREE.AnimationClip: No animation in JSONLoader data.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif (animationKeys.length !== 0) {\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\t\t\t\t\tAnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n\t\t\t\t\tif (times.length !== 0) {\n\t\t\t\t\t\tdestTracks.push(new trackType(trackName, times, values));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst tracks = [];\n\t\t\tconst clipName = animation.name || 'default';\n\t\t\tconst fps = animation.fps || 30;\n\t\t\tconst blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n\t\t\tlet duration = animation.length || -1;\n\t\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor (let h = 0; h < hierarchyTracks.length; h++) {\n\t\t\t\tconst animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n\t\t\t\tif (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n\t\t\t\tif (animationKeys[0].morphTargets) {\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tconst morphTargetNames = {};\n\t\t\t\t\tlet k;\n\n\t\t\t\t\tfor (k = 0; k < animationKeys.length; k++) {\n\t\t\t\t\t\tif (animationKeys[k].morphTargets) {\n\t\t\t\t\t\t\tfor (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n\t\t\t\t\t\t\t\tmorphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\n\n\t\t\t\t\tfor (const morphTargetName in morphTargetNames) {\n\t\t\t\t\t\tconst times = [];\n\t\t\t\t\t\tconst values = [];\n\n\t\t\t\t\t\tfor (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n\t\t\t\t\t\t\tconst animationKey = animationKeys[k];\n\t\t\t\t\t\t\ttimes.push(animationKey.time);\n\t\t\t\t\t\t\tvalues.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * (fps || 1.0);\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\t\t\t\t\tconst boneName = '.bones[' + bones[h].name + ']';\n\t\t\t\t\taddNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n\t\t\t\t\taddNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n\t\t\t\t\taddNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tracks.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst clip = new this(clipName, duration, tracks, blendMode);\n\t\t\treturn clip;\n\t\t}\n\n\t\tresetDuration() {\n\t\t\tconst tracks = this.tracks;\n\t\t\tlet duration = 0;\n\n\t\t\tfor (let i = 0, n = tracks.length; i !== n; ++i) {\n\t\t\t\tconst track = this.tracks[i];\n\t\t\t\tduration = Math.max(duration, track.times[track.times.length - 1]);\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\t\t\treturn this;\n\t\t}\n\n\t\ttrim() {\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tthis.tracks[i].trim(0, this.duration);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidate() {\n\t\t\tlet valid = true;\n\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tvalid = valid && this.tracks[i].validate();\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t}\n\n\t\toptimize() {\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tthis.tracks[i].optimize();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\ttracks.push(this.tracks[i].clone());\n\t\t\t}\n\n\t\t\treturn new this.constructor(this.name, this.duration, tracks, this.blendMode);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\treturn this.constructor.toJSON(this);\n\t\t}\n\n\t}\n\n\tfunction getTrackTypeForValueTypeName(typeName) {\n\t\tswitch (typeName.toLowerCase()) {\n\t\t\tcase 'scalar':\n\t\t\tcase 'double':\n\t\t\tcase 'float':\n\t\t\tcase 'number':\n\t\t\tcase 'integer':\n\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\tcase 'vector':\n\t\t\tcase 'vector2':\n\t\t\tcase 'vector3':\n\t\t\tcase 'vector4':\n\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\tcase 'color':\n\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\tcase 'quaternion':\n\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\tcase 'bool':\n\t\t\tcase 'boolean':\n\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\tcase 'string':\n\t\t\t\treturn StringKeyframeTrack;\n\t\t}\n\n\t\tthrow new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n\t}\n\n\tfunction parseKeyframeTrack(json) {\n\t\tif (json.type === undefined) {\n\t\t\tthrow new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n\t\t}\n\n\t\tconst trackType = getTrackTypeForValueTypeName(json.type);\n\n\t\tif (json.times === undefined) {\n\t\t\tconst times = [],\n\t\t\t\t\t\tvalues = [];\n\t\t\tAnimationUtils.flattenJSON(json.keys, times, values, 'value');\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\t\t} // derived classes can define a static parse method\n\n\n\t\tif (trackType.parse !== undefined) {\n\t\t\treturn trackType.parse(json);\n\t\t} else {\n\t\t\t// by default, we assume a constructor compatible with the base\n\t\t\treturn new trackType(json.name, json.times, json.values, json.interpolation);\n\t\t}\n\t}\n\n\tconst Cache = {\n\t\tenabled: false,\n\t\tfiles: {},\n\t\tadd: function (key, file) {\n\t\t\tif (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[key] = file;\n\t\t},\n\t\tget: function (key) {\n\t\t\tif (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[key];\n\t\t},\n\t\tremove: function (key) {\n\t\t\tdelete this.files[key];\n\t\t},\n\t\tclear: function () {\n\t\t\tthis.files = {};\n\t\t}\n\t};\n\n\tclass LoadingManager {\n\t\tconstructor(onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tlet isLoading = false;\n\t\t\tlet itemsLoaded = 0;\n\t\t\tlet itemsTotal = 0;\n\t\t\tlet urlModifier = undefined;\n\t\t\tconst handlers = []; // Refer to #5689 for the reason why we don't set .onStart\n\t\t\t// in the constructor\n\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\n\t\t\tthis.itemStart = function (url) {\n\t\t\t\titemsTotal++;\n\n\t\t\t\tif (isLoading === false) {\n\t\t\t\t\tif (scope.onStart !== undefined) {\n\t\t\t\t\t\tscope.onStart(url, itemsLoaded, itemsTotal);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tisLoading = true;\n\t\t\t};\n\n\t\t\tthis.itemEnd = function (url) {\n\t\t\t\titemsLoaded++;\n\n\t\t\t\tif (scope.onProgress !== undefined) {\n\t\t\t\t\tscope.onProgress(url, itemsLoaded, itemsTotal);\n\t\t\t\t}\n\n\t\t\t\tif (itemsLoaded === itemsTotal) {\n\t\t\t\t\tisLoading = false;\n\n\t\t\t\t\tif (scope.onLoad !== undefined) {\n\t\t\t\t\t\tscope.onLoad();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.itemError = function (url) {\n\t\t\t\tif (scope.onError !== undefined) {\n\t\t\t\t\tscope.onError(url);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.resolveURL = function (url) {\n\t\t\t\tif (urlModifier) {\n\t\t\t\t\treturn urlModifier(url);\n\t\t\t\t}\n\n\t\t\t\treturn url;\n\t\t\t};\n\n\t\t\tthis.setURLModifier = function (transform) {\n\t\t\t\turlModifier = transform;\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.addHandler = function (regex, loader) {\n\t\t\t\thandlers.push(regex, loader);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.removeHandler = function (regex) {\n\t\t\t\tconst index = handlers.indexOf(regex);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\thandlers.splice(index, 2);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.getHandler = function (file) {\n\t\t\t\tfor (let i = 0, l = handlers.length; i < l; i += 2) {\n\t\t\t\t\tconst regex = handlers[i];\n\t\t\t\t\tconst loader = handlers[i + 1];\n\t\t\t\t\tif (regex.global) regex.lastIndex = 0; // see #17920\n\n\t\t\t\t\tif (regex.test(file)) {\n\t\t\t\t\t\treturn loader;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}\n\n\t}\n\n\tconst DefaultLoadingManager = new LoadingManager();\n\n\tclass Loader {\n\t\tconstructor(manager) {\n\t\t\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\t\t\tthis.crossOrigin = 'anonymous';\n\t\t\tthis.withCredentials = false;\n\t\t\tthis.path = '';\n\t\t\tthis.resourcePath = '';\n\t\t\tthis.requestHeader = {};\n\t\t}\n\n\t\tload()\n\t\t/* url, onLoad, onProgress, onError */\n\t\t{}\n\n\t\tloadAsync(url, onProgress) {\n\t\t\tconst scope = this;\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tscope.load(url, resolve, onProgress, reject);\n\t\t\t});\n\t\t}\n\n\t\tparse()\n\t\t/* data */\n\t\t{}\n\n\t\tsetCrossOrigin(crossOrigin) {\n\t\t\tthis.crossOrigin = crossOrigin;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetWithCredentials(value) {\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetPath(path) {\n\t\t\tthis.path = path;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetResourcePath(resourcePath) {\n\t\t\tthis.resourcePath = resourcePath;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRequestHeader(requestHeader) {\n\t\t\tthis.requestHeader = requestHeader;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tconst loading = {};\n\n\tclass FileLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (url === undefined) url = '';\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t} // Check if request is duplicate\n\n\n\t\t\tif (loading[url] !== undefined) {\n\t\t\t\tloading[url].push({\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} // Check for data: URI\n\n\n\t\t\tconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tconst dataUriRegexResult = url.match(dataUriRegex);\n\t\t\tlet request; // Safari can not handle Data URIs through XMLHttpRequest so process manually\n\n\t\t\tif (dataUriRegexResult) {\n\t\t\t\tconst mimeType = dataUriRegexResult[1];\n\t\t\t\tconst isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tlet data = dataUriRegexResult[3];\n\t\t\t\tdata = decodeURIComponent(data);\n\t\t\t\tif (isBase64) data = atob(data);\n\n\t\t\t\ttry {\n\t\t\t\t\tlet response;\n\t\t\t\t\tconst responseType = (this.responseType || '').toLowerCase();\n\n\t\t\t\t\tswitch (responseType) {\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\t\t\t\t\t\t\tconst view = new Uint8Array(data.length);\n\n\t\t\t\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\t\t\t\tview[i] = data.charCodeAt(i);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (responseType === 'blob') {\n\t\t\t\t\t\t\t\tresponse = new Blob([view.buffer], {\n\t\t\t\t\t\t\t\t\ttype: mimeType\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse = view.buffer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString(data, mimeType);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tresponse = JSON.parse(data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// 'text' or other\n\t\t\t\t\t\t\tresponse = data;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\n\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (onLoad) onLoad(response);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Initialise array for duplicate requests\n\t\t\t\tloading[url] = [];\n\t\t\t\tloading[url].push({\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t\trequest = new XMLHttpRequest();\n\t\t\t\trequest.open('GET', url, true);\n\t\t\t\trequest.addEventListener('load', function (event) {\n\t\t\t\t\tconst response = this.response;\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tif (this.status === 200 || this.status === 0) {\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\t\t\t\t\tif (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t\t\t// error response bodies as proper responses to requests.\n\n\t\t\t\t\t\tCache.add(url, response);\n\n\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\t\tif (callback.onLoad) callback.onLoad(response);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('progress', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onProgress) callback.onProgress(event);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('error', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('abort', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, false);\n\t\t\t\tif (this.responseType !== undefined) request.responseType = this.responseType;\n\t\t\t\tif (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;\n\t\t\t\tif (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n\n\t\t\t\tfor (const header in this.requestHeader) {\n\t\t\t\t\trequest.setRequestHeader(header, this.requestHeader[header]);\n\t\t\t\t}\n\n\t\t\t\trequest.send(null);\n\t\t\t}\n\n\t\t\tscope.manager.itemStart(url);\n\t\t\treturn request;\n\t\t}\n\n\t\tsetResponseType(value) {\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMimeType(value) {\n\t\t\tthis.mimeType = value;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AnimationLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst animations = [];\n\n\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\tconst clip = AnimationClip.parse(json[i]);\n\t\t\t\tanimations.push(clip);\n\t\t\t}\n\n\t\t\treturn animations;\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t *\n\t * Sub classes have to implement the parse() method which will be used in load().\n\t */\n\n\tclass CompressedTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst images = [];\n\t\t\tconst texture = new CompressedTexture();\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tlet loaded = 0;\n\n\t\t\tfunction loadTexture(i) {\n\t\t\t\tloader.load(url[i], function (buffer) {\n\t\t\t\t\tconst texDatas = scope.parse(buffer, true);\n\t\t\t\t\timages[i] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif (loaded === 6) {\n\t\t\t\t\t\tif (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n\t\t\t\t\t\ttexture.image = images;\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t\t}\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\tif (Array.isArray(url)) {\n\t\t\t\tfor (let i = 0, il = url.length; i < il; ++i) {\n\t\t\t\t\tloadTexture(i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\t\t\tloader.load(url, function (buffer) {\n\t\t\t\t\tconst texDatas = scope.parse(buffer, true);\n\n\t\t\t\t\tif (texDatas.isCubemap) {\n\t\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor (let f = 0; f < faces; f++) {\n\t\t\t\t\t\t\timages[f] = {\n\t\t\t\t\t\t\t\tmipmaps: []\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tfor (let i = 0; i < texDatas.mipmapCount; i++) {\n\t\t\t\t\t\t\t\timages[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n\t\t\t\t\t\t\t\timages[f].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[f].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[f].height = texDatas.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture.image = images;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (texDatas.mipmapCount === 1) {\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\tclass ImageLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tconst image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');\n\n\t\t\tfunction onImageLoad() {\n\t\t\t\timage.removeEventListener('load', onImageLoad, false);\n\t\t\t\timage.removeEventListener('error', onImageError, false);\n\t\t\t\tCache.add(url, this);\n\t\t\t\tif (onLoad) onLoad(this);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}\n\n\t\t\tfunction onImageError(event) {\n\t\t\t\timage.removeEventListener('load', onImageLoad, false);\n\t\t\t\timage.removeEventListener('error', onImageError, false);\n\t\t\t\tif (onError) onError(event);\n\t\t\t\tscope.manager.itemError(url);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}\n\n\t\t\timage.addEventListener('load', onImageLoad, false);\n\t\t\timage.addEventListener('error', onImageError, false);\n\n\t\t\tif (url.substr(0, 5) !== 'data:') {\n\t\t\t\tif (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n\t\t\t}\n\n\t\t\tscope.manager.itemStart(url);\n\t\t\timage.src = url;\n\t\t\treturn image;\n\t\t}\n\n\t}\n\n\tclass CubeTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(urls, onLoad, onProgress, onError) {\n\t\t\tconst texture = new CubeTexture();\n\t\t\tconst loader = new ImageLoader(this.manager);\n\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\t\tloader.setPath(this.path);\n\t\t\tlet loaded = 0;\n\n\t\t\tfunction loadTexture(i) {\n\t\t\t\tloader.load(urls[i], function (image) {\n\t\t\t\t\ttexture.images[i] = image;\n\t\t\t\t\tloaded++;\n\n\t\t\t\t\tif (loaded === 6) {\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t\t}\n\t\t\t\t}, undefined, onError);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < urls.length; ++i) {\n\t\t\t\tloadTexture(i);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t *\n\t * Sub classes have to implement the parse() method which will be used in load().\n\t */\n\n\tclass DataTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst texture = new DataTexture();\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (buffer) {\n\t\t\t\tconst texData = scope.parse(buffer);\n\t\t\t\tif (!texData) return;\n\n\t\t\t\tif (texData.image !== undefined) {\n\t\t\t\t\ttexture.image = texData.image;\n\t\t\t\t} else if (texData.data !== undefined) {\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\t\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\t\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\t\tif (texData.encoding !== undefined) {\n\t\t\t\t\ttexture.encoding = texData.encoding;\n\t\t\t\t}\n\n\t\t\t\tif (texData.flipY !== undefined) {\n\t\t\t\t\ttexture.flipY = texData.flipY;\n\t\t\t\t}\n\n\t\t\t\tif (texData.format !== undefined) {\n\t\t\t\t\ttexture.format = texData.format;\n\t\t\t\t}\n\n\t\t\t\tif (texData.type !== undefined) {\n\t\t\t\t\ttexture.type = texData.type;\n\t\t\t\t}\n\n\t\t\t\tif (texData.mipmaps !== undefined) {\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\t\t\t\t}\n\n\t\t\t\tif (texData.mipmapCount === 1) {\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t}\n\n\t\t\t\tif (texData.generateMipmaps !== undefined) {\n\t\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif (onLoad) onLoad(texture, texData);\n\t\t\t}, onProgress, onError);\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\tclass TextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst texture = new Texture();\n\t\t\tconst loader = new ImageLoader(this.manager);\n\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.load(url, function (image) {\n\t\t\t\ttexture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\n\t\t\t\tconst isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif (onLoad !== undefined) {\n\t\t\t\t\tonLoad(texture);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\t/**\n\t * Extensible curve object.\n\t *\n\t * Some common of curve methods:\n\t * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n\t * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following curves inherit from THREE.Curve:\n\t *\n\t * -- 2D curves --\n\t * THREE.ArcCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.EllipseCurve\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.SplineCurve\n\t *\n\t * -- 3D curves --\n\t * THREE.CatmullRomCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath.\n\t *\n\t **/\n\n\tclass Curve {\n\t\tconstructor() {\n\t\t\tthis.type = 'Curve';\n\t\t\tthis.arcLengthDivisions = 200;\n\t\t} // Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\n\t\tgetPoint()\n\t\t/* t, optionalTarget */\n\t\t{\n\t\t\tconsole.warn('THREE.Curve: .getPoint() not implemented.');\n\t\t\treturn null;\n\t\t} // Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\tconst t = this.getUtoTmapping(u);\n\t\t\treturn this.getPoint(t, optionalTarget);\n\t\t} // Get sequence of points using getPoint( t )\n\n\n\t\tgetPoints(divisions = 5) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let d = 0; d <= divisions; d++) {\n\t\t\t\tpoints.push(this.getPoint(d / divisions));\n\t\t\t}\n\n\t\t\treturn points;\n\t\t} // Get sequence of points using getPointAt( u )\n\n\n\t\tgetSpacedPoints(divisions = 5) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let d = 0; d <= divisions; d++) {\n\t\t\t\tpoints.push(this.getPointAt(d / divisions));\n\t\t\t}\n\n\t\t\treturn points;\n\t\t} // Get total curve arc length\n\n\n\t\tgetLength() {\n\t\t\tconst lengths = this.getLengths();\n\t\t\treturn lengths[lengths.length - 1];\n\t\t} // Get list of cumulative segment lengths\n\n\n\t\tgetLengths(divisions = this.arcLengthDivisions) {\n\t\t\tif (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n\t\t\t\treturn this.cacheArcLengths;\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\t\t\tconst cache = [];\n\t\t\tlet current,\n\t\t\t\t\tlast = this.getPoint(0);\n\t\t\tlet sum = 0;\n\t\t\tcache.push(0);\n\n\t\t\tfor (let p = 1; p <= divisions; p++) {\n\t\t\t\tcurrent = this.getPoint(p / divisions);\n\t\t\t\tsum += current.distanceTo(last);\n\t\t\t\tcache.push(sum);\n\t\t\t\tlast = current;\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\t\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\t\t}\n\n\t\tupdateArcLengths() {\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\t\t} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\n\t\tgetUtoTmapping(u, distance) {\n\t\t\tconst arcLengths = this.getLengths();\n\t\t\tlet i = 0;\n\t\t\tconst il = arcLengths.length;\n\t\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\t\tif (distance) {\n\t\t\t\ttargetArcLength = distance;\n\t\t\t} else {\n\t\t\t\ttargetArcLength = u * arcLengths[il - 1];\n\t\t\t} // binary search for the index with largest value smaller than target u distance\n\n\n\t\t\tlet low = 0,\n\t\t\t\t\thigh = il - 1,\n\t\t\t\t\tcomparison;\n\n\t\t\twhile (low <= high) {\n\t\t\t\ti = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[i] - targetArcLength;\n\n\t\t\t\tif (comparison < 0) {\n\t\t\t\t\tlow = i + 1;\n\t\t\t\t} else if (comparison > 0) {\n\t\t\t\t\thigh = i - 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak; // DONE\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\tif (arcLengths[i] === targetArcLength) {\n\t\t\t\treturn i / (il - 1);\n\t\t\t} // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n\t\t\tconst lengthBefore = arcLengths[i];\n\t\t\tconst lengthAfter = arcLengths[i + 1];\n\t\t\tconst segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n\t\t\tconst segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n\t\t\tconst t = (i + segmentFraction) / (il - 1);\n\t\t\treturn t;\n\t\t} // Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\n\t\tgetTangent(t, optionalTarget) {\n\t\t\tconst delta = 0.0001;\n\t\t\tlet t1 = t - delta;\n\t\t\tlet t2 = t + delta; // Capping in case of danger\n\n\t\t\tif (t1 < 0) t1 = 0;\n\t\t\tif (t2 > 1) t2 = 1;\n\t\t\tconst pt1 = this.getPoint(t1);\n\t\t\tconst pt2 = this.getPoint(t2);\n\t\t\tconst tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n\t\t\ttangent.copy(pt2).sub(pt1).normalize();\n\t\t\treturn tangent;\n\t\t}\n\n\t\tgetTangentAt(u, optionalTarget) {\n\t\t\tconst t = this.getUtoTmapping(u);\n\t\t\treturn this.getTangent(t, optionalTarget);\n\t\t}\n\n\t\tcomputeFrenetFrames(segments, closed) {\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\t\tconst normal = new Vector3();\n\t\t\tconst tangents = [];\n\t\t\tconst normals = [];\n\t\t\tconst binormals = [];\n\t\t\tconst vec = new Vector3();\n\t\t\tconst mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n\t\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\t\tconst u = i / segments;\n\t\t\t\ttangents[i] = this.getTangentAt(u, new Vector3());\n\t\t\t\ttangents[i].normalize();\n\t\t\t} // select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\n\t\t\tnormals[0] = new Vector3();\n\t\t\tbinormals[0] = new Vector3();\n\t\t\tlet min = Number.MAX_VALUE;\n\t\t\tconst tx = Math.abs(tangents[0].x);\n\t\t\tconst ty = Math.abs(tangents[0].y);\n\t\t\tconst tz = Math.abs(tangents[0].z);\n\n\t\t\tif (tx <= min) {\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set(1, 0, 0);\n\t\t\t}\n\n\t\t\tif (ty <= min) {\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set(0, 1, 0);\n\t\t\t}\n\n\t\t\tif (tz <= min) {\n\t\t\t\tnormal.set(0, 0, 1);\n\t\t\t}\n\n\t\t\tvec.crossVectors(tangents[0], normal).normalize();\n\t\t\tnormals[0].crossVectors(tangents[0], vec);\n\t\t\tbinormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\tnormals[i] = normals[i - 1].clone();\n\t\t\t\tbinormals[i] = binormals[i - 1].clone();\n\t\t\t\tvec.crossVectors(tangents[i - 1], tangents[i]);\n\n\t\t\t\tif (vec.length() > Number.EPSILON) {\n\t\t\t\t\tvec.normalize();\n\t\t\t\t\tconst theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n\t\t\t\t}\n\n\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n\t\t\tif (closed === true) {\n\t\t\t\tlet theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n\t\t\t\t\ttheta = -theta;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n\t\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Curve',\n\t\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\t\tdata.type = this.type;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass EllipseCurve extends Curve {\n\t\tconstructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n\t\t\tsuper();\n\t\t\tthis.type = 'EllipseCurve';\n\t\t\tthis.aX = aX;\n\t\t\tthis.aY = aY;\n\t\t\tthis.xRadius = xRadius;\n\t\t\tthis.yRadius = yRadius;\n\t\t\tthis.aStartAngle = aStartAngle;\n\t\t\tthis.aEndAngle = aEndAngle;\n\t\t\tthis.aClockwise = aClockwise;\n\t\t\tthis.aRotation = aRotation;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget) {\n\t\t\tconst point = optionalTarget || new Vector2();\n\t\t\tconst twoPi = Math.PI * 2;\n\t\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tconst samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n\t\t\twhile (deltaAngle < 0) deltaAngle += twoPi;\n\n\t\t\twhile (deltaAngle > twoPi) deltaAngle -= twoPi;\n\n\t\t\tif (deltaAngle < Number.EPSILON) {\n\t\t\t\tif (samePoints) {\n\t\t\t\t\tdeltaAngle = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.aClockwise === true && !samePoints) {\n\t\t\t\tif (deltaAngle === twoPi) {\n\t\t\t\t\tdeltaAngle = -twoPi;\n\t\t\t\t} else {\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\t\tlet x = this.aX + this.xRadius * Math.cos(angle);\n\t\t\tlet y = this.aY + this.yRadius * Math.sin(angle);\n\n\t\t\tif (this.aRotation !== 0) {\n\t\t\t\tconst cos = Math.cos(this.aRotation);\n\t\t\t\tconst sin = Math.sin(this.aRotation);\n\t\t\t\tconst tx = x - this.aX;\n\t\t\t\tconst ty = y - this.aY; // Rotate the point about the center of the ellipse.\n\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\t\t}\n\n\t\t\treturn point.set(x, y);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.aX = source.aX;\n\t\t\tthis.aY = source.aY;\n\t\t\tthis.xRadius = source.xRadius;\n\t\t\tthis.yRadius = source.yRadius;\n\t\t\tthis.aStartAngle = source.aStartAngle;\n\t\t\tthis.aEndAngle = source.aEndAngle;\n\t\t\tthis.aClockwise = source.aClockwise;\n\t\t\tthis.aRotation = source.aRotation;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.aX = this.aX;\n\t\t\tdata.aY = this.aY;\n\t\t\tdata.xRadius = this.xRadius;\n\t\t\tdata.yRadius = this.yRadius;\n\t\t\tdata.aStartAngle = this.aStartAngle;\n\t\t\tdata.aEndAngle = this.aEndAngle;\n\t\t\tdata.aClockwise = this.aClockwise;\n\t\t\tdata.aRotation = this.aRotation;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.aX = json.aX;\n\t\t\tthis.aY = json.aY;\n\t\t\tthis.xRadius = json.xRadius;\n\t\t\tthis.yRadius = json.yRadius;\n\t\t\tthis.aStartAngle = json.aStartAngle;\n\t\t\tthis.aEndAngle = json.aEndAngle;\n\t\t\tthis.aClockwise = json.aClockwise;\n\t\t\tthis.aRotation = json.aRotation;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tclass ArcCurve extends EllipseCurve {\n\t\tconstructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tsuper(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\tthis.type = 'ArcCurve';\n\t\t}\n\n\t}\n\n\tArcCurve.prototype.isArcCurve = true;\n\n\t/**\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\t\tlet c0 = 0,\n\t\t\t\tc1 = 0,\n\t\t\t\tc2 = 0,\n\t\t\t\tc3 = 0;\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *\t p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *\t p(0) = x0, p(1) = x1\n\t\t *\tand\n\t\t *\t p'(0) = t0, p'(1) = t1.\n\t\t */\n\n\t\tfunction init(x0, x1, t0, t1) {\n\t\t\tc0 = x0;\n\t\t\tc1 = t0;\n\t\t\tc2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\t}\n\n\t\treturn {\n\t\t\tinitCatmullRom: function (x0, x1, x2, x3, tension) {\n\t\t\t\tinit(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n\t\t\t},\n\t\t\tinitNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tlet t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n\t\t\t\tlet t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]\n\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\t\t\t\tinit(x1, x2, t1, t2);\n\t\t\t},\n\t\t\tcalc: function (t) {\n\t\t\t\tconst t2 = t * t;\n\t\t\t\tconst t3 = t2 * t;\n\t\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\t\t\t}\n\t\t};\n\t} //\n\n\n\tconst tmp = new Vector3();\n\tconst px = new CubicPoly(),\n\t\t\t\tpy = new CubicPoly(),\n\t\t\t\tpz = new CubicPoly();\n\n\tclass CatmullRomCurve3 extends Curve {\n\t\tconstructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CatmullRomCurve3';\n\t\t\tthis.points = points;\n\t\t\tthis.closed = closed;\n\t\t\tthis.curveType = curveType;\n\t\t\tthis.tension = tension;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst points = this.points;\n\t\t\tconst l = points.length;\n\t\t\tconst p = (l - (this.closed ? 0 : 1)) * t;\n\t\t\tlet intPoint = Math.floor(p);\n\t\t\tlet weight = p - intPoint;\n\n\t\t\tif (this.closed) {\n\t\t\t\tintPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n\t\t\t} else if (weight === 0 && intPoint === l - 1) {\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\t\t\t}\n\n\t\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\t\tif (this.closed || intPoint > 0) {\n\t\t\t\tp0 = points[(intPoint - 1) % l];\n\t\t\t} else {\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors(points[0], points[1]).add(points[0]);\n\t\t\t\tp0 = tmp;\n\t\t\t}\n\n\t\t\tconst p1 = points[intPoint % l];\n\t\t\tconst p2 = points[(intPoint + 1) % l];\n\n\t\t\tif (this.closed || intPoint + 2 < l) {\n\t\t\t\tp3 = points[(intPoint + 2) % l];\n\t\t\t} else {\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n\t\t\t\tp3 = tmp;\n\t\t\t}\n\n\t\t\tif (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tlet dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n\t\t\t\tlet dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n\t\t\t\tlet dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points\n\n\t\t\t\tif (dt1 < 1e-4) dt1 = 1.0;\n\t\t\t\tif (dt0 < 1e-4) dt0 = dt1;\n\t\t\t\tif (dt2 < 1e-4) dt2 = dt1;\n\t\t\t\tpx.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n\t\t\t\tpy.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n\t\t\t\tpz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n\t\t\t} else if (this.curveType === 'catmullrom') {\n\t\t\t\tpx.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n\t\t\t\tpy.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n\t\t\t\tpz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n\t\t\t}\n\n\t\t\tpoint.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = source.points.length; i < l; i++) {\n\t\t\t\tconst point = source.points[i];\n\t\t\t\tthis.points.push(point.clone());\n\t\t\t}\n\n\t\t\tthis.closed = source.closed;\n\t\t\tthis.curveType = source.curveType;\n\t\t\tthis.tension = source.tension;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.points = [];\n\n\t\t\tfor (let i = 0, l = this.points.length; i < l; i++) {\n\t\t\t\tconst point = this.points[i];\n\t\t\t\tdata.points.push(point.toArray());\n\t\t\t}\n\n\t\t\tdata.closed = this.closed;\n\t\t\tdata.curveType = this.curveType;\n\t\t\tdata.tension = this.tension;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = json.points.length; i < l; i++) {\n\t\t\t\tconst point = json.points[i];\n\t\t\t\tthis.points.push(new Vector3().fromArray(point));\n\t\t\t}\n\n\t\t\tthis.closed = json.closed;\n\t\t\tthis.curveType = json.curveType;\n\t\t\tthis.tension = json.tension;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n\t/**\n\t * Bezier Curves formulas obtained from\n\t * http://en.wikipedia.org/wiki/Bézier_curve\n\t */\n\tfunction CatmullRom(t, p0, p1, p2, p3) {\n\t\tconst v0 = (p2 - p0) * 0.5;\n\t\tconst v1 = (p3 - p1) * 0.5;\n\t\tconst t2 = t * t;\n\t\tconst t3 = t * t2;\n\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t} //\n\n\n\tfunction QuadraticBezierP0(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn k * k * p;\n\t}\n\n\tfunction QuadraticBezierP1(t, p) {\n\t\treturn 2 * (1 - t) * t * p;\n\t}\n\n\tfunction QuadraticBezierP2(t, p) {\n\t\treturn t * t * p;\n\t}\n\n\tfunction QuadraticBezier(t, p0, p1, p2) {\n\t\treturn QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n\t} //\n\n\n\tfunction CubicBezierP0(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn k * k * k * p;\n\t}\n\n\tfunction CubicBezierP1(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\t}\n\n\tfunction CubicBezierP2(t, p) {\n\t\treturn 3 * (1 - t) * t * t * p;\n\t}\n\n\tfunction CubicBezierP3(t, p) {\n\t\treturn t * t * t * p;\n\t}\n\n\tfunction CubicBezier(t, p0, p1, p2, p3) {\n\t\treturn CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n\t}\n\n\tclass CubicBezierCurve extends Curve {\n\t\tconstructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubicBezierCurve';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2,\n\t\t\t\t\t\tv3 = this.v3;\n\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\tthis.v3.copy(source.v3);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\tthis.v3.fromArray(json.v3);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\n\tclass CubicBezierCurve3 extends Curve {\n\t\tconstructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubicBezierCurve3';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2,\n\t\t\t\t\t\tv3 = this.v3;\n\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\tthis.v3.copy(source.v3);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\tthis.v3.fromArray(json.v3);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\n\tclass LineCurve extends Curve {\n\t\tconstructor(v1 = new Vector2(), v2 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineCurve';\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\n\t\t\tif (t === 1) {\n\t\t\t\tpoint.copy(this.v2);\n\t\t\t} else {\n\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t}\n\n\t\t\treturn point;\n\t\t} // Line curve is linear, so we can overwrite default getPointAt\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t}\n\n\t\tgetTangent(t, optionalTarget) {\n\t\t\tconst tangent = optionalTarget || new Vector2();\n\t\t\ttangent.copy(this.v2).sub(this.v1).normalize();\n\t\t\treturn tangent;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tclass LineCurve3 extends Curve {\n\t\tconstructor(v1 = new Vector3(), v2 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineCurve3';\n\t\t\tthis.isLineCurve3 = true;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\n\t\t\tif (t === 1) {\n\t\t\t\tpoint.copy(this.v2);\n\t\t\t} else {\n\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t}\n\n\t\t\treturn point;\n\t\t} // Line curve is linear, so we can overwrite default getPointAt\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass QuadraticBezierCurve extends Curve {\n\t\tconstructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'QuadraticBezierCurve';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2;\n\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\n\tclass QuadraticBezierCurve3 extends Curve {\n\t\tconstructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'QuadraticBezierCurve3';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2;\n\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\n\tclass SplineCurve extends Curve {\n\t\tconstructor(points = []) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SplineCurve';\n\t\t\tthis.points = points;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst points = this.points;\n\t\t\tconst p = (points.length - 1) * t;\n\t\t\tconst intPoint = Math.floor(p);\n\t\t\tconst weight = p - intPoint;\n\t\t\tconst p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n\t\t\tconst p1 = points[intPoint];\n\t\t\tconst p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n\t\t\tconst p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n\t\t\tpoint.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = source.points.length; i < l; i++) {\n\t\t\t\tconst point = source.points[i];\n\t\t\t\tthis.points.push(point.clone());\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.points = [];\n\n\t\t\tfor (let i = 0, l = this.points.length; i < l; i++) {\n\t\t\t\tconst point = this.points[i];\n\t\t\t\tdata.points.push(point.toArray());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = json.points.length; i < l; i++) {\n\t\t\t\tconst point = json.points[i];\n\t\t\t\tthis.points.push(new Vector2().fromArray(point));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tvar Curves = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tArcCurve: ArcCurve,\n\t\tCatmullRomCurve3: CatmullRomCurve3,\n\t\tCubicBezierCurve: CubicBezierCurve,\n\t\tCubicBezierCurve3: CubicBezierCurve3,\n\t\tEllipseCurve: EllipseCurve,\n\t\tLineCurve: LineCurve,\n\t\tLineCurve3: LineCurve3,\n\t\tQuadraticBezierCurve: QuadraticBezierCurve,\n\t\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\t\tSplineCurve: SplineCurve\n\t});\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *\tcurves, but retains the api of a curve\n\t **************************************************************/\n\n\tclass CurvePath extends Curve {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'CurvePath';\n\t\t\tthis.curves = [];\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\t}\n\n\t\tadd(curve) {\n\t\t\tthis.curves.push(curve);\n\t\t}\n\n\t\tclosePath() {\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tconst startPoint = this.curves[0].getPoint(0);\n\t\t\tconst endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n\t\t\tif (!startPoint.equals(endPoint)) {\n\t\t\t\tthis.curves.push(new LineCurve(endPoint, startPoint));\n\t\t\t}\n\t\t} // To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\n\t\tgetPoint(t) {\n\t\t\tconst d = t * this.getLength();\n\t\t\tconst curveLengths = this.getCurveLengths();\n\t\t\tlet i = 0; // To think about boundaries points.\n\n\t\t\twhile (i < curveLengths.length) {\n\t\t\t\tif (curveLengths[i] >= d) {\n\t\t\t\t\tconst diff = curveLengths[i] - d;\n\t\t\t\t\tconst curve = this.curves[i];\n\t\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\t\t\t\treturn curve.getPointAt(u);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn null; // loop where sum != 0, sum > d , sum+1 <d\n\t\t} // We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\n\t\tgetLength() {\n\t\t\tconst lens = this.getCurveLengths();\n\t\t\treturn lens[lens.length - 1];\n\t\t} // cacheLengths must be recalculated.\n\n\n\t\tupdateArcLengths() {\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getCurveLengths();\n\t\t} // Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\n\t\tgetCurveLengths() {\n\t\t\t// We use cache values if curves and cache array are same length\n\t\t\tif (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n\t\t\t\treturn this.cacheLengths;\n\t\t\t} // Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\n\t\t\tconst lengths = [];\n\t\t\tlet sums = 0;\n\n\t\t\tfor (let i = 0, l = this.curves.length; i < l; i++) {\n\t\t\t\tsums += this.curves[i].getLength();\n\t\t\t\tlengths.push(sums);\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\t\t\treturn lengths;\n\t\t}\n\n\t\tgetSpacedPoints(divisions = 40) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let i = 0; i <= divisions; i++) {\n\t\t\t\tpoints.push(this.getPoint(i / divisions));\n\t\t\t}\n\n\t\t\tif (this.autoClose) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\treturn points;\n\t\t}\n\n\t\tgetPoints(divisions = 12) {\n\t\t\tconst points = [];\n\t\t\tlet last;\n\n\t\t\tfor (let i = 0, curves = this.curves; i < curves.length; i++) {\n\t\t\t\tconst curve = curves[i];\n\t\t\t\tconst resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n\t\t\t\tconst pts = curve.getPoints(resolution);\n\n\t\t\t\tfor (let j = 0; j < pts.length; j++) {\n\t\t\t\t\tconst point = pts[j];\n\t\t\t\t\tif (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push(point);\n\t\t\t\t\tlast = point;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\treturn points;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.curves = [];\n\n\t\t\tfor (let i = 0, l = source.curves.length; i < l; i++) {\n\t\t\t\tconst curve = source.curves[i];\n\t\t\t\tthis.curves.push(curve.clone());\n\t\t\t}\n\n\t\t\tthis.autoClose = source.autoClose;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.autoClose = this.autoClose;\n\t\t\tdata.curves = [];\n\n\t\t\tfor (let i = 0, l = this.curves.length; i < l; i++) {\n\t\t\t\tconst curve = this.curves[i];\n\t\t\t\tdata.curves.push(curve.toJSON());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.autoClose = json.autoClose;\n\t\t\tthis.curves = [];\n\n\t\t\tfor (let i = 0, l = json.curves.length; i < l; i++) {\n\t\t\t\tconst curve = json.curves[i];\n\t\t\t\tthis.curves.push(new Curves[curve.type]().fromJSON(curve));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Path extends CurvePath {\n\t\tconstructor(points) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Path';\n\t\t\tthis.currentPoint = new Vector2();\n\n\t\t\tif (points) {\n\t\t\t\tthis.setFromPoints(points);\n\t\t\t}\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.moveTo(points[0].x, points[0].y);\n\n\t\t\tfor (let i = 1, l = points.length; i < l; i++) {\n\t\t\t\tthis.lineTo(points[i].x, points[i].y);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tmoveTo(x, y) {\n\t\t\tthis.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlineTo(x, y) {\n\t\t\tconst curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tquadraticCurveTo(aCPx, aCPy, aX, aY) {\n\t\t\tconst curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tbezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\t\t\tconst curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tsplineThru(pts\n\t\t/*Array of Vector*/\n\t\t) {\n\t\t\tconst npts = [this.currentPoint.clone()].concat(pts);\n\t\t\tconst curve = new SplineCurve(npts);\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.copy(pts[pts.length - 1]);\n\t\t\treturn this;\n\t\t}\n\n\t\tarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tconst x0 = this.currentPoint.x;\n\t\t\tconst y0 = this.currentPoint.y;\n\t\t\tthis.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\treturn this;\n\t\t}\n\n\t\tabsarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\treturn this;\n\t\t}\n\n\t\tellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\t\t\tconst x0 = this.currentPoint.x;\n\t\t\tconst y0 = this.currentPoint.y;\n\t\t\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\t\t\treturn this;\n\t\t}\n\n\t\tabsellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\t\t\tconst curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n\t\t\tif (this.curves.length > 0) {\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tconst firstPoint = curve.getPoint(0);\n\n\t\t\t\tif (!firstPoint.equals(this.currentPoint)) {\n\t\t\t\t\tthis.lineTo(firstPoint.x, firstPoint.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.curves.push(curve);\n\t\t\tconst lastPoint = curve.getPoint(1);\n\t\t\tthis.currentPoint.copy(lastPoint);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.currentPoint.copy(source.currentPoint);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.currentPoint = this.currentPoint.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.currentPoint.fromArray(json.currentPoint);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Shape extends Path {\n\t\tconstructor(points) {\n\t\t\tsuper(points);\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.type = 'Shape';\n\t\t\tthis.holes = [];\n\t\t}\n\n\t\tgetPointsHoles(divisions) {\n\t\t\tconst holesPts = [];\n\n\t\t\tfor (let i = 0, l = this.holes.length; i < l; i++) {\n\t\t\t\tholesPts[i] = this.holes[i].getPoints(divisions);\n\t\t\t}\n\n\t\t\treturn holesPts;\n\t\t} // get points of shape and holes (keypoints based on segments parameter)\n\n\n\t\textractPoints(divisions) {\n\t\t\treturn {\n\t\t\t\tshape: this.getPoints(divisions),\n\t\t\t\tholes: this.getPointsHoles(divisions)\n\t\t\t};\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.holes = [];\n\n\t\t\tfor (let i = 0, l = source.holes.length; i < l; i++) {\n\t\t\t\tconst hole = source.holes[i];\n\t\t\t\tthis.holes.push(hole.clone());\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.holes = [];\n\n\t\t\tfor (let i = 0, l = this.holes.length; i < l; i++) {\n\t\t\t\tconst hole = this.holes[i];\n\t\t\t\tdata.holes.push(hole.toJSON());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.uuid = json.uuid;\n\t\t\tthis.holes = [];\n\n\t\t\tfor (let i = 0, l = json.holes.length; i < l; i++) {\n\t\t\t\tconst hole = json.holes[i];\n\t\t\t\tthis.holes.push(new Path().fromJSON(hole));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Light extends Object3D {\n\t\tconstructor(color, intensity = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Light';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.intensity = intensity;\n\t\t}\n\n\t\tdispose() {// Empty here in base class; some subclasses override.\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.intensity = source.intensity;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\t\t\tif (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();\n\t\t\tif (this.distance !== undefined) data.object.distance = this.distance;\n\t\t\tif (this.angle !== undefined) data.object.angle = this.angle;\n\t\t\tif (this.decay !== undefined) data.object.decay = this.decay;\n\t\t\tif (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n\t\t\tif (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tLight.prototype.isLight = true;\n\n\tclass HemisphereLight extends Light {\n\t\tconstructor(skyColor, groundColor, intensity) {\n\t\t\tsuper(skyColor, intensity);\n\t\t\tthis.type = 'HemisphereLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.groundColor = new Color(groundColor);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tLight.prototype.copy.call(this, source);\n\t\t\tthis.groundColor.copy(source.groundColor);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tHemisphereLight.prototype.isHemisphereLight = true;\n\n\tconst _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _lightPositionWorld$1 = /*@__PURE__*/new Vector3();\n\n\tconst _lookTarget$1 = /*@__PURE__*/new Vector3();\n\n\tclass LightShadow {\n\t\tconstructor(camera) {\n\t\t\tthis.camera = camera;\n\t\t\tthis.bias = 0;\n\t\t\tthis.normalBias = 0;\n\t\t\tthis.radius = 1;\n\t\t\tthis.mapSize = new Vector2(512, 512);\n\t\t\tthis.map = null;\n\t\t\tthis.mapPass = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\t\tthis._frustum = new Frustum();\n\t\t\tthis._frameExtents = new Vector2(1, 1);\n\t\t\tthis._viewportCount = 1;\n\t\t\tthis._viewports = [new Vector4(0, 0, 1, 1)];\n\t\t}\n\n\t\tgetViewportCount() {\n\t\t\treturn this._viewportCount;\n\t\t}\n\n\t\tgetFrustum() {\n\t\t\treturn this._frustum;\n\t\t}\n\n\t\tupdateMatrices(light) {\n\t\t\tconst shadowCamera = this.camera;\n\t\t\tconst shadowMatrix = this.matrix;\n\n\t\t\t_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\tshadowCamera.position.copy(_lightPositionWorld$1);\n\n\t\t\t_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n\n\t\t\tshadowCamera.lookAt(_lookTarget$1);\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n\n\t\t\tthis._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n\n\t\t\tshadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\t\t\tshadowMatrix.multiply(shadowCamera.projectionMatrix);\n\t\t\tshadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n\t\t}\n\n\t\tgetViewport(viewportIndex) {\n\t\t\treturn this._viewports[viewportIndex];\n\t\t}\n\n\t\tgetFrameExtents() {\n\t\t\treturn this._frameExtents;\n\t\t}\n\n\t\tdispose() {\n\t\t\tif (this.map) {\n\t\t\t\tthis.map.dispose();\n\t\t\t}\n\n\t\t\tif (this.mapPass) {\n\t\t\t\tthis.mapPass.dispose();\n\t\t\t}\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.camera = source.camera.clone();\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\t\t\tthis.mapSize.copy(source.mapSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst object = {};\n\t\t\tif (this.bias !== 0) object.bias = this.bias;\n\t\t\tif (this.normalBias !== 0) object.normalBias = this.normalBias;\n\t\t\tif (this.radius !== 1) object.radius = this.radius;\n\t\t\tif (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n\t\t\tobject.camera = this.camera.toJSON(false).object;\n\t\t\tdelete object.camera.matrix;\n\t\t\treturn object;\n\t\t}\n\n\t}\n\n\tclass SpotLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new PerspectiveCamera(50, 1, 0.5, 500));\n\t\t\tthis.focus = 1;\n\t\t}\n\n\t\tupdateMatrices(light) {\n\t\t\tconst camera = this.camera;\n\t\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tconst far = light.distance || camera.far;\n\n\t\t\tif (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\tsuper.updateMatrices(light);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.focus = source.focus;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpotLightShadow.prototype.isSpotLightShadow = true;\n\n\tclass SpotLight extends Light {\n\t\tconstructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'SpotLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.target = new Object3D();\n\t\t\tthis.distance = distance;\n\t\t\tthis.angle = angle;\n\t\t\tthis.penumbra = penumbra;\n\t\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\t}\n\n\t\tget power() {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t}\n\n\t\tset power(power) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\t\t\tthis.target = source.target.clone();\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpotLight.prototype.isSpotLight = true;\n\n\tconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _lightPositionWorld = /*@__PURE__*/new Vector3();\n\n\tconst _lookTarget = /*@__PURE__*/new Vector3();\n\n\tclass PointLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new PerspectiveCamera(90, 1, 0.5, 500));\n\t\t\tthis._frameExtents = new Vector2(4, 2);\n\t\t\tthis._viewportCount = 6;\n\t\t\tthis._viewports = [// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//\txzXZ\n\t\t\t//\t y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\t\t\t// positive X\n\t\t\tnew Vector4(2, 1, 1, 1), // negative X\n\t\t\tnew Vector4(0, 1, 1, 1), // positive Z\n\t\t\tnew Vector4(3, 1, 1, 1), // negative Z\n\t\t\tnew Vector4(1, 1, 1, 1), // positive Y\n\t\t\tnew Vector4(3, 0, 1, 1), // negative Y\n\t\t\tnew Vector4(1, 0, 1, 1)];\n\t\t\tthis._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];\n\t\t\tthis._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];\n\t\t}\n\n\t\tupdateMatrices(light, viewportIndex = 0) {\n\t\t\tconst camera = this.camera;\n\t\t\tconst shadowMatrix = this.matrix;\n\t\t\tconst far = light.distance || camera.far;\n\n\t\t\tif (far !== camera.far) {\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\tcamera.position.copy(_lightPositionWorld);\n\n\t\t\t_lookTarget.copy(camera.position);\n\n\t\t\t_lookTarget.add(this._cubeDirections[viewportIndex]);\n\n\t\t\tcamera.up.copy(this._cubeUps[viewportIndex]);\n\t\t\tcamera.lookAt(_lookTarget);\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tshadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n\n\t\t\t_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n\t\t\tthis._frustum.setFromProjectionMatrix(_projScreenMatrix);\n\t\t}\n\n\t}\n\n\tPointLightShadow.prototype.isPointLightShadow = true;\n\n\tclass PointLight extends Light {\n\t\tconstructor(color, intensity, distance = 0, decay = 1) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'PointLight';\n\t\t\tthis.distance = distance;\n\t\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\t\tthis.shadow = new PointLightShadow();\n\t\t}\n\n\t\tget power() {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\t\t}\n\n\t\tset power(power) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / (4 * Math.PI);\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tPointLight.prototype.isPointLight = true;\n\n\tclass OrthographicCamera extends Camera {\n\t\tconstructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {\n\t\t\tsuper();\n\t\t\tthis.type = 'OrthographicCamera';\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign({}, source.view);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetViewOffset(fullWidth, fullHeight, x, y, width, height) {\n\t\t\tif (this.view === null) {\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tclearViewOffset() {\n\t\t\tif (this.view !== null) {\n\t\t\t\tthis.view.enabled = false;\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tupdateProjectionMatrix() {\n\t\t\tconst dx = (this.right - this.left) / (2 * this.zoom);\n\t\t\tconst dy = (this.top - this.bottom) / (2 * this.zoom);\n\t\t\tconst cx = (this.right + this.left) / 2;\n\t\t\tconst cy = (this.top + this.bottom) / 2;\n\t\t\tlet left = cx - dx;\n\t\t\tlet right = cx + dx;\n\t\t\tlet top = cy + dy;\n\t\t\tlet bottom = cy - dy;\n\n\t\t\tif (this.view !== null && this.view.enabled) {\n\t\t\t\tconst scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n\t\t\t\tconst scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\t\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\t\tright = left + scaleW * this.view.width;\n\t\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\t\tbottom = top - scaleH * this.view.height;\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n\t\t\tthis.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tif (this.view !== null) data.object.view = Object.assign({}, this.view);\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tOrthographicCamera.prototype.isOrthographicCamera = true;\n\n\tclass DirectionalLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n\t\t}\n\n\t}\n\n\tDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\n\tclass DirectionalLight extends Light {\n\t\tconstructor(color, intensity) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'DirectionalLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.target = new Object3D();\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.target = source.target.clone();\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tDirectionalLight.prototype.isDirectionalLight = true;\n\n\tclass AmbientLight extends Light {\n\t\tconstructor(color, intensity) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'AmbientLight';\n\t\t}\n\n\t}\n\n\tAmbientLight.prototype.isAmbientLight = true;\n\n\tclass RectAreaLight extends Light {\n\t\tconstructor(color, intensity, width = 10, height = 10) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'RectAreaLight';\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.width = this.width;\n\t\t\tdata.object.height = this.height;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tRectAreaLight.prototype.isRectAreaLight = true;\n\n\t/**\n\t * Primary reference:\n\t *\t https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\t *\n\t * Secondary reference:\n\t *\t https://www.ppsloan.org/publications/StupidSH36.pdf\n\t */\n\t// 3-band SH defined by 9 coefficients\n\n\tclass SphericalHarmonics3 {\n\t\tconstructor() {\n\t\t\tthis.coefficients = [];\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients.push(new Vector3());\n\t\t\t}\n\t\t}\n\n\t\tset(coefficients) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].copy(coefficients[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tzero() {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].set(0, 0, 0);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // get the radiance in the direction of the normal\n\t\t// target is a Vector3\n\n\n\t\tgetAt(normal, target) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z;\n\t\t\tconst coeff = this.coefficients; // band 0\n\n\t\t\ttarget.copy(coeff[0]).multiplyScalar(0.282095); // band 1\n\n\t\t\ttarget.addScaledVector(coeff[1], 0.488603 * y);\n\t\t\ttarget.addScaledVector(coeff[2], 0.488603 * z);\n\t\t\ttarget.addScaledVector(coeff[3], 0.488603 * x); // band 2\n\n\t\t\ttarget.addScaledVector(coeff[4], 1.092548 * (x * y));\n\t\t\ttarget.addScaledVector(coeff[5], 1.092548 * (y * z));\n\t\t\ttarget.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n\t\t\ttarget.addScaledVector(coeff[7], 1.092548 * (x * z));\n\t\t\ttarget.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n\t\t\treturn target;\n\t\t} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t\t// target is a Vector3\n\t\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n\n\t\tgetIrradianceAt(normal, target) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z;\n\t\t\tconst coeff = this.coefficients; // band 0\n\n\t\t\ttarget.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095\n\t\t\t// band 1\n\n\t\t\ttarget.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603\n\n\t\t\ttarget.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n\t\t\ttarget.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2\n\n\t\t\ttarget.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548\n\n\t\t\ttarget.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n\t\t\ttarget.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3\n\n\t\t\ttarget.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n\t\t\ttarget.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274\n\n\t\t\treturn target;\n\t\t}\n\n\t\tadd(sh) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].add(sh.coefficients[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledSH(sh, s) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].addScaledVector(sh.coefficients[i], s);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(s) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].multiplyScalar(s);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlerp(sh, alpha) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].lerp(sh.coefficients[i], alpha);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(sh) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tif (!this.coefficients[i].equals(sh.coefficients[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcopy(sh) {\n\t\t\treturn this.set(sh.coefficients);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tconst coefficients = this.coefficients;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tcoefficients[i].fromArray(array, offset + i * 3);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst coefficients = this.coefficients;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tcoefficients[i].toArray(array, offset + i * 3);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t} // evaluate the basis functions\n\t\t// shBasis is an Array[ 9 ]\n\n\n\t\tstatic getBasisAt(normal, shBasis) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z; // band 0\n\n\t\t\tshBasis[0] = 0.282095; // band 1\n\n\t\t\tshBasis[1] = 0.488603 * y;\n\t\t\tshBasis[2] = 0.488603 * z;\n\t\t\tshBasis[3] = 0.488603 * x; // band 2\n\n\t\t\tshBasis[4] = 1.092548 * x * y;\n\t\t\tshBasis[5] = 1.092548 * y * z;\n\t\t\tshBasis[6] = 0.315392 * (3 * z * z - 1);\n\t\t\tshBasis[7] = 1.092548 * x * z;\n\t\t\tshBasis[8] = 0.546274 * (x * x - y * y);\n\t\t}\n\n\t}\n\n\tSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\n\tclass LightProbe extends Light {\n\t\tconstructor(sh = new SphericalHarmonics3(), intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tthis.sh = sh;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.sh.copy(source.sh);\n\t\t\treturn this;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\n\t\t\tthis.sh.fromArray(json.sh);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.sh = this.sh.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tLightProbe.prototype.isLightProbe = true;\n\n\tclass MaterialLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t\tthis.textures = {};\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(scope.manager);\n\t\t\tloader.setPath(scope.path);\n\t\t\tloader.setRequestHeader(scope.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst textures = this.textures;\n\n\t\t\tfunction getTexture(name) {\n\t\t\t\tif (textures[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.MaterialLoader: Undefined texture', name);\n\t\t\t\t}\n\n\t\t\t\treturn textures[name];\n\t\t\t}\n\n\t\t\tconst material = new Materials[json.type]();\n\t\t\tif (json.uuid !== undefined) material.uuid = json.uuid;\n\t\t\tif (json.name !== undefined) material.name = json.name;\n\t\t\tif (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);\n\t\t\tif (json.roughness !== undefined) material.roughness = json.roughness;\n\t\t\tif (json.metalness !== undefined) material.metalness = json.metalness;\n\t\t\tif (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);\n\t\t\tif (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);\n\t\t\tif (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);\n\t\t\tif (json.shininess !== undefined) material.shininess = json.shininess;\n\t\t\tif (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;\n\t\t\tif (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\t\tif (json.transmission !== undefined) material.transmission = json.transmission;\n\t\t\tif (json.thickness !== undefined) material.thickness = json.thickness;\n\t\t\tif (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;\n\t\t\tif (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);\n\t\t\tif (json.fog !== undefined) material.fog = json.fog;\n\t\t\tif (json.flatShading !== undefined) material.flatShading = json.flatShading;\n\t\t\tif (json.blending !== undefined) material.blending = json.blending;\n\t\t\tif (json.combine !== undefined) material.combine = json.combine;\n\t\t\tif (json.side !== undefined) material.side = json.side;\n\t\t\tif (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;\n\t\t\tif (json.opacity !== undefined) material.opacity = json.opacity;\n\t\t\tif (json.transparent !== undefined) material.transparent = json.transparent;\n\t\t\tif (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;\n\t\t\tif (json.depthTest !== undefined) material.depthTest = json.depthTest;\n\t\t\tif (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;\n\t\t\tif (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;\n\t\t\tif (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;\n\t\t\tif (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;\n\t\t\tif (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;\n\t\t\tif (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;\n\t\t\tif (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;\n\t\t\tif (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;\n\t\t\tif (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;\n\t\t\tif (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;\n\t\t\tif (json.wireframe !== undefined) material.wireframe = json.wireframe;\n\t\t\tif (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif (json.rotation !== undefined) material.rotation = json.rotation;\n\t\t\tif (json.linewidth !== 1) material.linewidth = json.linewidth;\n\t\t\tif (json.dashSize !== undefined) material.dashSize = json.dashSize;\n\t\t\tif (json.gapSize !== undefined) material.gapSize = json.gapSize;\n\t\t\tif (json.scale !== undefined) material.scale = json.scale;\n\t\t\tif (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;\n\t\t\tif (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\t\tif (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\t\t\tif (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;\n\t\t\tif (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;\n\t\t\tif (json.dithering !== undefined) material.dithering = json.dithering;\n\t\t\tif (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;\n\t\t\tif (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\t\tif (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;\n\t\t\tif (json.visible !== undefined) material.visible = json.visible;\n\t\t\tif (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;\n\t\t\tif (json.userData !== undefined) material.userData = json.userData;\n\n\t\t\tif (json.vertexColors !== undefined) {\n\t\t\t\tif (typeof json.vertexColors === 'number') {\n\t\t\t\t\tmaterial.vertexColors = json.vertexColors > 0 ? true : false;\n\t\t\t\t} else {\n\t\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\t\t\t\t}\n\t\t\t} // Shader Material\n\n\n\t\t\tif (json.uniforms !== undefined) {\n\t\t\t\tfor (const name in json.uniforms) {\n\t\t\t\t\tconst uniform = json.uniforms[name];\n\t\t\t\t\tmaterial.uniforms[name] = {};\n\n\t\t\t\t\tswitch (uniform.type) {\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = getTexture(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Color().setHex(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector2().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector3().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector4().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Matrix3().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Matrix4().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = uniform.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (json.defines !== undefined) material.defines = json.defines;\n\t\t\tif (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;\n\t\t\tif (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;\n\n\t\t\tif (json.extensions !== undefined) {\n\t\t\t\tfor (const key in json.extensions) {\n\t\t\t\t\tmaterial.extensions[key] = json.extensions[key];\n\t\t\t\t}\n\t\t\t} // Deprecated\n\n\n\t\t\tif (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading\n\t\t\t// for PointsMaterial\n\n\t\t\tif (json.size !== undefined) material.size = json.size;\n\t\t\tif (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps\n\n\t\t\tif (json.map !== undefined) material.map = getTexture(json.map);\n\t\t\tif (json.matcap !== undefined) material.matcap = getTexture(json.matcap);\n\t\t\tif (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);\n\t\t\tif (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);\n\t\t\tif (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;\n\t\t\tif (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);\n\t\t\tif (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;\n\n\t\t\tif (json.normalScale !== undefined) {\n\t\t\t\tlet normalScale = json.normalScale;\n\n\t\t\t\tif (Array.isArray(normalScale) === false) {\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\t\t\t\tnormalScale = [normalScale, normalScale];\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray(normalScale);\n\t\t\t}\n\n\t\t\tif (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);\n\t\t\tif (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;\n\t\t\tif (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;\n\t\t\tif (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);\n\t\t\tif (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);\n\t\t\tif (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);\n\t\t\tif (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;\n\t\t\tif (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);\n\t\t\tif (json.envMap !== undefined) material.envMap = getTexture(json.envMap);\n\t\t\tif (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;\n\t\t\tif (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;\n\t\t\tif (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;\n\t\t\tif (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);\n\t\t\tif (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;\n\t\t\tif (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);\n\t\t\tif (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;\n\t\t\tif (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);\n\t\t\tif (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);\n\t\t\tif (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);\n\t\t\tif (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);\n\t\t\tif (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);\n\t\t\tif (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);\n\t\t\tif (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);\n\t\t\treturn material;\n\t\t}\n\n\t\tsetTextures(value) {\n\t\t\tthis.textures = value;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass LoaderUtils {\n\t\tstatic decodeText(array) {\n\t\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\t\treturn new TextDecoder().decode(array);\n\t\t\t} // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\n\t\t\tlet s = '';\n\n\t\t\tfor (let i = 0, il = array.length; i < il; i++) {\n\t\t\t\t// Implicitly assumes little-endian.\n\t\t\t\ts += String.fromCharCode(array[i]);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// merges multi-byte utf-8 characters.\n\t\t\t\treturn decodeURIComponent(escape(s));\n\t\t\t} catch (e) {\n\t\t\t\t// see #16358\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\n\t\tstatic extractUrlBase(url) {\n\t\t\tconst index = url.lastIndexOf('/');\n\t\t\tif (index === -1) return './';\n\t\t\treturn url.substr(0, index + 1);\n\t\t}\n\n\t}\n\n\tclass InstancedBufferGeometry extends BufferGeometry {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.instanceCount = Infinity;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.instanceCount = source.instanceCount;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON(this);\n\t\t\tdata.instanceCount = this.instanceCount;\n\t\t\tdata.isInstancedBufferGeometry = true;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tclass InstancedBufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized, meshPerAttribute) {\n\t\t\tif (typeof normalized === 'number') {\n\t\t\t\tmeshPerAttribute = normalized;\n\t\t\t\tnormalized = false;\n\t\t\t\tconsole.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');\n\t\t\t}\n\n\t\t\tsuper(array, itemSize, normalized);\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\t\t\tdata.isInstancedBufferAttribute = true;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tclass BufferGeometryLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(scope.manager);\n\t\t\tloader.setPath(scope.path);\n\t\t\tloader.setRequestHeader(scope.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst interleavedBufferMap = {};\n\t\t\tconst arrayBufferMap = {};\n\n\t\t\tfunction getInterleavedBuffer(json, uuid) {\n\t\t\t\tif (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n\t\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\t\tconst interleavedBuffer = interleavedBuffers[uuid];\n\t\t\t\tconst buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n\t\t\t\tconst array = getTypedArray(interleavedBuffer.type, buffer);\n\t\t\t\tconst ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n\t\t\t\tib.uuid = interleavedBuffer.uuid;\n\t\t\t\tinterleavedBufferMap[uuid] = ib;\n\t\t\t\treturn ib;\n\t\t\t}\n\n\t\t\tfunction getArrayBuffer(json, uuid) {\n\t\t\t\tif (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n\t\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\t\tconst arrayBuffer = arrayBuffers[uuid];\n\t\t\t\tconst ab = new Uint32Array(arrayBuffer).buffer;\n\t\t\t\tarrayBufferMap[uuid] = ab;\n\t\t\t\treturn ab;\n\t\t\t}\n\n\t\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\t\t\tconst index = json.data.index;\n\n\t\t\tif (index !== undefined) {\n\t\t\t\tconst typedArray = getTypedArray(index.type, index.array);\n\t\t\t\tgeometry.setIndex(new BufferAttribute(typedArray, 1));\n\t\t\t}\n\n\t\t\tconst attributes = json.data.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tlet bufferAttribute;\n\n\t\t\t\tif (attribute.isInterleavedBufferAttribute) {\n\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n\t\t\t\t} else {\n\t\t\t\t\tconst typedArray = getTypedArray(attribute.type, attribute.array);\n\t\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\t\tbufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n\t\t\t\t}\n\n\t\t\t\tif (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n\t\t\t\tif (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n\n\t\t\t\tif (attribute.updateRange !== undefined) {\n\t\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute(key, bufferAttribute);\n\t\t\t}\n\n\t\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\t\tif (morphAttributes) {\n\t\t\t\tfor (const key in morphAttributes) {\n\t\t\t\t\tconst attributeArray = morphAttributes[key];\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor (let i = 0, il = attributeArray.length; i < il; i++) {\n\t\t\t\t\t\tconst attribute = attributeArray[i];\n\t\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\t\tif (attribute.isInterleavedBufferAttribute) {\n\t\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n\t\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst typedArray = getTypedArray(attribute.type, attribute.array);\n\t\t\t\t\t\t\tbufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n\t\t\t\t\t\tarray.push(bufferAttribute);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.morphAttributes[key] = array;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\t\tif (morphTargetsRelative) {\n\t\t\t\tgeometry.morphTargetsRelative = true;\n\t\t\t}\n\n\t\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif (groups !== undefined) {\n\t\t\t\tfor (let i = 0, n = groups.length; i !== n; ++i) {\n\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\tgeometry.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\t\tif (boundingSphere !== undefined) {\n\t\t\t\tconst center = new Vector3();\n\n\t\t\t\tif (boundingSphere.center !== undefined) {\n\t\t\t\t\tcenter.fromArray(boundingSphere.center);\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n\t\t\t}\n\n\t\t\tif (json.name) geometry.name = json.name;\n\t\t\tif (json.userData) geometry.userData = json.userData;\n\t\t\treturn geometry;\n\t\t}\n\n\t}\n\n\tclass ObjectLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n\t\t\tthis.resourcePath = this.resourcePath || path;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\tlet json = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(text);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (onError !== undefined) onError(error);\n\t\t\t\t\tconsole.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst metadata = json.metadata;\n\n\t\t\t\tif (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n\t\t\t\t\tconsole.error('THREE.ObjectLoader: Can\\'t load ' + url);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tscope.parse(json, onLoad);\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json, onLoad) {\n\t\t\tconst animations = this.parseAnimations(json.animations);\n\t\t\tconst shapes = this.parseShapes(json.shapes);\n\t\t\tconst geometries = this.parseGeometries(json.geometries, shapes);\n\t\t\tconst images = this.parseImages(json.images, function () {\n\t\t\t\tif (onLoad !== undefined) onLoad(object);\n\t\t\t});\n\t\t\tconst textures = this.parseTextures(json.textures, images);\n\t\t\tconst materials = this.parseMaterials(json.materials, textures);\n\t\t\tconst object = this.parseObject(json.object, geometries, materials, animations);\n\t\t\tconst skeletons = this.parseSkeletons(json.skeletons, object);\n\t\t\tthis.bindSkeletons(object, skeletons); //\n\n\t\t\tif (onLoad !== undefined) {\n\t\t\t\tlet hasImages = false;\n\n\t\t\t\tfor (const uuid in images) {\n\t\t\t\t\tif (images[uuid] instanceof HTMLImageElement) {\n\t\t\t\t\t\thasImages = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hasImages === false) onLoad(object);\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\n\t\tparseShapes(json) {\n\t\t\tconst shapes = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst shape = new Shape().fromJSON(json[i]);\n\t\t\t\t\tshapes[shape.uuid] = shape;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn shapes;\n\t\t}\n\n\t\tparseSkeletons(json, object) {\n\t\t\tconst skeletons = {};\n\t\t\tconst bones = {}; // generate bone lookup table\n\n\t\t\tobject.traverse(function (child) {\n\t\t\t\tif (child.isBone) bones[child.uuid] = child;\n\t\t\t}); // create skeletons\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst skeleton = new Skeleton().fromJSON(json[i], bones);\n\t\t\t\t\tskeletons[skeleton.uuid] = skeleton;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn skeletons;\n\t\t}\n\n\t\tparseGeometries(json, shapes) {\n\t\t\tconst geometries = {};\n\t\t\tlet geometryShapes;\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tlet geometry;\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tswitch (data.type) {\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.detail);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TubeGeometry':\n\t\t\t\t\t\tcase 'TubeBufferGeometry':\n\t\t\t\t\t\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t\t\t\t\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\t\tcase 'ShapeBufferGeometry':\n\t\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\t\tfor (let j = 0, jl = data.shapes.length; j < jl; j++) {\n\t\t\t\t\t\t\t\tconst shape = shapes[data.shapes[j]];\n\t\t\t\t\t\t\t\tgeometryShapes.push(shape);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](geometryShapes, data.curveSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ExtrudeGeometry':\n\t\t\t\t\t\tcase 'ExtrudeBufferGeometry':\n\t\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\t\tfor (let j = 0, jl = data.shapes.length; j < jl; j++) {\n\t\t\t\t\t\t\t\tconst shape = shapes[data.shapes[j]];\n\t\t\t\t\t\t\t\tgeometryShapes.push(shape);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst extrudePath = data.options.extrudePath;\n\n\t\t\t\t\t\t\tif (extrudePath !== undefined) {\n\t\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](geometryShapes, data.options);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\t\tcase 'InstancedBufferGeometry':\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse(data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\t\t\t\t\t\t\tconsole.error('THREE.ObjectLoader: Loading \"Geometry\" is not supported anymore.');\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"');\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\t\t\t\tif (data.name !== undefined) geometry.name = data.name;\n\t\t\t\t\tif (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;\n\t\t\t\t\tgeometries[data.uuid] = geometry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometries;\n\t\t}\n\n\t\tparseMaterials(json, textures) {\n\t\t\tconst cache = {}; // MultiMaterial\n\n\t\t\tconst materials = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tconst loader = new MaterialLoader();\n\t\t\t\tloader.setTextures(textures);\n\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tif (data.type === 'MultiMaterial') {\n\t\t\t\t\t\t// Deprecated\n\t\t\t\t\t\tconst array = [];\n\n\t\t\t\t\t\tfor (let j = 0; j < data.materials.length; j++) {\n\t\t\t\t\t\t\tconst material = data.materials[j];\n\n\t\t\t\t\t\t\tif (cache[material.uuid] === undefined) {\n\t\t\t\t\t\t\t\tcache[material.uuid] = loader.parse(material);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray.push(cache[material.uuid]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[data.uuid] = array;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cache[data.uuid] === undefined) {\n\t\t\t\t\t\t\tcache[data.uuid] = loader.parse(data);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[data.uuid] = cache[data.uuid];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tparseAnimations(json) {\n\t\t\tconst animations = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\t\tconst data = json[i];\n\t\t\t\t\tconst clip = AnimationClip.parse(data);\n\t\t\t\t\tanimations[clip.uuid] = clip;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn animations;\n\t\t}\n\n\t\tparseImages(json, onLoad) {\n\t\t\tconst scope = this;\n\t\t\tconst images = {};\n\t\t\tlet loader;\n\n\t\t\tfunction loadImage(url) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\treturn loader.load(url, function () {\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, undefined, function () {\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction deserializeImage(image) {\n\t\t\t\tif (typeof image === 'string') {\n\t\t\t\t\tconst url = image;\n\t\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n\t\t\t\t\treturn loadImage(path);\n\t\t\t\t} else {\n\t\t\t\t\tif (image.data) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdata: getTypedArray(image.type, image.data),\n\t\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\t\theight: image.height\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (json !== undefined && json.length > 0) {\n\t\t\t\tconst manager = new LoadingManager(onLoad);\n\t\t\t\tloader = new ImageLoader(manager);\n\t\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\n\t\t\t\tfor (let i = 0, il = json.length; i < il; i++) {\n\t\t\t\t\tconst image = json[i];\n\t\t\t\t\tconst url = image.url;\n\n\t\t\t\t\tif (Array.isArray(url)) {\n\t\t\t\t\t\t// load array of images e.g CubeTexture\n\t\t\t\t\t\timages[image.uuid] = [];\n\n\t\t\t\t\t\tfor (let j = 0, jl = url.length; j < jl; j++) {\n\t\t\t\t\t\t\tconst currentUrl = url[j];\n\t\t\t\t\t\t\tconst deserializedImage = deserializeImage(currentUrl);\n\n\t\t\t\t\t\t\tif (deserializedImage !== null) {\n\t\t\t\t\t\t\t\tif (deserializedImage instanceof HTMLImageElement) {\n\t\t\t\t\t\t\t\t\timages[image.uuid].push(deserializedImage);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\t\t\t\t\t\t\t\t\timages[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// load single image\n\t\t\t\t\t\tconst deserializedImage = deserializeImage(image.url);\n\n\t\t\t\t\t\tif (deserializedImage !== null) {\n\t\t\t\t\t\t\timages[image.uuid] = deserializedImage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn images;\n\t\t}\n\n\t\tparseTextures(json, images) {\n\t\t\tfunction parseConstant(value, type) {\n\t\t\t\tif (typeof value === 'number') return value;\n\t\t\t\tconsole.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n\t\t\t\treturn type[value];\n\t\t\t}\n\n\t\t\tconst textures = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tif (data.image === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (images[data.image] === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined image', data.image);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet texture;\n\t\t\t\t\tconst image = images[data.image];\n\n\t\t\t\t\tif (Array.isArray(image)) {\n\t\t\t\t\t\ttexture = new CubeTexture(image);\n\t\t\t\t\t\tif (image.length === 6) texture.needsUpdate = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (image && image.data) {\n\t\t\t\t\t\t\ttexture = new DataTexture(image.data, image.width, image.height);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexture = new Texture(image);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (image) texture.needsUpdate = true; // textures can have undefined image data\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\t\t\t\t\tif (data.name !== undefined) texture.name = data.name;\n\t\t\t\t\tif (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n\t\t\t\t\tif (data.offset !== undefined) texture.offset.fromArray(data.offset);\n\t\t\t\t\tif (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n\t\t\t\t\tif (data.center !== undefined) texture.center.fromArray(data.center);\n\t\t\t\t\tif (data.rotation !== undefined) texture.rotation = data.rotation;\n\n\t\t\t\t\tif (data.wrap !== undefined) {\n\t\t\t\t\t\ttexture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n\t\t\t\t\t\ttexture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.format !== undefined) texture.format = data.format;\n\t\t\t\t\tif (data.type !== undefined) texture.type = data.type;\n\t\t\t\t\tif (data.encoding !== undefined) texture.encoding = data.encoding;\n\t\t\t\t\tif (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n\t\t\t\t\tif (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n\t\t\t\t\tif (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n\t\t\t\t\tif (data.flipY !== undefined) texture.flipY = data.flipY;\n\t\t\t\t\tif (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\t\tif (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\t\ttextures[data.uuid] = texture;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn textures;\n\t\t}\n\n\t\tparseObject(data, geometries, materials, animations) {\n\t\t\tlet object;\n\n\t\t\tfunction getGeometry(name) {\n\t\t\t\tif (geometries[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined geometry', name);\n\t\t\t\t}\n\n\t\t\t\treturn geometries[name];\n\t\t\t}\n\n\t\t\tfunction getMaterial(name) {\n\t\t\t\tif (name === undefined) return undefined;\n\n\t\t\t\tif (Array.isArray(name)) {\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor (let i = 0, l = name.length; i < l; i++) {\n\t\t\t\t\t\tconst uuid = name[i];\n\n\t\t\t\t\t\tif (materials[uuid] === undefined) {\n\t\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined material', uuid);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push(materials[uuid]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array;\n\t\t\t\t}\n\n\t\t\t\tif (materials[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined material', name);\n\t\t\t\t}\n\n\t\t\t\treturn materials[name];\n\t\t\t}\n\n\t\t\tlet geometry, material;\n\n\t\t\tswitch (data.type) {\n\t\t\t\tcase 'Scene':\n\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\tif (data.background !== undefined) {\n\t\t\t\t\t\tif (Number.isInteger(data.background)) {\n\t\t\t\t\t\t\tobject.background = new Color(data.background);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.fog !== undefined) {\n\t\t\t\t\t\tif (data.fog.type === 'Fog') {\n\t\t\t\t\t\t\tobject.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n\t\t\t\t\t\t} else if (data.fog.type === 'FogExp2') {\n\t\t\t\t\t\t\tobject.fog = new FogExp2(data.fog.color, data.fog.density);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\t\t\t\t\tobject = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n\t\t\t\t\tif (data.focus !== undefined) object.focus = data.focus;\n\t\t\t\t\tif (data.zoom !== undefined) object.zoom = data.zoom;\n\t\t\t\t\tif (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif (data.view !== undefined) object.view = Object.assign({}, data.view);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\t\t\t\t\tobject = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n\t\t\t\t\tif (data.zoom !== undefined) object.zoom = data.zoom;\n\t\t\t\t\tif (data.view !== undefined) object.view = Object.assign({}, data.view);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\t\t\t\t\tobject = new AmbientLight(data.color, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tobject = new DirectionalLight(data.color, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tobject = new PointLight(data.color, data.intensity, data.distance, data.decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tobject = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tobject = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tobject = new HemisphereLight(data.color, data.groundColor, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LightProbe':\n\t\t\t\t\tobject = new LightProbe().fromJSON(data);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SkinnedMesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tobject = new SkinnedMesh(geometry, material);\n\t\t\t\t\tif (data.bindMode !== undefined) object.bindMode = data.bindMode;\n\t\t\t\t\tif (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n\t\t\t\t\tif (data.skeleton !== undefined) object.skeleton = data.skeleton;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tobject = new Mesh(geometry, material);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'InstancedMesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tconst count = data.count;\n\t\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\t\tconst instanceColor = data.instanceColor;\n\t\t\t\t\tobject = new InstancedMesh(geometry, material, count);\n\t\t\t\t\tobject.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);\n\t\t\t\t\tif (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\t\t\t\t\tobject = new LOD();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\t\t\t\t\tobject = new Line(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineLoop':\n\t\t\t\t\tobject = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineSegments':\n\t\t\t\t\tobject = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\t\t\t\t\tobject = new Points(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\t\t\t\t\tobject = new Sprite(getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\t\t\t\t\tobject = new Group();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Bone':\n\t\t\t\t\tobject = new Bone();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tobject = new Object3D();\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\t\t\tif (data.name !== undefined) object.name = data.name;\n\n\t\t\tif (data.matrix !== undefined) {\n\t\t\t\tobject.matrix.fromArray(data.matrix);\n\t\t\t\tif (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\t\tif (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n\t\t\t} else {\n\t\t\t\tif (data.position !== undefined) object.position.fromArray(data.position);\n\t\t\t\tif (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n\t\t\t\tif (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n\t\t\t\tif (data.scale !== undefined) object.scale.fromArray(data.scale);\n\t\t\t}\n\n\t\t\tif (data.castShadow !== undefined) object.castShadow = data.castShadow;\n\t\t\tif (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif (data.shadow) {\n\t\t\t\tif (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n\t\t\t\tif (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\t\tif (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n\t\t\t\tif (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n\t\t\t\tif (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n\t\t\t}\n\n\t\t\tif (data.visible !== undefined) object.visible = data.visible;\n\t\t\tif (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n\t\t\tif (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n\t\t\tif (data.userData !== undefined) object.userData = data.userData;\n\t\t\tif (data.layers !== undefined) object.layers.mask = data.layers;\n\n\t\t\tif (data.children !== undefined) {\n\t\t\t\tconst children = data.children;\n\n\t\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\t\tobject.add(this.parseObject(children[i], geometries, materials, animations));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.animations !== undefined) {\n\t\t\t\tconst objectAnimations = data.animations;\n\n\t\t\t\tfor (let i = 0; i < objectAnimations.length; i++) {\n\t\t\t\t\tconst uuid = objectAnimations[i];\n\t\t\t\t\tobject.animations.push(animations[uuid]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.type === 'LOD') {\n\t\t\t\tif (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n\t\t\t\tconst levels = data.levels;\n\n\t\t\t\tfor (let l = 0; l < levels.length; l++) {\n\t\t\t\t\tconst level = levels[l];\n\t\t\t\t\tconst child = object.getObjectByProperty('uuid', level.object);\n\n\t\t\t\t\tif (child !== undefined) {\n\t\t\t\t\t\tobject.addLevel(child, level.distance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\n\t\tbindSkeletons(object, skeletons) {\n\t\t\tif (Object.keys(skeletons).length === 0) return;\n\t\t\tobject.traverse(function (child) {\n\t\t\t\tif (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n\t\t\t\t\tconst skeleton = skeletons[child.skeleton];\n\n\t\t\t\t\tif (skeleton === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.bind(skeleton, child.bindMatrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t/* DEPRECATED */\n\n\n\t\tsetTexturePath(value) {\n\t\t\tconsole.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');\n\t\t\treturn this.setResourcePath(value);\n\t\t}\n\n\t}\n\n\tconst TEXTURE_MAPPING = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tconst TEXTURE_WRAPPING = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tconst TEXTURE_FILTER = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\t\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\t\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n\t};\n\n\tclass ImageBitmapLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\n\t\t\tif (typeof createImageBitmap === 'undefined') {\n\t\t\t\tconsole.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');\n\t\t\t}\n\n\t\t\tif (typeof fetch === 'undefined') {\n\t\t\t\tconsole.warn('THREE.ImageBitmapLoader: fetch() not supported.');\n\t\t\t}\n\n\t\t\tthis.options = {\n\t\t\t\tpremultiplyAlpha: 'none'\n\t\t\t};\n\t\t}\n\n\t\tsetOptions(options) {\n\t\t\tthis.options = options;\n\t\t\treturn this;\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (url === undefined) url = '';\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tconst fetchOptions = {};\n\t\t\tfetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';\n\t\t\tfetchOptions.headers = this.requestHeader;\n\t\t\tfetch(url, fetchOptions).then(function (res) {\n\t\t\t\treturn res.blob();\n\t\t\t}).then(function (blob) {\n\t\t\t\treturn createImageBitmap(blob, Object.assign(scope.options, {\n\t\t\t\t\tcolorSpaceConversion: 'none'\n\t\t\t\t}));\n\t\t\t}).then(function (imageBitmap) {\n\t\t\t\tCache.add(url, imageBitmap);\n\t\t\t\tif (onLoad) onLoad(imageBitmap);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}).catch(function (e) {\n\t\t\t\tif (onError) onError(e);\n\t\t\t\tscope.manager.itemError(url);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t});\n\t\t\tscope.manager.itemStart(url);\n\t\t}\n\n\t}\n\n\tImageBitmapLoader.prototype.isImageBitmapLoader = true;\n\n\tclass ShapePath {\n\t\tconstructor() {\n\t\t\tthis.type = 'ShapePath';\n\t\t\tthis.color = new Color();\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\t}\n\n\t\tmoveTo(x, y) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tlineTo(x, y) {\n\t\t\tthis.currentPath.lineTo(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tquadraticCurveTo(aCPx, aCPy, aX, aY) {\n\t\t\tthis.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tbezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\t\t\tthis.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tsplineThru(pts) {\n\t\t\tthis.currentPath.splineThru(pts);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoShapes(isCCW, noHoles) {\n\t\t\tfunction toShapesNoHoles(inSubpaths) {\n\t\t\t\tconst shapes = [];\n\n\t\t\t\tfor (let i = 0, l = inSubpaths.length; i < l; i++) {\n\t\t\t\t\tconst tmpPath = inSubpaths[i];\n\t\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push(tmpShape);\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon(inPt, inPolygon) {\n\t\t\t\tconst polyLen = inPolygon.length; // inPt on polygon contour => immediate success\t\tor\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//\twith the horizontal line through inPt, left of inPt\n\t\t\t\t//\tnot counting lowerY endpoints of edges and whole edges on that line\n\n\t\t\t\tlet inside = false;\n\n\t\t\t\tfor (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n\t\t\t\t\tlet edgeLowPt = inPolygon[p];\n\t\t\t\t\tlet edgeHighPt = inPolygon[q];\n\t\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif (Math.abs(edgeDy) > Number.EPSILON) {\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif (edgeDy < 0) {\n\t\t\t\t\t\t\tedgeLowPt = inPolygon[q];\n\t\t\t\t\t\t\tedgeDx = -edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[p];\n\t\t\t\t\t\t\tedgeDy = -edgeDy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n\t\t\t\t\t\tif (inPt.y === edgeLowPt.y) {\n\t\t\t\t\t\t\tif (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n\t\t\t\t\t\t\tif (perpEdge === 0) return true; // inPt is on contour ?\n\n\t\t\t\t\t\t\tif (perpEdge < 0) continue;\n\t\t\t\t\t\t\tinside = !inside; // true intersection left of inPt\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif (inPt.y !== edgeLowPt.y) continue; // parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\n\t\t\t\t\t\tif (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn inside;\n\t\t\t}\n\n\t\t\tconst isClockWise = ShapeUtils.isClockWise;\n\t\t\tconst subPaths = this.subPaths;\n\t\t\tif (subPaths.length === 0) return [];\n\t\t\tif (noHoles === true) return toShapesNoHoles(subPaths);\n\t\t\tlet solid, tmpPath, tmpShape;\n\t\t\tconst shapes = [];\n\n\t\t\tif (subPaths.length === 1) {\n\t\t\t\ttmpPath = subPaths[0];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push(tmpShape);\n\t\t\t\treturn shapes;\n\t\t\t}\n\n\t\t\tlet holesFirst = !isClockWise(subPaths[0].getPoints());\n\t\t\tholesFirst = isCCW ? !holesFirst : holesFirst; // console.log(\"Holes first\", holesFirst);\n\n\t\t\tconst betterShapeHoles = [];\n\t\t\tconst newShapes = [];\n\t\t\tlet newShapeHoles = [];\n\t\t\tlet mainIdx = 0;\n\t\t\tlet tmpPoints;\n\t\t\tnewShapes[mainIdx] = undefined;\n\t\t\tnewShapeHoles[mainIdx] = [];\n\n\t\t\tfor (let i = 0, l = subPaths.length; i < l; i++) {\n\t\t\t\ttmpPath = subPaths[i];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise(tmpPoints);\n\t\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\t\tif (solid) {\n\t\t\t\t\tif (!holesFirst && newShapes[mainIdx]) mainIdx++;\n\t\t\t\t\tnewShapes[mainIdx] = {\n\t\t\t\t\t\ts: new Shape(),\n\t\t\t\t\t\tp: tmpPoints\n\t\t\t\t\t};\n\t\t\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\n\t\t\t\t\tif (holesFirst) mainIdx++;\n\t\t\t\t\tnewShapeHoles[mainIdx] = []; //console.log('cw', i);\n\t\t\t\t} else {\n\t\t\t\t\tnewShapeHoles[mainIdx].push({\n\t\t\t\t\t\th: tmpPath,\n\t\t\t\t\t\tp: tmpPoints[0]\n\t\t\t\t\t}); //console.log('ccw', i);\n\t\t\t\t}\n\t\t\t} // only Holes? -> probably all Shapes with wrong orientation\n\n\n\t\t\tif (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n\t\t\tif (newShapes.length > 1) {\n\t\t\t\tlet ambiguous = false;\n\t\t\t\tconst toChange = [];\n\n\t\t\t\tfor (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n\t\t\t\t\tbetterShapeHoles[sIdx] = [];\n\t\t\t\t}\n\n\t\t\t\tfor (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n\t\t\t\t\tconst sho = newShapeHoles[sIdx];\n\n\t\t\t\t\tfor (let hIdx = 0; hIdx < sho.length; hIdx++) {\n\t\t\t\t\t\tconst ho = sho[hIdx];\n\t\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\t\tfor (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n\t\t\t\t\t\t\tif (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n\t\t\t\t\t\t\t\tif (sIdx !== s2Idx) toChange.push({\n\t\t\t\t\t\t\t\t\tfroms: sIdx,\n\t\t\t\t\t\t\t\t\ttos: s2Idx,\n\t\t\t\t\t\t\t\t\thole: hIdx\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif (hole_unassigned) {\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push(ho);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hole_unassigned) {\n\t\t\t\t\t\t\tbetterShapeHoles[sIdx].push(ho);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // console.log(\"ambiguous: \", ambiguous);\n\n\n\t\t\t\tif (toChange.length > 0) {\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif (!ambiguous) newShapeHoles = betterShapeHoles;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet tmpHoles;\n\n\t\t\tfor (let i = 0, il = newShapes.length; i < il; i++) {\n\t\t\t\ttmpShape = newShapes[i].s;\n\t\t\t\tshapes.push(tmpShape);\n\t\t\t\ttmpHoles = newShapeHoles[i];\n\n\t\t\t\tfor (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n\t\t\t\t\ttmpShape.holes.push(tmpHoles[j].h);\n\t\t\t\t}\n\t\t\t} //console.log(\"shape\", shapes);\n\n\n\t\t\treturn shapes;\n\t\t}\n\n\t}\n\n\tclass Font {\n\t\tconstructor(data) {\n\t\t\tthis.type = 'Font';\n\t\t\tthis.data = data;\n\t\t}\n\n\t\tgenerateShapes(text, size = 100) {\n\t\t\tconst shapes = [];\n\t\t\tconst paths = createPaths(text, size, this.data);\n\n\t\t\tfor (let p = 0, pl = paths.length; p < pl; p++) {\n\t\t\t\tArray.prototype.push.apply(shapes, paths[p].toShapes());\n\t\t\t}\n\n\t\t\treturn shapes;\n\t\t}\n\n\t}\n\n\tfunction createPaths(text, size, data) {\n\t\tconst chars = Array.from(text);\n\t\tconst scale = size / data.resolution;\n\t\tconst line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n\t\tconst paths = [];\n\t\tlet offsetX = 0,\n\t\t\t\toffsetY = 0;\n\n\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\tconst char = chars[i];\n\n\t\t\tif (char === '\\n') {\n\t\t\t\toffsetX = 0;\n\t\t\t\toffsetY -= line_height;\n\t\t\t} else {\n\t\t\t\tconst ret = createPath(char, scale, offsetX, offsetY, data);\n\t\t\t\toffsetX += ret.offsetX;\n\t\t\t\tpaths.push(ret.path);\n\t\t\t}\n\t\t}\n\n\t\treturn paths;\n\t}\n\n\tfunction createPath(char, scale, offsetX, offsetY, data) {\n\t\tconst glyph = data.glyphs[char] || data.glyphs['?'];\n\n\t\tif (!glyph) {\n\t\t\tconsole.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst path = new ShapePath();\n\t\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\t\tif (glyph.o) {\n\t\t\tconst outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n\t\t\tfor (let i = 0, l = outline.length; i < l;) {\n\t\t\t\tconst action = outline[i++];\n\n\t\t\t\tswitch (action) {\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t// moveTo\n\t\t\t\t\t\tx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\ty = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t// lineTo\n\t\t\t\t\t\tx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\ty = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t// quadraticCurveTo\n\t\t\t\t\t\tcpx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t// bezierCurveTo\n\t\t\t\t\t\tcpx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx2 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy2 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\toffsetX: glyph.ha * scale,\n\t\t\tpath: path\n\t\t};\n\t}\n\n\tFont.prototype.isFont = true;\n\n\tclass FontLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\tlet json;\n\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(text);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');\n\t\t\t\t\tjson = JSON.parse(text.substring(65, text.length - 2));\n\t\t\t\t}\n\n\t\t\t\tconst font = scope.parse(json);\n\t\t\t\tif (onLoad) onLoad(font);\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\treturn new Font(json);\n\t\t}\n\n\t}\n\n\tlet _context;\n\n\tconst AudioContext = {\n\t\tgetContext: function () {\n\t\t\tif (_context === undefined) {\n\t\t\t\t_context = new (window.AudioContext || window.webkitAudioContext)();\n\t\t\t}\n\n\t\t\treturn _context;\n\t\t},\n\t\tsetContext: function (value) {\n\t\t\t_context = value;\n\t\t}\n\t};\n\n\tclass AudioLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (buffer) {\n\t\t\t\ttry {\n\t\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\t\tconst bufferCopy = buffer.slice(0);\n\t\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\t\tcontext.decodeAudioData(bufferCopy, function (audioBuffer) {\n\t\t\t\t\t\tonLoad(audioBuffer);\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t}\n\n\tclass HemisphereLightProbe extends LightProbe {\n\t\tconstructor(skyColor, groundColor, intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tconst color1 = new Color().set(skyColor);\n\t\t\tconst color2 = new Color().set(groundColor);\n\t\t\tconst sky = new Vector3(color1.r, color1.g, color1.b);\n\t\t\tconst ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\n\t\t\tconst c0 = Math.sqrt(Math.PI);\n\t\t\tconst c1 = c0 * Math.sqrt(0.75);\n\t\t\tthis.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n\t\t\tthis.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n\t\t}\n\n\t}\n\n\tHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\n\tclass AmbientLightProbe extends LightProbe {\n\t\tconstructor(color, intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tconst color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\n\t\t\tthis.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\n\t\t}\n\n\t}\n\n\tAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\n\tconst _eyeRight = /*@__PURE__*/new Matrix4();\n\n\tconst _eyeLeft = /*@__PURE__*/new Matrix4();\n\n\tclass StereoCamera {\n\t\tconstructor() {\n\t\t\tthis.type = 'StereoCamera';\n\t\t\tthis.aspect = 1;\n\t\t\tthis.eyeSep = 0.064;\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable(1);\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable(2);\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\t\tthis._cache = {\n\t\t\t\tfocus: null,\n\t\t\t\tfov: null,\n\t\t\t\taspect: null,\n\t\t\t\tnear: null,\n\t\t\t\tfar: null,\n\t\t\t\tzoom: null,\n\t\t\t\teyeSep: null\n\t\t\t};\n\t\t}\n\n\t\tupdate(camera) {\n\t\t\tconst cache = this._cache;\n\t\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\t\tif (needsUpdate) {\n\t\t\t\tcache.focus = camera.focus;\n\t\t\t\tcache.fov = camera.fov;\n\t\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\t\tcache.near = camera.near;\n\t\t\t\tcache.far = camera.far;\n\t\t\t\tcache.zoom = camera.zoom;\n\t\t\t\tcache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\t\tconst ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;\n\t\t\t\tlet xmin, xmax; // translate xOffset\n\n\t\t\t\t_eyeLeft.elements[12] = -eyeSepHalf;\n\t\t\t\t_eyeRight.elements[12] = eyeSepHalf; // for left eye\n\n\t\t\t\txmin = -ymax * cache.aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\t\t\t\tprojectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n\t\t\t\tprojectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n\t\t\t\tthis.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye\n\n\t\t\t\txmin = -ymax * cache.aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\t\t\t\tprojectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n\t\t\t\tprojectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n\t\t\t\tthis.cameraR.projectionMatrix.copy(projectionMatrix);\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);\n\t\t\tthis.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);\n\t\t}\n\n\t}\n\n\tclass Clock {\n\t\tconstructor(autoStart = true) {\n\t\t\tthis.autoStart = autoStart;\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = false;\n\t\t}\n\n\t\tstart() {\n\t\t\tthis.startTime = now();\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\t\t}\n\n\t\tstop() {\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\t\t\tthis.autoStart = false;\n\t\t}\n\n\t\tgetElapsedTime() {\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\t\t}\n\n\t\tgetDelta() {\n\t\t\tlet diff = 0;\n\n\t\t\tif (this.autoStart && !this.running) {\n\t\t\t\tthis.start();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (this.running) {\n\t\t\t\tconst newTime = now();\n\t\t\t\tdiff = (newTime - this.oldTime) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\t\t\t\tthis.elapsedTime += diff;\n\t\t\t}\n\n\t\t\treturn diff;\n\t\t}\n\n\t}\n\n\tfunction now() {\n\t\treturn (typeof performance === 'undefined' ? Date : performance).now(); // see #10732\n\t}\n\n\tconst _position$1 = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$1 = /*@__PURE__*/new Quaternion();\n\n\tconst _scale$1 = /*@__PURE__*/new Vector3();\n\n\tconst _orientation$1 = /*@__PURE__*/new Vector3();\n\n\tclass AudioListener extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'AudioListener';\n\t\t\tthis.context = AudioContext.getContext();\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect(this.context.destination);\n\t\t\tthis.filter = null;\n\t\t\tthis.timeDelta = 0; // private\n\n\t\t\tthis._clock = new Clock();\n\t\t}\n\n\t\tgetInput() {\n\t\t\treturn this.gain;\n\t\t}\n\n\t\tremoveFilter() {\n\t\t\tif (this.filter !== null) {\n\t\t\t\tthis.gain.disconnect(this.filter);\n\t\t\t\tthis.filter.disconnect(this.context.destination);\n\t\t\t\tthis.gain.connect(this.context.destination);\n\t\t\t\tthis.filter = null;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetFilter() {\n\t\t\treturn this.filter;\n\t\t}\n\n\t\tsetFilter(value) {\n\t\t\tif (this.filter !== null) {\n\t\t\t\tthis.gain.disconnect(this.filter);\n\t\t\t\tthis.filter.disconnect(this.context.destination);\n\t\t\t} else {\n\t\t\t\tthis.gain.disconnect(this.context.destination);\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect(this.filter);\n\t\t\tthis.filter.connect(this.context.destination);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMasterVolume() {\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\n\t\tsetMasterVolume(value) {\n\t\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tconst listener = this.context.listener;\n\t\t\tconst up = this.up;\n\t\t\tthis.timeDelta = this._clock.getDelta();\n\t\t\tthis.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);\n\n\t\t\t_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);\n\n\t\t\tif (listener.positionX) {\n\t\t\t\t// code path for Chrome (see #14393)\n\t\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\t\t\t\tlistener.positionX.linearRampToValueAtTime(_position$1.x, endTime);\n\t\t\t\tlistener.positionY.linearRampToValueAtTime(_position$1.y, endTime);\n\t\t\t\tlistener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);\n\t\t\t\tlistener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);\n\t\t\t\tlistener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);\n\t\t\t\tlistener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);\n\t\t\t\tlistener.upX.linearRampToValueAtTime(up.x, endTime);\n\t\t\t\tlistener.upY.linearRampToValueAtTime(up.y, endTime);\n\t\t\t\tlistener.upZ.linearRampToValueAtTime(up.z, endTime);\n\t\t\t} else {\n\t\t\t\tlistener.setPosition(_position$1.x, _position$1.y, _position$1.z);\n\t\t\t\tlistener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Audio extends Object3D {\n\t\tconstructor(listener) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Audio';\n\t\t\tthis.listener = listener;\n\t\t\tthis.context = listener.context;\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect(listener.getInput());\n\t\t\tthis.autoplay = false;\n\t\t\tthis.buffer = null;\n\t\t\tthis.detune = 0;\n\t\t\tthis.loop = false;\n\t\t\tthis.loopStart = 0;\n\t\t\tthis.loopEnd = 0;\n\t\t\tthis.offset = 0;\n\t\t\tthis.duration = undefined;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.source = null;\n\t\t\tthis.sourceType = 'empty';\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._progress = 0;\n\t\t\tthis._connected = false;\n\t\t\tthis.filters = [];\n\t\t}\n\n\t\tgetOutput() {\n\t\t\treturn this.gain;\n\t\t}\n\n\t\tsetNodeSource(audioNode) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMediaElementSource(mediaElement) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'mediaNode';\n\t\t\tthis.source = this.context.createMediaElementSource(mediaElement);\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMediaStreamSource(mediaStream) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'mediaStreamNode';\n\t\t\tthis.source = this.context.createMediaStreamSource(mediaStream);\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetBuffer(audioBuffer) {\n\t\t\tthis.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\t\t\tif (this.autoplay) this.play();\n\t\t\treturn this;\n\t\t}\n\n\t\tplay(delay = 0) {\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tconsole.warn('THREE.Audio: Audio is already playing.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._startedAt = this.context.currentTime + delay;\n\t\t\tconst source = this.context.createBufferSource();\n\t\t\tsource.buffer = this.buffer;\n\t\t\tsource.loop = this.loop;\n\t\t\tsource.loopStart = this.loopStart;\n\t\t\tsource.loopEnd = this.loopEnd;\n\t\t\tsource.onended = this.onEnded.bind(this);\n\t\t\tsource.start(this._startedAt, this._progress + this.offset, this.duration);\n\t\t\tthis.isPlaying = true;\n\t\t\tthis.source = source;\n\t\t\tthis.setDetune(this.detune);\n\t\t\tthis.setPlaybackRate(this.playbackRate);\n\t\t\treturn this.connect();\n\t\t}\n\n\t\tpause() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\t// update current progress\n\t\t\t\tthis._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n\n\t\t\t\tif (this.loop === true) {\n\t\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\t\t\t\t\tthis._progress = this._progress % (this.duration || this.buffer.duration);\n\t\t\t\t}\n\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.source.onended = null;\n\t\t\t\tthis.isPlaying = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tstop() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._progress = 0;\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\t\t\tthis.isPlaying = false;\n\t\t\treturn this;\n\t\t}\n\n\t\tconnect() {\n\t\t\tif (this.filters.length > 0) {\n\t\t\t\tthis.source.connect(this.filters[0]);\n\n\t\t\t\tfor (let i = 1, l = this.filters.length; i < l; i++) {\n\t\t\t\t\tthis.filters[i - 1].connect(this.filters[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.filters[this.filters.length - 1].connect(this.getOutput());\n\t\t\t} else {\n\t\t\t\tthis.source.connect(this.getOutput());\n\t\t\t}\n\n\t\t\tthis._connected = true;\n\t\t\treturn this;\n\t\t}\n\n\t\tdisconnect() {\n\t\t\tif (this.filters.length > 0) {\n\t\t\t\tthis.source.disconnect(this.filters[0]);\n\n\t\t\t\tfor (let i = 1, l = this.filters.length; i < l; i++) {\n\t\t\t\t\tthis.filters[i - 1].disconnect(this.filters[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.filters[this.filters.length - 1].disconnect(this.getOutput());\n\t\t\t} else {\n\t\t\t\tthis.source.disconnect(this.getOutput());\n\t\t\t}\n\n\t\t\tthis._connected = false;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetFilters() {\n\t\t\treturn this.filters;\n\t\t}\n\n\t\tsetFilters(value) {\n\t\t\tif (!value) value = [];\n\n\t\t\tif (this._connected === true) {\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value.slice();\n\t\t\t\tthis.connect();\n\t\t\t} else {\n\t\t\t\tthis.filters = value.slice();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetDetune(value) {\n\t\t\tthis.detune = value;\n\t\t\tif (this.source.detune === undefined) return; // only set detune when available\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetDetune() {\n\t\t\treturn this.detune;\n\t\t}\n\n\t\tgetFilter() {\n\t\t\treturn this.getFilters()[0];\n\t\t}\n\n\t\tsetFilter(filter) {\n\t\t\treturn this.setFilters(filter ? [filter] : []);\n\t\t}\n\n\t\tsetPlaybackRate(value) {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetPlaybackRate() {\n\t\t\treturn this.playbackRate;\n\t\t}\n\n\t\tonEnded() {\n\t\t\tthis.isPlaying = false;\n\t\t}\n\n\t\tgetLoop() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn this.loop;\n\t\t}\n\n\t\tsetLoop(value) {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.loop = value;\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.loop = this.loop;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoopStart(value) {\n\t\t\tthis.loopStart = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoopEnd(value) {\n\t\t\tthis.loopEnd = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetVolume() {\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\n\t\tsetVolume(value) {\n\t\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tconst _position = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion = /*@__PURE__*/new Quaternion();\n\n\tconst _scale = /*@__PURE__*/new Vector3();\n\n\tconst _orientation = /*@__PURE__*/new Vector3();\n\n\tclass PositionalAudio extends Audio {\n\t\tconstructor(listener) {\n\t\t\tsuper(listener);\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.panningModel = 'HRTF';\n\t\t\tthis.panner.connect(this.gain);\n\t\t}\n\n\t\tgetOutput() {\n\t\t\treturn this.panner;\n\t\t}\n\n\t\tgetRefDistance() {\n\t\t\treturn this.panner.refDistance;\n\t\t}\n\n\t\tsetRefDistance(value) {\n\t\t\tthis.panner.refDistance = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetRolloffFactor() {\n\t\t\treturn this.panner.rolloffFactor;\n\t\t}\n\n\t\tsetRolloffFactor(value) {\n\t\t\tthis.panner.rolloffFactor = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetDistanceModel() {\n\t\t\treturn this.panner.distanceModel;\n\t\t}\n\n\t\tsetDistanceModel(value) {\n\t\t\tthis.panner.distanceModel = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMaxDistance() {\n\t\t\treturn this.panner.maxDistance;\n\t\t}\n\n\t\tsetMaxDistance(value) {\n\t\t\tthis.panner.maxDistance = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n\t\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\t\tthis.panner.coneOuterGain = coneOuterGain;\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tif (this.hasPlaybackControl === true && this.isPlaying === false) return;\n\t\t\tthis.matrixWorld.decompose(_position, _quaternion, _scale);\n\n\t\t\t_orientation.set(0, 0, 1).applyQuaternion(_quaternion);\n\n\t\t\tconst panner = this.panner;\n\n\t\t\tif (panner.positionX) {\n\t\t\t\t// code path for Chrome and Firefox (see #14393)\n\t\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\t\t\t\tpanner.positionX.linearRampToValueAtTime(_position.x, endTime);\n\t\t\t\tpanner.positionY.linearRampToValueAtTime(_position.y, endTime);\n\t\t\t\tpanner.positionZ.linearRampToValueAtTime(_position.z, endTime);\n\t\t\t\tpanner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);\n\t\t\t\tpanner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);\n\t\t\t\tpanner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);\n\t\t\t} else {\n\t\t\t\tpanner.setPosition(_position.x, _position.y, _position.z);\n\t\t\t\tpanner.setOrientation(_orientation.x, _orientation.y, _orientation.z);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass AudioAnalyser {\n\t\tconstructor(audio, fftSize = 2048) {\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize;\n\t\t\tthis.data = new Uint8Array(this.analyser.frequencyBinCount);\n\t\t\taudio.getOutput().connect(this.analyser);\n\t\t}\n\n\t\tgetFrequencyData() {\n\t\t\tthis.analyser.getByteFrequencyData(this.data);\n\t\t\treturn this.data;\n\t\t}\n\n\t\tgetAverageFrequency() {\n\t\t\tlet value = 0;\n\t\t\tconst data = this.getFrequencyData();\n\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tvalue += data[i];\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\t\t}\n\n\t}\n\n\tclass PropertyMixer {\n\t\tconstructor(binding, typeName, valueSize) {\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\t\tlet mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\t\t//\n\t\t\t// 'add' is used for additive cumulative results\n\t\t\t//\n\t\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t\t// to store intermediate quaternion multiplication results\n\n\t\t\tswitch (typeName) {\n\t\t\t\tcase 'quaternion':\n\t\t\t\t\tmixFunction = this._slerp;\n\t\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\t\t\t\t\tthis.buffer = new Float64Array(valueSize * 6);\n\t\t\t\t\tthis._workIndex = 5;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\t\t\t\tmixFunction = this._select; // Use the regular mix function and for additive on these types,\n\t\t\t\t\t// additive is not relevant for non-numeric types\n\n\t\t\t\t\tmixFunctionAdditive = this._select;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\t\t\t\t\tthis.buffer = new Array(valueSize * 5);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmixFunction = this._lerp;\n\t\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\t\t\t\t\tthis.buffer = new Float64Array(valueSize * 5);\n\t\t\t}\n\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\t\tthis._setIdentity = setIdentity;\n\t\t\tthis._origIndex = 3;\n\t\t\tthis._addIndex = 4;\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\t} // accumulate data in the 'incoming' region into 'accu<i>'\n\n\n\t\taccumulate(accuIndex, weight) {\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = accuIndex * stride + stride;\n\t\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\t\tif (currentWeight === 0) {\n\t\t\t\t// accuN := incoming * weight\n\t\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\t\tbuffer[offset + i] = buffer[i];\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\t\t\t} else {\n\t\t\t\t// accuN := accuN + incoming * weight\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tconst mix = weight / currentWeight;\n\n\t\t\t\tthis._mixBufferRegion(buffer, offset, 0, mix, stride);\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\t\t} // accumulate data in the 'incoming' region into 'add'\n\n\n\t\taccumulateAdditive(weight) {\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = stride * this._addIndex;\n\n\t\t\tif (this.cumulativeWeightAdditive === 0) {\n\t\t\t\t// add = identity\n\t\t\t\tthis._setIdentity();\n\t\t\t} // add := add + incoming * weight\n\n\n\t\t\tthis._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n\t\t\tthis.cumulativeWeightAdditive += weight;\n\t\t} // apply the state of 'accu<i>' to the binding when accus differ\n\n\n\t\tapply(accuIndex) {\n\t\t\tconst stride = this.valueSize,\n\t\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\t\t\t\t\tweight = this.cumulativeWeight,\n\t\t\t\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\t\t\t\t\t\tbinding = this.binding;\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\t\tif (weight < 1) {\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\t\tthis._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n\t\t\t}\n\n\t\t\tif (weightAdditive > 0) {\n\t\t\t\t// accuN := accuN + additive accuN\n\t\t\t\tthis._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n\t\t\t}\n\n\t\t\tfor (let i = stride, e = stride + stride; i !== e; ++i) {\n\t\t\t\tif (buffer[i] !== buffer[i + stride]) {\n\t\t\t\t\t// value has changed -> update scene graph\n\t\t\t\t\tbinding.setValue(buffer, offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} // remember the state of the bound property and copy it to both accus\n\n\n\t\tsaveOriginalState() {\n\t\t\tconst binding = this.binding;\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toriginalValueOffset = stride * this._origIndex;\n\t\t\tbinding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n\t\t\tfor (let i = stride, e = originalValueOffset; i !== e; ++i) {\n\t\t\t\tbuffer[i] = buffer[originalValueOffset + i % stride];\n\t\t\t} // Add to identity for additive\n\n\n\t\t\tthis._setIdentity();\n\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\t\t} // apply the state previously taken via 'saveOriginalState' to the binding\n\n\n\t\trestoreOriginalState() {\n\t\t\tconst originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue(this.buffer, originalValueOffset);\n\t\t}\n\n\t\t_setAdditiveIdentityNumeric() {\n\t\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tthis.buffer[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t_setAdditiveIdentityQuaternion() {\n\t\t\tthis._setAdditiveIdentityNumeric();\n\n\t\t\tthis.buffer[this._addIndex * this.valueSize + 3] = 1;\n\t\t}\n\n\t\t_setAdditiveIdentityOther() {\n\t\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\t\tfor (let i = 0; i < this.valueSize; i++) {\n\t\t\t\tthis.buffer[targetIndex + i] = this.buffer[startIndex + i];\n\t\t\t}\n\t\t} // mix functions\n\n\n\t\t_select(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tif (t >= 0.5) {\n\t\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\t\tbuffer[dstOffset + i] = buffer[srcOffset + i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_slerp(buffer, dstOffset, srcOffset, t) {\n\t\t\tQuaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n\t\t}\n\n\t\t_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tconst workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n\t\t\tQuaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n\t\t\tQuaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n\t\t}\n\n\t\t_lerp(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tconst s = 1 - t;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tconst j = dstOffset + i;\n\t\t\t\tbuffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n\t\t\t}\n\t\t}\n\n\t\t_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tconst j = dstOffset + i;\n\t\t\t\tbuffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Characters [].:/ are reserved for track binding syntax.\n\tconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\n\tconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t// instead, we exclude reserved characters and match everything else.\n\n\n\tconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\n\n\tconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t// be matched to parse the rest of the track name.\n\n\n\tconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\n\n\tconst _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n\t// characters. Accessor may contain any character except closing bracket.\n\n\n\tconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n\t// contain any non-bracket characters.\n\n\n\tconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\n\tconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\n\n\tconst _supportedObjectNames = ['material', 'materials', 'bones'];\n\n\tclass Composite {\n\t\tconstructor(targetGroup, path, optionalParsedPath) {\n\t\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_(path, parsedPath);\n\t\t}\n\n\t\tgetValue(array, offset) {\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tbinding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n\t\t\tif (binding !== undefined) binding.getValue(array, offset);\n\t\t}\n\n\t\tsetValue(array, offset) {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].setValue(array, offset);\n\t\t\t}\n\t\t}\n\n\t\tbind() {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].bind();\n\t\t\t}\n\t\t}\n\n\t\tunbind() {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].unbind();\n\t\t\t}\n\t\t}\n\n\t} // Note: This class uses a State pattern on a per-method basis:\n\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t// prototype version of these methods with one that represents\n\t// the bound state. When the property is not found, the methods\n\t// become no-ops.\n\n\n\tclass PropertyBinding {\n\t\tconstructor(rootNode, path, parsedPath) {\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n\t\t\tthis.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n\t\t\tthis.rootNode = rootNode; // initial state of these methods that calls 'bind'\n\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\t}\n\n\t\tstatic create(root, path, parsedPath) {\n\t\t\tif (!(root && root.isAnimationObjectGroup)) {\n\t\t\t\treturn new PropertyBinding(root, path, parsedPath);\n\t\t\t} else {\n\t\t\t\treturn new PropertyBinding.Composite(root, path, parsedPath);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Replaces spaces with underscores and removes unsupported characters from\n\t\t * node names, to ensure compatibility with parseTrackName().\n\t\t *\n\t\t * @param {string} name Node name to be sanitized.\n\t\t * @return {string}\n\t\t */\n\n\n\t\tstatic sanitizeNodeName(name) {\n\t\t\treturn name.replace(/\\s/g, '_').replace(_reservedRe, '');\n\t\t}\n\n\t\tstatic parseTrackName(trackName) {\n\t\t\tconst matches = _trackRe.exec(trackName);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n\t\t\t}\n\n\t\t\tconst results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[2],\n\t\t\t\tobjectName: matches[3],\n\t\t\t\tobjectIndex: matches[4],\n\t\t\t\tpropertyName: matches[5],\n\t\t\t\t// required\n\t\t\t\tpropertyIndex: matches[6]\n\t\t\t};\n\t\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n\t\t\tif (lastDot !== undefined && lastDot !== -1) {\n\t\t\t\tconst objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t// include '.' characters).\n\n\t\t\t\tif (_supportedObjectNames.indexOf(objectName) !== -1) {\n\t\t\t\t\tresults.nodeName = results.nodeName.substring(0, lastDot);\n\t\t\t\t\tresults.objectName = objectName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (results.propertyName === null || results.propertyName.length === 0) {\n\t\t\t\tthrow new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}\n\n\t\tstatic findNode(root, nodeName) {\n\t\t\tif (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n\t\t\t\treturn root;\n\t\t\t} // search into skeleton bones.\n\n\n\t\t\tif (root.skeleton) {\n\t\t\t\tconst bone = root.skeleton.getBoneByName(nodeName);\n\n\t\t\t\tif (bone !== undefined) {\n\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t\t} // search into node subtree.\n\n\n\t\t\tif (root.children) {\n\t\t\t\tconst searchNodeSubtree = function (children) {\n\t\t\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\t\t\tconst childNode = children[i];\n\n\t\t\t\t\t\tif (childNode.name === nodeName || childNode.uuid === nodeName) {\n\t\t\t\t\t\t\treturn childNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = searchNodeSubtree(childNode.children);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst subTreeNode = searchNodeSubtree(root.children);\n\n\t\t\t\tif (subTreeNode) {\n\t\t\t\t\treturn subTreeNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} // these are used to \"bind\" a nonexistent property\n\n\n\t\t_getValue_unavailable() {}\n\n\t\t_setValue_unavailable() {} // Getters\n\n\n\t\t_getValue_direct(buffer, offset) {\n\t\t\tbuffer[offset] = this.node[this.propertyName];\n\t\t}\n\n\t\t_getValue_array(buffer, offset) {\n\t\t\tconst source = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = source.length; i !== n; ++i) {\n\t\t\t\tbuffer[offset++] = source[i];\n\t\t\t}\n\t\t}\n\n\t\t_getValue_arrayElement(buffer, offset) {\n\t\t\tbuffer[offset] = this.resolvedProperty[this.propertyIndex];\n\t\t}\n\n\t\t_getValue_toArray(buffer, offset) {\n\t\t\tthis.resolvedProperty.toArray(buffer, offset);\n\t\t} // Direct\n\n\n\t\t_setValue_direct(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t}\n\n\t\t_setValue_direct_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // EntireArray\n\n\n\t\t_setValue_array(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\t\t}\n\n\t\t_setValue_array_setNeedsUpdate(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // ArrayElement\n\n\n\t\t_setValue_arrayElement(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t}\n\n\t\t_setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // HasToFromArray\n\n\n\t\t_setValue_fromArray(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t}\n\n\t\t_setValue_fromArray_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t}\n\n\t\t_getValue_unbound(targetArray, offset) {\n\t\t\tthis.bind();\n\t\t\tthis.getValue(targetArray, offset);\n\t\t}\n\n\t\t_setValue_unbound(sourceArray, offset) {\n\t\t\tthis.bind();\n\t\t\tthis.setValue(sourceArray, offset);\n\t\t} // create getter / setter pair for a property in the scene graph\n\n\n\t\tbind() {\n\t\t\tlet targetObject = this.node;\n\t\t\tconst parsedPath = this.parsedPath;\n\t\t\tconst objectName = parsedPath.objectName;\n\t\t\tconst propertyName = parsedPath.propertyName;\n\t\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif (!targetObject) {\n\t\t\t\ttargetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n\t\t\t\tthis.node = targetObject;\n\t\t\t} // set fail state so we can just 'return' on error\n\n\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable; // ensure there is a value node\n\n\t\t\tif (!targetObject) {\n\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (objectName) {\n\t\t\t\tlet objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n\t\t\t\tswitch (objectName) {\n\t\t\t\t\tcase 'materials':\n\t\t\t\t\t\tif (!targetObject.material) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!targetObject.material.materials) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\t\t\t\t\t\tif (!targetObject.skeleton) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} // potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n\t\t\t\t\t\tfor (let i = 0; i < targetObject.length; i++) {\n\t\t\t\t\t\t\tif (targetObject[i].name === objectIndex) {\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (targetObject[objectName] === undefined) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[objectName];\n\t\t\t\t}\n\n\t\t\t\tif (objectIndex !== undefined) {\n\t\t\t\t\tif (targetObject[objectIndex] === undefined) {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[objectIndex];\n\t\t\t\t}\n\t\t\t} // resolve property\n\n\n\t\t\tconst nodeProperty = targetObject[propertyName];\n\n\t\t\tif (nodeProperty === undefined) {\n\t\t\t\tconst nodeName = parsedPath.nodeName;\n\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n\t\t\t\treturn;\n\t\t\t} // determine versioning scheme\n\n\n\t\t\tlet versioning = this.Versioning.None;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t\tif (targetObject.needsUpdate !== undefined) {\n\t\t\t\t// material\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n\t\t\t\t// node transform\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t} // determine how the property gets bound\n\n\n\t\t\tlet bindingType = this.BindingType.Direct;\n\n\t\t\tif (propertyIndex !== undefined) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\t\t\tif (propertyName === 'morphTargetInfluences') {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif (!targetObject.geometry) {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetObject.geometry.isBufferGeometry) {\n\t\t\t\t\t\tif (!targetObject.geometry.morphAttributes) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n\t\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\t\t} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t} else if (Array.isArray(nodeProperty)) {\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t} else {\n\t\t\t\tthis.propertyName = propertyName;\n\t\t\t} // select getter / setter\n\n\n\t\t\tthis.getValue = this.GetterByBindingType[bindingType];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n\t\t}\n\n\t\tunbind() {\n\t\t\tthis.node = null; // back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\t}\n\n\t}\n\n\tPropertyBinding.Composite = Composite;\n\tPropertyBinding.prototype.BindingType = {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t};\n\tPropertyBinding.prototype.Versioning = {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t};\n\tPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\n\tPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct\n\tPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray\n\tPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement\n\tPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray\n\tPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t *\t- Add objects you would otherwise pass as 'root' to the\n\t *\t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t *\t- Instead pass this object as 'root'.\n\t *\n\t *\t- You can also add and remove objects later when the mixer\n\t *\t\tis running.\n\t *\n\t * Note:\n\t *\n\t *\t\tObjects of this class appear as one object to the mixer,\n\t *\t\tso cache control of the individual objects must be done\n\t *\t\ton the group.\n\t *\n\t * Limitation:\n\t *\n\t *\t- The animated properties must be compatible among the\n\t *\t\tall objects in the group.\n\t *\n\t *\t- A single property can either be controlled through a\n\t *\t\ttarget group or directly, but not both.\n\t */\n\n\tclass AnimationObjectGroup {\n\t\tconstructor() {\n\t\t\tthis.uuid = generateUUID(); // cached objects followed by the active ones\n\n\t\t\tthis._objects = Array.prototype.slice.call(arguments);\n\t\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\n\t\t\tconst indices = {};\n\t\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tindices[arguments[i].uuid] = i;\n\t\t\t}\n\n\t\t\tthis._paths = []; // inside: string\n\n\t\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\n\t\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\n\t\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\t\tconst scope = this;\n\t\t\tthis.stats = {\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._objects.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tget bindingsPerObject() {\n\t\t\t\t\treturn scope._bindings.length;\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tadd() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet knownObject = undefined,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid;\n\t\t\t\tlet index = indicesByUUID[uuid];\n\n\t\t\t\tif (index === undefined) {\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\t\t\t\tindex = nObjects++;\n\t\t\t\t\tindicesByUUID[uuid] = index;\n\t\t\t\t\tobjects.push(object); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tbindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n\t\t\t\t\t}\n\t\t\t\t} else if (index < nCachedObjects) {\n\t\t\t\t\tknownObject = objects[index]; // move existing object to the ACTIVE region\n\n\t\t\t\t\tconst firstActiveIndex = --nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[firstActiveIndex];\n\t\t\t\t\tindicesByUUID[lastCachedObject.uuid] = index;\n\t\t\t\t\tobjects[index] = lastCachedObject;\n\t\t\t\t\tindicesByUUID[uuid] = firstActiveIndex;\n\t\t\t\t\tobjects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[firstActiveIndex];\n\t\t\t\t\t\tlet binding = bindingsForPath[index];\n\t\t\t\t\t\tbindingsForPath[index] = lastCached;\n\n\t\t\t\t\t\tif (binding === undefined) {\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\t\t\t\t\t\t\tbinding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[firstActiveIndex] = binding;\n\t\t\t\t\t}\n\t\t\t\t} else if (objects[index] !== knownObject) {\n\t\t\t\t\tconsole.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t}\n\n\t\tremove() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\t\tindex = indicesByUUID[uuid];\n\n\t\t\t\tif (index !== undefined && index >= nCachedObjects) {\n\t\t\t\t\t// move existing object into the CACHED region\n\t\t\t\t\tconst lastCachedIndex = nCachedObjects++,\n\t\t\t\t\t\t\t\tfirstActiveObject = objects[lastCachedIndex];\n\t\t\t\t\tindicesByUUID[firstActiveObject.uuid] = index;\n\t\t\t\t\tobjects[index] = firstActiveObject;\n\t\t\t\t\tindicesByUUID[uuid] = lastCachedIndex;\n\t\t\t\t\tobjects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[lastCachedIndex],\n\t\t\t\t\t\t\t\t\tbinding = bindingsForPath[index];\n\t\t\t\t\t\tbindingsForPath[index] = firstActive;\n\t\t\t\t\t\tbindingsForPath[lastCachedIndex] = binding;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t} // remove & forget\n\n\n\t\tuncache() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tnObjects = objects.length;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\t\tindex = indicesByUUID[uuid];\n\n\t\t\t\tif (index !== undefined) {\n\t\t\t\t\tdelete indicesByUUID[uuid];\n\n\t\t\t\t\tif (index < nCachedObjects) {\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\t\t\t\t\tconst firstActiveIndex = --nCachedObjects,\n\t\t\t\t\t\t\t\t\tlastCachedObject = objects[firstActiveIndex],\n\t\t\t\t\t\t\t\t\tlastIndex = --nObjects,\n\t\t\t\t\t\t\t\t\tlastObject = objects[lastIndex]; // last cached object takes this object's place\n\n\t\t\t\t\t\tindicesByUUID[lastCachedObject.uuid] = index;\n\t\t\t\t\t\tobjects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n\t\t\t\t\t\tindicesByUUID[lastObject.uuid] = firstActiveIndex;\n\t\t\t\t\t\tobjects[firstActiveIndex] = lastObject;\n\t\t\t\t\t\tobjects.pop(); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[firstActiveIndex],\n\t\t\t\t\t\t\t\t\t\tlast = bindingsForPath[lastIndex];\n\t\t\t\t\t\t\tbindingsForPath[index] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[firstActiveIndex] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\t\t\t\t\tconst lastIndex = --nObjects,\n\t\t\t\t\t\t\t\t\tlastObject = objects[lastIndex];\n\n\t\t\t\t\t\tif (lastIndex > 0) {\n\t\t\t\t\t\t\tindicesByUUID[lastObject.uuid] = index;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjects[index] = lastObject;\n\t\t\t\t\t\tobjects.pop(); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\t\tconst bindingsForPath = bindings[j];\n\t\t\t\t\t\t\tbindingsForPath[index] = bindingsForPath[lastIndex];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t} // Internal interface used by befriended PropertyBinding.Composite:\n\n\n\t\tsubscribe_(path, parsedPath) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\t\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\t\tlet index = indicesByPath[path];\n\t\t\tconst bindings = this._bindings;\n\t\t\tif (index !== undefined) return bindings[index];\n\t\t\tconst paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\t\tbindingsForPath = new Array(nObjects);\n\t\t\tindex = bindings.length;\n\t\t\tindicesByPath[path] = index;\n\t\t\tpaths.push(path);\n\t\t\tparsedPaths.push(parsedPath);\n\t\t\tbindings.push(bindingsForPath);\n\n\t\t\tfor (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n\t\t\t\tconst object = objects[i];\n\t\t\t\tbindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\t\t}\n\n\t\tunsubscribe_(path) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\t\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\t\tindex = indicesByPath[path];\n\n\t\t\tif (index !== undefined) {\n\t\t\t\tconst paths = this._paths,\n\t\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\t\tlastBindings = bindings[lastBindingsIndex],\n\t\t\t\t\t\t\tlastBindingsPath = path[lastBindingsIndex];\n\t\t\t\tindicesByPath[lastBindingsPath] = index;\n\t\t\t\tbindings[index] = lastBindings;\n\t\t\t\tbindings.pop();\n\t\t\t\tparsedPaths[index] = parsedPaths[lastBindingsIndex];\n\t\t\t\tparsedPaths.pop();\n\t\t\t\tpaths[index] = paths[lastBindingsIndex];\n\t\t\t\tpaths.pop();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\n\n\tclass AnimationAction {\n\t\tconstructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot;\n\t\t\tthis.blendMode = blendMode;\n\t\t\tconst tracks = clip.tracks,\n\t\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\t\tinterpolants = new Array(nTracks);\n\t\t\tconst interpolantSettings = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\n\t\t\tfor (let i = 0; i !== nTracks; ++i) {\n\t\t\t\tconst interpolant = tracks[i].createInterpolant(null);\n\t\t\t\tinterpolants[i] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\t\t}\n\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\t\tthis._interpolants = interpolants; // bound by the mixer\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\n\t\t\tthis._propertyBindings = new Array(nTracks);\n\t\t\tthis._cacheIndex = null; // for the memory manager\n\n\t\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = -1; // global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\n\t\t\tthis._startTime = null; // scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\n\t\t\tthis.time = 0;\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\t\tthis.paused = false; // true -> zero effective time scale\n\n\t\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\t\tthis.clampWhenFinished = false; // keep feeding the last frame?\n\n\t\t\tthis.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n\t\t\tthis.zeroSlopeAtEnd = true; // clips for start, loop and end\n\t\t} // State & Scheduling\n\n\n\t\tplay() {\n\t\t\tthis._mixer._activateAction(this);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tstop() {\n\t\t\tthis._mixer._deactivateAction(this);\n\n\t\t\treturn this.reset();\n\t\t}\n\n\t\treset() {\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\t\t\tthis.time = 0; // restart clip\n\n\t\t\tthis._loopCount = -1; // forget previous loops\n\n\t\t\tthis._startTime = null; // forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\t\t}\n\n\t\tisRunning() {\n\t\t\treturn this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n\t\t} // return true when play has been called\n\n\n\t\tisScheduled() {\n\t\t\treturn this._mixer._isActiveAction(this);\n\t\t}\n\n\t\tstartAt(time) {\n\t\t\tthis._startTime = time;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoop(mode, repetitions) {\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\t\t\treturn this;\n\t\t} // Weight\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\n\n\t\tsetEffectiveWeight(weight) {\n\t\t\tthis.weight = weight; // note: same logic as when updated at runtime\n\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\t\treturn this.stopFading();\n\t\t} // return the weight considering fading and .enabled\n\n\n\t\tgetEffectiveWeight() {\n\t\t\treturn this._effectiveWeight;\n\t\t}\n\n\t\tfadeIn(duration) {\n\t\t\treturn this._scheduleFading(duration, 0, 1);\n\t\t}\n\n\t\tfadeOut(duration) {\n\t\t\treturn this._scheduleFading(duration, 1, 0);\n\t\t}\n\n\t\tcrossFadeFrom(fadeOutAction, duration, warp) {\n\t\t\tfadeOutAction.fadeOut(duration);\n\t\t\tthis.fadeIn(duration);\n\n\t\t\tif (warp) {\n\t\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\t\t\tfadeOutAction.warp(1.0, startEndRatio, duration);\n\t\t\t\tthis.warp(endStartRatio, 1.0, duration);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcrossFadeTo(fadeInAction, duration, warp) {\n\t\t\treturn fadeInAction.crossFadeFrom(this, duration, warp);\n\t\t}\n\n\t\tstopFading() {\n\t\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\t\tif (weightInterpolant !== null) {\n\t\t\t\tthis._weightInterpolant = null;\n\n\t\t\t\tthis._mixer._takeBackControlInterpolant(weightInterpolant);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Time Scale Control\n\t\t// set the time scale stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\n\n\t\tsetEffectiveTimeScale(timeScale) {\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\t\t\treturn this.stopWarping();\n\t\t} // return the time scale considering warping and .paused\n\n\n\t\tgetEffectiveTimeScale() {\n\t\t\treturn this._effectiveTimeScale;\n\t\t}\n\n\t\tsetDuration(duration) {\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\t\treturn this.stopWarping();\n\t\t}\n\n\t\tsyncWith(action) {\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\t\t\treturn this.stopWarping();\n\t\t}\n\n\t\thalt(duration) {\n\t\t\treturn this.warp(this._effectiveTimeScale, 0, duration);\n\t\t}\n\n\t\twarp(startTimeScale, endTimeScale, duration) {\n\t\t\tconst mixer = this._mixer,\n\t\t\t\t\t\tnow = mixer.time,\n\t\t\t\t\t\ttimeScale = this.timeScale;\n\t\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\t\tif (interpolant === null) {\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\t\t}\n\n\t\t\tconst times = interpolant.parameterPositions,\n\t\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\t\ttimes[0] = now;\n\t\t\ttimes[1] = now + duration;\n\t\t\tvalues[0] = startTimeScale / timeScale;\n\t\t\tvalues[1] = endTimeScale / timeScale;\n\t\t\treturn this;\n\t\t}\n\n\t\tstopWarping() {\n\t\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif (timeScaleInterpolant !== null) {\n\t\t\t\tthis._timeScaleInterpolant = null;\n\n\t\t\t\tthis._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Object Accessors\n\n\n\t\tgetMixer() {\n\t\t\treturn this._mixer;\n\t\t}\n\n\t\tgetClip() {\n\t\t\treturn this._clip;\n\t\t}\n\n\t\tgetRoot() {\n\t\t\treturn this._localRoot || this._mixer._root;\n\t\t} // Interna\n\n\n\t\t_update(time, deltaTime, timeDirection, accuIndex) {\n\t\t\t// called by the mixer\n\t\t\tif (!this.enabled) {\n\t\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\t\t\t\tthis._updateWeight(time);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst startTime = this._startTime;\n\n\t\t\tif (startTime !== null) {\n\t\t\t\t// check for scheduled start of action\n\t\t\t\tconst timeRunning = (time - startTime) * timeDirection;\n\n\t\t\t\tif (timeRunning < 0 || timeDirection === 0) {\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\t\t\t} // start\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\t\t} // apply time scale and advance time\n\n\n\t\t\tdeltaTime *= this._updateTimeScale(time);\n\n\t\t\tconst clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\n\t\t\tconst weight = this._updateWeight(time);\n\n\t\t\tif (weight > 0) {\n\t\t\t\tconst interpolants = this._interpolants;\n\t\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\t\tswitch (this.blendMode) {\n\t\t\t\t\tcase AdditiveAnimationBlendMode:\n\t\t\t\t\t\tfor (let j = 0, m = interpolants.length; j !== m; ++j) {\n\t\t\t\t\t\t\tinterpolants[j].evaluate(clipTime);\n\t\t\t\t\t\t\tpropertyMixers[j].accumulateAdditive(weight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfor (let j = 0, m = interpolants.length; j !== m; ++j) {\n\t\t\t\t\t\t\tinterpolants[j].evaluate(clipTime);\n\t\t\t\t\t\t\tpropertyMixers[j].accumulate(accuIndex, weight);\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_updateWeight(time) {\n\t\t\tlet weight = 0;\n\n\t\t\tif (this.enabled) {\n\t\t\t\tweight = this.weight;\n\t\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\t\tif (interpolant !== null) {\n\t\t\t\t\tconst interpolantValue = interpolant.evaluate(time)[0];\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif (time > interpolant.parameterPositions[1]) {\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif (interpolantValue === 0) {\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\t\t}\n\n\t\t_updateTimeScale(time) {\n\t\t\tlet timeScale = 0;\n\n\t\t\tif (!this.paused) {\n\t\t\t\ttimeScale = this.timeScale;\n\t\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif (interpolant !== null) {\n\t\t\t\t\tconst interpolantValue = interpolant.evaluate(time)[0];\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif (time > interpolant.parameterPositions[1]) {\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif (timeScale === 0) {\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\t\t}\n\n\t\t_updateTime(deltaTime) {\n\t\t\tconst duration = this._clip.duration;\n\t\t\tconst loop = this.loop;\n\t\t\tlet time = this.time + deltaTime;\n\t\t\tlet loopCount = this._loopCount;\n\t\t\tconst pingPong = loop === LoopPingPong;\n\n\t\t\tif (deltaTime === 0) {\n\t\t\t\tif (loopCount === -1) return time;\n\t\t\t\treturn pingPong && (loopCount & 1) === 1 ? duration - time : time;\n\t\t\t}\n\n\t\t\tif (loop === LoopOnce) {\n\t\t\t\tif (loopCount === -1) {\n\t\t\t\t\t// just started\n\t\t\t\t\tthis._loopCount = 0;\n\n\t\t\t\t\tthis._setEndings(true, true, false);\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\t\t\t\t\tif (time >= duration) {\n\t\t\t\t\t\ttime = duration;\n\t\t\t\t\t} else if (time < 0) {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\tbreak handle_stop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\ttype: 'finished',\n\t\t\t\t\t\taction: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// repetitive Repeat or PingPong\n\t\t\t\tif (loopCount === -1) {\n\t\t\t\t\t// just started\n\t\t\t\t\tif (deltaTime >= 0) {\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(true, this.repetitions === 0, pingPong);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\t\t\t\t\t\tthis._setEndings(this.repetitions === 0, true, pingPong);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (time >= duration || time < 0) {\n\t\t\t\t\t// wrap around\n\t\t\t\t\tconst loopDelta = Math.floor(time / duration); // signed\n\n\t\t\t\t\ttime -= duration * loopDelta;\n\t\t\t\t\tloopCount += Math.abs(loopDelta);\n\t\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif (pending <= 0) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\t\t\t\t\tif (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'finished',\n\t\t\t\t\t\t\taction: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\t\t\t\t\t\tif (pending === 1) {\n\t\t\t\t\t\t\t// entering the last round\n\t\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\n\t\t\t\t\t\t\tthis._setEndings(atStart, !atStart, pingPong);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setEndings(false, false, pingPong);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'loop',\n\t\t\t\t\t\t\taction: this,\n\t\t\t\t\t\t\tloopDelta: loopDelta\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.time = time;\n\t\t\t\t}\n\n\t\t\t\tif (pingPong && (loopCount & 1) === 1) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\t\t\t\t\treturn duration - time;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn time;\n\t\t}\n\n\t\t_setEndings(atStart, atEnd, pingPong) {\n\t\t\tconst settings = this._interpolantSettings;\n\n\t\t\tif (pingPong) {\n\t\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\t\t\t} else {\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\t\t\tif (atStart) {\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\t\t\t} else {\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\t\t\t}\n\n\t\t\t\tif (atEnd) {\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\t\t\t} else {\n\t\t\t\t\tsettings.endingEnd = WrapAroundEnding;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_scheduleFading(duration, weightNow, weightThen) {\n\t\t\tconst mixer = this._mixer,\n\t\t\t\t\t\tnow = mixer.time;\n\t\t\tlet interpolant = this._weightInterpolant;\n\n\t\t\tif (interpolant === null) {\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._weightInterpolant = interpolant;\n\t\t\t}\n\n\t\t\tconst times = interpolant.parameterPositions,\n\t\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\t\ttimes[0] = now;\n\t\t\tvalues[0] = weightNow;\n\t\t\ttimes[1] = now + duration;\n\t\t\tvalues[1] = weightThen;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AnimationMixer extends EventDispatcher {\n\t\tconstructor(root) {\n\t\t\tsuper();\n\t\t\tthis._root = root;\n\n\t\t\tthis._initMemoryManager();\n\n\t\t\tthis._accuIndex = 0;\n\t\t\tthis.time = 0;\n\t\t\tthis.timeScale = 1.0;\n\t\t}\n\n\t\t_bindAction(action, prototypeAction) {\n\t\t\tconst root = action._localRoot || this._root,\n\t\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\t\t\tlet bindingsByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingsByName === undefined) {\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[rootUuid] = bindingsByName;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i !== nTracks; ++i) {\n\t\t\t\tconst track = tracks[i],\n\t\t\t\t\t\t\ttrackName = track.name;\n\t\t\t\tlet binding = bindingsByName[trackName];\n\n\t\t\t\tif (binding !== undefined) {\n\t\t\t\t\tbindings[i] = binding;\n\t\t\t\t} else {\n\t\t\t\t\tbinding = bindings[i];\n\n\t\t\t\t\tif (binding !== undefined) {\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\t\t\t\t\tif (binding._cacheIndex === null) {\n\t\t\t\t\t\t\t++binding.referenceCount;\n\n\t\t\t\t\t\t\tthis._addInactiveBinding(binding, rootUuid, trackName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n\t\t\t\t\tbinding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n\t\t\t\t\t++binding.referenceCount;\n\n\t\t\t\t\tthis._addInactiveBinding(binding, rootUuid, trackName);\n\n\t\t\t\t\tbindings[i] = binding;\n\t\t\t\t}\n\n\t\t\t\tinterpolants[i].resultBuffer = binding.buffer;\n\t\t\t}\n\t\t}\n\n\t\t_activateAction(action) {\n\t\t\tif (!this._isActiveAction(action)) {\n\t\t\t\tif (action._cacheIndex === null) {\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\t\t\t\t\tconst rootUuid = (action._localRoot || this._root).uuid,\n\t\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[clipUuid];\n\n\t\t\t\t\tthis._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n\t\t\t\t\tthis._addInactiveAction(action, clipUuid, rootUuid);\n\t\t\t\t}\n\n\t\t\t\tconst bindings = action._propertyBindings; // increment reference counts / sort out state\n\n\t\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\t\tif (binding.useCount++ === 0) {\n\t\t\t\t\t\tthis._lendBinding(binding);\n\n\t\t\t\t\t\tbinding.saveOriginalState();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction(action);\n\t\t\t}\n\t\t}\n\n\t\t_deactivateAction(action) {\n\t\t\tif (this._isActiveAction(action)) {\n\t\t\t\tconst bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n\t\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\t\tif (--binding.useCount === 0) {\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\n\t\t\t\t\t\tthis._takeBackBinding(binding);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction(action);\n\t\t\t}\n\t\t} // Memory manager\n\n\n\t\t_initMemoryManager() {\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._actionsByClip = {}; // inside:\n\t\t\t// {\n\t\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t\t// }\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n\t\t\tthis._nActiveBindings = 0;\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\n\t\t\tthis._nActiveControlInterpolants = 0;\n\t\t\tconst scope = this;\n\t\t\tthis.stats = {\n\t\t\t\tactions: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._actions.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveActions;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._bindings.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveBindings;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._controlInterpolants.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t};\n\t\t} // Memory management for AnimationAction objects\n\n\n\t\t_isActiveAction(action) {\n\t\t\tconst index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\t\t}\n\n\t\t_addInactiveAction(action, clipUuid, rootUuid) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\t\tlet actionsForClip = actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip === undefined) {\n\t\t\t\tactionsForClip = {\n\t\t\t\t\tknownActions: [action],\n\t\t\t\t\tactionByRoot: {}\n\t\t\t\t};\n\t\t\t\taction._byClipCacheIndex = 0;\n\t\t\t\tactionsByClip[clipUuid] = actionsForClip;\n\t\t\t} else {\n\t\t\t\tconst knownActions = actionsForClip.knownActions;\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push(action);\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push(action);\n\t\t\tactionsForClip.actionByRoot[rootUuid] = action;\n\t\t}\n\n\t\t_removeInactiveAction(action) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tlastInactiveAction = actions[actions.length - 1],\n\t\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[cacheIndex] = lastInactiveAction;\n\t\t\tactions.pop();\n\t\t\taction._cacheIndex = null;\n\t\t\tconst clipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\t\tactionsForClip = actionsByClip[clipUuid],\n\t\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\t\t\t\t\tlastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n\t\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[byClipCacheIndex] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\t\t\taction._byClipCacheIndex = null;\n\t\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\t\trootUuid = (action._localRoot || this._root).uuid;\n\t\t\tdelete actionByRoot[rootUuid];\n\n\t\t\tif (knownActionsForClip.length === 0) {\n\t\t\t\tdelete actionsByClip[clipUuid];\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction(action);\n\t\t}\n\n\t\t_removeInactiveBindingsForAction(action) {\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\tif (--binding.referenceCount === 0) {\n\t\t\t\t\tthis._removeInactiveBinding(binding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_lendAction(action) {\n\t\t\t// [ active actions |\tinactive actions\t]\n\t\t\t// [\tactive actions >| inactive actions ]\n\t\t\t//\t\t\t\t\t\t\t\t s\t\t\t\ta\n\t\t\t//\t\t\t\t\t\t\t\t\t<-swap->\n\t\t\t//\t\t\t\t\t\t\t\t a\t\t\t\ts\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveActions++,\n\t\t\t\t\t\tfirstInactiveAction = actions[lastActiveIndex];\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[lastActiveIndex] = action;\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[prevIndex] = firstInactiveAction;\n\t\t}\n\n\t\t_takeBackAction(action) {\n\t\t\t// [\tactive actions\t| inactive actions ]\n\t\t\t// [ active actions |< inactive actions\t]\n\t\t\t//\t\t\t\ta\t\t\t\ts\n\t\t\t//\t\t\t\t <-swap->\n\t\t\t//\t\t\t\ts\t\t\t\ta\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveActions,\n\t\t\t\t\t\tlastActiveAction = actions[firstInactiveIndex];\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[firstInactiveIndex] = action;\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[prevIndex] = lastActiveAction;\n\t\t} // Memory management for PropertyMixer objects\n\n\n\t\t_addInactiveBinding(binding, rootUuid, trackName) {\n\t\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindings = this._bindings;\n\t\t\tlet bindingByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingByName === undefined) {\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[rootUuid] = bindingByName;\n\t\t\t}\n\n\t\t\tbindingByName[trackName] = binding;\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push(binding);\n\t\t}\n\n\t\t_removeInactiveBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindingByName = bindingsByRoot[rootUuid],\n\t\t\t\t\t\tlastInactiveBinding = bindings[bindings.length - 1],\n\t\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[cacheIndex] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\t\t\tdelete bindingByName[trackName];\n\n\t\t\tif (Object.keys(bindingByName).length === 0) {\n\t\t\t\tdelete bindingsByRoot[rootUuid];\n\t\t\t}\n\t\t}\n\n\t\t_lendBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveBindings++,\n\t\t\t\t\t\tfirstInactiveBinding = bindings[lastActiveIndex];\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[lastActiveIndex] = binding;\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[prevIndex] = firstInactiveBinding;\n\t\t}\n\n\t\t_takeBackBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveBindings,\n\t\t\t\t\t\tlastActiveBinding = bindings[firstInactiveIndex];\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[firstInactiveIndex] = binding;\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[prevIndex] = lastActiveBinding;\n\t\t} // Memory management of Interpolants for weight and time scale\n\n\n\t\t_lendControlInterpolant() {\n\t\t\tconst interpolants = this._controlInterpolants,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants++;\n\t\t\tlet interpolant = interpolants[lastActiveIndex];\n\n\t\t\tif (interpolant === undefined) {\n\t\t\t\tinterpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[lastActiveIndex] = interpolant;\n\t\t\t}\n\n\t\t\treturn interpolant;\n\t\t}\n\n\t\t_takeBackControlInterpolant(interpolant) {\n\t\t\tconst interpolants = this._controlInterpolants,\n\t\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveControlInterpolants,\n\t\t\t\t\t\tlastActiveInterpolant = interpolants[firstInactiveIndex];\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[firstInactiveIndex] = interpolant;\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[prevIndex] = lastActiveInterpolant;\n\t\t} // return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\n\n\t\tclipAction(clip, optionalRoot, blendMode) {\n\t\t\tconst root = optionalRoot || this._root,\n\t\t\t\t\t\trootUuid = root.uuid;\n\t\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n\t\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\t\t\tconst actionsForClip = this._actionsByClip[clipUuid];\n\t\t\tlet prototypeAction = null;\n\n\t\t\tif (blendMode === undefined) {\n\t\t\t\tif (clipObject !== null) {\n\t\t\t\t\tblendMode = clipObject.blendMode;\n\t\t\t\t} else {\n\t\t\t\t\tblendMode = NormalAnimationBlendMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\tconst existingAction = actionsForClip.actionByRoot[rootUuid];\n\n\t\t\t\tif (existingAction !== undefined && existingAction.blendMode === blendMode) {\n\t\t\t\t\treturn existingAction;\n\t\t\t\t} // we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\n\n\t\t\t\tprototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n\t\t\t\tif (clipObject === null) clipObject = prototypeAction._clip;\n\t\t\t} // clip must be known when specified via string\n\n\n\t\t\tif (clipObject === null) return null; // allocate all resources required to run it\n\n\t\t\tconst newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n\t\t\tthis._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n\t\t\tthis._addInactiveAction(newAction, clipUuid, rootUuid);\n\n\t\t\treturn newAction;\n\t\t} // get an existing action\n\n\n\t\texistingAction(clip, optionalRoot) {\n\t\t\tconst root = optionalRoot || this._root,\n\t\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\t\tclipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n\t\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\treturn actionsForClip.actionByRoot[rootUuid] || null;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} // deactivates all previously scheduled actions\n\n\n\t\tstopAllAction() {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tnActions = this._nActiveActions;\n\n\t\t\tfor (let i = nActions - 1; i >= 0; --i) {\n\t\t\t\tactions[i].stop();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // advance the time and update apply the animation\n\n\n\t\tupdate(deltaTime) {\n\t\t\tdeltaTime *= this.timeScale;\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\t\ttimeDirection = Math.sign(deltaTime),\n\t\t\t\t\t\taccuIndex = this._accuIndex ^= 1; // run active actions\n\n\t\t\tfor (let i = 0; i !== nActions; ++i) {\n\t\t\t\tconst action = actions[i];\n\n\t\t\t\taction._update(time, deltaTime, timeDirection, accuIndex);\n\t\t\t} // update scene graph\n\n\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor (let i = 0; i !== nBindings; ++i) {\n\t\t\t\tbindings[i].apply(accuIndex);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Allows you to seek to a specific time in an animation.\n\n\n\t\tsetTime(timeInSeconds) {\n\t\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\n\t\t\tfor (let i = 0; i < this._actions.length; i++) {\n\t\t\t\tthis._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\t\t\t}\n\n\t\t\treturn this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\t\t} // return this mixer's root target object\n\n\n\t\tgetRoot() {\n\t\t\treturn this._root;\n\t\t} // free all resources specific to a particular clip\n\n\n\t\tuncacheClip(clip) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\t\tactionsForClip = actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\t\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n\t\t\t\t\tconst action = actionsToRemove[i];\n\n\t\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\t\tlastInactiveAction = actions[actions.length - 1];\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[cacheIndex] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction(action);\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[clipUuid];\n\t\t\t}\n\t\t} // free all resources specific to a particular root target object\n\n\n\t\tuncacheRoot(root) {\n\t\t\tconst rootUuid = root.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor (const clipUuid in actionsByClip) {\n\t\t\t\tconst actionByRoot = actionsByClip[clipUuid].actionByRoot,\n\t\t\t\t\t\t\taction = actionByRoot[rootUuid];\n\n\t\t\t\tif (action !== undefined) {\n\t\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\t\tthis._removeInactiveAction(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindingByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingByName !== undefined) {\n\t\t\t\tfor (const trackName in bindingByName) {\n\t\t\t\t\tconst binding = bindingByName[trackName];\n\t\t\t\t\tbinding.restoreOriginalState();\n\n\t\t\t\t\tthis._removeInactiveBinding(binding);\n\t\t\t\t}\n\t\t\t}\n\t\t} // remove a targeted clip from the cache\n\n\n\t\tuncacheAction(clip, optionalRoot) {\n\t\t\tconst action = this.existingAction(clip, optionalRoot);\n\n\t\t\tif (action !== null) {\n\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\tthis._removeInactiveAction(action);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\n\n\tclass Uniform {\n\t\tconstructor(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tconsole.warn('THREE.Uniform: Type parameter is no longer needed.');\n\t\t\t\tvalue = arguments[1];\n\t\t\t}\n\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Uniform(this.value.clone === undefined ? this.value : this.value.clone());\n\t\t}\n\n\t}\n\n\tclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\t\tconstructor(array, stride, meshPerAttribute = 1) {\n\t\t\tsuper(array, stride);\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tconst ib = super.clone(data);\n\t\t\tib.meshPerAttribute = this.meshPerAttribute;\n\t\t\treturn ib;\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tconst json = super.toJSON(data);\n\t\t\tjson.isInstancedInterleavedBuffer = true;\n\t\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\t\t\treturn json;\n\t\t}\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tclass GLBufferAttribute {\n\t\tconstructor(buffer, type, itemSize, elementSize, count) {\n\t\t\tthis.buffer = buffer;\n\t\t\tthis.type = type;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.elementSize = elementSize;\n\t\t\tthis.count = count;\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetBuffer(buffer) {\n\t\t\tthis.buffer = buffer;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetType(type, elementSize) {\n\t\t\tthis.type = type;\n\t\t\tthis.elementSize = elementSize;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetItemSize(itemSize) {\n\t\t\tthis.itemSize = itemSize;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetCount(count) {\n\t\t\tthis.count = count;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tGLBufferAttribute.prototype.isGLBufferAttribute = true;\n\n\tclass Raycaster {\n\t\tconstructor(origin, direction, near = 0, far = Infinity) {\n\t\t\tthis.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.camera = null;\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {\n\t\t\t\t\tthreshold: 1\n\t\t\t\t},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: {\n\t\t\t\t\tthreshold: 1\n\t\t\t\t},\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\t}\n\n\t\tset(origin, direction) {\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\t\tthis.ray.set(origin, direction);\n\t\t}\n\n\t\tsetFromCamera(coords, camera) {\n\t\t\tif (camera && camera.isPerspectiveCamera) {\n\t\t\t\tthis.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n\t\t\t\tthis.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n\t\t\t\tthis.camera = camera;\n\t\t\t} else if (camera && camera.isOrthographicCamera) {\n\t\t\t\tthis.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n\t\t\t\tthis.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n\t\t\t\tthis.camera = camera;\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n\t\t\t}\n\t\t}\n\n\t\tintersectObject(object, recursive = false, intersects = []) {\n\t\t\tintersectObject(object, this, intersects, recursive);\n\t\t\tintersects.sort(ascSort);\n\t\t\treturn intersects;\n\t\t}\n\n\t\tintersectObjects(objects, recursive = false, intersects = []) {\n\t\t\tfor (let i = 0, l = objects.length; i < l; i++) {\n\t\t\t\tintersectObject(objects[i], this, intersects, recursive);\n\t\t\t}\n\n\t\t\tintersects.sort(ascSort);\n\t\t\treturn intersects;\n\t\t}\n\n\t}\n\n\tfunction ascSort(a, b) {\n\t\treturn a.distance - b.distance;\n\t}\n\n\tfunction intersectObject(object, raycaster, intersects, recursive) {\n\t\tif (object.layers.test(raycaster.layers)) {\n\t\t\tobject.raycast(raycaster, intersects);\n\t\t}\n\n\t\tif (recursive === true) {\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tintersectObject(children[i], raycaster, intersects, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n\t * The azimuthal angle (theta) is measured from the positive z-axis.\n\t */\n\n\tclass Spherical {\n\t\tconstructor(radius = 1, phi = 0, theta = 0) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi; // polar angle\n\n\t\t\tthis.theta = theta; // azimuthal angle\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(radius, phi, theta) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(other) {\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\t\t\treturn this;\n\t\t} // restrict phi to be betwee EPS and PI-EPS\n\n\n\t\tmakeSafe() {\n\t\t\tconst EPS = 0.000001;\n\t\t\tthis.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromVector3(v) {\n\t\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\n\t\t}\n\n\t\tsetFromCartesianCoords(x, y, z) {\n\t\t\tthis.radius = Math.sqrt(x * x + y * y + z * z);\n\n\t\t\tif (this.radius === 0) {\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\t\t\t} else {\n\t\t\t\tthis.theta = Math.atan2(x, z);\n\t\t\t\tthis.phi = Math.acos(clamp(y / this.radius, -1, 1));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\t/**\n\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n\t */\n\tclass Cylindrical {\n\t\tconstructor(radius = 1, theta = 0, y = 0) {\n\t\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\n\t\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\n\t\t\tthis.y = y; // height above the x-z plane\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(radius, theta, y) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.theta = theta;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(other) {\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.theta = other.theta;\n\t\t\tthis.y = other.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromVector3(v) {\n\t\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\n\t\t}\n\n\t\tsetFromCartesianCoords(x, y, z) {\n\t\t\tthis.radius = Math.sqrt(x * x + z * z);\n\t\t\tthis.theta = Math.atan2(x, z);\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tconst _vector$4 = /*@__PURE__*/new Vector2();\n\n\tclass Box2 {\n\t\tconstructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\t\t}\n\n\t\tset(min, max) {\n\t\t\tthis.min.copy(min);\n\t\t\tthis.max.copy(max);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCenterAndSize(center, size) {\n\t\t\tconst halfSize = _vector$4.copy(size).multiplyScalar(0.5);\n\n\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\tthis.max.copy(center).add(halfSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(box) {\n\t\t\tthis.min.copy(box.min);\n\t\t\tthis.max.copy(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.min.x = this.min.y = +Infinity;\n\t\t\tthis.max.x = this.max.y = -Infinity;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t}\n\n\t\tgetSize(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getSize() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\tthis.min.min(point);\n\t\t\tthis.max.max(point);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByVector(vector) {\n\t\t\tthis.min.sub(vector);\n\t\t\tthis.max.add(vector);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByScalar(scalar) {\n\t\t\tthis.min.addScalar(-scalar);\n\t\t\tthis.max.addScalar(scalar);\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;\n\t\t}\n\n\t\tcontainsBox(box) {\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;\n\t\t}\n\n\t\tgetParameter(point, target) {\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getParameter() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\t// using 4 splitting planes to rule out intersections\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\tconst clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);\n\n\t\t\treturn clampedPoint.sub(point).length();\n\t\t}\n\n\t\tintersect(box) {\n\t\t\tthis.min.max(box.min);\n\t\t\tthis.max.min(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(box) {\n\t\t\tthis.min.min(box.min);\n\t\t\tthis.max.max(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.min.add(offset);\n\t\t\tthis.max.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(box) {\n\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t}\n\n\t}\n\n\tBox2.prototype.isBox2 = true;\n\n\tconst _startP = /*@__PURE__*/new Vector3();\n\n\tconst _startEnd = /*@__PURE__*/new Vector3();\n\n\tclass Line3 {\n\t\tconstructor(start = new Vector3(), end = new Vector3()) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\tset(start, end) {\n\t\t\tthis.start.copy(start);\n\t\t\tthis.end.copy(end);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(line) {\n\t\t\tthis.start.copy(line.start);\n\t\t\tthis.end.copy(line.end);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\n\t\t}\n\n\t\tdelta(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .delta() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.subVectors(this.end, this.start);\n\t\t}\n\n\t\tdistanceSq() {\n\t\t\treturn this.start.distanceToSquared(this.end);\n\t\t}\n\n\t\tdistance() {\n\t\t\treturn this.start.distanceTo(this.end);\n\t\t}\n\n\t\tat(t, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .at() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\n\t\t}\n\n\t\tclosestPointToPointParameter(point, clampToLine) {\n\t\t\t_startP.subVectors(point, this.start);\n\n\t\t\t_startEnd.subVectors(this.end, this.start);\n\n\t\t\tconst startEnd2 = _startEnd.dot(_startEnd);\n\n\t\t\tconst startEnd_startP = _startEnd.dot(_startP);\n\n\t\t\tlet t = startEnd_startP / startEnd2;\n\n\t\t\tif (clampToLine) {\n\t\t\t\tt = clamp(t, 0, 1);\n\t\t\t}\n\n\t\t\treturn t;\n\t\t}\n\n\t\tclosestPointToPoint(point, clampToLine, target) {\n\t\t\tconst t = this.closestPointToPointParameter(point, clampToLine);\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tthis.start.applyMatrix4(matrix);\n\t\t\tthis.end.applyMatrix4(matrix);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(line) {\n\t\t\treturn line.start.equals(this.start) && line.end.equals(this.end);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tclass ImmediateRenderObject extends Object3D {\n\t\tconstructor(material) {\n\t\t\tsuper();\n\t\t\tthis.material = material;\n\n\t\t\tthis.render = function ()\n\t\t\t/* renderCallback */\n\t\t\t{};\n\n\t\t\tthis.hasPositions = false;\n\t\t\tthis.hasNormals = false;\n\t\t\tthis.hasColors = false;\n\t\t\tthis.hasUvs = false;\n\t\t\tthis.positionArray = null;\n\t\t\tthis.normalArray = null;\n\t\t\tthis.colorArray = null;\n\t\t\tthis.uvArray = null;\n\t\t\tthis.count = 0;\n\t\t}\n\n\t}\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\tconst _vector$3 = /*@__PURE__*/new Vector3();\n\n\tclass SpotLightHelper extends Object3D {\n\t\tconstructor(light, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];\n\n\t\t\tfor (let i = 0, j = 1, l = 32; i < l; i++, j++) {\n\t\t\t\tconst p1 = i / l * Math.PI * 2;\n\t\t\t\tconst p2 = j / l * Math.PI * 2;\n\t\t\t\tpositions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tthis.cone = new LineSegments(geometry, material);\n\t\t\tthis.add(this.cone);\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tconst coneWidth = coneLength * Math.tan(this.light.angle);\n\t\t\tthis.cone.scale.set(coneWidth, coneWidth, coneLength);\n\n\t\t\t_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);\n\n\t\t\tthis.cone.lookAt(_vector$3);\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.cone.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.cone.material.color.copy(this.light.color);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst _vector$2 = /*@__PURE__*/new Vector3();\n\n\tconst _boneMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _matrixWorldInv = /*@__PURE__*/new Matrix4();\n\n\tclass SkeletonHelper extends LineSegments {\n\t\tconstructor(object) {\n\t\t\tconst bones = getBoneList(object);\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst vertices = [];\n\t\t\tconst colors = [];\n\t\t\tconst color1 = new Color(0, 0, 1);\n\t\t\tconst color2 = new Color(0, 1, 0);\n\n\t\t\tfor (let i = 0; i < bones.length; i++) {\n\t\t\t\tconst bone = bones[i];\n\n\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\t\tcolors.push(color1.r, color1.g, color1.b);\n\t\t\t\t\tcolors.push(color2.r, color2.g, color2.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttoneMapped: false,\n\t\t\t\ttransparent: true\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'SkeletonHelper';\n\t\t\tthis.isSkeletonHelper = true;\n\t\t\tthis.root = object;\n\t\t\tthis.bones = bones;\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tconst bones = this.bones;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst position = geometry.getAttribute('position');\n\n\t\t\t_matrixWorldInv.copy(this.root.matrixWorld).invert();\n\n\t\t\tfor (let i = 0, j = 0; i < bones.length; i++) {\n\t\t\t\tconst bone = bones[i];\n\n\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\t_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n\n\t\t\t\t\t_vector$2.setFromMatrixPosition(_boneMatrix);\n\n\t\t\t\t\tposition.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n\n\t\t\t\t\t_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n\n\t\t\t\t\t_vector$2.setFromMatrixPosition(_boneMatrix);\n\n\t\t\t\t\tposition.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n\t\t\t\t\tj += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.getAttribute('position').needsUpdate = true;\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tfunction getBoneList(object) {\n\t\tconst boneList = [];\n\n\t\tif (object && object.isBone) {\n\t\t\tboneList.push(object);\n\t\t}\n\n\t\tfor (let i = 0; i < object.children.length; i++) {\n\t\t\tboneList.push.apply(boneList, getBoneList(object.children[i]));\n\t\t}\n\n\t\treturn boneList;\n\t}\n\n\tclass PointLightHelper extends Mesh {\n\t\tconstructor(light, sphereSize, color) {\n\t\t\tconst geometry = new SphereGeometry(sphereSize, 4, 2);\n\t\t\tconst material = new MeshBasicMaterial({\n\t\t\t\twireframe: true,\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.color = color;\n\t\t\tthis.type = 'PointLightHelper';\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\t\t/*\n\t\t\t// TODO: delete this comment?\n\t\t\tconst distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\t\t\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\t\tconst d = light.distance;\n\t\t\tif ( d === 0.0 ) {\n\t\t\t\tthis.lightDistance.visible = false;\n\t\t\t} else {\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\t\t}\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.material.color.copy(this.light.color);\n\t\t\t}\n\t\t\t/*\n\t\t\tconst d = this.light.distance;\n\t\t\t\tif ( d === 0.0 ) {\n\t\t\t\t\tthis.lightDistance.visible = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\t\t\t}\n\t\t\t*/\n\n\t\t}\n\n\t}\n\n\tconst _vector$1 = /*@__PURE__*/new Vector3();\n\n\tconst _color1 = /*@__PURE__*/new Color();\n\n\tconst _color2 = /*@__PURE__*/new Color();\n\n\tclass HemisphereLightHelper extends Object3D {\n\t\tconstructor(light, size, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tconst geometry = new OctahedronGeometry(size);\n\t\t\tgeometry.rotateY(Math.PI * 0.5);\n\t\t\tthis.material = new MeshBasicMaterial({\n\t\t\t\twireframe: true,\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tif (this.color === undefined) this.material.vertexColors = true;\n\t\t\tconst position = geometry.getAttribute('position');\n\t\t\tconst colors = new Float32Array(position.count * 3);\n\t\t\tgeometry.setAttribute('color', new BufferAttribute(colors, 3));\n\t\t\tthis.add(new Mesh(geometry, this.material));\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.children[0].geometry.dispose();\n\t\t\tthis.children[0].material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst mesh = this.children[0];\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tconst colors = mesh.geometry.getAttribute('color');\n\n\t\t\t\t_color1.copy(this.light.color);\n\n\t\t\t\t_color2.copy(this.light.groundColor);\n\n\t\t\t\tfor (let i = 0, l = colors.count; i < l; i++) {\n\t\t\t\t\tconst color = i < l / 2 ? _color1 : _color2;\n\t\t\t\t\tcolors.setXYZ(i, color.r, color.g, color.b);\n\t\t\t\t}\n\n\t\t\t\tcolors.needsUpdate = true;\n\t\t\t}\n\n\t\t\tmesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());\n\t\t}\n\n\t}\n\n\tclass GridHelper extends LineSegments {\n\t\tconstructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {\n\t\t\tcolor1 = new Color(color1);\n\t\t\tcolor2 = new Color(color2);\n\t\t\tconst center = divisions / 2;\n\t\t\tconst step = size / divisions;\n\t\t\tconst halfSize = size / 2;\n\t\t\tconst vertices = [],\n\t\t\t\t\t\tcolors = [];\n\n\t\t\tfor (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n\t\t\t\tvertices.push(-halfSize, 0, k, halfSize, 0, k);\n\t\t\t\tvertices.push(k, 0, -halfSize, k, 0, halfSize);\n\t\t\t\tconst color = i === center ? color1 : color2;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'GridHelper';\n\t\t}\n\n\t}\n\n\tclass PolarGridHelper extends LineSegments {\n\t\tconstructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {\n\t\t\tcolor1 = new Color(color1);\n\t\t\tcolor2 = new Color(color2);\n\t\t\tconst vertices = [];\n\t\t\tconst colors = []; // create the radials\n\n\t\t\tfor (let i = 0; i <= radials; i++) {\n\t\t\t\tconst v = i / radials * (Math.PI * 2);\n\t\t\t\tconst x = Math.sin(v) * radius;\n\t\t\t\tconst z = Math.cos(v) * radius;\n\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\tconst color = i & 1 ? color1 : color2;\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t} // create the circles\n\n\n\t\t\tfor (let i = 0; i <= circles; i++) {\n\t\t\t\tconst color = i & 1 ? color1 : color2;\n\t\t\t\tconst r = radius - radius / circles * i;\n\n\t\t\t\tfor (let j = 0; j < divisions; j++) {\n\t\t\t\t\t// first vertex\n\t\t\t\t\tlet v = j / divisions * (Math.PI * 2);\n\t\t\t\t\tlet x = Math.sin(v) * r;\n\t\t\t\t\tlet z = Math.cos(v) * r;\n\t\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\t\tcolors.push(color.r, color.g, color.b); // second vertex\n\n\t\t\t\t\tv = (j + 1) / divisions * (Math.PI * 2);\n\t\t\t\t\tx = Math.sin(v) * r;\n\t\t\t\t\tz = Math.cos(v) * r;\n\t\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'PolarGridHelper';\n\t\t}\n\n\t}\n\n\tconst _v1 = /*@__PURE__*/new Vector3();\n\n\tconst _v2 = /*@__PURE__*/new Vector3();\n\n\tconst _v3 = /*@__PURE__*/new Vector3();\n\n\tclass DirectionalLightHelper extends Object3D {\n\t\tconstructor(light, size, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tif (size === undefined) size = 1;\n\t\t\tlet geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tthis.lightPlane = new Line(geometry, material);\n\t\t\tthis.add(this.lightPlane);\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\t\t\tthis.targetLine = new Line(geometry, material);\n\t\t\tthis.add(this.targetLine);\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.lightPlane.geometry.dispose();\n\t\t\tthis.lightPlane.material.dispose();\n\t\t\tthis.targetLine.geometry.dispose();\n\t\t\tthis.targetLine.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\t_v1.setFromMatrixPosition(this.light.matrixWorld);\n\n\t\t\t_v2.setFromMatrixPosition(this.light.target.matrixWorld);\n\n\t\t\t_v3.subVectors(_v2, _v1);\n\n\t\t\tthis.lightPlane.lookAt(_v2);\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.lightPlane.material.color.set(this.color);\n\t\t\t\tthis.targetLine.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.lightPlane.material.color.copy(this.light.color);\n\t\t\t\tthis.targetLine.material.color.copy(this.light.color);\n\t\t\t}\n\n\t\t\tthis.targetLine.lookAt(_v2);\n\t\t\tthis.targetLine.scale.z = _v3.length();\n\t\t}\n\n\t}\n\n\tconst _vector = /*@__PURE__*/new Vector3();\n\n\tconst _camera = /*@__PURE__*/new Camera();\n\t/**\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\n\tclass CameraHelper extends LineSegments {\n\t\tconstructor(camera) {\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tconst vertices = [];\n\t\t\tconst colors = [];\n\t\t\tconst pointMap = {}; // colors\n\n\t\t\tconst colorFrustum = new Color(0xffaa00);\n\t\t\tconst colorCone = new Color(0xff0000);\n\t\t\tconst colorUp = new Color(0x00aaff);\n\t\t\tconst colorTarget = new Color(0xffffff);\n\t\t\tconst colorCross = new Color(0x333333); // near\n\n\t\t\taddLine('n1', 'n2', colorFrustum);\n\t\t\taddLine('n2', 'n4', colorFrustum);\n\t\t\taddLine('n4', 'n3', colorFrustum);\n\t\t\taddLine('n3', 'n1', colorFrustum); // far\n\n\t\t\taddLine('f1', 'f2', colorFrustum);\n\t\t\taddLine('f2', 'f4', colorFrustum);\n\t\t\taddLine('f4', 'f3', colorFrustum);\n\t\t\taddLine('f3', 'f1', colorFrustum); // sides\n\n\t\t\taddLine('n1', 'f1', colorFrustum);\n\t\t\taddLine('n2', 'f2', colorFrustum);\n\t\t\taddLine('n3', 'f3', colorFrustum);\n\t\t\taddLine('n4', 'f4', colorFrustum); // cone\n\n\t\t\taddLine('p', 'n1', colorCone);\n\t\t\taddLine('p', 'n2', colorCone);\n\t\t\taddLine('p', 'n3', colorCone);\n\t\t\taddLine('p', 'n4', colorCone); // up\n\n\t\t\taddLine('u1', 'u2', colorUp);\n\t\t\taddLine('u2', 'u3', colorUp);\n\t\t\taddLine('u3', 'u1', colorUp); // target\n\n\t\t\taddLine('c', 't', colorTarget);\n\t\t\taddLine('p', 'c', colorCross); // cross\n\n\t\t\taddLine('cn1', 'cn2', colorCross);\n\t\t\taddLine('cn3', 'cn4', colorCross);\n\t\t\taddLine('cf1', 'cf2', colorCross);\n\t\t\taddLine('cf3', 'cf4', colorCross);\n\n\t\t\tfunction addLine(a, b, color) {\n\t\t\t\taddPoint(a, color);\n\t\t\t\taddPoint(b, color);\n\t\t\t}\n\n\t\t\tfunction addPoint(id, color) {\n\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\n\t\t\t\tif (pointMap[id] === undefined) {\n\t\t\t\t\tpointMap[id] = [];\n\t\t\t\t}\n\n\t\t\t\tpointMap[id].push(vertices.length / 3 - 1);\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'CameraHelper';\n\t\t\tthis.camera = camera;\n\t\t\tif (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.pointMap = pointMap;\n\t\t\tthis.update();\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst pointMap = this.pointMap;\n\t\t\tconst w = 1,\n\t\t\t\t\t\th = 1; // we need just camera projection matrix inverse\n\t\t\t// world matrix must be identity\n\n\t\t\t_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target\n\n\n\t\t\tsetPoint('c', pointMap, geometry, _camera, 0, 0, -1);\n\t\t\tsetPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near\n\n\t\t\tsetPoint('n1', pointMap, geometry, _camera, -w, -h, -1);\n\t\t\tsetPoint('n2', pointMap, geometry, _camera, w, -h, -1);\n\t\t\tsetPoint('n3', pointMap, geometry, _camera, -w, h, -1);\n\t\t\tsetPoint('n4', pointMap, geometry, _camera, w, h, -1); // far\n\n\t\t\tsetPoint('f1', pointMap, geometry, _camera, -w, -h, 1);\n\t\t\tsetPoint('f2', pointMap, geometry, _camera, w, -h, 1);\n\t\t\tsetPoint('f3', pointMap, geometry, _camera, -w, h, 1);\n\t\t\tsetPoint('f4', pointMap, geometry, _camera, w, h, 1); // up\n\n\t\t\tsetPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);\n\t\t\tsetPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);\n\t\t\tsetPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross\n\n\t\t\tsetPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);\n\t\t\tsetPoint('cf2', pointMap, geometry, _camera, w, 0, 1);\n\t\t\tsetPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);\n\t\t\tsetPoint('cf4', pointMap, geometry, _camera, 0, h, 1);\n\t\t\tsetPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);\n\t\t\tsetPoint('cn2', pointMap, geometry, _camera, w, 0, -1);\n\t\t\tsetPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);\n\t\t\tsetPoint('cn4', pointMap, geometry, _camera, 0, h, -1);\n\t\t\tgeometry.getAttribute('position').needsUpdate = true;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t}\n\n\tfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n\t\t_vector.set(x, y, z).unproject(camera);\n\n\t\tconst points = pointMap[point];\n\n\t\tif (points !== undefined) {\n\t\t\tconst position = geometry.getAttribute('position');\n\n\t\t\tfor (let i = 0, l = points.length; i < l; i++) {\n\t\t\t\tposition.setXYZ(points[i], _vector.x, _vector.y, _vector.z);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst _box = /*@__PURE__*/new Box3();\n\n\tclass BoxHelper extends LineSegments {\n\t\tconstructor(object, color = 0xffff00) {\n\t\t\tconst indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n\t\t\tconst positions = new Float32Array(8 * 3);\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex(new BufferAttribute(indices, 1));\n\t\t\tgeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.object = object;\n\t\t\tthis.type = 'BoxHelper';\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\t}\n\n\t\tupdate(object) {\n\t\t\tif (object !== undefined) {\n\t\t\t\tconsole.warn('THREE.BoxHelper: .update() has no longer arguments.');\n\t\t\t}\n\n\t\t\tif (this.object !== undefined) {\n\t\t\t\t_box.setFromObject(this.object);\n\t\t\t}\n\n\t\t\tif (_box.isEmpty()) return;\n\t\t\tconst min = _box.min;\n\t\t\tconst max = _box.max;\n\t\t\t/*\n\t\t\t\t5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tconst position = this.geometry.attributes.position;\n\t\t\tconst array = position.array;\n\t\t\tarray[0] = max.x;\n\t\t\tarray[1] = max.y;\n\t\t\tarray[2] = max.z;\n\t\t\tarray[3] = min.x;\n\t\t\tarray[4] = max.y;\n\t\t\tarray[5] = max.z;\n\t\t\tarray[6] = min.x;\n\t\t\tarray[7] = min.y;\n\t\t\tarray[8] = max.z;\n\t\t\tarray[9] = max.x;\n\t\t\tarray[10] = min.y;\n\t\t\tarray[11] = max.z;\n\t\t\tarray[12] = max.x;\n\t\t\tarray[13] = max.y;\n\t\t\tarray[14] = min.z;\n\t\t\tarray[15] = min.x;\n\t\t\tarray[16] = max.y;\n\t\t\tarray[17] = min.z;\n\t\t\tarray[18] = min.x;\n\t\t\tarray[19] = min.y;\n\t\t\tarray[20] = min.z;\n\t\t\tarray[21] = max.x;\n\t\t\tarray[22] = min.y;\n\t\t\tarray[23] = min.z;\n\t\t\tposition.needsUpdate = true;\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\t}\n\n\t\tsetFromObject(object) {\n\t\t\tthis.object = object;\n\t\t\tthis.update();\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tLineSegments.prototype.copy.call(this, source);\n\t\t\tthis.object = source.object;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Box3Helper extends LineSegments {\n\t\tconstructor(box, color = 0xffff00) {\n\t\t\tconst indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n\t\t\tconst positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex(new BufferAttribute(indices, 1));\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.box = box;\n\t\t\tthis.type = 'Box3Helper';\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tconst box = this.box;\n\t\t\tif (box.isEmpty()) return;\n\t\t\tbox.getCenter(this.position);\n\t\t\tbox.getSize(this.scale);\n\t\t\tthis.scale.multiplyScalar(0.5);\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tclass PlaneHelper extends Line {\n\t\tconstructor(plane, size = 1, hex = 0xffff00) {\n\t\t\tconst color = hex;\n\t\t\tconst positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tgeometry.computeBoundingSphere();\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.type = 'PlaneHelper';\n\t\t\tthis.plane = plane;\n\t\t\tthis.size = size;\n\t\t\tconst positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];\n\t\t\tconst geometry2 = new BufferGeometry();\n\t\t\tgeometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));\n\t\t\tgeometry2.computeBoundingSphere();\n\t\t\tthis.add(new Mesh(geometry2, new MeshBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\topacity: 0.2,\n\t\t\t\ttransparent: true,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttoneMapped: false\n\t\t\t})));\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tlet scale = -this.plane.constant;\n\t\t\tif (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter\n\n\t\t\tthis.scale.set(0.5 * this.size, 0.5 * this.size, scale);\n\t\t\tthis.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\t\t\tthis.lookAt(this.plane.normal);\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tconst _axis = /*@__PURE__*/new Vector3();\n\n\tlet _lineGeometry, _coneGeometry;\n\n\tclass ArrowHelper extends Object3D {\n\t\t// dir is assumed to be normalized\n\t\tconstructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ArrowHelper';\n\n\t\t\tif (_lineGeometry === undefined) {\n\t\t\t\t_lineGeometry = new BufferGeometry();\n\n\t\t\t\t_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\t\t\t_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);\n\n\t\t\t\t_coneGeometry.translate(0, -0.5, 0);\n\t\t\t}\n\n\t\t\tthis.position.copy(origin);\n\t\t\tthis.line = new Line(_lineGeometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add(this.line);\n\t\t\tthis.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add(this.cone);\n\t\t\tthis.setDirection(dir);\n\t\t\tthis.setLength(length, headLength, headWidth);\n\t\t}\n\n\t\tsetDirection(dir) {\n\t\t\t// dir is assumed to be normalized\n\t\t\tif (dir.y > 0.99999) {\n\t\t\t\tthis.quaternion.set(0, 0, 0, 1);\n\t\t\t} else if (dir.y < -0.99999) {\n\t\t\t\tthis.quaternion.set(1, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\t_axis.set(dir.z, 0, -dir.x).normalize();\n\n\t\t\t\tconst radians = Math.acos(dir.y);\n\t\t\t\tthis.quaternion.setFromAxisAngle(_axis, radians);\n\t\t\t}\n\t\t}\n\n\t\tsetLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {\n\t\t\tthis.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458\n\n\t\t\tthis.line.updateMatrix();\n\t\t\tthis.cone.scale.set(headWidth, headLength, headWidth);\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\t}\n\n\t\tsetColor(color) {\n\t\t\tthis.line.material.color.set(color);\n\t\t\tthis.cone.material.color.set(color);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source, false);\n\t\t\tthis.line.copy(source.line);\n\t\t\tthis.cone.copy(source.cone);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AxesHelper extends LineSegments {\n\t\tconstructor(size = 1) {\n\t\t\tconst vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];\n\t\t\tconst colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'AxesHelper';\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t}\n\n\tconst _floatView = new Float32Array(1);\n\n\tconst _int32View = new Int32Array(_floatView.buffer);\n\n\tclass DataUtils {\n\t\t// Converts float32 to float16 (stored as uint16 value).\n\t\tstatic toHalfFloat(val) {\n\t\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t\t* used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t\t* by James Tursa?s half-precision code. */\n\t\t\t_floatView[0] = val;\n\t\t\tconst x = _int32View[0];\n\t\t\tlet bits = x >> 16 & 0x8000;\n\t\t\t/* Get the sign */\n\n\t\t\tlet m = x >> 12 & 0x07ff;\n\t\t\t/* Keep one extra bit for rounding */\n\n\t\t\tconst e = x >> 23 & 0xff;\n\t\t\t/* Using int is faster here */\n\n\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t\t* half, return signed zero. */\n\n\t\t\tif (e < 103) return bits;\n\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\t\t\tif (e > 142) {\n\t\t\t\tbits |= 0x7c00;\n\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\n\t\t\t\tbits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\t\treturn bits;\n\t\t\t}\n\t\t\t/* If exponent underflows but not too much, return a denormal */\n\n\n\t\t\tif (e < 113) {\n\t\t\t\tm |= 0x0800;\n\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t\t* to 1, which is OK. */\n\n\t\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\tbits |= e - 112 << 10 | m >> 1;\n\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t\t* the exponent, which is OK. */\n\n\t\t\tbits += m & 1;\n\t\t\treturn bits;\n\t\t}\n\n\t}\n\n\tconst LOD_MIN = 4;\n\tconst LOD_MAX = 8;\n\tconst SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n\t// chosen to approximate a Trowbridge-Reitz distribution function times the\n\t// geometric shadowing function. These sigma values squared must match the\n\t// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\n\tconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\tconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n\t// samples and exit early, but not recompile the shader.\n\n\tconst MAX_SAMPLES = 20;\n\tconst ENCODINGS = {\n\t\t[LinearEncoding]: 0,\n\t\t[sRGBEncoding]: 1,\n\t\t[RGBEEncoding]: 2,\n\t\t[RGBM7Encoding]: 3,\n\t\t[RGBM16Encoding]: 4,\n\t\t[RGBDEncoding]: 5,\n\t\t[GammaEncoding]: 6\n\t};\n\tconst backgroundMaterial = new MeshBasicMaterial({\n\t\tside: BackSide,\n\t\tdepthWrite: false,\n\t\tdepthTest: false\n\t});\n\tconst backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n\n\tconst _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\n\tconst {\n\t\t_lodPlanes,\n\t\t_sizeLods,\n\t\t_sigmas\n\t} = /*@__PURE__*/_createPlanes();\n\n\tconst _clearColor = /*@__PURE__*/new Color();\n\n\tlet _oldTarget = null; // Golden Ratio\n\n\tconst PHI = (1 + Math.sqrt(5)) / 2;\n\tconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n\t// same axis), used as axis directions evenly spread on a sphere.\n\n\tconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n\t/**\n\t * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n\t * (PMREM) from a cubeMap environment texture. This allows different levels of\n\t * blur to be quickly accessed based on material roughness. It is packed into a\n\t * special CubeUV format that allows us to perform custom interpolation so that\n\t * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n\t * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n\t * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n\t * higher roughness levels. In this way we maintain resolution to smoothly\n\t * interpolate diffuse lighting while limiting sampling computation.\n\t *\n\t * Paper: Fast, Accurate Image-Based Lighting\n\t * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n\t*/\n\n\tfunction convertLinearToRGBE(color) {\n\t\tconst maxComponent = Math.max(color.r, color.g, color.b);\n\t\tconst fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n\t\tcolor.multiplyScalar(Math.pow(2.0, -fExp));\n\t\tconst alpha = (fExp + 128.0) / 255.0;\n\t\treturn alpha;\n\t}\n\n\tclass PMREMGenerator {\n\t\tconstructor(renderer) {\n\t\t\tthis._renderer = renderer;\n\t\t\tthis._pingPongRenderTarget = null;\n\t\t\tthis._blurMaterial = _getBlurShader(MAX_SAMPLES);\n\t\t\tthis._equirectShader = null;\n\t\t\tthis._cubemapShader = null;\n\n\t\t\tthis._compileMaterial(this._blurMaterial);\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t\t * is placed at the origin).\n\t\t */\n\n\n\t\tfromScene(scene, sigma = 0, near = 0.1, far = 100) {\n\t\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\t\tthis._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n\t\t\tif (sigma > 0) {\n\t\t\t\tthis._blur(cubeUVRenderTarget, 0, 0, sigma);\n\t\t\t}\n\n\t\t\tthis._applyPMREM(cubeUVRenderTarget);\n\n\t\t\tthis._cleanup(cubeUVRenderTarget);\n\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t\t * as this matches best with the 256 x 256 cubemap output.\n\t\t */\n\n\n\t\tfromEquirectangular(equirectangular) {\n\t\t\treturn this._fromTexture(equirectangular);\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t\t * as this matches best with the 256 x 256 cubemap output.\n\t\t */\n\n\n\t\tfromCubemap(cubemap) {\n\t\t\treturn this._fromTexture(cubemap);\n\t\t}\n\t\t/**\n\t\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t\t * your texture's network fetch for increased concurrency.\n\t\t */\n\n\n\t\tcompileCubemapShader() {\n\t\t\tif (this._cubemapShader === null) {\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t\tthis._compileMaterial(this._cubemapShader);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t\t * your texture's network fetch for increased concurrency.\n\t\t */\n\n\n\t\tcompileEquirectangularShader() {\n\t\t\tif (this._equirectShader === null) {\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t\tthis._compileMaterial(this._equirectShader);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t\t * one of them will cause any others to also become unusable.\n\t\t */\n\n\n\t\tdispose() {\n\t\t\tthis._blurMaterial.dispose();\n\n\t\t\tif (this._cubemapShader !== null) this._cubemapShader.dispose();\n\t\t\tif (this._equirectShader !== null) this._equirectShader.dispose();\n\n\t\t\tfor (let i = 0; i < _lodPlanes.length; i++) {\n\t\t\t\t_lodPlanes[i].dispose();\n\t\t\t}\n\t\t} // private interface\n\n\n\t\t_cleanup(outputTarget) {\n\t\t\tthis._pingPongRenderTarget.dispose();\n\n\t\t\tthis._renderer.setRenderTarget(_oldTarget);\n\n\t\t\toutputTarget.scissorTest = false;\n\n\t\t\t_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n\t\t}\n\n\t\t_fromTexture(texture) {\n\t\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\t\tconst cubeUVRenderTarget = this._allocateTargets(texture);\n\n\t\t\tthis._textureToCubeUV(texture, cubeUVRenderTarget);\n\n\t\t\tthis._applyPMREM(cubeUVRenderTarget);\n\n\t\t\tthis._cleanup(cubeUVRenderTarget);\n\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\n\t\t_allocateTargets(texture) {\n\t\t\t// warning: null texture is valid\n\t\t\tconst params = {\n\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\ttype: UnsignedByteType,\n\t\t\t\tformat: RGBEFormat,\n\t\t\t\tencoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n\t\t\t\tdepthBuffer: false\n\t\t\t};\n\n\t\t\tconst cubeUVRenderTarget = _createRenderTarget(params);\n\n\t\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget(params);\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\n\t\t_compileMaterial(material) {\n\t\t\tconst tmpMesh = new Mesh(_lodPlanes[0], material);\n\n\t\t\tthis._renderer.compile(tmpMesh, _flatCamera);\n\t\t}\n\n\t\t_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n\t\t\tconst fov = 90;\n\t\t\tconst aspect = 1;\n\t\t\tconst cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tconst upSign = [1, -1, 1, 1, 1, 1];\n\t\t\tconst forwardSign = [1, 1, 1, -1, -1, -1];\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst originalAutoClear = renderer.autoClear;\n\t\t\tconst outputEncoding = renderer.outputEncoding;\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\trenderer.getClearColor(_clearColor);\n\t\t\trenderer.toneMapping = NoToneMapping;\n\t\t\trenderer.outputEncoding = LinearEncoding;\n\t\t\trenderer.autoClear = false;\n\t\t\tlet useSolidColor = false;\n\t\t\tconst background = scene.background;\n\n\t\t\tif (background) {\n\t\t\t\tif (background.isColor) {\n\t\t\t\t\tbackgroundMaterial.color.copy(background).convertSRGBToLinear();\n\t\t\t\t\tscene.background = null;\n\t\t\t\t\tconst alpha = convertLinearToRGBE(backgroundMaterial.color);\n\t\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\t\tuseSolidColor = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbackgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();\n\t\t\t\tconst alpha = convertLinearToRGBE(backgroundMaterial.color);\n\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\tuseSolidColor = true;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst col = i % 3;\n\n\t\t\t\tif (col == 0) {\n\t\t\t\t\tcubeCamera.up.set(0, upSign[i], 0);\n\t\t\t\t\tcubeCamera.lookAt(forwardSign[i], 0, 0);\n\t\t\t\t} else if (col == 1) {\n\t\t\t\t\tcubeCamera.up.set(0, 0, upSign[i]);\n\t\t\t\t\tcubeCamera.lookAt(0, forwardSign[i], 0);\n\t\t\t\t} else {\n\t\t\t\t\tcubeCamera.up.set(0, upSign[i], 0);\n\t\t\t\t\tcubeCamera.lookAt(0, 0, forwardSign[i]);\n\t\t\t\t}\n\n\t\t\t\t_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n\t\t\t\trenderer.setRenderTarget(cubeUVRenderTarget);\n\n\t\t\t\tif (useSolidColor) {\n\t\t\t\t\trenderer.render(backgroundBox, cubeCamera);\n\t\t\t\t}\n\n\t\t\t\trenderer.render(scene, cubeCamera);\n\t\t\t}\n\n\t\t\trenderer.toneMapping = toneMapping;\n\t\t\trenderer.outputEncoding = outputEncoding;\n\t\t\trenderer.autoClear = originalAutoClear;\n\t\t}\n\n\t\t_textureToCubeUV(texture, cubeUVRenderTarget) {\n\t\t\tconst renderer = this._renderer;\n\n\t\t\tif (texture.isCubeTexture) {\n\t\t\t\tif (this._cubemapShader == null) {\n\t\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._equirectShader == null) {\n\t\t\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\t\tconst mesh = new Mesh(_lodPlanes[0], material);\n\t\t\tconst uniforms = material.uniforms;\n\t\t\tuniforms['envMap'].value = texture;\n\n\t\t\tif (!texture.isCubeTexture) {\n\t\t\t\tuniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n\t\t\t}\n\n\t\t\tuniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n\t\t\tuniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n\n\t\t\t_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n\t\t\trenderer.setRenderTarget(cubeUVRenderTarget);\n\t\t\trenderer.render(mesh, _flatCamera);\n\t\t}\n\n\t\t_applyPMREM(cubeUVRenderTarget) {\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst autoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tfor (let i = 1; i < TOTAL_LODS; i++) {\n\t\t\t\tconst sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n\t\t\t\tconst poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n\t\t\t\tthis._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n\t\t\t}\n\n\t\t\trenderer.autoClear = autoClear;\n\t\t}\n\t\t/**\n\t\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t\t * accurate at the poles, but still does a decent job.\n\t\t */\n\n\n\t\t_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n\t\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\t\tthis._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n\t\t\tthis._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n\t\t}\n\n\t\t_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst blurMaterial = this._blurMaterial;\n\n\t\t\tif (direction !== 'latitudinal' && direction !== 'longitudinal') {\n\t\t\t\tconsole.error('blur direction must be either latitudinal or longitudinal!');\n\t\t\t} // Number of standard deviations at which to cut off the discrete approximation.\n\n\n\t\t\tconst STANDARD_DEVIATIONS = 3;\n\t\t\tconst blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n\t\t\tconst blurUniforms = blurMaterial.uniforms;\n\t\t\tconst pixels = _sizeLods[lodIn] - 1;\n\t\t\tconst radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n\t\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\t\tconst samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n\t\t\tif (samples > MAX_SAMPLES) {\n\t\t\t\tconsole.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n\t\t\t}\n\n\t\t\tconst weights = [];\n\t\t\tlet sum = 0;\n\n\t\t\tfor (let i = 0; i < MAX_SAMPLES; ++i) {\n\t\t\t\tconst x = i / sigmaPixels;\n\t\t\t\tconst weight = Math.exp(-x * x / 2);\n\t\t\t\tweights.push(weight);\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tsum += weight;\n\t\t\t\t} else if (i < samples) {\n\t\t\t\t\tsum += 2 * weight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = weights[i] / sum;\n\t\t\t}\n\n\t\t\tblurUniforms['envMap'].value = targetIn.texture;\n\t\t\tblurUniforms['samples'].value = samples;\n\t\t\tblurUniforms['weights'].value = weights;\n\t\t\tblurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n\t\t\tif (poleAxis) {\n\t\t\t\tblurUniforms['poleAxis'].value = poleAxis;\n\t\t\t}\n\n\t\t\tblurUniforms['dTheta'].value = radiansPerPixel;\n\t\t\tblurUniforms['mipInt'].value = LOD_MAX - lodIn;\n\t\t\tblurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n\t\t\tblurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n\t\t\tconst outputSize = _sizeLods[lodOut];\n\t\t\tconst x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n\t\t\tconst y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n\t\t\t_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n\t\t\trenderer.setRenderTarget(targetOut);\n\t\t\trenderer.render(blurMesh, _flatCamera);\n\t\t}\n\n\t}\n\n\tfunction _isLDR(texture) {\n\t\tif (texture === undefined || texture.type !== UnsignedByteType) return false;\n\t\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\t}\n\n\tfunction _createPlanes() {\n\t\tconst _lodPlanes = [];\n\t\tconst _sizeLods = [];\n\t\tconst _sigmas = [];\n\t\tlet lod = LOD_MAX;\n\n\t\tfor (let i = 0; i < TOTAL_LODS; i++) {\n\t\t\tconst sizeLod = Math.pow(2, lod);\n\n\t\t\t_sizeLods.push(sizeLod);\n\n\t\t\tlet sigma = 1.0 / sizeLod;\n\n\t\t\tif (i > LOD_MAX - LOD_MIN) {\n\t\t\t\tsigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n\t\t\t} else if (i == 0) {\n\t\t\t\tsigma = 0;\n\t\t\t}\n\n\t\t\t_sigmas.push(sigma);\n\n\t\t\tconst texelSize = 1.0 / (sizeLod - 1);\n\t\t\tconst min = -texelSize / 2;\n\t\t\tconst max = 1 + texelSize / 2;\n\t\t\tconst uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n\t\t\tconst cubeFaces = 6;\n\t\t\tconst vertices = 6;\n\t\t\tconst positionSize = 3;\n\t\t\tconst uvSize = 2;\n\t\t\tconst faceIndexSize = 1;\n\t\t\tconst position = new Float32Array(positionSize * vertices * cubeFaces);\n\t\t\tconst uv = new Float32Array(uvSize * vertices * cubeFaces);\n\t\t\tconst faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n\t\t\tfor (let face = 0; face < cubeFaces; face++) {\n\t\t\t\tconst x = face % 3 * 2 / 3 - 1;\n\t\t\t\tconst y = face > 2 ? 0 : -1;\n\t\t\t\tconst coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n\t\t\t\tposition.set(coordinates, positionSize * vertices * face);\n\t\t\t\tuv.set(uv1, uvSize * vertices * face);\n\t\t\t\tconst fill = [face, face, face, face, face, face];\n\t\t\t\tfaceIndex.set(fill, faceIndexSize * vertices * face);\n\t\t\t}\n\n\t\t\tconst planes = new BufferGeometry();\n\t\t\tplanes.setAttribute('position', new BufferAttribute(position, positionSize));\n\t\t\tplanes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n\t\t\tplanes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n\t\t\t_lodPlanes.push(planes);\n\n\t\t\tif (lod > LOD_MIN) {\n\t\t\t\tlod--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t_lodPlanes,\n\t\t\t_sizeLods,\n\t\t\t_sigmas\n\t\t};\n\t}\n\n\tfunction _createRenderTarget(params) {\n\t\tconst cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n\t\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\t\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\t\tcubeUVRenderTarget.scissorTest = true;\n\t\treturn cubeUVRenderTarget;\n\t}\n\n\tfunction _setViewport(target, x, y, width, height) {\n\t\ttarget.viewport.set(x, y, width, height);\n\t\ttarget.scissor.set(x, y, width, height);\n\t}\n\n\tfunction _getBlurShader(maxSamples) {\n\t\tconst weights = new Float32Array(maxSamples);\n\t\tconst poleAxis = new Vector3(0, 1, 0);\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'SphericalGaussianBlur',\n\t\t\tdefines: {\n\t\t\t\t'n': maxSamples\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'samples': {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\t'weights': {\n\t\t\t\t\tvalue: weights\n\t\t\t\t},\n\t\t\t\t'latitudinal': {\n\t\t\t\t\tvalue: false\n\t\t\t\t},\n\t\t\t\t'dTheta': {\n\t\t\t\t\tvalue: 0\n\t\t\t\t},\n\t\t\t\t'mipInt': {\n\t\t\t\t\tvalue: 0\n\t\t\t\t},\n\t\t\t\t'poleAxis': {\n\t\t\t\t\tvalue: poleAxis\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getEquirectShader() {\n\t\tconst texelSize = new Vector2(1, 1);\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'EquirectangularToCubeUV',\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'texelSize': {\n\t\t\t\t\tvalue: texelSize\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getCubemapShader() {\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'CubemapToCubeUV',\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getCommonVertexShader() {\n\t\treturn (\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n\t\t);\n\t}\n\n\tfunction _getEncodings() {\n\t\treturn (\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`\n\t\t);\n\t}\n\n\tconst LineStrip = 0;\n\tconst LinePieces = 1;\n\tconst NoColors = 0;\n\tconst FaceColors = 1;\n\tconst VertexColors = 2;\n\tfunction MeshFaceMaterial(materials) {\n\t\tconsole.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');\n\t\treturn materials;\n\t}\n\tfunction MultiMaterial(materials = []) {\n\t\tconsole.warn('THREE.MultiMaterial has been removed. Use an Array instead.');\n\t\tmaterials.isMultiMaterial = true;\n\t\tmaterials.materials = materials;\n\n\t\tmaterials.clone = function () {\n\t\t\treturn materials.slice();\n\t\t};\n\n\t\treturn materials;\n\t}\n\tfunction PointCloud(geometry, material) {\n\t\tconsole.warn('THREE.PointCloud has been renamed to THREE.Points.');\n\t\treturn new Points(geometry, material);\n\t}\n\tfunction Particle(material) {\n\t\tconsole.warn('THREE.Particle has been renamed to THREE.Sprite.');\n\t\treturn new Sprite(material);\n\t}\n\tfunction ParticleSystem(geometry, material) {\n\t\tconsole.warn('THREE.ParticleSystem has been renamed to THREE.Points.');\n\t\treturn new Points(geometry, material);\n\t}\n\tfunction PointCloudMaterial(parameters) {\n\t\tconsole.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction ParticleBasicMaterial(parameters) {\n\t\tconsole.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction ParticleSystemMaterial(parameters) {\n\t\tconsole.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction Vertex(x, y, z) {\n\t\tconsole.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');\n\t\treturn new Vector3(x, y, z);\n\t} //\n\n\tfunction DynamicBufferAttribute(array, itemSize) {\n\t\tconsole.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');\n\t\treturn new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);\n\t}\n\tfunction Int8Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');\n\t\treturn new Int8BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint8Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');\n\t\treturn new Uint8BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint8ClampedAttribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');\n\t\treturn new Uint8ClampedBufferAttribute(array, itemSize);\n\t}\n\tfunction Int16Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');\n\t\treturn new Int16BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint16Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');\n\t\treturn new Uint16BufferAttribute(array, itemSize);\n\t}\n\tfunction Int32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');\n\t\treturn new Int32BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');\n\t\treturn new Uint32BufferAttribute(array, itemSize);\n\t}\n\tfunction Float32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');\n\t\treturn new Float32BufferAttribute(array, itemSize);\n\t}\n\tfunction Float64Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');\n\t\treturn new Float64BufferAttribute(array, itemSize);\n\t} //\n\n\tCurve.create = function (construct, getPoint) {\n\t\tconsole.log('THREE.Curve.create() has been deprecated');\n\t\tconstruct.prototype = Object.create(Curve.prototype);\n\t\tconstruct.prototype.constructor = construct;\n\t\tconstruct.prototype.getPoint = getPoint;\n\t\treturn construct;\n\t}; //\n\n\n\tPath.prototype.fromPoints = function (points) {\n\t\tconsole.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');\n\t\treturn this.setFromPoints(points);\n\t}; //\n\n\n\tfunction AxisHelper(size) {\n\t\tconsole.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');\n\t\treturn new AxesHelper(size);\n\t}\n\tfunction BoundingBoxHelper(object, color) {\n\t\tconsole.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');\n\t\treturn new BoxHelper(object, color);\n\t}\n\tfunction EdgesHelper(object, hex) {\n\t\tconsole.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');\n\t\treturn new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({\n\t\t\tcolor: hex !== undefined ? hex : 0xffffff\n\t\t}));\n\t}\n\n\tGridHelper.prototype.setColors = function () {\n\t\tconsole.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\t\tconsole.error('THREE.SkeletonHelper: update() no longer needs to be called.');\n\t};\n\n\tfunction WireframeHelper(object, hex) {\n\t\tconsole.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');\n\t\treturn new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({\n\t\t\tcolor: hex !== undefined ? hex : 0xffffff\n\t\t}));\n\t} //\n\n\tLoader.prototype.extractUrlBase = function (url) {\n\t\tconsole.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');\n\t\treturn LoaderUtils.extractUrlBase(url);\n\t};\n\n\tLoader.Handlers = {\n\t\tadd: function ()\n\t\t/* regex, loader */\n\t\t{\n\t\t\tconsole.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');\n\t\t},\n\t\tget: function ()\n\t\t/* file */\n\t\t{\n\t\t\tconsole.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');\n\t\t}\n\t};\n\tfunction XHRLoader(manager) {\n\t\tconsole.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');\n\t\treturn new FileLoader(manager);\n\t}\n\tfunction BinaryTextureLoader(manager) {\n\t\tconsole.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');\n\t\treturn new DataTextureLoader(manager);\n\t} //\n\n\tBox2.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box2: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t};\n\n\tBox2.prototype.empty = function () {\n\t\tconsole.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t};\n\n\tBox2.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tBox2.prototype.size = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box2: .size() has been renamed to .getSize().');\n\t\treturn this.getSize(optionalTarget);\n\t}; //\n\n\n\tBox3.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box3: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t};\n\n\tBox3.prototype.empty = function () {\n\t\tconsole.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t};\n\n\tBox3.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tBox3.prototype.isIntersectionSphere = function (sphere) {\n\t\tconsole.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n\t\treturn this.intersectsSphere(sphere);\n\t};\n\n\tBox3.prototype.size = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box3: .size() has been renamed to .getSize().');\n\t\treturn this.getSize(optionalTarget);\n\t}; //\n\n\n\tSphere.prototype.empty = function () {\n\t\tconsole.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t}; //\n\n\n\tFrustum.prototype.setFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');\n\t\treturn this.setFromProjectionMatrix(m);\n\t}; //\n\n\n\tLine3.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Line3: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t}; //\n\n\n\tMatrix3.prototype.flattenToArrayOffset = function (array, offset) {\n\t\tconsole.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n\t\treturn this.toArray(array, offset);\n\t};\n\n\tMatrix3.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\n\t\treturn vector.applyMatrix3(this);\n\t};\n\n\tMatrix3.prototype.multiplyVector3Array = function ()\n\t/* a */\n\t{\n\t\tconsole.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');\n\t};\n\n\tMatrix3.prototype.applyToBufferAttribute = function (attribute) {\n\t\tconsole.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');\n\t\treturn attribute.applyMatrix3(this);\n\t};\n\n\tMatrix3.prototype.applyToVector3Array = function ()\n\t/* array, offset, length */\n\t{\n\t\tconsole.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\n\t};\n\n\tMatrix3.prototype.getInverse = function (matrix) {\n\t\tconsole.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n\t\treturn this.copy(matrix).invert();\n\t}; //\n\n\n\tMatrix4.prototype.extractPosition = function (m) {\n\t\tconsole.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\n\t\treturn this.copyPosition(m);\n\t};\n\n\tMatrix4.prototype.flattenToArrayOffset = function (array, offset) {\n\t\tconsole.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n\t\treturn this.toArray(array, offset);\n\t};\n\n\tMatrix4.prototype.getPosition = function () {\n\t\tconsole.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\n\t\treturn new Vector3().setFromMatrixColumn(this, 3);\n\t};\n\n\tMatrix4.prototype.setRotationFromQuaternion = function (q) {\n\t\tconsole.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\n\t\treturn this.makeRotationFromQuaternion(q);\n\t};\n\n\tMatrix4.prototype.multiplyToArray = function () {\n\t\tconsole.warn('THREE.Matrix4: .multiplyToArray() has been removed.');\n\t};\n\n\tMatrix4.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.multiplyVector4 = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.multiplyVector3Array = function ()\n\t/* a */\n\t{\n\t\tconsole.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateAxis = function (v) {\n\t\tconsole.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\n\t\tv.transformDirection(this);\n\t};\n\n\tMatrix4.prototype.crossVector = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.translate = function () {\n\t\tconsole.error('THREE.Matrix4: .translate() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateX = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateX() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateY = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateY() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateZ = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateZ() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateByAxis = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n\t};\n\n\tMatrix4.prototype.applyToBufferAttribute = function (attribute) {\n\t\tconsole.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');\n\t\treturn attribute.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.applyToVector3Array = function ()\n\t/* array, offset, length */\n\t{\n\t\tconsole.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\n\t};\n\n\tMatrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {\n\t\tconsole.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');\n\t\treturn this.makePerspective(left, right, top, bottom, near, far);\n\t};\n\n\tMatrix4.prototype.getInverse = function (matrix) {\n\t\tconsole.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n\t\treturn this.copy(matrix).invert();\n\t}; //\n\n\n\tPlane.prototype.isIntersectionLine = function (line) {\n\t\tconsole.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');\n\t\treturn this.intersectsLine(line);\n\t}; //\n\n\n\tQuaternion.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\n\t\treturn vector.applyQuaternion(this);\n\t};\n\n\tQuaternion.prototype.inverse = function () {\n\t\tconsole.warn('THREE.Quaternion: .inverse() has been renamed to invert().');\n\t\treturn this.invert();\n\t}; //\n\n\n\tRay.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tRay.prototype.isIntersectionPlane = function (plane) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');\n\t\treturn this.intersectsPlane(plane);\n\t};\n\n\tRay.prototype.isIntersectionSphere = function (sphere) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n\t\treturn this.intersectsSphere(sphere);\n\t}; //\n\n\n\tTriangle.prototype.area = function () {\n\t\tconsole.warn('THREE.Triangle: .area() has been renamed to .getArea().');\n\t\treturn this.getArea();\n\t};\n\n\tTriangle.prototype.barycoordFromPoint = function (point, target) {\n\t\tconsole.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n\t\treturn this.getBarycoord(point, target);\n\t};\n\n\tTriangle.prototype.midpoint = function (target) {\n\t\tconsole.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');\n\t\treturn this.getMidpoint(target);\n\t};\n\n\tTriangle.prototypenormal = function (target) {\n\t\tconsole.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n\t\treturn this.getNormal(target);\n\t};\n\n\tTriangle.prototype.plane = function (target) {\n\t\tconsole.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');\n\t\treturn this.getPlane(target);\n\t};\n\n\tTriangle.barycoordFromPoint = function (point, a, b, c, target) {\n\t\tconsole.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n\t\treturn Triangle.getBarycoord(point, a, b, c, target);\n\t};\n\n\tTriangle.normal = function (a, b, c, target) {\n\t\tconsole.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n\t\treturn Triangle.getNormal(a, b, c, target);\n\t}; //\n\n\n\tShape.prototype.extractAllPoints = function (divisions) {\n\t\tconsole.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');\n\t\treturn this.extractPoints(divisions);\n\t};\n\n\tShape.prototype.extrude = function (options) {\n\t\tconsole.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');\n\t\treturn new ExtrudeGeometry(this, options);\n\t};\n\n\tShape.prototype.makeGeometry = function (options) {\n\t\tconsole.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');\n\t\treturn new ShapeGeometry(this, options);\n\t}; //\n\n\n\tVector2.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector2.prototype.distanceToManhattan = function (v) {\n\t\tconsole.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n\t\treturn this.manhattanDistanceTo(v);\n\t};\n\n\tVector2.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tVector3.prototype.setEulerFromRotationMatrix = function () {\n\t\tconsole.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n\t};\n\n\tVector3.prototype.setEulerFromQuaternion = function () {\n\t\tconsole.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n\t};\n\n\tVector3.prototype.getPositionFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\n\t\treturn this.setFromMatrixPosition(m);\n\t};\n\n\tVector3.prototype.getScaleFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\n\t\treturn this.setFromMatrixScale(m);\n\t};\n\n\tVector3.prototype.getColumnFromMatrix = function (index, matrix) {\n\t\tconsole.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\n\t\treturn this.setFromMatrixColumn(matrix, index);\n\t};\n\n\tVector3.prototype.applyProjection = function (m) {\n\t\tconsole.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');\n\t\treturn this.applyMatrix4(m);\n\t};\n\n\tVector3.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector3.prototype.distanceToManhattan = function (v) {\n\t\tconsole.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n\t\treturn this.manhattanDistanceTo(v);\n\t};\n\n\tVector3.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tVector4.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector4.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tObject3D.prototype.getChildByName = function (name) {\n\t\tconsole.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\n\t\treturn this.getObjectByName(name);\n\t};\n\n\tObject3D.prototype.renderDepth = function () {\n\t\tconsole.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\n\t};\n\n\tObject3D.prototype.translate = function (distance, axis) {\n\t\tconsole.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\n\t\treturn this.translateOnAxis(axis, distance);\n\t};\n\n\tObject3D.prototype.getWorldRotation = function () {\n\t\tconsole.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');\n\t};\n\n\tObject3D.prototype.applyMatrix = function (matrix) {\n\t\tconsole.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');\n\t\treturn this.applyMatrix4(matrix);\n\t};\n\n\tObject.defineProperties(Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\t\t\t}\n\t\t}\n\t});\n\n\tMesh.prototype.setDrawMode = function () {\n\t\tconsole.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n\t};\n\n\tObject.defineProperties(Mesh.prototype, {\n\t\tdrawMode: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');\n\t\t\t\treturn TrianglesDrawMode;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n\t\t\t}\n\t\t}\n\t});\n\n\tSkinnedMesh.prototype.initBones = function () {\n\t\tconsole.error('THREE.SkinnedMesh: initBones() has been removed.');\n\t}; //\n\n\n\tPerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {\n\t\tconsole.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');\n\t\tif (filmGauge !== undefined) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength(focalLength);\n\t}; //\n\n\n\tObject.defineProperties(Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .onlyShadow has been removed.');\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowBias is now .shadow.bias.');\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .shadowDarkness has been removed.');\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tObject.defineProperties(BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t},\n\t\tdynamic: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n\t\t\t\treturn this.usage === DynamicDrawUsage;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* value */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n\t\t\t\tthis.setUsage(DynamicDrawUsage);\n\t\t\t}\n\t\t}\n\t});\n\n\tBufferAttribute.prototype.setDynamic = function (value) {\n\t\tconsole.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');\n\t\tthis.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n\t\treturn this;\n\t};\n\n\tBufferAttribute.prototype.copyIndicesArray = function ()\n\t/* indices */\n\t{\n\t\tconsole.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');\n\t}, BufferAttribute.prototype.setArray = function ()\n\t/* array */\n\t{\n\t\tconsole.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n\t}; //\n\n\tBufferGeometry.prototype.addIndex = function (index) {\n\t\tconsole.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\n\t\tthis.setIndex(index);\n\t};\n\n\tBufferGeometry.prototype.addAttribute = function (name, attribute) {\n\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');\n\n\t\tif (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\n\t\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n\t\t\treturn this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\n\t\t}\n\n\t\tif (name === 'index') {\n\t\t\tconsole.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\n\t\t\tthis.setIndex(attribute);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.setAttribute(name, attribute);\n\t};\n\n\tBufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {\n\t\tif (indexOffset !== undefined) {\n\t\t\tconsole.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\n\t\t}\n\n\t\tconsole.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\n\t\tthis.addGroup(start, count);\n\t};\n\n\tBufferGeometry.prototype.clearDrawCalls = function () {\n\t\tconsole.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\n\t\tthis.clearGroups();\n\t};\n\n\tBufferGeometry.prototype.computeOffsets = function () {\n\t\tconsole.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n\t};\n\n\tBufferGeometry.prototype.removeAttribute = function (name) {\n\t\tconsole.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');\n\t\treturn this.deleteAttribute(name);\n\t};\n\n\tBufferGeometry.prototype.applyMatrix = function (matrix) {\n\t\tconsole.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');\n\t\treturn this.applyMatrix4(matrix);\n\t};\n\n\tObject.defineProperties(BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t});\n\n\tInterleavedBuffer.prototype.setDynamic = function (value) {\n\t\tconsole.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');\n\t\tthis.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n\t\treturn this;\n\t};\n\n\tInterleavedBuffer.prototype.setArray = function ()\n\t/* array */\n\t{\n\t\tconsole.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n\t}; //\n\n\n\tExtrudeGeometry.prototype.getArrays = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');\n\t};\n\n\tExtrudeGeometry.prototype.addShapeList = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .addShape() has been removed.');\n\t}; //\n\n\n\tScene.prototype.dispose = function () {\n\t\tconsole.error('THREE.Scene: .dispose() has been removed.');\n\t}; //\n\n\n\tUniform.prototype.onUpdate = function () {\n\t\tconsole.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');\n\t\treturn this;\n\t}; //\n\n\n\tObject.defineProperties(Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapAround has been removed.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapAround has been removed.');\n\t\t\t}\n\t\t},\n\t\toverdraw: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .overdraw has been removed.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Material: .overdraw has been removed.');\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapRGB has been removed.');\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t},\n\t\tshading: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t\tthis.flatShading = value === FlatShading;\n\t\t\t}\n\t\t},\n\t\tstencilMask: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n\t\t\t\treturn this.stencilFuncMask;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n\t\t\t\tthis.stencilFuncMask = value;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperties(ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tWebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {\n\t\tconsole.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');\n\t\tthis.setRenderTarget(renderTarget);\n\t\tthis.clear(color, depth, stencil);\n\t};\n\n\tWebGLRenderer.prototype.animate = function (callback) {\n\t\tconsole.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');\n\t\tthis.setAnimationLoop(callback);\n\t};\n\n\tWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');\n\t\treturn this.getRenderTarget();\n\t};\n\n\tWebGLRenderer.prototype.getMaxAnisotropy = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');\n\t\treturn this.capabilities.getMaxAnisotropy();\n\t};\n\n\tWebGLRenderer.prototype.getPrecision = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');\n\t\treturn this.capabilities.precision;\n\t};\n\n\tWebGLRenderer.prototype.resetGLState = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');\n\t\treturn this.state.reset();\n\t};\n\n\tWebGLRenderer.prototype.supportsFloatTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\n\t\treturn this.extensions.get('OES_texture_float');\n\t};\n\n\tWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\n\t\treturn this.extensions.get('OES_texture_half_float');\n\t};\n\n\tWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\n\t\treturn this.extensions.get('OES_standard_derivatives');\n\t};\n\n\tWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\n\t\treturn this.extensions.get('WEBGL_compressed_texture_s3tc');\n\t};\n\n\tWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\n\t\treturn this.extensions.get('WEBGL_compressed_texture_pvrtc');\n\t};\n\n\tWebGLRenderer.prototype.supportsBlendMinMax = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\n\t\treturn this.extensions.get('EXT_blend_minmax');\n\t};\n\n\tWebGLRenderer.prototype.supportsVertexTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');\n\t\treturn this.capabilities.vertexTextures;\n\t};\n\n\tWebGLRenderer.prototype.supportsInstancedArrays = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\n\t\treturn this.extensions.get('ANGLE_instanced_arrays');\n\t};\n\n\tWebGLRenderer.prototype.enableScissorTest = function (boolean) {\n\t\tconsole.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');\n\t\tthis.setScissorTest(boolean);\n\t};\n\n\tWebGLRenderer.prototype.initMaterial = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.addPrePlugin = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.addPostPlugin = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.updateShadowMap = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setFaceCulling = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.allocTextureUnit = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTexture = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTexture() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTexture2D = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTextureCube = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');\n\t\treturn this.getActiveMipmapLevel();\n\t};\n\n\tObject.defineProperties(WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* value */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\tcontext: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');\n\t\t\t\treturn this.getContext();\n\t\t\t}\n\t\t},\n\t\tvr: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');\n\t\t\t\treturn this.xr;\n\t\t\t}\n\t\t},\n\t\tgammaInput: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n\t\t\t}\n\t\t},\n\t\tgammaOutput: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n\t\t\t\tthis.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;\n\t\t\t}\n\t\t},\n\t\ttoneMappingWhitePoint: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n\t\t\t\treturn 1.0;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperties(WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* cullFace */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\trenderReverseSided: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\trenderSingleSided: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t}\n\t});\n\tfunction WebGLRenderTargetCube(width, height, options) {\n\t\tconsole.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');\n\t\treturn new WebGLCubeRenderTarget(width, options);\n\t} //\n\n\tObject.defineProperties(WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tAudio.prototype.load = function (file) {\n\t\tconsole.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');\n\t\tconst scope = this;\n\t\tconst audioLoader = new AudioLoader();\n\t\taudioLoader.load(file, function (buffer) {\n\t\t\tscope.setBuffer(buffer);\n\t\t});\n\t\treturn this;\n\t};\n\n\tAudioAnalyser.prototype.getData = function () {\n\t\tconsole.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');\n\t\treturn this.getFrequencyData();\n\t}; //\n\n\n\tCubeCamera.prototype.updateCubeMap = function (renderer, scene) {\n\t\tconsole.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');\n\t\treturn this.update(renderer, scene);\n\t};\n\n\tCubeCamera.prototype.clear = function (renderer, color, depth, stencil) {\n\t\tconsole.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');\n\t\treturn this.renderTarget.clear(renderer, color, depth, stencil);\n\t};\n\n\tImageUtils.crossOrigin = undefined;\n\n\tImageUtils.loadTexture = function (url, mapping, onLoad, onError) {\n\t\tconsole.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');\n\t\tconst loader = new TextureLoader();\n\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\tconst texture = loader.load(url, onLoad, undefined, onError);\n\t\tif (mapping) texture.mapping = mapping;\n\t\treturn texture;\n\t};\n\n\tImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {\n\t\tconsole.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');\n\t\tconst loader = new CubeTextureLoader();\n\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\tconst texture = loader.load(urls, onLoad, undefined, onError);\n\t\tif (mapping) texture.mapping = mapping;\n\t\treturn texture;\n\t};\n\n\tImageUtils.loadCompressedTexture = function () {\n\t\tconsole.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\n\t};\n\n\tImageUtils.loadCompressedTextureCube = function () {\n\t\tconsole.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\n\t}; //\n\n\n\tfunction CanvasRenderer() {\n\t\tconsole.error('THREE.CanvasRenderer has been removed');\n\t} //\n\n\tfunction JSONLoader() {\n\t\tconsole.error('THREE.JSONLoader has been removed.');\n\t} //\n\n\tconst SceneUtils = {\n\t\tcreateMultiMaterialObject: function ()\n\t\t/* geometry, materials */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t},\n\t\tdetach: function ()\n\t\t/* child, parent, scene */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t},\n\t\tattach: function ()\n\t\t/* child, scene, parent */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t}\n\t}; //\n\n\tfunction LensFlare() {\n\t\tconsole.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');\n\t}\n\n\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t/* eslint-disable no-undef */\n\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {\n\t\t\tdetail: {\n\t\t\t\trevision: REVISION\n\t\t\t}\n\t\t}));\n\t\t/* eslint-enable no-undef */\n\n\t}\n\n\tif (typeof window !== 'undefined') {\n\t\tif (window.__THREE__) {\n\t\t\tconsole.warn('WARNING: Multiple instances of Three.js being imported.');\n\t\t} else {\n\t\t\twindow.__THREE__ = REVISION;\n\t\t}\n\t}\n\n\texports.ACESFilmicToneMapping = ACESFilmicToneMapping;\n\texports.AddEquation = AddEquation;\n\texports.AddOperation = AddOperation;\n\texports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.AlphaFormat = AlphaFormat;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.AlwaysStencilFunc = AlwaysStencilFunc;\n\texports.AmbientLight = AmbientLight;\n\texports.AmbientLightProbe = AmbientLightProbe;\n\texports.AnimationClip = AnimationClip;\n\texports.AnimationLoader = AnimationLoader;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationUtils = AnimationUtils;\n\texports.ArcCurve = ArcCurve;\n\texports.ArrayCamera = ArrayCamera;\n\texports.ArrowHelper = ArrowHelper;\n\texports.Audio = Audio;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.AudioContext = AudioContext;\n\texports.AudioListener = AudioListener;\n\texports.AudioLoader = AudioLoader;\n\texports.AxesHelper = AxesHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.BackSide = BackSide;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.Bone = Bone;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.Box2 = Box2;\n\texports.Box3 = Box3;\n\texports.Box3Helper = Box3Helper;\n\texports.BoxBufferGeometry = BoxGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.BoxHelper = BoxHelper;\n\texports.BufferAttribute = BufferAttribute;\n\texports.BufferGeometry = BufferGeometry;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.ByteType = ByteType;\n\texports.Cache = Cache;\n\texports.Camera = Camera;\n\texports.CameraHelper = CameraHelper;\n\texports.CanvasRenderer = CanvasRenderer;\n\texports.CanvasTexture = CanvasTexture;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.CircleBufferGeometry = CircleGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.Clock = Clock;\n\texports.Color = Color;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.ConeBufferGeometry = ConeGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.CubeCamera = CubeCamera;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.CubeTexture = CubeTexture;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.CullFaceNone = CullFaceNone;\n\texports.Curve = Curve;\n\texports.CurvePath = CurvePath;\n\texports.CustomBlending = CustomBlending;\n\texports.CustomToneMapping = CustomToneMapping;\n\texports.CylinderBufferGeometry = CylinderGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.Cylindrical = Cylindrical;\n\texports.DataTexture = DataTexture;\n\texports.DataTexture2DArray = DataTexture2DArray;\n\texports.DataTexture3D = DataTexture3D;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.DataUtils = DataUtils;\n\texports.DecrementStencilOp = DecrementStencilOp;\n\texports.DecrementWrapStencilOp = DecrementWrapStencilOp;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.DepthTexture = DepthTexture;\n\texports.DirectionalLight = DirectionalLight;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.DodecahedronBufferGeometry = DodecahedronGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DoubleSide = DoubleSide;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.DynamicCopyUsage = DynamicCopyUsage;\n\texports.DynamicDrawUsage = DynamicDrawUsage;\n\texports.DynamicReadUsage = DynamicReadUsage;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.EdgesHelper = EdgesHelper;\n\texports.EllipseCurve = EllipseCurve;\n\texports.EqualDepth = EqualDepth;\n\texports.EqualStencilFunc = EqualStencilFunc;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.Euler = Euler;\n\texports.EventDispatcher = EventDispatcher;\n\texports.ExtrudeBufferGeometry = ExtrudeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.FaceColors = FaceColors;\n\texports.FileLoader = FileLoader;\n\texports.FlatShading = FlatShading;\n\texports.Float16BufferAttribute = Float16BufferAttribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Float32BufferAttribute = Float32BufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float64BufferAttribute = Float64BufferAttribute;\n\texports.FloatType = FloatType;\n\texports.Fog = Fog;\n\texports.FogExp2 = FogExp2;\n\texports.Font = Font;\n\texports.FontLoader = FontLoader;\n\texports.FrontSide = FrontSide;\n\texports.Frustum = Frustum;\n\texports.GLBufferAttribute = GLBufferAttribute;\n\texports.GLSL1 = GLSL1;\n\texports.GLSL3 = GLSL3;\n\texports.GammaEncoding = GammaEncoding;\n\texports.GreaterDepth = GreaterDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;\n\texports.GreaterStencilFunc = GreaterStencilFunc;\n\texports.GridHelper = GridHelper;\n\texports.Group = Group;\n\texports.HalfFloatType = HalfFloatType;\n\texports.HemisphereLight = HemisphereLight;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.HemisphereLightProbe = HemisphereLightProbe;\n\texports.IcosahedronBufferGeometry = IcosahedronGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.ImageBitmapLoader = ImageBitmapLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.ImageUtils = ImageUtils;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.IncrementStencilOp = IncrementStencilOp;\n\texports.IncrementWrapStencilOp = IncrementWrapStencilOp;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InstancedMesh = InstancedMesh;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Int16BufferAttribute = Int16BufferAttribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Int32BufferAttribute = Int32BufferAttribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.Int8BufferAttribute = Int8BufferAttribute;\n\texports.IntType = IntType;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.Interpolant = Interpolant;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.InvertStencilOp = InvertStencilOp;\n\texports.JSONLoader = JSONLoader;\n\texports.KeepStencilOp = KeepStencilOp;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.LOD = LOD;\n\texports.LatheBufferGeometry = LatheGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.Layers = Layers;\n\texports.LensFlare = LensFlare;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.LessEqualStencilFunc = LessEqualStencilFunc;\n\texports.LessStencilFunc = LessStencilFunc;\n\texports.Light = Light;\n\texports.LightProbe = LightProbe;\n\texports.Line = Line;\n\texports.Line3 = Line3;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.LineCurve = LineCurve;\n\texports.LineCurve3 = LineCurve3;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineLoop = LineLoop;\n\texports.LinePieces = LinePieces;\n\texports.LineSegments = LineSegments;\n\texports.LineStrip = LineStrip;\n\texports.LinearEncoding = LinearEncoding;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;\n\texports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.Loader = Loader;\n\texports.LoaderUtils = LoaderUtils;\n\texports.LoadingManager = LoadingManager;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopPingPong = LoopPingPong;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.MOUSE = MOUSE;\n\texports.Material = Material;\n\texports.MaterialLoader = MaterialLoader;\n\texports.Math = MathUtils;\n\texports.MathUtils = MathUtils;\n\texports.Matrix3 = Matrix3;\n\texports.Matrix4 = Matrix4;\n\texports.MaxEquation = MaxEquation;\n\texports.Mesh = Mesh;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshDistanceMaterial = MeshDistanceMaterial;\n\texports.MeshFaceMaterial = MeshFaceMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshMatcapMaterial = MeshMatcapMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshToonMaterial = MeshToonMaterial;\n\texports.MinEquation = MinEquation;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.MixOperation = MixOperation;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;\n\texports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;\n\texports.NeverDepth = NeverDepth;\n\texports.NeverStencilFunc = NeverStencilFunc;\n\texports.NoBlending = NoBlending;\n\texports.NoColors = NoColors;\n\texports.NoToneMapping = NoToneMapping;\n\texports.NormalAnimationBlendMode = NormalAnimationBlendMode;\n\texports.NormalBlending = NormalBlending;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.NotEqualStencilFunc = NotEqualStencilFunc;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.Object3D = Object3D;\n\texports.ObjectLoader = ObjectLoader;\n\texports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;\n\texports.OctahedronBufferGeometry = OctahedronGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OneFactor = OneFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.PMREMGenerator = PMREMGenerator;\n\texports.ParametricBufferGeometry = ParametricGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.Particle = Particle;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystem = ParticleSystem;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Path = Path;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.Plane = Plane;\n\texports.PlaneBufferGeometry = PlaneGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.PlaneHelper = PlaneHelper;\n\texports.PointCloud = PointCloud;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.PointLight = PointLight;\n\texports.PointLightHelper = PointLightHelper;\n\texports.Points = Points;\n\texports.PointsMaterial = PointsMaterial;\n\texports.PolarGridHelper = PolarGridHelper;\n\texports.PolyhedronBufferGeometry = PolyhedronGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PositionalAudio = PositionalAudio;\n\texports.PropertyBinding = PropertyBinding;\n\texports.PropertyMixer = PropertyMixer;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.Quaternion = Quaternion;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.REVISION = REVISION;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.RGBAFormat = RGBAFormat;\n\texports.RGBAIntegerFormat = RGBAIntegerFormat;\n\texports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;\n\texports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;\n\texports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;\n\texports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;\n\texports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;\n\texports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;\n\texports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;\n\texports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;\n\texports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;\n\texports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;\n\texports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;\n\texports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;\n\texports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;\n\texports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;\n\texports.RGBA_BPTC_Format = RGBA_BPTC_Format;\n\texports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.RGBEFormat = RGBEFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBIntegerFormat = RGBIntegerFormat;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.RGB_ETC2_Format = RGB_ETC2_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGFormat = RGFormat;\n\texports.RGIntegerFormat = RGIntegerFormat;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.Ray = Ray;\n\texports.Raycaster = Raycaster;\n\texports.RectAreaLight = RectAreaLight;\n\texports.RedFormat = RedFormat;\n\texports.RedIntegerFormat = RedIntegerFormat;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ReplaceStencilOp = ReplaceStencilOp;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.RingBufferGeometry = RingGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;\n\texports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;\n\texports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;\n\texports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;\n\texports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;\n\texports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;\n\texports.Scene = Scene;\n\texports.SceneUtils = SceneUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.ShaderLib = ShaderLib;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.Shape = Shape;\n\texports.ShapeBufferGeometry = ShapeGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ShapePath = ShapePath;\n\texports.ShapeUtils = ShapeUtils;\n\texports.ShortType = ShortType;\n\texports.Skeleton = Skeleton;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.SmoothShading = SmoothShading;\n\texports.Sphere = Sphere;\n\texports.SphereBufferGeometry = SphereGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.Spherical = Spherical;\n\texports.SphericalHarmonics3 = SphericalHarmonics3;\n\texports.SplineCurve = SplineCurve;\n\texports.SpotLight = SpotLight;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.Sprite = Sprite;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.StaticCopyUsage = StaticCopyUsage;\n\texports.StaticDrawUsage = StaticDrawUsage;\n\texports.StaticReadUsage = StaticReadUsage;\n\texports.StereoCamera = StereoCamera;\n\texports.StreamCopyUsage = StreamCopyUsage;\n\texports.StreamDrawUsage = StreamDrawUsage;\n\texports.StreamReadUsage = StreamReadUsage;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.SubtractEquation = SubtractEquation;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.TOUCH = TOUCH;\n\texports.TangentSpaceNormalMap = TangentSpaceNormalMap;\n\texports.TetrahedronBufferGeometry = TetrahedronGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TextBufferGeometry = TextGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.Texture = Texture;\n\texports.TextureLoader = TextureLoader;\n\texports.TorusBufferGeometry = TorusGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.Triangle = Triangle;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TubeBufferGeometry = TubeGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.UVMapping = UVMapping;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Uint16BufferAttribute = Uint16BufferAttribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Uint32BufferAttribute = Uint32BufferAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Uint8BufferAttribute = Uint8BufferAttribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n\texports.Uniform = Uniform;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.VSMShadowMap = VSMShadowMap;\n\texports.Vector2 = Vector2;\n\texports.Vector3 = Vector3;\n\texports.Vector4 = Vector4;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.Vertex = Vertex;\n\texports.VertexColors = VertexColors;\n\texports.VideoTexture = VideoTexture;\n\texports.WebGL1Renderer = WebGL1Renderer;\n\texports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;\n\texports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;\n\texports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.WebGLUtils = WebGLUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.WireframeHelper = WireframeHelper;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.XHRLoader = XHRLoader;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroFactor = ZeroFactor;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.ZeroStencilOp = ZeroStencilOp;\n\texports.sRGBEncoding = sRGBEncoding;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",null,"module.exports = function( THREE ) {\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls( object, domElement ) {\n\n\t\tthis.object = object;\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function update () {\n\n\t\t\t\tvar position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function() {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tvar spherical = new THREE.Spherical();\n\t\tvar sphericalDelta = new THREE.Spherical();\n\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tvar panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tvar pan = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\treturn function pan ( deltaX, deltaY ) {\n\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\t//console.log( 'handleMouseDownPan' );\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\t//console.log( 'handleMouseMovePan' );\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( event ) {\n\n\t\t\t//console.log( 'handleMouseUp' );\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\t//console.log( 'handleMouseWheel' );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\t//console.log( 'handleKeyDown' );\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\t//console.log( 'handleTouchStartPan' );\n\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\t//console.log( 'handleTouchMovePan' );\n\n\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchEnd( event ) {\n\n\t\t\t//console.log( 'handleTouchEnd' );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleTouchStartDolly( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tcenter: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\t\treturn this.target;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n};\n",null,null,null,null,null,null],"names":["HMR_HOST","HMR_PORT","HMR_SECURE","HMR_ENV_HASH","module","bundle","HMR_BUNDLE_ID","OVERLAY_ID","OldModule","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","undefined","checkedAssets","acceptedAssets","assetsToAccept","location","protocol","indexOf","hostname","port","parent","isParcelRequire","WebSocket","getHostname","getPort","test","ws","onmessage","event","JSON","parse","type","removeErrorOverlay","assets","filter","asset","envHash","handled","forEach","didAccept","hmrAcceptCheck","root","id","depsByBundle","console","clear","hmrApply","i","length","hmrAcceptRun","window","reload","ansiDiagnostic","diagnostics","ansi","stack","codeframe","error","message","hints","join","overlay","createErrorOverlay","html","document","body","appendChild","onerror","e","onclose","warn","getElementById","remove","log","createElement","errorHTML","diagnostic","map","hint","innerHTML","modules","parents","k","d","dep","Array","isArray","concat","getParents","link","newLink","cloneNode","onload","parentNode","removeChild","setAttribute","getAttribute","split","Date","now","insertBefore","nextSibling","cssTimeout","setTimeout","links","querySelectorAll","href","servedFromHMRServer","RegExp","absolute","origin","updateLink","reloadCSS","deps","Function","output","cached","cache","some","v","cb","assetsToAlsoAccept","apply","getRandomNum","max","min","Math","floor","random","initialRotate","rotateSpeed","constructor","inGroup","velocity","THREE","Vector3","acceleration","wonderTheta","maxSpeed","boost","BuildMesh","geometry","CylinderGeometry","rotateX","degToRad","material","MeshPhongMaterial","color","mesh","Mesh","Start","radius","theta","phi","position","x","sin","cos","y","z","Update","time","ApplyForce","multiplyScalar","add","clampLength","head","clone","lookAt","f","params","seek","maxForce","align","effectiveRange","separate","cohesion","group","Group","count","agents","agent","Agent","Align","Separate","Cohesion","AvoidBoxContainer","rotation","currAgent","sumVec","steer","otherAgent","dist","distanceTo","divideScalar","normalize","subVectors","closeVec","Seek","target","toGoalVector","Avoid","wall","computeBoundingSphere","boundingSphere","distance","pow","rangeWidth","rangeHeight","rangeDepth","size","BoxGeometry","MeshNormalMaterial","wireframe","boid","Boid","arena","Arena","addEventListener","className","value","isHidden","innerText","scene","options","name","Entity","Error","_id","_scene","Add","entities","Scene","cameraController","SetupScene","renderer","setAnimationLoop","ambientLight","AmbientLight","intensity","light","DirectionalLight","set","fog","Fog","entity","global","factory","exports","define","amd","globalThis","self","REVISION","MOUSE","LEFT","MIDDLE","RIGHT","ROTATE","DOLLY","PAN","TOUCH","DOLLY_PAN","DOLLY_ROTATE","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","VSMShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","CineonToneMapping","ACESFilmicToneMapping","CustomToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NearestMipMapNearestFilter","NearestMipmapLinearFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipMapNearestFilter","LinearMipmapLinearFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","UnsignedInt248Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","DepthStencilFormat","RedFormat","RedIntegerFormat","RGFormat","RGIntegerFormat","RGBIntegerFormat","RGBAIntegerFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","RGBA_BPTC_Format","SRGB8_ALPHA8_ASTC_4x4_Format","SRGB8_ALPHA8_ASTC_5x4_Format","SRGB8_ALPHA8_ASTC_5x5_Format","SRGB8_ALPHA8_ASTC_6x5_Format","SRGB8_ALPHA8_ASTC_6x6_Format","SRGB8_ALPHA8_ASTC_8x5_Format","SRGB8_ALPHA8_ASTC_8x6_Format","SRGB8_ALPHA8_ASTC_8x8_Format","SRGB8_ALPHA8_ASTC_10x5_Format","SRGB8_ALPHA8_ASTC_10x6_Format","SRGB8_ALPHA8_ASTC_10x8_Format","SRGB8_ALPHA8_ASTC_10x10_Format","SRGB8_ALPHA8_ASTC_12x10_Format","SRGB8_ALPHA8_ASTC_12x12_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","NormalAnimationBlendMode","AdditiveAnimationBlendMode","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","TangentSpaceNormalMap","ObjectSpaceNormalMap","ZeroStencilOp","KeepStencilOp","ReplaceStencilOp","IncrementStencilOp","DecrementStencilOp","IncrementWrapStencilOp","DecrementWrapStencilOp","InvertStencilOp","NeverStencilFunc","LessStencilFunc","EqualStencilFunc","LessEqualStencilFunc","GreaterStencilFunc","NotEqualStencilFunc","GreaterEqualStencilFunc","AlwaysStencilFunc","StaticDrawUsage","DynamicDrawUsage","StreamDrawUsage","StaticReadUsage","DynamicReadUsage","StreamReadUsage","StaticCopyUsage","DynamicCopyUsage","StreamCopyUsage","GLSL1","GLSL3","listener","_listeners","listeners","hasEventListener","removeEventListener","listenerArray","index","splice","dispatchEvent","array","slice","l","_lut","toString","_seed","DEG2RAD","PI","RAD2DEG","d0","d1","d2","d3","uuid","toUpperCase","n","m","a1","a2","b1","b2","t","lambda","dt","lerp","exp","abs","euclideanModulo","low","high","range","s","degrees","radians","ceil","LN2","q","a","b","c","order","c2","s2","c13","s13","c1_3","s1_3","c3_1","s3_1","MathUtils","Object","freeze","__proto__","generateUUID","clamp","mapLinear","inverseLerp","damp","pingpong","smoothstep","smootherstep","randInt","randFloat","randFloatSpread","seededRandom","radToDeg","isPowerOfTwo","ceilPowerOfTwo","floorPowerOfTwo","setQuaternionFromProperEuler","width","height","setScalar","scalar","setX","setY","setComponent","getComponent","copy","w","addVectors","addScalar","addScaledVector","sub","subScalar","multiply","divide","applyMatrix3","elements","clampScalar","minVal","maxVal","round","roundToZero","negate","dot","cross","lengthSq","sqrt","manhattanLength","angle","atan2","distanceToSquared","dx","dy","manhattanDistanceTo","setLength","alpha","lerpVectors","v1","v2","equals","fromArray","offset","toArray","fromBufferAttribute","attribute","getX","getY","rotateAround","center","Vector2","prototype","isVector2","arguments","n11","n12","n13","n21","n22","n23","n31","n32","n33","te","identity","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","premultiply","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","determinant","g","h","invert","t11","t12","t13","det","detInv","transpose","tmp","getNormalMatrix","matrix4","transposeIntoArray","r","setUvTransform","tx","ty","sx","sy","cx","cy","scale","rotate","translate","matrix","Matrix3","isMatrix3","_canvas","getDataURL","image","src","HTMLCanvasElement","canvas","createElementNS","context","getContext","ImageData","putImageData","drawImage","toDataURL","textureId","EventDispatcher","Texture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","defineProperty","mipmaps","internalFormat","repeat","matrixAutoUpdate","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","version","onUpdate","updateMatrix","source","toJSON","meta","isRootObject","textures","metadata","generator","wrap","images","url","isDataTexture","serializeImage","transformUv","uv","needsUpdate","isTexture","HTMLImageElement","ImageBitmap","ImageUtils","setZ","setW","applyMatrix4","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","epsilon","epsilon2","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","getZ","getW","Vector4","isVector4","depth","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","setTexture","setSize","WebGLRenderTarget","isWebGLRenderTarget","il","WebGLMultipleRenderTargets","isWebGLMultipleRenderTargets","samples","WebGLMultisampleRenderTarget","isWebGLMultisampleRenderTarget","_x","_y","_z","_w","slerp","qa","qb","qm","slerpQuaternions","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","Number","EPSILON","len","tDir","multiplyQuaternionsFlat","_onChangeCallback","quaternion","setFromEuler","euler","update","isEuler","_order","c1","c3","s1","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","vFrom","vTo","angleTo","rotateTowards","step","conjugate","p","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","_onChange","callback","Quaternion","isQuaternion","multiplyVectors","applyEuler","applyQuaternion","_quaternion$4","applyAxisAngle","applyNormalMatrix","qx","qy","qz","qw","ix","iy","iz","iw","project","camera","matrixWorldInverse","projectionMatrix","unproject","projectionMatrixInverse","matrixWorld","transformDirection","crossVectors","ax","ay","az","bx","by","bz","projectOnVector","denominator","projectOnPlane","planeNormal","_vector$c","reflect","normal","dz","setFromSpherical","setFromSphericalCoords","sinPhiRadius","setFromCylindrical","setFromCylindricalCoords","setFromMatrixPosition","setFromMatrixScale","setFromMatrixColumn","sz","isVector3","Infinity","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromBufferAttribute","setFromPoints","points","makeEmpty","expandByPoint","setFromCenterAndSize","halfSize","_vector$b","setFromObject","object","expandByObject","box","isEmpty","getCenter","getSize","point","expandByVector","vector","expandByScalar","updateWorldMatrix","boundingBox","computeBoundingBox","_box$3","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","intersectsPlane","plane","constant","intersectsTriangle","triangle","_center","_extents","_v0$2","_v1$7","_v2$3","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","distanceToPoint","clampedPoint","getBoundingSphere","intersect","_points","Box3","isBox3","_testAxis","v0","extents","j","p0","p1","p2","_box$2","_v1$6","_toFarthestPoint","_toPoint","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","getMaxScaleOnAxis","missingRadiusHalf","_vector$a","_segCenter","_segDir","_diff","_edge1","_edge2","_normal$1","direction","ray","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","optionalPointOnRay","optionalPointOnSegment","segExtent","a01","b0","s0","sqrDist","extDet","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","backfaceCulling","DdN","sign","DdQxE2","DdE1xQ","QdN","n14","n24","n34","n41","n42","n43","n44","Matrix4","copyPosition","setFromMatrix3","makeBasis","extractRotation","scaleX","_v1$5","scaleY","scaleZ","makeRotationFromEuler","af","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","compose","_zero","_one","eye","up","a14","a24","a34","a41","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","setPosition","t14","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","makeScale","makeShear","yx","zx","zy","x2","y2","z2","wx","wy","wz","decompose","_m1$2","invSX","invSY","invSZ","makePerspective","left","right","top","bottom","near","far","makeOrthographic","isMatrix4","_matrix$1","_quaternion$3","Euler","DefaultOrder","asin","setFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","RotationOrders","mask","channel","enable","enableAll","toggle","disable","disableAll","layers","_object3DId","_v1$4","_q1","_m1$1","_target","_position$3","_scale$2","_quaternion$2","_xAxis","_yAxis","_zAxis","_addedEvent","_removedEvent","Object3D","DefaultUp","onRotationChange","onQuaternionChange","defineProperties","configurable","enumerable","modelViewMatrix","normalMatrix","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","Layers","visible","castShadow","receiveShadow","frustumCulled","renderOrder","animations","userData","onBeforeRender","onAfterRender","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","isCamera","isLight","isObject3D","removeFromParent","attach","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldScale","getWorldDirection","raycast","traverse","traverseVisible","traverseAncestors","updateMatrixWorld","force","updateParents","updateChildren","geometries","materials","shapes","skeletons","stringify","isInstancedMesh","instanceMatrix","instanceColor","library","element","isMesh","isLine","isPoints","serialize","parameters","shape","isSkinnedMesh","bindMode","bindMatrix","skeleton","uuids","animation","extractFromCache","values","key","recursive","_vector1","_vector2$1","_normalMatrix","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","intersectLine","line","delta","start","intersectsLine","startSign","endSign","end","coplanarPoint","optionalNormalMatrix","referencePoint","Plane","isPlane","_v0$1","_v1$3","_v2$2","_v3$1","_vab","_vac","_vbc","_vap","_vbp","_vcp","getNormal","targetLengthSq","getBarycoord","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","getUV","p3","uv1","uv2","uv3","isFrontFacing","setFromPointsAndIndices","i0","i1","i2","getArea","getMidpoint","Triangle","getPlane","d4","vc","d5","d6","vb","va","materialId","blending","side","vertexColors","opacity","transparent","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","depthTest","depthWrite","stencilWriteMask","stencilFunc","stencilRef","stencilFuncMask","stencilFail","stencilZFail","stencilZPass","stencilWrite","clippingPlanes","clipIntersection","clipShadows","shadowSide","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","dithering","alphaTest","alphaToCoverage","premultipliedAlpha","toneMapped","onBuild","onBeforeCompile","customProgramCacheKey","setValues","newValue","flatShading","currentValue","isColor","isRoot","getHex","roughness","metalness","sheen","emissive","emissiveIntensity","specular","shininess","clearcoat","clearcoatRoughness","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","clearcoatNormalScale","matcap","alphaMap","lightMap","lightMapIntensity","aoMap","aoMapIntensity","bumpMap","bumpScale","normalMap","normalMapType","normalScale","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","specularMap","envMap","combine","envMapIntensity","reflectivity","refractionRatio","gradientMap","transmission","transmissionMap","thickness","thicknessMap","attenuationDistance","attenuationColor","sizeAttenuation","linewidth","dashSize","gapSize","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","morphTargets","morphNormals","srcPlanes","dstPlanes","Material","isMaterial","_colorKeywords","_hslA","_hslB","setRGB","setHex","setStyle","hex","setHSL","hue2rgb","style","string","parseFloat","exec","components","parseInt","handleAlpha","charAt","setColorName","toLowerCase","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","copySRGBToLinear","SRGBToLinear","copyLinearToSRGB","LinearToSRGB","convertSRGBToLinear","convertLinearToSRGB","getHexString","getHSL","hue","saturation","lightness","getStyle","offsetHSL","addColors","color1","color2","lerpColors","lerpHSL","normalized","Color","NAMES","MeshBasicMaterial","isMeshBasicMaterial","_vector$9","_vector2","itemSize","TypeError","usage","updateRange","onUploadCallback","setUsage","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","setXY","setXYZ","setXYZW","onUpload","BufferAttribute","isBufferAttribute","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float16BufferAttribute","isFloat16BufferAttribute","Float32Array","Float64Array","TYPED_ARRAYS","buffer","_m1","_obj","_offset","_box$1","_boxMorphTargets","_vector$8","attributes","morphAttributes","morphTargetsRelative","groups","drawRange","getIndex","setIndex","arrayMax","Uint32BufferAttribute","Uint16BufferAttribute","deleteAttribute","hasAttribute","addGroup","materialIndex","clearGroups","setDrawRange","tangent","Float32BufferAttribute","morphAttributesPosition","isGLBufferAttribute","morphAttribute","isNaN","Sphere","jl","computeFaceNormals","computeTangents","indices","positions","normals","uvs","nVertices","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","isFinite","handleTriangle","tmp2","n2","handleVertex","computeVertexNormals","positionAttribute","normalAttribute","pA","pB","pC","nA","nB","nC","ab","normalizeNormals","merge","isBufferGeometry","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","toNonIndexed","array2","geometry2","BufferGeometry","newAttribute","convertBufferAttribute","morphArray","keys","hasMorphAttributes","attributeArray","_inverseMatrix$2","_ray$2","Ray","_sphere$3","_vA$1","_vB$1","_vC$1","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA$1","_uvB$1","_uvC$1","_intersectionPoint","_intersectionPointWorld","updateMorphTargets","morphTargetInfluences","morphTargetDictionary","assign","ml","String","raycaster","intersects","intersection","morphPosition","groupMaterial","checkBufferGeometryIntersection","faceIndex","face","isGeometry","morphInfluences","influence","boneTransform","checkIntersection","widthSegments","heightSegments","depthSegments","scope","vertices","numberOfVertices","groupStart","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","property","uniforms","merged","cloneUniforms","UniformsUtils","mergeUniforms","default_vertex","default_fragment","defines","vertexShader","fragmentShader","lights","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","uniformsNeedUpdate","glslVersion","uniform","ShaderMaterial","isShaderMaterial","Camera","fov","aspect","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","enabled","offsetX","offsetY","clearViewOffset","skew","PerspectiveCamera","isPerspectiveCamera","renderTarget","isWebGLCubeRenderTarget","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","currentXrEnabled","xr","currentRenderTarget","getRenderTarget","setRenderTarget","render","_needsFlipEnvMap","CubeTexture","isCubeTexture","dummy","isInteger","fromEquirectangularTexture","shader","tEquirect","currentMinFilter","CubeCamera","stencil","WebGLCubeRenderTarget","_sphere$2","_vector$7","p4","p5","planes","frustum","setFromProjectionMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsObject","intersectsSprite","sprite","negRadius","isAnimating","animationLoop","requestId","frame","requestAnimationFrame","onAnimationFrame","stop","cancelAnimationFrame","setContext","gl","capabilities","isWebGL2","buffers","WeakMap","bufferType","createBuffer","bindBuffer","bufferData","FLOAT","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","bytesPerElement","BYTES_PER_ELEMENT","bufferSubData","subarray","isInterleavedBufferAttribute","get","deleteBuffer","delete","elementSize","updateBuffer","width_half","height_half","segment_width","segment_height","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_common_pars_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_vertex","fog_pars_vertex","fog_fragment","fog_pars_fragment","gradientmap_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars_begin","envmap_physical_pars_fragment","lights_toon_fragment","lights_toon_pars_fragment","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_fragment_begin","normal_fragment_maps","normalmap_pars_fragment","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","clearcoat_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","dithering_fragment","dithering_pars_fragment","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","transmission_fragment","transmission_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","background_frag","background_vert","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshmatcap_frag","meshmatcap_vert","meshtoon_frag","meshtoon_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","sprite_frag","sprite_vert","ShaderChunk","UniformsLib","diffuse","uvTransform","uv2Transform","specularmap","envmap","flipEnvMap","maxMipLevel","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","gradientmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","lightProbe","directionalLights","properties","directionalLightShadows","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","decay","spotLightShadows","spotShadowMap","spotShadowMatrix","pointLights","pointLightShadows","shadowCameraNear","shadowCameraFar","pointShadowMap","pointShadowMatrix","hemisphereLights","skyColor","groundColor","rectAreaLights","ltc_1","ltc_2","ShaderLib","basic","lambert","phong","standard","toon","dashed","totalSize","background","t2D","cube","equirect","distanceRGBA","referencePosition","nearDistance","farDistance","shadow","physical","transmissionSamplerSize","transmissionSamplerMap","cubemaps","state","objects","clearColor","clearAlpha","planeMesh","boxMesh","currentBackground","currentBackgroundVersion","currentTonemapping","renderList","forceClear","isScene","session","getSession","environmentBlendMode","setClear","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMapping","unshift","PlaneGeometry","getClearColor","setClearColor","getClearAlpha","setClearAlpha","maxVertexAttributes","MAX_VERTEX_ATTRIBS","extension","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","program","updateBuffers","getBindingState","bindVertexArrayObject","saveCache","ELEMENT_ARRAY_BUFFER","setupVertexAttributes","createVertexArray","createVertexArrayOES","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","programMap","stateMap","createVertexArrayObject","newAttributes","enabledAttributes","attributeDivisors","cachedAttributes","geometryAttributes","attributesNum","cachedAttribute","geometryAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableVertexAttribArray","stride","vertexAttribIPointer","vertexAttribPointer","isInstancedBufferGeometry","initAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","isInstancedInterleavedBuffer","_maxInstanceCount","enableAttribute","ARRAY_BUFFER","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","reset","geometryId","programId","deleteVertexArrayObject","resetDefaultState","setup","releaseStatesOfGeometry","releaseStatesOfProgram","info","mode","drawArrays","primcount","methodName","setMode","renderInstances","maxAnisotropy","has","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","WebGL2RenderingContext","WebGL2ComputeRenderingContext","maxPrecision","getMaxPrecision","logarithmicDepthBuffer","maxTextures","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","floatVertexTextures","maxSamples","MAX_SAMPLES","getMaxAnisotropy","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","viewNormalMatrix","numPlanes","numIntersection","init","enableLocalClipping","projectPlanes","beginShadows","endShadows","resetGlobalState","setState","useCache","materialProperties","nGlobal","lGlobal","dstArray","clippingState","skipTransform","nPlanes","flatSize","viewMatrix","i4","cubemap","mapTextureMapping","onTextureDispose","getExtension","wireframeAttributes","onGeometryDispose","memory","geometryIndex","geometryPosition","previousAttribute","currentAttribute","updateWireframeAttribute","getWireframeAttribute","drawElements","calls","triangles","lines","instanceCount","TRIANGLES","LINES","LINE_STRIP","LINE_LOOP","POINTS","programs","autoReset","influencesList","workInfluences","objectInfluences","influences","sort","absNumericalSort","MAX_SAFE_INTEGER","numericalSort","morphInfluencesSum","morphBaseInfluence","getUniforms","setValue","updateMap","buffergeometry","onInstancedMeshDispose","instancedMesh","wrapR","DataTexture2DArray","isDataTexture2DArray","DataTexture3D","isDataTexture3D","emptyTexture","emptyTexture2dArray","emptyTexture3d","emptyCubeTexture","arrayCacheF32","arrayCacheI32","mat4array","mat3array","mat2array","nBlocks","blockSize","firstElem","allocateTextureUnit","uniform1f","addr","uniform2f","arraysEqual","uniform2fv","uniform3f","uniform3fv","uniform4f","uniform4fv","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","uniform1i","uniform2iv","uniform3iv","uniform4iv","uniform1ui","uniform2uiv","uniform3uiv","uniform4uiv","unit","safeSetTexture2D","setTexture3D","safeSetTextureCube","setTexture2DArray","setValueV1f","setValueV2f","setValueV3f","setValueV4f","setValueM2","setValueM3","setValueM4","setValueV1i","setValueV2i","setValueV3i","setValueV4i","setValueV1ui","setValueV2ui","setValueV3ui","setValueV4ui","setValueT1","setValueT3D1","setValueT6","setValueT2DArray1","uniform1fv","flatten","uniform1iv","uniform1uiv","units","allocTexUnits","setValueV1fArray","setValueV2fArray","setValueV3fArray","setValueV4fArray","setValueM2Array","setValueM3Array","setValueM4Array","setValueV1iArray","setValueV2iArray","setValueV3iArray","setValueV4iArray","setValueV1uiArray","setValueV2uiArray","setValueV3uiArray","setValueV4uiArray","setValueT1Array","setValueT6Array","activeInfo","getSingularSetter","getPureArraySetter","PureArrayUniform","updateCache","seq","StructuredUniform","RePathPart","container","uniformObject","path","pathLength","lastIndex","match","matchEnd","idIsIndex","subscript","addUniform","SingleUniform","next","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","parseUniform","WebGLUniforms","setOptional","upload","seqWithValue","createShader","shaderSource","compileShader","programIdCount","status","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","trim","getShaderSource","addLineNumbers","functionName","getEncodingComponents","toneMappingName","chunks","extensionDerivatives","envMapCubeUV","tangentSpaceNormalMap","shaderID","extensionFragDepth","rendererExtensionFragDepth","extensionDrawBuffers","rendererExtensionDrawBuffers","extensionShaderTextureLOD","rendererExtensionShaderTextureLod","filterEmptyLine","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replace","numDirLights","numSpotLights","numRectAreaLights","numPointLights","numHemiLights","numDirLightShadows","numSpotLightShadows","numPointLightShadows","numClippingPlanes","numClipIntersection","includePattern","includeReplacer","include","resolveIncludes","deprecatedUnrollLoopPattern","unrollLoopPattern","loopReplacer","deprecatedLoopReplacer","snippet","precisionstring","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapMode","envMapModeDefine","envMapBlendingDefine","cacheKey","generateShadowMapTypeDefine","generateEnvMapTypeDefine","generateEnvMapModeDefine","generateEnvMapBlendingDefine","gammaFactorDefine","customExtensions","generateExtensions","customDefines","generateDefines","createProgram","prefixVertex","prefixFragment","versionString","isRawShaderMaterial","generatePrecision","shaderName","instancing","instancingColor","supportsVertexTextures","maxBones","useFog","fogExp2","objectSpaceNormalMap","vertexTangents","vertexAlphas","vertexUvs","uvsVertexOnly","skinning","useVertexTexture","doubleSided","flipSided","shadowMapEnabled","physicallyCorrectLights","getToneMappingFunction","getTexelDecodingFunction","mapEncoding","matcapEncoding","envMapEncoding","emissiveMapEncoding","lightMapEncoding","getTexelEncodingFunction","outputEncoding","depthPacking","replaceLightNums","replaceClippingPlaneNums","unrollLoops","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","debug","checkShaderErrors","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","vertexErrors","getShaderErrors","fragmentErrors","getError","VALIDATE_STATUS","prefix","deleteShader","cachedUniforms","fetchAttributeLocations","destroy","deleteProgram","usedTimes","shaderIDs","MeshDepthMaterial","MeshDistanceMaterial","MeshLambertMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","parameterNames","bones","nVertexUniforms","nVertexMatrices","shadows","environment","isMeshStandardMaterial","getMaxBones","getTextureEncodingFromMap","isFogExp2","directional","spot","rectArea","hemi","shadowMap","pl","preexistingProgram","WebGLProgram","pop","getParameters","getProgramCacheKey","acquireProgram","releaseProgram","groupOrder","renderItems","renderItemsIndex","opaque","transmissive","defaultProgram","renderItem","getNextRenderItem","customOpaqueSort","customTransparentSort","painterSortStable","reversePainterSortStable","finish","lists","renderCallDepth","list","WebGLRenderList","halfWidth","halfHeight","nextVersion","lightA","lightB","UniformsCache","shadowCache","ShadowUniformsCache","hash","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","numDirectionalShadows","numPointShadows","numSpotShadows","ambient","probe","directionalShadow","spotShadow","rectAreaLTC1","rectAreaLTC2","pointShadow","vector3","matrix42","shadowCastingLightsFirst","isAmbientLight","isLightProbe","sh","coefficients","isDirectionalLight","shadowUniforms","bias","normalBias","mapSize","isSpotLight","penumbra","isRectAreaLight","isPointLight","isHemisphereLight","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setupView","WebGLLights","lightsArray","shadowsArray","shadowLight","setupLights","setupLightsView","pushLight","pushShadow","renderStates","renderState","WebGLRenderState","isMeshDepthMaterial","isMeshDistanceMaterial","vsm_frag","vsm_vert","_renderer","_objects","_capabilities","_frustum","Frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterials","_distanceMaterials","_materialCache","_maxTextureSize","shadowMaterialVertical","SAMPLE_RATE","HALF_SAMPLE_RATE","shadow_pass","resolution","shadowMaterialHorizontal","HORIZONTAL_PASS","fullScreenTri","fullScreenMesh","autoUpdate","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","setBlending","setTest","setScissorTest","shadowFrameExtents","getFrameExtents","isPointLightShadow","pars","mapPass","viewportCount","getViewportCount","vp","getViewport","updateMatrices","getFrustum","renderObject","VSMPass","renderBufferDirect","useMorphing","result","getMaterialVariant","getDepthMaterialVariant","customMaterial","customDepthMaterial","getDistanceMaterialVariant","customDistanceMaterial","keyA","keyB","materialsForVariant","cachedMaterial","shadowCamera","kl","depthMaterial","getDepthMaterial","locked","currentColorMask","currentColorClear","setMask","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","DEPTH_TEST","depthMask","setFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","clearDepth","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","setOp","stencilOp","clearStencil","colorBuffer","ColorBuffer","DepthBuffer","StencilBuffer","enabledCapabilities","xrFramebuffer","currentBoundFramebuffers","currentProgram","currentBlendingEnabled","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","MAX_COMBINED_TEXTURE_IMAGE_UNITS","lineWidthAvailable","glVersion","VERSION","currentTextureSlot","currentBoundTextures","scissorParam","SCISSOR_BOX","viewportParam","VIEWPORT","currentScissor","currentViewport","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","setFlipSided","setCullFace","CULL_FACE","framebuffer","bindFramebuffer","FRAMEBUFFER","DRAW_FRAMEBUFFER","useProgram","equationToGL","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","MIN","MAX","MIN_EXT","MAX_EXT","factorToGL","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","BLEND","blendFuncSeparate","blendFunc","blendEquationSeparate","frontFaceCW","setPolygonOffset","SAMPLE_ALPHA_TO_COVERAGE","frontFace","CW","CCW","cullFace","BACK","FRONT","FRONT_AND_BACK","lineWidth","factor","POLYGON_OFFSET_FILL","SCISSOR_TEST","webglSlot","TEXTURE0","activeTexture","webglType","webglTexture","boundTexture","compressedTexImage2D","texImage3D","KEEP","READ_FRAMEBUFFER","bindXRFramebuffer","setMaterial","setLineWidth","unbindTexture","_gl","utils","_videoTextures","useOffscreenCanvas","OffscreenCanvas","err","needsPowerOfTwo","needsNewCanvas","maxSize","createCanvas","supportsMips","generateMipmap","textureProperties","__maxMipLevel","log2","internalFormatName","glFormat","glType","RED","R32F","R16F","R8","RGB","RGB32F","RGB16F","RGB8","RGBA32F","RGBA16F","RGBA8","LINEAR","deallocateTexture","isVideoTexture","onRenderTargetDispose","deallocateRenderTarget","__webglInit","deleteTexture","__webglTexture","renderTargetProperties","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__webglMultisampledFramebuffer","__webglColorRenderbuffer","__webglDepthRenderbuffer","attachmentProperties","textureUnits","textureUnit","slot","updateVideoTexture","__version","complete","uploadTexture","TEXTURE_2D_ARRAY","TEXTURE_3D","uploadCubeTexture","wrappingToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","filterToGL","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","initTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","textureNeedsPowerOfTwo","isPowerOfTwo$1","resizeImage","convert","glInternalFormat","getInternalFormat","setTextureParameters","mipmap","isDepthTexture","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT24","DEPTH24_STENCIL8","DEPTH_COMPONENT16","DEPTH_STENCIL","isCompressedTexture","textureNeedsGenerateMipmaps","isCompressed","cubeImage","mipmapImage","attachment","textureTarget","framebufferTexture2D","renderbuffer","isMultisample","bindRenderbuffer","RENDERBUFFER","getRenderTargetSamples","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","isCube","setTexture2D","webglDepthTexture","setupDepthTexture","createRenderbuffer","setupRenderBufferStorage","isMultipleRenderTargets","isRenderTarget3D","createFramebuffer","COLOR_ATTACHMENT0","setupFrameBufferTexture","glTextureType","isTexture3D","setupDepthRenderbuffer","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","blitFramebuffer","warnedTexture2D","warnedTextureCube","setTextureCube","resetTextureUnits","setupRenderTarget","updateRenderTargetMipmap","updateMultisampleRenderTarget","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","LUMINANCE","LUMINANCE_ALPHA","RED_INTEGER","RG","RG_INTEGER","RGB_INTEGER","RGBA_INTEGER","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_RGB8_ETC2","COMPRESSED_RGBA8_ETC2_EAC","UNSIGNED_INT_24_8","UNSIGNED_INT_24_8_WEBGL","cameras","ArrayCamera","isArrayCamera","isGroup","_moveEvent","_targetRay","_grip","_hand","getHandSpace","joints","inputState","pinching","getTargetRaySpace","hasLinearVelocity","linearVelocity","hasAngularVelocity","angularVelocity","getGripSpace","disconnect","inputSource","referenceSpace","inputPose","gripPose","handPose","targetRay","grip","hand","visibilityState","getPose","targetRaySpace","transform","inputjoint","jointPose","getJointPose","jointName","joint","jointRadius","indexTip","thumbTip","distanceToPinch","threshold","handedness","gripSpace","framebufferScaleFactor","referenceSpaceType","pose","controllers","inputSourcesMap","Map","cameraL","cameraR","cameraVR","_currentDepthNear","_currentDepthFar","cameraAutoUpdate","isPresenting","getController","controller","WebXRController","getControllerGrip","getHand","setFramebufferScaleFactor","setReferenceSpaceType","getReferenceSpace","setSession","onSessionEvent","onSessionEnd","onInputSourcesChange","getContextAttributes","xrCompatible","makeXRCompatible","layerInit","antialias","baseLayer","XRWebGLLayer","updateRenderState","requestReferenceSpace","inputSources","removed","added","cameraLPos","cameraRPos","ipd","projL","projR","topFov","bottomFov","leftFov","rightFov","zOffset","xOffset","near2","far2","left2","right2","top2","bottom2","updateCamera","depthNear","depthFar","setProjectionFromUnion","getCamera","onAnimationFrameCallback","getViewerPose","views","cameraVRNeedsUpdate","WebGLAnimation","isFog","density","pixelRatio","transmissionRenderTarget","refreshUniformsCommon","isMeshLambertMaterial","refreshUniformsLambert","isMeshToonMaterial","refreshUniformsToon","isMeshPhongMaterial","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshMatcapMaterial","refreshUniformsMatcap","refreshUniformsDepth","refreshUniformsDistance","isMeshNormalMaterial","refreshUniformsNormal","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","isSpriteMaterial","refreshUniformsSprites","isShadowMaterial","uvScaleMap","uv2ScaleMap","refreshFogUniforms","refreshMaterialUniforms","display","createCanvasElement","_context","_alpha","_depth","_stencil","_antialias","_premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_failIfMajorPerformanceCaveat","failIfMajorPerformanceCaveat","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","sortObjects","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_width","_height","_pixelRatio","_opaqueSort","_transparentSort","_scissor","_scissorTest","_currentDrawBuffers","_clippingEnabled","_localClippingEnabled","_transmissionRenderTarget","_projScreenMatrix","_vector3","_emptyScene","overrideMaterial","contextNames","contextAttributes","contextName","onContextLost","onContextRestore","isWebGL1Renderer","shift","programCache","renderLists","morphtargets","bufferRenderer","indexedBufferRenderer","WebGLExtensions","WebGLCapabilities","WebGLUtils","WebGLState","WebGLInfo","WebGLProperties","WebGLTextures","WebGLCubeMaps","WebGLAttributes","WebGLBindingStates","WebGLGeometries","WebGLObjects","WebGLMorphtargets","WebGLClipping","WebGLPrograms","WebGLMaterials","WebGLRenderLists","WebGLRenderStates","WebGLBackground","WebGLShadowMap","WebGLBufferRenderer","WebGLIndexedBufferRenderer","initGLContext","WebXRManager","forceContextLoss","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","updateStyle","setViewport","getDrawingBufferSize","setDrawingBufferSize","getCurrentViewport","getScissor","setScissor","getScissorTest","boolean","setOpaqueSort","method","setTransparentSort","bits","onXRSessionStart","onXRSessionEnd","preventDefault","infoAutoReset","shadowMapAutoUpdate","shadowMapNeedsUpdate","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReferences","renderBufferImmediate","hasPositions","hasNormals","hasUvs","hasColors","positionArray","DYNAMIC_DRAW","normalArray","uvArray","colorArray","setProgram","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","getTargetPixelRatio","isLineSegments","isLineLoop","isSprite","compile","material2","getProgram","projectObject","opaqueObjects","transmissiveObjects","transparentObjects","renderObjects","renderTransmissiveObjects","isLOD","isImmediateRenderObject","camera2","renderObjectImmediate","lightsStateVersion","programCacheKey","updateCommonMaterialProperties","needsLights","materialNeedsLights","progUniforms","uniformsList","needsProgramChange","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","uCamPos","cameraPosition","isOrthographicCamera","boneTexture","computeBoneTexture","boneTextureSize","markUniformsLightsNeedsUpdate","framebufferBound","drawBuffersWEBGL","layer","framebufferTextureLayer","readRenderTargetPixels","activeCubeFaceIndex","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","halfFloatSupportedByExt","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","copyFramebufferToTexture","level","levelScale","copyTexImage2D","copyTextureToTexture","srcTexture","dstTexture","texSubImage2D","compressedTexSubImage2D","copyTextureToTexture3D","sourceBox","glTarget","unpackRowLen","UNPACK_ROW_LENGTH","unpackImageHeight","UNPACK_IMAGE_HEIGHT","unpackSkipPixels","UNPACK_SKIP_PIXELS","unpackSkipRows","UNPACK_SKIP_ROWS","unpackSkipImages","UNPACK_SKIP_IMAGES","texSubImage3D","resetState","__THREE_DEVTOOLS__","CustomEvent","detail","WebGLRenderer","WebGL1Renderer","FogExp2","arrayBuffers","_uuid","ib","InterleavedBuffer","isInterleavedBuffer","_vector$6","interleavedBuffer","interleavedBuffers","InterleavedBufferAttribute","_geometry","_intersectPoint","_worldScale","_mvPosition","_alignedPosition","_rotatedPosition","_viewWorldMatrix","_vA","_vB","_vC","_uvA","_uvB","_uvC","float32Array","transformVertex","Sprite","vertexPosition","mvPosition","_v1$2","_v2$1","_currentLevel","levels","addLevel","getCurrentLevel","getObjectForDistance","_basePosition","_skinIndex","_skinWeight","_vector$5","_matrix","bindMatrixInverse","bind","calculateInverses","normalizeSkinWeights","skinWeight","skinIndex","weight","boneIndex","boneInverses","SkinnedMesh","Bone","isBone","DataTexture","_offsetMatrix","_identityMatrix","boneMatrices","inverse","bone","Skeleton","getBoneByName","fromJSON","json","boneInverse","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_mesh","getColorAt","getMatrixAt","raycastTimes","instanceId","setColorAt","setMatrixAt","InstancedMesh","linecap","linejoin","_start$1","_end$1","_inverseMatrix$1","_ray$1","_sphere$1","computeLineDistances","lineDistances","Line","localThreshold","localThresholdSq","vStart","vEnd","interSegment","interRay","distSq","_start","_end","LineSegments","LineLoop","_inverseMatrix","_ray","_sphere","_position$2","Points","testPoint","rayPointDistanceSq","intersectPoint","distanceToRay","video","requestVideoFrameCallback","updateVideo","hasVideoFrameCallback","readyState","HAVE_CURRENT_DATA","VideoTexture","CompressedTexture","CanvasTexture","isCanvasTexture","DepthTexture","segments","thetaStart","thetaLength","vertex","segment","radiusTop","radiusBottom","radialSegments","openEnded","indexArray","generateTorso","generateCap","slope","indexRow","sinTheta","cosTheta","centerIndexStart","centerIndexEnd","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","getVertexByIndex","subdivideFace","cols","aj","bj","rows","pushVertex","azimuth","inclination","correctUVs","correctSeam","centroid","azi","correctUV","PolyhedronGeometry","_v0","_v1$1","_normal","_triangle","thresholdAngle","precisionPoints","thresholdDot","indexAttr","positionAttr","indexCount","indexArr","vertKeys","hashes","edgeData","jNext","vecHash0","vecHash1","reverseHash","index0","Earcut","triangulate","holeIndices","dim","hasHoles","outerLen","outerNode","linkedList","prev","invSize","eliminateHoles","earcutLinked","clockwise","last","signedArea","insertNode","removeNode","again","steiner","area","ear","pass","indexCurve","isEarHashed","isEar","filterPoints","cureLocalIntersections","splitEarcut","pointInTriangle","minTX","minTY","maxTX","maxTY","zOrder","prevZ","nextZ","locallyInside","isValidDiagonal","splitPolygon","queue","getLeftmost","compareX","eliminateHole","hole","findHoleBridge","hx","hy","mx","my","tanMin","sectorContainsSector","sortLinked","tail","numMerges","pSize","qSize","inSize","leftmost","px","py","intersectsPolygon","middleInside","q1","q2","o1","o2","o3","o4","onSegment","num","inside","Node","an","bp","sum","contour","isClockWise","pts","ShapeUtils","triangulateShape","holes","faces","removeDupEndPts","addContour","holeIndex","verticesArray","addShape","placeholder","curveSegments","steps","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","amount","extrudePts","extrudeByPath","splineTube","binormal","position2","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","reverse","hl","ahole","pt","vec","vlen","flen","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","contourMovements","getBevelVec","holesMovements","oneHoleMovements","verticesMovements","bs","vert","scalePt2","binormals","buildLidFaces","buildSideFaces","f3","layeroffset","sidewalls","sl","slen1","slen2","f4","addVertex","nextIndex","generateTopUV","addUV","generateSideWallUV","vector2","toJSON$1","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","phiStart","phiLength","inverseSegments","base","n1","func","slices","stacks","EPS","pu","pv","sliceCount","innerRadius","outerRadius","thetaSegments","phiSegments","radiusStep","thetaSegmentLevel","indexOffset","shapeVertices","shapeHoles","shapeHole","thetaEnd","grid","verticesRow","uOffset","ExtrudeGeometry","text","font","isFont","generateShapes","tube","tubularSegments","arc","P1","P2","B","T","N","calculatePositionOnCurve","cu","su","quOverP","cs","closed","frames","P","generateBufferData","generateSegment","generateIndices","getPointAt","edge","edges","o","ol","edge1","edge2","Geometries","BoxBufferGeometry","CircleGeometry","CircleBufferGeometry","ConeGeometry","ConeBufferGeometry","CylinderBufferGeometry","DodecahedronGeometry","DodecahedronBufferGeometry","EdgesGeometry","ExtrudeBufferGeometry","IcosahedronGeometry","IcosahedronBufferGeometry","LatheGeometry","LatheBufferGeometry","OctahedronGeometry","OctahedronBufferGeometry","ParametricGeometry","ParametricBufferGeometry","PlaneBufferGeometry","PolyhedronBufferGeometry","RingGeometry","RingBufferGeometry","ShapeGeometry","ShapeBufferGeometry","SphereGeometry","SphereBufferGeometry","TetrahedronGeometry","TetrahedronBufferGeometry","TextGeometry","TextBufferGeometry","TorusGeometry","TorusBufferGeometry","TorusKnotGeometry","TorusKnotBufferGeometry","TubeGeometry","TubeBufferGeometry","WireframeGeometry","RawShaderMaterial","ior","Materials","AnimationUtils","arraySlice","from","to","isTypedArray","convertArray","forceClone","ArrayBuffer","isView","DataView","getKeyframeOrder","times","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","subclip","sourceClip","startFrame","endFrame","fps","clip","tracks","track","valueSize","getValueSize","minStartTime","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","referenceQuat","numTimes","valueStart","valueEnd","blendMode","parameterPositions","sampleValues","sampleSize","_cachedIndex","settings","DefaultSettings_","pp","validate_interval","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","getSettings_","copySampleValue_","Interpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","trackType","getInterpolation","InterpolantFactoryMethodDiscrete","DiscreteInterpolant","InterpolantFactoryMethodLinear","LinearInterpolant","InterpolantFactoryMethodSmooth","CubicInterpolant","factoryMethod","timeOffset","timeScale","startTime","endTime","nKeys","validate","valid","prevTime","currTime","optimize","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","duration","jsonTracks","frameTime","parseKeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","morphTarget","parts","animationMorphTargets","clips","parseAnimation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","typeName","getTrackTypeForValueTypeName","Cache","files","file","onLoad","onProgress","onError","isLoading","itemsLoaded","itemsTotal","urlModifier","handlers","onStart","itemStart","itemEnd","itemError","resolveURL","setURLModifier","addHandler","regex","loader","removeHandler","getHandler","DefaultLoadingManager","LoadingManager","manager","crossOrigin","withCredentials","resourcePath","requestHeader","load","loadAsync","Promise","resolve","reject","setCrossOrigin","setWithCredentials","setPath","setResourcePath","setRequestHeader","loading","Loader","dataUriRegex","dataUriRegexResult","request","mimeType","isBase64","decodeURIComponent","atob","response","responseType","charCodeAt","Blob","parser","DOMParser","parseFromString","XMLHttpRequest","open","callbacks","overrideMimeType","header","send","setResponseType","setMimeType","FileLoader","AnimationClip","loaded","texDatas","mipmapCount","loadTexture","isCubemap","onImageLoad","onImageError","substr","urls","ImageLoader","texData","isJPEG","search","arcLengthDivisions","getPoint","optionalTarget","getUtoTmapping","getPoints","divisions","getLength","lengths","getLengths","cacheArcLengths","current","updateArcLengths","arcLengths","targetArcLength","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","t2","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","Curve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","twoPi","deltaAngle","samePoints","EllipseCurve","isEllipseCurve","aRadius","ArcCurve","isArcCurve","c0","initCatmullRom","x3","tension","initNonuniformCatmullRom","dt0","dt1","dt2","calc","t3","CubicPoly","pz","curveType","intPoint","CatmullRomCurve3","isCatmullRomCurve3","QuadraticBezierP0","QuadraticBezierP1","QuadraticBezierP2","CubicBezierP0","CubicBezierP1","CubicBezierP2","CubicBezierP3","v3","CubicBezier","CubicBezierCurve","isCubicBezierCurve","CubicBezierCurve3","isCubicBezierCurve3","LineCurve","isLineCurve","isLineCurve3","QuadraticBezier","QuadraticBezierCurve","isQuadraticBezierCurve","QuadraticBezierCurve3","isQuadraticBezierCurve3","CatmullRom","SplineCurve","isSplineCurve","Curves","LineCurve3","curves","autoClose","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","diff","lens","cacheLengths","sums","CurvePath","currentPoint","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","Path","getPointsHoles","holesPts","Light","HemisphereLight","_projScreenMatrix$1","_lightPositionWorld$1","_lookTarget$1","_frameExtents","_viewportCount","_viewports","shadowMatrix","viewportIndex","LightShadow","SpotLightShadow","isSpotLightShadow","power","SpotLight","_lightPositionWorld","_lookTarget","_cubeDirections","_cubeUps","PointLightShadow","PointLight","scaleW","scaleH","OrthographicCamera","DirectionalLightShadow","isDirectionalLightShadow","RectAreaLight","zero","getAt","coeff","getIrradianceAt","addScaledSH","getBasisAt","shBasis","SphericalHarmonics3","isSphericalHarmonics3","LightProbe","getTexture","shading","setTextures","decodeText","TextDecoder","decode","fromCharCode","escape","extractUrlBase","lastIndexOf","InstancedBufferGeometry","InstancedBufferAttribute","interleavedBufferMap","arrayBufferMap","getArrayBuffer","getTypedArray","arrayBuffer","typedArray","bufferAttribute","getInterleavedBuffer","bufferAttributeConstr","drawcalls","offsets","LoaderUtils","parseAnimations","parseShapes","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","parseSkeletons","bindSkeletons","hasImages","Shape","geometryShapes","bufferGeometryLoader","BufferGeometryLoader","details","MaterialLoader","loadImage","currentUrl","deserializedImage","deserializeImage","parseConstant","TEXTURE_MAPPING","TEXTURE_WRAPPING","TEXTURE_FILTER","getGeometry","getMaterial","LOD","objectAnimations","setTexturePath","createImageBitmap","fetch","setOptions","fetchOptions","credentials","headers","then","res","blob","colorSpaceConversion","imageBitmap","catch","ImageBitmapLoader","isImageBitmapLoader","subPaths","currentPath","toShapes","isCCW","noHoles","inSubpaths","tmpPath","tmpShape","inPolygon","polyLen","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","toShapesNoHoles","solid","holesFirst","betterShapeHoles","newShapes","newShapeHoles","mainIdx","tmpPoints","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","isPointInsidePolygon","froms","tos","tmpHoles","paths","createPaths","chars","line_height","yMax","yMin","underlineThickness","char","ret","createPath","glyph","glyphs","familyName","ShapePath","cpx","cpy","cpx1","cpy1","cpx2","cpy2","outline","_cachedOutline","action","ha","Font","substring","AudioContext","webkitAudioContext","bufferCopy","decodeAudioData","audioBuffer","sky","ground","HemisphereLightProbe","isHemisphereLightProbe","AmbientLightProbe","isAmbientLightProbe","_eyeRight","_eyeLeft","eyeSep","_cache","eyeSepHalf","eyeSepOnProjection","ymax","xmin","xmax","autoStart","oldTime","elapsedTime","running","getElapsedTime","getDelta","newTime","performance","_position$1","_quaternion$1","_scale$1","_orientation$1","gain","createGain","connect","destination","timeDelta","_clock","Clock","getInput","removeFilter","getFilter","setFilter","getMasterVolume","setMasterVolume","setTargetAtTime","currentTime","positionX","linearRampToValueAtTime","positionY","positionZ","forwardX","forwardY","forwardZ","upX","upY","upZ","setOrientation","autoplay","detune","loop","loopStart","loopEnd","playbackRate","isPlaying","hasPlaybackControl","sourceType","_startedAt","_progress","_connected","filters","getOutput","setNodeSource","audioNode","setMediaElementSource","mediaElement","createMediaElementSource","setMediaStreamSource","mediaStream","createMediaStreamSource","setBuffer","play","delay","createBufferSource","onended","onEnded","setDetune","setPlaybackRate","pause","getFilters","setFilters","getDetune","getPlaybackRate","getLoop","setLoop","setLoopStart","setLoopEnd","getVolume","setVolume","_position","_quaternion","_scale","_orientation","Audio","panner","createPanner","panningModel","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","orientationX","orientationY","orientationZ","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getFrequencyData","getByteFrequencyData","getAverageFrequency","binding","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","_workIndex","_select","_setAdditiveIdentityOther","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","accumulate","accuIndex","currentWeight","mix","accumulateAdditive","weightAdditive","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","targetIndex","workOffset","_RESERVED_CHARS_RE","_reservedRe","_wordChar","_wordCharOrDot","_directoryRe","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","targetGroup","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","firstValidIndex","nCachedObjects_","bindings","unbind","rootNode","node","findNode","nodeName","_getValue_unbound","_setValue_unbound","create","isAnimationObjectGroup","Composite","sanitizeNodeName","matches","results","objectName","objectIndex","propertyIndex","lastDot","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","_setValue_direct","targetObject","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","stats","total","inUse","bindingsPerObject","indicesByUUID","parsedPaths","nBindings","knownObject","nObjects","nCachedObjects","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","AnimationObjectGroup","mixer","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","_loopCount","_startTime","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","_updateWeight","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","interpolantValue","loopCount","pingPong","_setEndings","handle_stop","loopDelta","pending","atStart","atEnd","weightNow","weightThen","_initMemoryManager","_accuIndex","_bindAction","prototypeAction","rootUuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","_addInactiveBinding","PropertyMixer","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","actions","controlInterpolants","actionsByClip","actionByRoot","_removeInactiveAction","lastInactiveAction","cacheIndex","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","lastInactiveBinding","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","clipAction","optionalRoot","clipObject","existingAction","newAction","AnimationAction","stopAllAction","nActions","setTime","timeInSeconds","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction","AnimationMixer","Uniform","InstancedInterleavedBuffer","setType","setItemSize","setCount","GLBufferAttribute","setFromCamera","coords","intersectObject","ascSort","intersectObjects","other","makeSafe","setFromCartesianCoords","_vector$4","Box2","isBox2","_startP","_startEnd","distanceSq","closestPointToPointParameter","clampToLine","startEnd2","startEnd_startP","ImmediateRenderObject","_vector$3","cone","coneLength","coneWidth","_vector$2","_boneMatrix","_matrixWorldInv","getBoneList","isSkeletonHelper","boneList","sphereSize","_vector$1","_color1","_color2","radials","circles","_v1","_v2","_v3","lightPlane","targetLine","_vector","_camera","pointMap","colorFrustum","colorCone","colorUp","colorTarget","colorCross","addLine","addPoint","setPoint","_box","positions2","_axis","_lineGeometry","_coneGeometry","headLength","headWidth","setDirection","setColor","_floatView","_int32View","toHalfFloat","val","LOD_MIN","LOD_MAX","SIZE_MAX","EXTRA_LOD_SIGMA","TOTAL_LODS","ENCODINGS","backgroundMaterial","backgroundBox","_flatCamera","_lodPlanes","_sizeLods","_sigmas","_createPlanes","_clearColor","_oldTarget","PHI","INV_PHI","_axisDirections","maxComponent","fExp","_pingPongRenderTarget","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_compileMaterial","fromScene","sigma","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","_fromTexture","fromCubemap","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","outputTarget","_setViewport","_textureToCubeUV","_isLDR","_createRenderTarget","tmpMesh","cubeCamera","upSign","forwardSign","originalAutoClear","useSolidColor","convertLinearToRGBE","col","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","sigmaPixels","weights","outputSize","lod","sizeLod","texelSize","cubeFaces","positionSize","uvSize","faceIndexSize","coordinates","fill","shaderMaterial","_getCommonVertexShader","_getEncodings","LineStrip","LinePieces","NoColors","FaceColors","VertexColors","isMultiMaterial","Int8BufferAttribute","Uint8BufferAttribute","Uint8ClampedBufferAttribute","Int16BufferAttribute","Int32BufferAttribute","Float64BufferAttribute","construct","fromPoints","AxesHelper","BoxHelper","GridHelper","setColors","SkeletonHelper","Handlers","DataTextureLoader","empty","isIntersectionBox","isIntersectionSphere","setFromMatrix","Line3","flattenToArrayOffset","multiplyVector3","multiplyVector3Array","applyToBufferAttribute","applyToVector3Array","getInverse","extractPosition","getPosition","multiplyToArray","multiplyVector4","rotateAxis","crossVector","rotateByAxis","makeFrustum","isIntersectionLine","isIntersectionPlane","barycoordFromPoint","midpoint","prototypenormal","extractAllPoints","extrude","makeGeometry","fromAttribute","distanceToManhattan","lengthManhattan","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","applyProjection","getChildByName","renderDepth","getWorldRotation","applyMatrix","eulerOrder","useQuaternion","setDrawMode","drawMode","initBones","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","dynamic","setDynamic","copyIndicesArray","setArray","addIndex","addAttribute","addDrawCall","clearDrawCalls","computeOffsets","removeAttribute","getArrays","addShapeList","wrapAround","overdraw","wrapRGB","clearTarget","animate","getCurrentRenderTarget","getPrecision","resetGLState","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","initMaterial","addPrePlugin","addPostPlugin","updateShadowMap","setFaceCulling","allocTextureUnit","getActiveMipMapLevel","shadowMapCullFace","vr","gammaInput","gammaOutput","toneMappingWhitePoint","renderReverseSided","renderSingleSided","audioLoader","AudioLoader","AudioAnalyser","getData","updateCubeMap","TextureLoader","loadTextureCube","CubeTextureLoader","loadCompressedTexture","loadCompressedTextureCube","SceneUtils","createMultiMaterialObject","detach","revision","__THREE__","AnimationLoader","ArrowHelper","AudioListener","AxisHelper","BinaryTextureLoader","BoundingBoxHelper","Box3Helper","CameraHelper","CanvasRenderer","CompressedTextureLoader","Cylindrical","DataUtils","DirectionalLightHelper","DynamicBufferAttribute","EdgesHelper","Float32Attribute","Float64Attribute","FontLoader","HemisphereLightHelper","Int16Attribute","Int32Attribute","Int8Attribute","JSONLoader","LensFlare","MeshFaceMaterial","MultiMaterial","ObjectLoader","PMREMGenerator","Particle","ParticleBasicMaterial","ParticleSystem","ParticleSystemMaterial","PlaneHelper","PointCloud","PointCloudMaterial","PointLightHelper","PolarGridHelper","PositionalAudio","Raycaster","Spherical","SpotLightHelper","StereoCamera","Uint16Attribute","Uint32Attribute","Uint8Attribute","Uint8ClampedAttribute","Vertex","WebGLRenderTargetCube","WireframeHelper","XHRLoader","OrbitControls","AddRenderer","AddCamera","AddControls","HandleResize","innerWidth","innerHeight","controls","autoRotate","enableDamping","dampingFactor","clientWidth","clientHeight","devicePixelRatio"],"version":3,"file":"index.72166a09.js.map","sourceRoot":"/__parcel_source_root/"}